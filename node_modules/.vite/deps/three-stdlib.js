import {
  AddEquation,
  AddOperation,
  AdditiveBlending,
  AmbientLight,
  AnimationClip,
  AnimationMixer,
  BackSide,
  Bone,
  BooleanKeyframeTrack,
  Box2,
  Box3,
  Box3Helper,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  BufferGeometryLoader,
  Camera,
  CanvasTexture,
  ClampToEdgeWrapping,
  Clock,
  Color,
  ColorKeyframeTrack,
  CompressedTexture,
  CompressedTextureLoader,
  ConeGeometry,
  CubeTexture,
  Curve,
  CustomBlending,
  CylinderGeometry,
  Data3DTexture,
  DataTexture,
  DataTexture3D,
  DataTextureLoader,
  DataUtils,
  DefaultLoadingManager,
  DepthStencilFormat,
  DepthTexture,
  DirectionalLight,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicDrawUsage,
  EllipseCurve,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  Euler,
  EventDispatcher,
  ExtrudeGeometry,
  FileLoader as FileLoader2,
  Float32BufferAttribute,
  FloatType,
  FrontSide,
  Frustum,
  GridHelper,
  Group,
  HalfFloatType,
  IcosahedronGeometry,
  ImageBitmapLoader,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  LightProbe,
  Line,
  Line3,
  LineBasicMaterial,
  LineLoop,
  LineSegments,
  LinearEncoding,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  Loader,
  LoaderUtils,
  LoadingManager,
  LuminanceFormat,
  MOUSE,
  Material,
  MaterialLoader,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  MirroredRepeatWrapping,
  MultiplyOperation,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NoBlending,
  NormalBlending,
  NumberKeyframeTrack,
  Object3D,
  ObjectLoader,
  ObjectSpaceNormalMap,
  OctahedronGeometry,
  OneMinusSrcAlphaFactor,
  OrthographicCamera,
  Path,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PointLight,
  Points,
  PointsMaterial,
  PropertyBinding,
  Quaternion,
  QuaternionKeyframeTrack,
  REVISION,
  RGBADepthPacking,
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  RawShaderMaterial,
  Ray,
  Raycaster,
  RectAreaLight,
  RedFormat,
  RepeatWrapping,
  Scene,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  Shape,
  ShapePath,
  ShapeUtils,
  Skeleton,
  SkeletonHelper,
  SkinnedMesh,
  Sphere,
  SphereGeometry,
  Spherical,
  SphericalHarmonics3,
  SpotLight,
  Sprite,
  SpriteMaterial,
  SrcAlphaFactor,
  StereoCamera,
  TOUCH,
  TangentSpaceNormalMap,
  Texture,
  TextureLoader,
  TorusGeometry,
  Triangle,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  UVMapping,
  Uint16BufferAttribute,
  Uint32BufferAttribute,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedShortType,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  WebGLCubeRenderTarget,
  WebGLRenderTarget,
  WireframeGeometry,
  ZeroFactor,
  __commonJS,
  __export,
  __toESM,
  sRGBEncoding
} from "./chunk-NODTPR4M.js";

// node_modules/chevrotain/lib/src/version.js
var require_version = __commonJS({
  "node_modules/chevrotain/lib/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VERSION = void 0;
    exports2.VERSION = "10.3.0";
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports2, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports2, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    module2.exports = isObject;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module2.exports = DataView2;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module2.exports = WeakMap2;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports2, module2) {
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag2 = baseGetTag;
    if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
      getTag2 = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag2;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports2, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module2.exports = isArrayLike;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports2, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports2, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports2, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports2, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/lodash/isEmpty.js"(exports2, module2) {
    var baseKeys = require_baseKeys();
    var getTag2 = require_getTag();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLike = require_isArrayLike();
    var isBuffer = require_isBuffer();
    var isPrototype = require_isPrototype();
    var isTypedArray = require_isTypedArray();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag2(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = isEmpty;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports2, module2) {
    function arrayMap(array, iteratee) {
      var index = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
      while (++index < length2) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports2, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length2 = array.length;
      while (length2--) {
        if (eq(array[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports2, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports2, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports2, module2) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports2, module2) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports2, module2) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports2, module2) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module2.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports2, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports2, module2) {
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports2, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports2, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports2, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length2 = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length2) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports2, module2) {
    function arraySome(array, predicate) {
      var index = -1, length2 = array == null ? 0 : array.length;
      while (++index < length2) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports2, module2) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports2, module2) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports2, module2) {
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports2, module2) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports2, module2) {
    function arrayPush(array, values) {
      var index = -1, length2 = values.length, offset = array.length;
      while (++index < length2) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module2.exports = arrayPush;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports2, module2) {
    function arrayFilter(array, predicate) {
      var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length2) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports2, module2) {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports2, module2) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length2) {
      var type2 = typeof value;
      length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
      return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    module2.exports = isIndex;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports2, module2) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag2 = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag2(object), othTag = othIsArr ? arrayTag : getTag2(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module2.exports = baseIsEqual;
  }
});

// node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length2 = index, noCustomizer = !customizer;
      if (object == null) {
        return !length2;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length2) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch;
  }
});

// node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
    var isObject = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    module2.exports = isStrictComparable;
  }
});

// node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/lodash/_getMatchData.js"(exports2, module2) {
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length2 = result.length;
      while (length2--) {
        var key = result[length2], value = object[key];
        result[length2] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module2.exports = getMatchData;
  }
});

// node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    module2.exports = matchesStrictComparable;
  }
});

// node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/lodash/_baseMatches.js"(exports2, module2) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    module2.exports = baseMatches;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports2, module2) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module2.exports = memoize;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports2, module2) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY2 = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports2, module2) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports2, module2) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module2.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    var INFINITY2 = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports2, module2) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length2 = path.length;
      while (object != null && index < length2) {
        object = object[toKey(path[index++])];
      }
      return index && index == length2 ? object : void 0;
    }
    module2.exports = baseGet;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get;
  }
});

// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/lodash/_baseHasIn.js"(exports2, module2) {
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    module2.exports = baseHasIn;
  }
});

// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/lodash/_hasPath.js"(exports2, module2) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index = -1, length2 = path.length, result = false;
      while (++index < length2) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length2) {
        return result;
      }
      length2 = object == null ? 0 : object.length;
      return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray(object) || isArguments(object));
    }
    module2.exports = hasPath;
  }
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/lodash/hasIn.js"(exports2, module2) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    module2.exports = hasIn;
  }
});

// node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
    var baseIsEqual = require_baseIsEqual();
    var get = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module2.exports = baseMatchesProperty;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports2, module2) {
    function identity(value) {
      return value;
    }
    module2.exports = identity;
  }
});

// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/lodash/_baseProperty.js"(exports2, module2) {
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    module2.exports = baseProperty;
  }
});

// node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    module2.exports = basePropertyDeep;
  }
});

// node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/lodash/property.js"(exports2, module2) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = property;
  }
});

// node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/lodash/_baseIteratee.js"(exports2, module2) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module2.exports = baseIteratee;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports2, module2) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
        while (length2--) {
          var key = props[fromRight ? length2 : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module2.exports = createBaseFor;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports2, module2) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "node_modules/lodash/_baseForOwn.js"(exports2, module2) {
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module2.exports = baseForOwn;
  }
});

// node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "node_modules/lodash/_createBaseEach.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length2 = collection.length, index = fromRight ? length2 : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length2) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module2.exports = createBaseEach;
  }
});

// node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "node_modules/lodash/_baseEach.js"(exports2, module2) {
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module2.exports = baseEach;
  }
});

// node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "node_modules/lodash/_baseMap.js"(exports2, module2) {
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    module2.exports = baseMap;
  }
});

// node_modules/lodash/map.js
var require_map = __commonJS({
  "node_modules/lodash/map.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var isArray = require_isArray();
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee, 3));
    }
    module2.exports = map;
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports2, module2) {
    function arrayEach(array, iteratee) {
      var index = -1, length2 = array == null ? 0 : array.length;
      while (++index < length2) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module2.exports = arrayEach;
  }
});

// node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "node_modules/lodash/_castFunction.js"(exports2, module2) {
    var identity = require_identity();
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    module2.exports = castFunction;
  }
});

// node_modules/lodash/forEach.js
var require_forEach = __commonJS({
  "node_modules/lodash/forEach.js"(exports2, module2) {
    var arrayEach = require_arrayEach();
    var baseEach = require_baseEach();
    var castFunction = require_castFunction();
    var isArray = require_isArray();
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    module2.exports = forEach;
  }
});

// node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
  "node_modules/lodash/_baseValues.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    module2.exports = baseValues;
  }
});

// node_modules/lodash/values.js
var require_values = __commonJS({
  "node_modules/lodash/values.js"(exports2, module2) {
    var baseValues = require_baseValues();
    var keys = require_keys();
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }
    module2.exports = values;
  }
});

// node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "node_modules/lodash/_baseHas.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }
    module2.exports = baseHas;
  }
});

// node_modules/lodash/has.js
var require_has = __commonJS({
  "node_modules/lodash/has.js"(exports2, module2) {
    var baseHas = require_baseHas();
    var hasPath = require_hasPath();
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }
    module2.exports = has;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports2, module2) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module2.exports = assignValue;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length2 = props.length;
      while (++index < length2) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module2.exports = copyObject;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module2.exports = baseAssign;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = nativeKeysIn;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeysIn;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = keysIn;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module2.exports = baseAssignIn;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
    var root = require_root();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var length2 = buffer2.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer2.constructor(length2);
      buffer2.copy(result);
      return result;
    }
    module2.exports = cloneBuffer;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports2, module2) {
    function copyArray(source, array) {
      var index = -1, length2 = source.length;
      array || (array = Array(length2));
      while (++index < length2) {
        array[index] = source[index];
      }
      return array;
    }
    module2.exports = copyArray;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module2.exports = copySymbols;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports2, module2) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module2.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module2.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module2.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length2 = array.length, result = new array.constructor(length2);
      if (length2 && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module2.exports = initCloneArray;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module2.exports = cloneArrayBuffer;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module2.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module2.exports = cloneSymbol;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module2.exports = initCloneByTag;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports2, module2) {
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module2.exports = baseCreate;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports2, module2) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module2.exports = initCloneObject;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports2, module2) {
    var getTag2 = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag2(value) == mapTag;
    }
    module2.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports2, module2) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module2.exports = isMap;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports2, module2) {
    var getTag2 = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag2(value) == setTag;
    }
    module2.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports2, module2) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module2.exports = isSet;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports2, module2) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag2 = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag2(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module2.exports = baseClone;
  }
});

// node_modules/lodash/clone.js
var require_clone = __commonJS({
  "node_modules/lodash/clone.js"(exports2, module2) {
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    module2.exports = clone;
  }
});

// node_modules/@chevrotain/utils/lib/src/print.js
var require_print = __commonJS({
  "node_modules/@chevrotain/utils/lib/src/print.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PRINT_WARNING = exports2.PRINT_ERROR = void 0;
    function PRINT_ERROR(msg) {
      if (console && console.error) {
        console.error("Error: ".concat(msg));
      }
    }
    exports2.PRINT_ERROR = PRINT_ERROR;
    function PRINT_WARNING(msg) {
      if (console && console.warn) {
        console.warn("Warning: ".concat(msg));
      }
    }
    exports2.PRINT_WARNING = PRINT_WARNING;
  }
});

// node_modules/@chevrotain/utils/lib/src/timer.js
var require_timer = __commonJS({
  "node_modules/@chevrotain/utils/lib/src/timer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timer = void 0;
    function timer(func) {
      var start = new Date().getTime();
      var val = func();
      var end = new Date().getTime();
      var total = end - start;
      return { time: total, value: val };
    }
    exports2.timer = timer;
  }
});

// node_modules/@chevrotain/utils/lib/src/to-fast-properties.js
var require_to_fast_properties = __commonJS({
  "node_modules/@chevrotain/utils/lib/src/to-fast-properties.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toFastProperties = void 0;
    function toFastProperties(toBecomeFast) {
      function FakeConstructor() {
      }
      FakeConstructor.prototype = toBecomeFast;
      var fakeInstance = new FakeConstructor();
      function fakeAccess() {
        return typeof fakeInstance.bar;
      }
      fakeAccess();
      fakeAccess();
      if (1)
        return toBecomeFast;
      eval(toBecomeFast);
    }
    exports.toFastProperties = toFastProperties;
  }
});

// node_modules/@chevrotain/utils/lib/src/api.js
var require_api = __commonJS({
  "node_modules/@chevrotain/utils/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toFastProperties = exports2.timer = exports2.PRINT_ERROR = exports2.PRINT_WARNING = void 0;
    var print_1 = require_print();
    Object.defineProperty(exports2, "PRINT_WARNING", { enumerable: true, get: function() {
      return print_1.PRINT_WARNING;
    } });
    Object.defineProperty(exports2, "PRINT_ERROR", { enumerable: true, get: function() {
      return print_1.PRINT_ERROR;
    } });
    var timer_1 = require_timer();
    Object.defineProperty(exports2, "timer", { enumerable: true, get: function() {
      return timer_1.timer;
    } });
    var to_fast_properties_1 = require_to_fast_properties();
    Object.defineProperty(exports2, "toFastProperties", { enumerable: true, get: function() {
      return to_fast_properties_1.toFastProperties;
    } });
  }
});

// node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "node_modules/lodash/_baseSlice.js"(exports2, module2) {
    function baseSlice(array, start, end) {
      var index = -1, length2 = array.length;
      if (start < 0) {
        start = -start > length2 ? 0 : length2 + start;
      }
      end = end > length2 ? length2 : end;
      if (end < 0) {
        end += length2;
      }
      length2 = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length2);
      while (++index < length2) {
        result[index] = array[index + start];
      }
      return result;
    }
    module2.exports = baseSlice;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports2, module2) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    module2.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports2, module2) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module2.exports = baseTrim;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports2, module2) {
    var baseTrim = require_baseTrim();
    var isObject = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = toNumber;
  }
});

// node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "node_modules/lodash/toFinite.js"(exports2, module2) {
    var toNumber = require_toNumber();
    var INFINITY2 = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY2 || value === -INFINITY2) {
        var sign2 = value < 0 ? -1 : 1;
        return sign2 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    module2.exports = toFinite;
  }
});

// node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/lodash/toInteger.js"(exports2, module2) {
    var toFinite = require_toFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder2 = result % 1;
      return result === result ? remainder2 ? result - remainder2 : result : 0;
    }
    module2.exports = toInteger;
  }
});

// node_modules/lodash/drop.js
var require_drop = __commonJS({
  "node_modules/lodash/drop.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    var toInteger = require_toInteger();
    function drop(array, n, guard) {
      var length2 = array == null ? 0 : array.length;
      if (!length2) {
        return [];
      }
      n = guard || n === void 0 ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length2);
    }
    module2.exports = drop;
  }
});

// node_modules/lodash/isString.js
var require_isString = __commonJS({
  "node_modules/lodash/isString.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isArray = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// node_modules/lodash/_baseIsRegExp.js
var require_baseIsRegExp = __commonJS({
  "node_modules/lodash/_baseIsRegExp.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var regexpTag = "[object RegExp]";
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }
    module2.exports = baseIsRegExp;
  }
});

// node_modules/lodash/isRegExp.js
var require_isRegExp = __commonJS({
  "node_modules/lodash/isRegExp.js"(exports2, module2) {
    var baseIsRegExp = require_baseIsRegExp();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
    module2.exports = isRegExp;
  }
});

// node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "node_modules/lodash/_baseSet.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);
      var index = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
      while (nested != null && ++index < length2) {
        var key = toKey(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    module2.exports = baseSet;
  }
});

// node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "node_modules/lodash/_basePickBy.js"(exports2, module2) {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index = -1, length2 = paths.length, result = {};
      while (++index < length2) {
        var path = paths[index], value = baseGet(object, path);
        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }
    module2.exports = basePickBy;
  }
});

// node_modules/lodash/pickBy.js
var require_pickBy = __commonJS({
  "node_modules/lodash/pickBy.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var basePickBy = require_basePickBy();
    var getAllKeysIn = require_getAllKeysIn();
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = baseIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }
    module2.exports = pickBy;
  }
});

// node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/lodash/_apply.js"(exports2, module2) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module2.exports = apply;
  }
});

// node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/lodash/_overRest.js"(exports2, module2) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length2 = nativeMax(args.length - start, 0), array = Array(length2);
        while (++index < length2) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    module2.exports = overRest;
  }
});

// node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/lodash/constant.js"(exports2, module2) {
    function constant2(value) {
      return function() {
        return value;
      };
    }
    module2.exports = constant2;
  }
});

// node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/lodash/_baseSetToString.js"(exports2, module2) {
    var constant2 = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant2(string),
        "writable": true
      });
    };
    module2.exports = baseSetToString;
  }
});

// node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/lodash/_shortOut.js"(exports2, module2) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module2.exports = shortOut;
  }
});

// node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/lodash/_setToString.js"(exports2, module2) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module2.exports = setToString;
  }
});

// node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "node_modules/lodash/_baseRest.js"(exports2, module2) {
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module2.exports = baseRest;
  }
});

// node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "node_modules/lodash/_isIterateeCall.js"(exports2, module2) {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type2 = typeof index;
      if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module2.exports = isIterateeCall;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length2 < 3 ? void 0 : customizer;
          length2 = 1;
        }
        object = Object(object);
        while (++index < length2) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module2.exports = createAssigner;
  }
});

// node_modules/lodash/assign.js
var require_assign = __commonJS({
  "node_modules/lodash/assign.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var isArrayLike = require_isArrayLike();
    var isPrototype = require_isPrototype();
    var keys = require_keys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var assign2 = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });
    module2.exports = assign2;
  }
});

// node_modules/@chevrotain/gast/lib/src/model.js
var require_model = __commonJS({
  "node_modules/@chevrotain/gast/lib/src/model.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b5) {
          d2.__proto__ = b5;
        } || function(d2, b5) {
          for (var p in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p))
              d2[p] = b5[p];
        };
        return extendStatics(d, b3);
      };
      return function(d, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d, b3);
        function __() {
          this.constructor = d;
        }
        d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.Repetition = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Option = exports2.Alternative = exports2.Rule = exports2.NonTerminal = exports2.AbstractProduction = void 0;
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var isString_1 = __importDefault(require_isString());
    var isRegExp_1 = __importDefault(require_isRegExp());
    var pickBy_1 = __importDefault(require_pickBy());
    var assign_1 = __importDefault(require_assign());
    function tokenLabel2(tokType) {
      if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
      } else {
        return tokType.name;
      }
    }
    function hasTokenLabel(obj) {
      return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
    }
    var AbstractProduction = function() {
      function AbstractProduction2(_definition) {
        this._definition = _definition;
      }
      Object.defineProperty(AbstractProduction2.prototype, "definition", {
        get: function() {
          return this._definition;
        },
        set: function(value) {
          this._definition = value;
        },
        enumerable: false,
        configurable: true
      });
      AbstractProduction2.prototype.accept = function(visitor) {
        visitor.visit(this);
        (0, forEach_1.default)(this.definition, function(prod) {
          prod.accept(visitor);
        });
      };
      return AbstractProduction2;
    }();
    exports2.AbstractProduction = AbstractProduction;
    var NonTerminal2 = function(_super) {
      __extends(NonTerminal3, _super);
      function NonTerminal3(options) {
        var _this = _super.call(this, []) || this;
        _this.idx = 1;
        (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
          return v !== void 0;
        }));
        return _this;
      }
      Object.defineProperty(NonTerminal3.prototype, "definition", {
        get: function() {
          if (this.referencedRule !== void 0) {
            return this.referencedRule.definition;
          }
          return [];
        },
        set: function(definition) {
        },
        enumerable: false,
        configurable: true
      });
      NonTerminal3.prototype.accept = function(visitor) {
        visitor.visit(this);
      };
      return NonTerminal3;
    }(AbstractProduction);
    exports2.NonTerminal = NonTerminal2;
    var Rule2 = function(_super) {
      __extends(Rule3, _super);
      function Rule3(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.orgText = "";
        (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
          return v !== void 0;
        }));
        return _this;
      }
      return Rule3;
    }(AbstractProduction);
    exports2.Rule = Rule2;
    var Alternative2 = function(_super) {
      __extends(Alternative3, _super);
      function Alternative3(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.ignoreAmbiguities = false;
        (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
          return v !== void 0;
        }));
        return _this;
      }
      return Alternative3;
    }(AbstractProduction);
    exports2.Alternative = Alternative2;
    var Option2 = function(_super) {
      __extends(Option3, _super);
      function Option3(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
          return v !== void 0;
        }));
        return _this;
      }
      return Option3;
    }(AbstractProduction);
    exports2.Option = Option2;
    var RepetitionMandatory2 = function(_super) {
      __extends(RepetitionMandatory3, _super);
      function RepetitionMandatory3(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
          return v !== void 0;
        }));
        return _this;
      }
      return RepetitionMandatory3;
    }(AbstractProduction);
    exports2.RepetitionMandatory = RepetitionMandatory2;
    var RepetitionMandatoryWithSeparator2 = function(_super) {
      __extends(RepetitionMandatoryWithSeparator3, _super);
      function RepetitionMandatoryWithSeparator3(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
          return v !== void 0;
        }));
        return _this;
      }
      return RepetitionMandatoryWithSeparator3;
    }(AbstractProduction);
    exports2.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator2;
    var Repetition2 = function(_super) {
      __extends(Repetition3, _super);
      function Repetition3(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
          return v !== void 0;
        }));
        return _this;
      }
      return Repetition3;
    }(AbstractProduction);
    exports2.Repetition = Repetition2;
    var RepetitionWithSeparator2 = function(_super) {
      __extends(RepetitionWithSeparator3, _super);
      function RepetitionWithSeparator3(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
          return v !== void 0;
        }));
        return _this;
      }
      return RepetitionWithSeparator3;
    }(AbstractProduction);
    exports2.RepetitionWithSeparator = RepetitionWithSeparator2;
    var Alternation2 = function(_super) {
      __extends(Alternation3, _super);
      function Alternation3(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        _this.ignoreAmbiguities = false;
        _this.hasPredicates = false;
        (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
          return v !== void 0;
        }));
        return _this;
      }
      Object.defineProperty(Alternation3.prototype, "definition", {
        get: function() {
          return this._definition;
        },
        set: function(value) {
          this._definition = value;
        },
        enumerable: false,
        configurable: true
      });
      return Alternation3;
    }(AbstractProduction);
    exports2.Alternation = Alternation2;
    var Terminal2 = function() {
      function Terminal3(options) {
        this.idx = 1;
        (0, assign_1.default)(this, (0, pickBy_1.default)(options, function(v) {
          return v !== void 0;
        }));
      }
      Terminal3.prototype.accept = function(visitor) {
        visitor.visit(this);
      };
      return Terminal3;
    }();
    exports2.Terminal = Terminal2;
    function serializeGrammar2(topRules) {
      return (0, map_1.default)(topRules, serializeProduction2);
    }
    exports2.serializeGrammar = serializeGrammar2;
    function serializeProduction2(node) {
      function convertDefinition(definition) {
        return (0, map_1.default)(definition, serializeProduction2);
      }
      if (node instanceof NonTerminal2) {
        var serializedNonTerminal = {
          type: "NonTerminal",
          name: node.nonTerminalName,
          idx: node.idx
        };
        if ((0, isString_1.default)(node.label)) {
          serializedNonTerminal.label = node.label;
        }
        return serializedNonTerminal;
      } else if (node instanceof Alternative2) {
        return {
          type: "Alternative",
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Option2) {
        return {
          type: "Option",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionMandatory2) {
        return {
          type: "RepetitionMandatory",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionMandatoryWithSeparator2) {
        return {
          type: "RepetitionMandatoryWithSeparator",
          idx: node.idx,
          separator: serializeProduction2(new Terminal2({ terminalType: node.separator })),
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionWithSeparator2) {
        return {
          type: "RepetitionWithSeparator",
          idx: node.idx,
          separator: serializeProduction2(new Terminal2({ terminalType: node.separator })),
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Repetition2) {
        return {
          type: "Repetition",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Alternation2) {
        return {
          type: "Alternation",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Terminal2) {
        var serializedTerminal = {
          type: "Terminal",
          name: node.terminalType.name,
          label: tokenLabel2(node.terminalType),
          idx: node.idx
        };
        if ((0, isString_1.default)(node.label)) {
          serializedTerminal.terminalLabel = node.label;
        }
        var pattern = node.terminalType.PATTERN;
        if (node.terminalType.PATTERN) {
          serializedTerminal.pattern = (0, isRegExp_1.default)(pattern) ? pattern.source : pattern;
        }
        return serializedTerminal;
      } else if (node instanceof Rule2) {
        return {
          type: "Rule",
          name: node.name,
          orgText: node.orgText,
          definition: convertDefinition(node.definition)
        };
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.serializeProduction = serializeProduction2;
  }
});

// node_modules/@chevrotain/gast/lib/src/visitor.js
var require_visitor = __commonJS({
  "node_modules/@chevrotain/gast/lib/src/visitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GAstVisitor = void 0;
    var model_1 = require_model();
    var GAstVisitor2 = function() {
      function GAstVisitor3() {
      }
      GAstVisitor3.prototype.visit = function(node) {
        var nodeAny = node;
        switch (nodeAny.constructor) {
          case model_1.NonTerminal:
            return this.visitNonTerminal(nodeAny);
          case model_1.Alternative:
            return this.visitAlternative(nodeAny);
          case model_1.Option:
            return this.visitOption(nodeAny);
          case model_1.RepetitionMandatory:
            return this.visitRepetitionMandatory(nodeAny);
          case model_1.RepetitionMandatoryWithSeparator:
            return this.visitRepetitionMandatoryWithSeparator(nodeAny);
          case model_1.RepetitionWithSeparator:
            return this.visitRepetitionWithSeparator(nodeAny);
          case model_1.Repetition:
            return this.visitRepetition(nodeAny);
          case model_1.Alternation:
            return this.visitAlternation(nodeAny);
          case model_1.Terminal:
            return this.visitTerminal(nodeAny);
          case model_1.Rule:
            return this.visitRule(nodeAny);
          default:
            throw Error("non exhaustive match");
        }
      };
      GAstVisitor3.prototype.visitNonTerminal = function(node) {
      };
      GAstVisitor3.prototype.visitAlternative = function(node) {
      };
      GAstVisitor3.prototype.visitOption = function(node) {
      };
      GAstVisitor3.prototype.visitRepetition = function(node) {
      };
      GAstVisitor3.prototype.visitRepetitionMandatory = function(node) {
      };
      GAstVisitor3.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
      };
      GAstVisitor3.prototype.visitRepetitionWithSeparator = function(node) {
      };
      GAstVisitor3.prototype.visitAlternation = function(node) {
      };
      GAstVisitor3.prototype.visitTerminal = function(node) {
      };
      GAstVisitor3.prototype.visitRule = function(node) {
      };
      return GAstVisitor3;
    }();
    exports2.GAstVisitor = GAstVisitor2;
  }
});

// node_modules/lodash/_baseSome.js
var require_baseSome = __commonJS({
  "node_modules/lodash/_baseSome.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseSome(collection, predicate) {
      var result;
      baseEach(collection, function(value, index, collection2) {
        result = predicate(value, index, collection2);
        return !result;
      });
      return !!result;
    }
    module2.exports = baseSome;
  }
});

// node_modules/lodash/some.js
var require_some = __commonJS({
  "node_modules/lodash/some.js"(exports2, module2) {
    var arraySome = require_arraySome();
    var baseIteratee = require_baseIteratee();
    var baseSome = require_baseSome();
    var isArray = require_isArray();
    var isIterateeCall = require_isIterateeCall();
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = some;
  }
});

// node_modules/lodash/_arrayEvery.js
var require_arrayEvery = __commonJS({
  "node_modules/lodash/_arrayEvery.js"(exports2, module2) {
    function arrayEvery(array, predicate) {
      var index = -1, length2 = array == null ? 0 : array.length;
      while (++index < length2) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = arrayEvery;
  }
});

// node_modules/lodash/_baseEvery.js
var require_baseEvery = __commonJS({
  "node_modules/lodash/_baseEvery.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection2) {
        result = !!predicate(value, index, collection2);
        return result;
      });
      return result;
    }
    module2.exports = baseEvery;
  }
});

// node_modules/lodash/every.js
var require_every = __commonJS({
  "node_modules/lodash/every.js"(exports2, module2) {
    var arrayEvery = require_arrayEvery();
    var baseEvery = require_baseEvery();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    var isIterateeCall = require_isIterateeCall();
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = every;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports2, module2) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length2 = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length2) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports2, module2) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module2.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports2, module2) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length2 = array.length;
      while (++index < length2) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module2.exports = baseIndexOf;
  }
});

// node_modules/lodash/includes.js
var require_includes = __commonJS({
  "node_modules/lodash/includes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    var isArrayLike = require_isArrayLike();
    var isString = require_isString();
    var toInteger = require_toInteger();
    var values = require_values();
    var nativeMax = Math.max;
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length2 = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length2 + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
    }
    module2.exports = includes;
  }
});

// node_modules/@chevrotain/gast/lib/src/helpers.js
var require_helpers = __commonJS({
  "node_modules/@chevrotain/gast/lib/src/helpers.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProductionDslName = exports2.isBranchingProd = exports2.isOptionalProd = exports2.isSequenceProd = void 0;
    var some_1 = __importDefault(require_some());
    var every_1 = __importDefault(require_every());
    var includes_1 = __importDefault(require_includes());
    var model_1 = require_model();
    function isSequenceProd(prod) {
      return prod instanceof model_1.Alternative || prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionMandatory || prod instanceof model_1.RepetitionMandatoryWithSeparator || prod instanceof model_1.RepetitionWithSeparator || prod instanceof model_1.Terminal || prod instanceof model_1.Rule;
    }
    exports2.isSequenceProd = isSequenceProd;
    function isOptionalProd(prod, alreadyVisited) {
      if (alreadyVisited === void 0) {
        alreadyVisited = [];
      }
      var isDirectlyOptional = prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionWithSeparator;
      if (isDirectlyOptional) {
        return true;
      }
      if (prod instanceof model_1.Alternation) {
        return (0, some_1.default)(prod.definition, function(subProd) {
          return isOptionalProd(subProd, alreadyVisited);
        });
      } else if (prod instanceof model_1.NonTerminal && (0, includes_1.default)(alreadyVisited, prod)) {
        return false;
      } else if (prod instanceof model_1.AbstractProduction) {
        if (prod instanceof model_1.NonTerminal) {
          alreadyVisited.push(prod);
        }
        return (0, every_1.default)(prod.definition, function(subProd) {
          return isOptionalProd(subProd, alreadyVisited);
        });
      } else {
        return false;
      }
    }
    exports2.isOptionalProd = isOptionalProd;
    function isBranchingProd(prod) {
      return prod instanceof model_1.Alternation;
    }
    exports2.isBranchingProd = isBranchingProd;
    function getProductionDslName(prod) {
      if (prod instanceof model_1.NonTerminal) {
        return "SUBRULE";
      } else if (prod instanceof model_1.Option) {
        return "OPTION";
      } else if (prod instanceof model_1.Alternation) {
        return "OR";
      } else if (prod instanceof model_1.RepetitionMandatory) {
        return "AT_LEAST_ONE";
      } else if (prod instanceof model_1.RepetitionMandatoryWithSeparator) {
        return "AT_LEAST_ONE_SEP";
      } else if (prod instanceof model_1.RepetitionWithSeparator) {
        return "MANY_SEP";
      } else if (prod instanceof model_1.Repetition) {
        return "MANY";
      } else if (prod instanceof model_1.Terminal) {
        return "CONSUME";
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.getProductionDslName = getProductionDslName;
  }
});

// node_modules/@chevrotain/gast/lib/src/api.js
var require_api2 = __commonJS({
  "node_modules/@chevrotain/gast/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSequenceProd = exports2.isBranchingProd = exports2.isOptionalProd = exports2.getProductionDslName = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Alternative = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Terminal = exports2.Rule = void 0;
    var model_1 = require_model();
    Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
      return model_1.Rule;
    } });
    Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
      return model_1.Terminal;
    } });
    Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
      return model_1.NonTerminal;
    } });
    Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
      return model_1.Option;
    } });
    Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
      return model_1.Repetition;
    } });
    Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
      return model_1.RepetitionMandatory;
    } });
    Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
      return model_1.RepetitionMandatoryWithSeparator;
    } });
    Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
      return model_1.RepetitionWithSeparator;
    } });
    Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
      return model_1.Alternation;
    } });
    Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
      return model_1.Alternative;
    } });
    Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
      return model_1.serializeGrammar;
    } });
    Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
      return model_1.serializeProduction;
    } });
    var visitor_1 = require_visitor();
    Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
      return visitor_1.GAstVisitor;
    } });
    var helpers_1 = require_helpers();
    Object.defineProperty(exports2, "getProductionDslName", { enumerable: true, get: function() {
      return helpers_1.getProductionDslName;
    } });
    Object.defineProperty(exports2, "isOptionalProd", { enumerable: true, get: function() {
      return helpers_1.isOptionalProd;
    } });
    Object.defineProperty(exports2, "isBranchingProd", { enumerable: true, get: function() {
      return helpers_1.isBranchingProd;
    } });
    Object.defineProperty(exports2, "isSequenceProd", { enumerable: true, get: function() {
      return helpers_1.isSequenceProd;
    } });
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/rest.js
var require_rest = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/rest.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestWalker = void 0;
    var drop_1 = __importDefault(require_drop());
    var forEach_1 = __importDefault(require_forEach());
    var gast_1 = require_api2();
    var RestWalker = function() {
      function RestWalker2() {
      }
      RestWalker2.prototype.walk = function(prod, prevRest) {
        var _this = this;
        if (prevRest === void 0) {
          prevRest = [];
        }
        (0, forEach_1.default)(prod.definition, function(subProd, index) {
          var currRest = (0, drop_1.default)(prod.definition, index + 1);
          if (subProd instanceof gast_1.NonTerminal) {
            _this.walkProdRef(subProd, currRest, prevRest);
          } else if (subProd instanceof gast_1.Terminal) {
            _this.walkTerminal(subProd, currRest, prevRest);
          } else if (subProd instanceof gast_1.Alternative) {
            _this.walkFlat(subProd, currRest, prevRest);
          } else if (subProd instanceof gast_1.Option) {
            _this.walkOption(subProd, currRest, prevRest);
          } else if (subProd instanceof gast_1.RepetitionMandatory) {
            _this.walkAtLeastOne(subProd, currRest, prevRest);
          } else if (subProd instanceof gast_1.RepetitionMandatoryWithSeparator) {
            _this.walkAtLeastOneSep(subProd, currRest, prevRest);
          } else if (subProd instanceof gast_1.RepetitionWithSeparator) {
            _this.walkManySep(subProd, currRest, prevRest);
          } else if (subProd instanceof gast_1.Repetition) {
            _this.walkMany(subProd, currRest, prevRest);
          } else if (subProd instanceof gast_1.Alternation) {
            _this.walkOr(subProd, currRest, prevRest);
          } else {
            throw Error("non exhaustive match");
          }
        });
      };
      RestWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
      };
      RestWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
      };
      RestWalker2.prototype.walkFlat = function(flatProd, currRest, prevRest) {
        var fullOrRest = currRest.concat(prevRest);
        this.walk(flatProd, fullOrRest);
      };
      RestWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
        var fullOrRest = currRest.concat(prevRest);
        this.walk(optionProd, fullOrRest);
      };
      RestWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
        var fullAtLeastOneRest = [
          new gast_1.Option({ definition: atLeastOneProd.definition })
        ].concat(currRest, prevRest);
        this.walk(atLeastOneProd, fullAtLeastOneRest);
      };
      RestWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
        var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
      };
      RestWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
        var fullManyRest = [
          new gast_1.Option({ definition: manyProd.definition })
        ].concat(currRest, prevRest);
        this.walk(manyProd, fullManyRest);
      };
      RestWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
        var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
        this.walk(manySepProd, fullManySepRest);
      };
      RestWalker2.prototype.walkOr = function(orProd, currRest, prevRest) {
        var _this = this;
        var fullOrRest = currRest.concat(prevRest);
        (0, forEach_1.default)(orProd.definition, function(alt) {
          var prodWrapper = new gast_1.Alternative({ definition: [alt] });
          _this.walk(prodWrapper, fullOrRest);
        });
      };
      return RestWalker2;
    }();
    exports2.RestWalker = RestWalker;
    function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
      var repSepRest = [
        new gast_1.Option({
          definition: [
            new gast_1.Terminal({ terminalType: repSepProd.separator })
          ].concat(repSepProd.definition)
        })
      ];
      var fullRepSepRest = repSepRest.concat(currRest, prevRest);
      return fullRepSepRest;
    }
  }
});

// node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/lodash/_isFlattenable.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module2.exports = isFlattenable;
  }
});

// node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/lodash/_baseFlatten.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length2 = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length2) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module2.exports = baseFlatten;
  }
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "node_modules/lodash/flatten.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length2 = array == null ? 0 : array.length;
      return length2 ? baseFlatten(array, 1) : [];
    }
    module2.exports = flatten;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length2 = array == null ? 0 : array.length;
      return !!length2 && baseIndexOf(array, value, 0) > -1;
    }
    module2.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports2, module2) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length2 = array == null ? 0 : array.length;
      while (++index < length2) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports2, module2) {
    function noop() {
    }
    module2.exports = noop;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports2, module2) {
    var Set2 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY2 = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY2) ? noop : function(values) {
      return new Set2(values);
    };
    module2.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length2 = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length2 >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length2) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseUniq;
  }
});

// node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "node_modules/lodash/uniq.js"(exports2, module2) {
    var baseUniq = require_baseUniq();
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module2.exports = uniq;
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/first.js
var require_first = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/first.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.firstForTerminal = exports2.firstForBranching = exports2.firstForSequence = exports2.first = void 0;
    var flatten_1 = __importDefault(require_flatten());
    var uniq_1 = __importDefault(require_uniq());
    var map_1 = __importDefault(require_map());
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    function first(prod) {
      if (prod instanceof gast_1.NonTerminal) {
        return first(prod.referencedRule);
      } else if (prod instanceof gast_1.Terminal) {
        return firstForTerminal(prod);
      } else if ((0, gast_2.isSequenceProd)(prod)) {
        return firstForSequence(prod);
      } else if ((0, gast_2.isBranchingProd)(prod)) {
        return firstForBranching(prod);
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.first = first;
    function firstForSequence(prod) {
      var firstSet = [];
      var seq = prod.definition;
      var nextSubProdIdx = 0;
      var hasInnerProdsRemaining = seq.length > nextSubProdIdx;
      var currSubProd;
      var isLastInnerProdOptional = true;
      while (hasInnerProdsRemaining && isLastInnerProdOptional) {
        currSubProd = seq[nextSubProdIdx];
        isLastInnerProdOptional = (0, gast_2.isOptionalProd)(currSubProd);
        firstSet = firstSet.concat(first(currSubProd));
        nextSubProdIdx = nextSubProdIdx + 1;
        hasInnerProdsRemaining = seq.length > nextSubProdIdx;
      }
      return (0, uniq_1.default)(firstSet);
    }
    exports2.firstForSequence = firstForSequence;
    function firstForBranching(prod) {
      var allAlternativesFirsts = (0, map_1.default)(prod.definition, function(innerProd) {
        return first(innerProd);
      });
      return (0, uniq_1.default)((0, flatten_1.default)(allAlternativesFirsts));
    }
    exports2.firstForBranching = firstForBranching;
    function firstForTerminal(terminal) {
      return [terminal.terminalType];
    }
    exports2.firstForTerminal = firstForTerminal;
  }
});

// node_modules/chevrotain/lib/src/parse/constants.js
var require_constants = __commonJS({
  "node_modules/chevrotain/lib/src/parse/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IN = void 0;
    exports2.IN = "_~IN~_";
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/follow.js
var require_follow = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/follow.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b5) {
          d2.__proto__ = b5;
        } || function(d2, b5) {
          for (var p in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p))
              d2[p] = b5[p];
        };
        return extendStatics(d, b3);
      };
      return function(d, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d, b3);
        function __() {
          this.constructor = d;
        }
        d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildInProdFollowPrefix = exports2.buildBetweenProdsFollowPrefix = exports2.computeAllProdsFollows = exports2.ResyncFollowsWalker = void 0;
    var rest_1 = require_rest();
    var first_1 = require_first();
    var forEach_1 = __importDefault(require_forEach());
    var assign_1 = __importDefault(require_assign());
    var constants_1 = require_constants();
    var gast_1 = require_api2();
    var ResyncFollowsWalker = function(_super) {
      __extends(ResyncFollowsWalker2, _super);
      function ResyncFollowsWalker2(topProd) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.follows = {};
        return _this;
      }
      ResyncFollowsWalker2.prototype.startWalking = function() {
        this.walk(this.topProd);
        return this.follows;
      };
      ResyncFollowsWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
      };
      ResyncFollowsWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
        var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;
        var fullRest = currRest.concat(prevRest);
        var restProd = new gast_1.Alternative({ definition: fullRest });
        var t_in_topProd_follows = (0, first_1.first)(restProd);
        this.follows[followName] = t_in_topProd_follows;
      };
      return ResyncFollowsWalker2;
    }(rest_1.RestWalker);
    exports2.ResyncFollowsWalker = ResyncFollowsWalker;
    function computeAllProdsFollows(topProductions) {
      var reSyncFollows = {};
      (0, forEach_1.default)(topProductions, function(topProd) {
        var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
        (0, assign_1.default)(reSyncFollows, currRefsFollow);
      });
      return reSyncFollows;
    }
    exports2.computeAllProdsFollows = computeAllProdsFollows;
    function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
      return inner.name + occurenceInParent + constants_1.IN;
    }
    exports2.buildBetweenProdsFollowPrefix = buildBetweenProdsFollowPrefix;
    function buildInProdFollowPrefix(terminal) {
      var terminalName = terminal.terminalType.name;
      return terminalName + terminal.idx + constants_1.IN;
    }
    exports2.buildInProdFollowPrefix = buildInProdFollowPrefix;
  }
});

// node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS({
  "node_modules/lodash/isUndefined.js"(exports2, module2) {
    function isUndefined(value) {
      return value === void 0;
    }
    module2.exports = isUndefined;
  }
});

// node_modules/regexp-to-ast/lib/regexp-to-ast.js
var require_regexp_to_ast = __commonJS({
  "node_modules/regexp-to-ast/lib/regexp-to-ast.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.regexpToAst = factory();
      }
    })(
      typeof self !== "undefined" ? self : exports2,
      function() {
        function RegExpParser() {
        }
        RegExpParser.prototype.saveState = function() {
          return {
            idx: this.idx,
            input: this.input,
            groupIdx: this.groupIdx
          };
        };
        RegExpParser.prototype.restoreState = function(newState) {
          this.idx = newState.idx;
          this.input = newState.input;
          this.groupIdx = newState.groupIdx;
        };
        RegExpParser.prototype.pattern = function(input) {
          this.idx = 0;
          this.input = input;
          this.groupIdx = 0;
          this.consumeChar("/");
          var value = this.disjunction();
          this.consumeChar("/");
          var flags = {
            type: "Flags",
            loc: { begin: this.idx, end: input.length },
            global: false,
            ignoreCase: false,
            multiLine: false,
            unicode: false,
            sticky: false
          };
          while (this.isRegExpFlag()) {
            switch (this.popChar()) {
              case "g":
                addFlag(flags, "global");
                break;
              case "i":
                addFlag(flags, "ignoreCase");
                break;
              case "m":
                addFlag(flags, "multiLine");
                break;
              case "u":
                addFlag(flags, "unicode");
                break;
              case "y":
                addFlag(flags, "sticky");
                break;
            }
          }
          if (this.idx !== this.input.length) {
            throw Error(
              "Redundant input: " + this.input.substring(this.idx)
            );
          }
          return {
            type: "Pattern",
            flags,
            value,
            loc: this.loc(0)
          };
        };
        RegExpParser.prototype.disjunction = function() {
          var alts = [];
          var begin = this.idx;
          alts.push(this.alternative());
          while (this.peekChar() === "|") {
            this.consumeChar("|");
            alts.push(this.alternative());
          }
          return { type: "Disjunction", value: alts, loc: this.loc(begin) };
        };
        RegExpParser.prototype.alternative = function() {
          var terms = [];
          var begin = this.idx;
          while (this.isTerm()) {
            terms.push(this.term());
          }
          return { type: "Alternative", value: terms, loc: this.loc(begin) };
        };
        RegExpParser.prototype.term = function() {
          if (this.isAssertion()) {
            return this.assertion();
          } else {
            return this.atom();
          }
        };
        RegExpParser.prototype.assertion = function() {
          var begin = this.idx;
          switch (this.popChar()) {
            case "^":
              return {
                type: "StartAnchor",
                loc: this.loc(begin)
              };
            case "$":
              return { type: "EndAnchor", loc: this.loc(begin) };
            case "\\":
              switch (this.popChar()) {
                case "b":
                  return {
                    type: "WordBoundary",
                    loc: this.loc(begin)
                  };
                case "B":
                  return {
                    type: "NonWordBoundary",
                    loc: this.loc(begin)
                  };
              }
              throw Error("Invalid Assertion Escape");
            case "(":
              this.consumeChar("?");
              var type2;
              switch (this.popChar()) {
                case "=":
                  type2 = "Lookahead";
                  break;
                case "!":
                  type2 = "NegativeLookahead";
                  break;
              }
              ASSERT_EXISTS(type2);
              var disjunction = this.disjunction();
              this.consumeChar(")");
              return {
                type: type2,
                value: disjunction,
                loc: this.loc(begin)
              };
          }
          ASSERT_NEVER_REACH_HERE();
        };
        RegExpParser.prototype.quantifier = function(isBacktracking) {
          var range;
          var begin = this.idx;
          switch (this.popChar()) {
            case "*":
              range = {
                atLeast: 0,
                atMost: Infinity
              };
              break;
            case "+":
              range = {
                atLeast: 1,
                atMost: Infinity
              };
              break;
            case "?":
              range = {
                atLeast: 0,
                atMost: 1
              };
              break;
            case "{":
              var atLeast = this.integerIncludingZero();
              switch (this.popChar()) {
                case "}":
                  range = {
                    atLeast,
                    atMost: atLeast
                  };
                  break;
                case ",":
                  var atMost;
                  if (this.isDigit()) {
                    atMost = this.integerIncludingZero();
                    range = {
                      atLeast,
                      atMost
                    };
                  } else {
                    range = {
                      atLeast,
                      atMost: Infinity
                    };
                  }
                  this.consumeChar("}");
                  break;
              }
              if (isBacktracking === true && range === void 0) {
                return void 0;
              }
              ASSERT_EXISTS(range);
              break;
          }
          if (isBacktracking === true && range === void 0) {
            return void 0;
          }
          ASSERT_EXISTS(range);
          if (this.peekChar(0) === "?") {
            this.consumeChar("?");
            range.greedy = false;
          } else {
            range.greedy = true;
          }
          range.type = "Quantifier";
          range.loc = this.loc(begin);
          return range;
        };
        RegExpParser.prototype.atom = function() {
          var atom;
          var begin = this.idx;
          switch (this.peekChar()) {
            case ".":
              atom = this.dotAll();
              break;
            case "\\":
              atom = this.atomEscape();
              break;
            case "[":
              atom = this.characterClass();
              break;
            case "(":
              atom = this.group();
              break;
          }
          if (atom === void 0 && this.isPatternCharacter()) {
            atom = this.patternCharacter();
          }
          ASSERT_EXISTS(atom);
          atom.loc = this.loc(begin);
          if (this.isQuantifier()) {
            atom.quantifier = this.quantifier();
          }
          return atom;
        };
        RegExpParser.prototype.dotAll = function() {
          this.consumeChar(".");
          return {
            type: "Set",
            complement: true,
            value: [cc("\n"), cc("\r"), cc("\u2028"), cc("\u2029")]
          };
        };
        RegExpParser.prototype.atomEscape = function() {
          this.consumeChar("\\");
          switch (this.peekChar()) {
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return this.decimalEscapeAtom();
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
              return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
              return this.controlEscapeAtom();
            case "c":
              return this.controlLetterEscapeAtom();
            case "0":
              return this.nulCharacterAtom();
            case "x":
              return this.hexEscapeSequenceAtom();
            case "u":
              return this.regExpUnicodeEscapeSequenceAtom();
            default:
              return this.identityEscapeAtom();
          }
        };
        RegExpParser.prototype.decimalEscapeAtom = function() {
          var value = this.positiveInteger();
          return { type: "GroupBackReference", value };
        };
        RegExpParser.prototype.characterClassEscape = function() {
          var set;
          var complement = false;
          switch (this.popChar()) {
            case "d":
              set = digitsCharCodes;
              break;
            case "D":
              set = digitsCharCodes;
              complement = true;
              break;
            case "s":
              set = whitespaceCodes;
              break;
            case "S":
              set = whitespaceCodes;
              complement = true;
              break;
            case "w":
              set = wordCharCodes;
              break;
            case "W":
              set = wordCharCodes;
              complement = true;
              break;
          }
          ASSERT_EXISTS(set);
          return { type: "Set", value: set, complement };
        };
        RegExpParser.prototype.controlEscapeAtom = function() {
          var escapeCode;
          switch (this.popChar()) {
            case "f":
              escapeCode = cc("\f");
              break;
            case "n":
              escapeCode = cc("\n");
              break;
            case "r":
              escapeCode = cc("\r");
              break;
            case "t":
              escapeCode = cc("	");
              break;
            case "v":
              escapeCode = cc("\v");
              break;
          }
          ASSERT_EXISTS(escapeCode);
          return { type: "Character", value: escapeCode };
        };
        RegExpParser.prototype.controlLetterEscapeAtom = function() {
          this.consumeChar("c");
          var letter = this.popChar();
          if (/[a-zA-Z]/.test(letter) === false) {
            throw Error("Invalid ");
          }
          var letterCode = letter.toUpperCase().charCodeAt(0) - 64;
          return { type: "Character", value: letterCode };
        };
        RegExpParser.prototype.nulCharacterAtom = function() {
          this.consumeChar("0");
          return { type: "Character", value: cc("\0") };
        };
        RegExpParser.prototype.hexEscapeSequenceAtom = function() {
          this.consumeChar("x");
          return this.parseHexDigits(2);
        };
        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {
          this.consumeChar("u");
          return this.parseHexDigits(4);
        };
        RegExpParser.prototype.identityEscapeAtom = function() {
          var escapedChar = this.popChar();
          return { type: "Character", value: cc(escapedChar) };
        };
        RegExpParser.prototype.classPatternCharacterAtom = function() {
          switch (this.peekChar()) {
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
            case "\\":
            case "]":
              throw Error("TBD");
            default:
              var nextChar = this.popChar();
              return { type: "Character", value: cc(nextChar) };
          }
        };
        RegExpParser.prototype.characterClass = function() {
          var set = [];
          var complement = false;
          this.consumeChar("[");
          if (this.peekChar(0) === "^") {
            this.consumeChar("^");
            complement = true;
          }
          while (this.isClassAtom()) {
            var from = this.classAtom();
            var isFromSingleChar = from.type === "Character";
            if (isFromSingleChar && this.isRangeDash()) {
              this.consumeChar("-");
              var to = this.classAtom();
              var isToSingleChar = to.type === "Character";
              if (isToSingleChar) {
                if (to.value < from.value) {
                  throw Error("Range out of order in character class");
                }
                set.push({ from: from.value, to: to.value });
              } else {
                insertToSet(from.value, set);
                set.push(cc("-"));
                insertToSet(to.value, set);
              }
            } else {
              insertToSet(from.value, set);
            }
          }
          this.consumeChar("]");
          return { type: "Set", complement, value: set };
        };
        RegExpParser.prototype.classAtom = function() {
          switch (this.peekChar()) {
            case "]":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              throw Error("TBD");
            case "\\":
              return this.classEscape();
            default:
              return this.classPatternCharacterAtom();
          }
        };
        RegExpParser.prototype.classEscape = function() {
          this.consumeChar("\\");
          switch (this.peekChar()) {
            case "b":
              this.consumeChar("b");
              return { type: "Character", value: cc("\b") };
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
              return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
              return this.controlEscapeAtom();
            case "c":
              return this.controlLetterEscapeAtom();
            case "0":
              return this.nulCharacterAtom();
            case "x":
              return this.hexEscapeSequenceAtom();
            case "u":
              return this.regExpUnicodeEscapeSequenceAtom();
            default:
              return this.identityEscapeAtom();
          }
        };
        RegExpParser.prototype.group = function() {
          var capturing = true;
          this.consumeChar("(");
          switch (this.peekChar(0)) {
            case "?":
              this.consumeChar("?");
              this.consumeChar(":");
              capturing = false;
              break;
            default:
              this.groupIdx++;
              break;
          }
          var value = this.disjunction();
          this.consumeChar(")");
          var groupAst = {
            type: "Group",
            capturing,
            value
          };
          if (capturing) {
            groupAst.idx = this.groupIdx;
          }
          return groupAst;
        };
        RegExpParser.prototype.positiveInteger = function() {
          var number = this.popChar();
          if (decimalPatternNoZero.test(number) === false) {
            throw Error("Expecting a positive integer");
          }
          while (decimalPattern.test(this.peekChar(0))) {
            number += this.popChar();
          }
          return parseInt(number, 10);
        };
        RegExpParser.prototype.integerIncludingZero = function() {
          var number = this.popChar();
          if (decimalPattern.test(number) === false) {
            throw Error("Expecting an integer");
          }
          while (decimalPattern.test(this.peekChar(0))) {
            number += this.popChar();
          }
          return parseInt(number, 10);
        };
        RegExpParser.prototype.patternCharacter = function() {
          var nextChar = this.popChar();
          switch (nextChar) {
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
            case "^":
            case "$":
            case "\\":
            case ".":
            case "*":
            case "+":
            case "?":
            case "(":
            case ")":
            case "[":
            case "|":
              throw Error("TBD");
            default:
              return { type: "Character", value: cc(nextChar) };
          }
        };
        RegExpParser.prototype.isRegExpFlag = function() {
          switch (this.peekChar(0)) {
            case "g":
            case "i":
            case "m":
            case "u":
            case "y":
              return true;
            default:
              return false;
          }
        };
        RegExpParser.prototype.isRangeDash = function() {
          return this.peekChar() === "-" && this.isClassAtom(1);
        };
        RegExpParser.prototype.isDigit = function() {
          return decimalPattern.test(this.peekChar(0));
        };
        RegExpParser.prototype.isClassAtom = function(howMuch) {
          if (howMuch === void 0) {
            howMuch = 0;
          }
          switch (this.peekChar(howMuch)) {
            case "]":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return false;
            default:
              return true;
          }
        };
        RegExpParser.prototype.isTerm = function() {
          return this.isAtom() || this.isAssertion();
        };
        RegExpParser.prototype.isAtom = function() {
          if (this.isPatternCharacter()) {
            return true;
          }
          switch (this.peekChar(0)) {
            case ".":
            case "\\":
            case "[":
            case "(":
              return true;
            default:
              return false;
          }
        };
        RegExpParser.prototype.isAssertion = function() {
          switch (this.peekChar(0)) {
            case "^":
            case "$":
              return true;
            case "\\":
              switch (this.peekChar(1)) {
                case "b":
                case "B":
                  return true;
                default:
                  return false;
              }
            case "(":
              return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
            default:
              return false;
          }
        };
        RegExpParser.prototype.isQuantifier = function() {
          var prevState = this.saveState();
          try {
            return this.quantifier(true) !== void 0;
          } catch (e) {
            return false;
          } finally {
            this.restoreState(prevState);
          }
        };
        RegExpParser.prototype.isPatternCharacter = function() {
          switch (this.peekChar()) {
            case "^":
            case "$":
            case "\\":
            case ".":
            case "*":
            case "+":
            case "?":
            case "(":
            case ")":
            case "[":
            case "|":
            case "/":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return false;
            default:
              return true;
          }
        };
        RegExpParser.prototype.parseHexDigits = function(howMany) {
          var hexString = "";
          for (var i3 = 0; i3 < howMany; i3++) {
            var hexChar = this.popChar();
            if (hexDigitPattern.test(hexChar) === false) {
              throw Error("Expecting a HexDecimal digits");
            }
            hexString += hexChar;
          }
          var charCode = parseInt(hexString, 16);
          return { type: "Character", value: charCode };
        };
        RegExpParser.prototype.peekChar = function(howMuch) {
          if (howMuch === void 0) {
            howMuch = 0;
          }
          return this.input[this.idx + howMuch];
        };
        RegExpParser.prototype.popChar = function() {
          var nextChar = this.peekChar(0);
          this.consumeChar();
          return nextChar;
        };
        RegExpParser.prototype.consumeChar = function(char) {
          if (char !== void 0 && this.input[this.idx] !== char) {
            throw Error(
              "Expected: '" + char + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx
            );
          }
          if (this.idx >= this.input.length) {
            throw Error("Unexpected end of input");
          }
          this.idx++;
        };
        RegExpParser.prototype.loc = function(begin) {
          return { begin, end: this.idx };
        };
        var hexDigitPattern = /[0-9a-fA-F]/;
        var decimalPattern = /[0-9]/;
        var decimalPatternNoZero = /[1-9]/;
        function cc(char) {
          return char.charCodeAt(0);
        }
        function insertToSet(item, set) {
          if (item.length !== void 0) {
            item.forEach(function(subItem) {
              set.push(subItem);
            });
          } else {
            set.push(item);
          }
        }
        function addFlag(flagObj, flagKey) {
          if (flagObj[flagKey] === true) {
            throw "duplicate flag " + flagKey;
          }
          flagObj[flagKey] = true;
        }
        function ASSERT_EXISTS(obj) {
          if (obj === void 0) {
            throw Error("Internal Error - Should never get here!");
          }
        }
        function ASSERT_NEVER_REACH_HERE() {
          throw Error("Internal Error - Should never get here!");
        }
        var i2;
        var digitsCharCodes = [];
        for (i2 = cc("0"); i2 <= cc("9"); i2++) {
          digitsCharCodes.push(i2);
        }
        var wordCharCodes = [cc("_")].concat(digitsCharCodes);
        for (i2 = cc("a"); i2 <= cc("z"); i2++) {
          wordCharCodes.push(i2);
        }
        for (i2 = cc("A"); i2 <= cc("Z"); i2++) {
          wordCharCodes.push(i2);
        }
        var whitespaceCodes = [
          cc(" "),
          cc("\f"),
          cc("\n"),
          cc("\r"),
          cc("	"),
          cc("\v"),
          cc("	"),
          cc("\xA0"),
          cc("\u1680"),
          cc("\u2000"),
          cc("\u2001"),
          cc("\u2002"),
          cc("\u2003"),
          cc("\u2004"),
          cc("\u2005"),
          cc("\u2006"),
          cc("\u2007"),
          cc("\u2008"),
          cc("\u2009"),
          cc("\u200A"),
          cc("\u2028"),
          cc("\u2029"),
          cc("\u202F"),
          cc("\u205F"),
          cc("\u3000"),
          cc("\uFEFF")
        ];
        function BaseRegExpVisitor() {
        }
        BaseRegExpVisitor.prototype.visitChildren = function(node) {
          for (var key in node) {
            var child = node[key];
            if (node.hasOwnProperty(key)) {
              if (child.type !== void 0) {
                this.visit(child);
              } else if (Array.isArray(child)) {
                child.forEach(function(subChild) {
                  this.visit(subChild);
                }, this);
              }
            }
          }
        };
        BaseRegExpVisitor.prototype.visit = function(node) {
          switch (node.type) {
            case "Pattern":
              this.visitPattern(node);
              break;
            case "Flags":
              this.visitFlags(node);
              break;
            case "Disjunction":
              this.visitDisjunction(node);
              break;
            case "Alternative":
              this.visitAlternative(node);
              break;
            case "StartAnchor":
              this.visitStartAnchor(node);
              break;
            case "EndAnchor":
              this.visitEndAnchor(node);
              break;
            case "WordBoundary":
              this.visitWordBoundary(node);
              break;
            case "NonWordBoundary":
              this.visitNonWordBoundary(node);
              break;
            case "Lookahead":
              this.visitLookahead(node);
              break;
            case "NegativeLookahead":
              this.visitNegativeLookahead(node);
              break;
            case "Character":
              this.visitCharacter(node);
              break;
            case "Set":
              this.visitSet(node);
              break;
            case "Group":
              this.visitGroup(node);
              break;
            case "GroupBackReference":
              this.visitGroupBackReference(node);
              break;
            case "Quantifier":
              this.visitQuantifier(node);
              break;
          }
          this.visitChildren(node);
        };
        BaseRegExpVisitor.prototype.visitPattern = function(node) {
        };
        BaseRegExpVisitor.prototype.visitFlags = function(node) {
        };
        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {
        };
        BaseRegExpVisitor.prototype.visitAlternative = function(node) {
        };
        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {
        };
        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {
        };
        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {
        };
        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {
        };
        BaseRegExpVisitor.prototype.visitLookahead = function(node) {
        };
        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {
        };
        BaseRegExpVisitor.prototype.visitCharacter = function(node) {
        };
        BaseRegExpVisitor.prototype.visitSet = function(node) {
        };
        BaseRegExpVisitor.prototype.visitGroup = function(node) {
        };
        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {
        };
        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {
        };
        return {
          RegExpParser,
          BaseRegExpVisitor,
          VERSION: "0.5.0"
        };
      }
    );
  }
});

// node_modules/lodash/head.js
var require_head = __commonJS({
  "node_modules/lodash/head.js"(exports2, module2) {
    function head2(array) {
      return array && array.length ? array[0] : void 0;
    }
    module2.exports = head2;
  }
});

// node_modules/lodash/first.js
var require_first2 = __commonJS({
  "node_modules/lodash/first.js"(exports2, module2) {
    module2.exports = require_head();
  }
});

// node_modules/lodash/compact.js
var require_compact = __commonJS({
  "node_modules/lodash/compact.js"(exports2, module2) {
    function compact(array) {
      var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length2) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = compact;
  }
});

// node_modules/lodash/_baseFilter.js
var require_baseFilter = __commonJS({
  "node_modules/lodash/_baseFilter.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection2) {
        if (predicate(value, index, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    module2.exports = baseFilter;
  }
});

// node_modules/lodash/negate.js
var require_negate = __commonJS({
  "node_modules/lodash/negate.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    function negate2(predicate) {
      if (typeof predicate != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return !predicate.call(this);
          case 1:
            return !predicate.call(this, args[0]);
          case 2:
            return !predicate.call(this, args[0], args[1]);
          case 3:
            return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }
    module2.exports = negate2;
  }
});

// node_modules/lodash/reject.js
var require_reject = __commonJS({
  "node_modules/lodash/reject.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    var negate2 = require_negate();
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate2(baseIteratee(predicate, 3)));
    }
    module2.exports = reject;
  }
});

// node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "node_modules/lodash/_baseDifference.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length2 = array.length, result = [], valuesLength = values.length;
      if (!length2) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length2) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseDifference;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module2.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/difference.js
var require_difference = __commonJS({
  "node_modules/lodash/difference.js"(exports2, module2) {
    var baseDifference = require_baseDifference();
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });
    module2.exports = difference;
  }
});

// node_modules/lodash/indexOf.js
var require_indexOf = __commonJS({
  "node_modules/lodash/indexOf.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function indexOf(array, value, fromIndex) {
      var length2 = array == null ? 0 : array.length;
      if (!length2) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length2 + index, 0);
      }
      return baseIndexOf(array, value, index);
    }
    module2.exports = indexOf;
  }
});

// node_modules/lodash/_createFind.js
var require_createFind = __commonJS({
  "node_modules/lodash/_createFind.js"(exports2, module2) {
    var baseIteratee = require_baseIteratee();
    var isArrayLike = require_isArrayLike();
    var keys = require_keys();
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) {
            return iteratee(iterable[key], key, iterable);
          };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
      };
    }
    module2.exports = createFind;
  }
});

// node_modules/lodash/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/lodash/findIndex.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIteratee = require_baseIteratee();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function findIndex(array, predicate, fromIndex) {
      var length2 = array == null ? 0 : array.length;
      if (!length2) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length2 + index, 0);
      }
      return baseFindIndex(array, baseIteratee(predicate, 3), index);
    }
    module2.exports = findIndex;
  }
});

// node_modules/lodash/find.js
var require_find = __commonJS({
  "node_modules/lodash/find.js"(exports2, module2) {
    var createFind = require_createFind();
    var findIndex = require_findIndex();
    var find = createFind(findIndex);
    module2.exports = find;
  }
});

// node_modules/lodash/filter.js
var require_filter = __commonJS({
  "node_modules/lodash/filter.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = filter;
  }
});

// node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "node_modules/lodash/defaults.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length2 = sources.length;
      var guard = length2 > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length2 = 1;
      }
      while (++index < length2) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    module2.exports = defaults;
  }
});

// node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "node_modules/lodash/_arrayReduce.js"(exports2, module2) {
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length2 = array == null ? 0 : array.length;
      if (initAccum && length2) {
        accumulator = array[++index];
      }
      while (++index < length2) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    module2.exports = arrayReduce;
  }
});

// node_modules/lodash/_baseReduce.js
var require_baseReduce = __commonJS({
  "node_modules/lodash/_baseReduce.js"(exports2, module2) {
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    module2.exports = baseReduce;
  }
});

// node_modules/lodash/reduce.js
var require_reduce = __commonJS({
  "node_modules/lodash/reduce.js"(exports2, module2) {
    var arrayReduce = require_arrayReduce();
    var baseEach = require_baseEach();
    var baseIteratee = require_baseIteratee();
    var baseReduce = require_baseReduce();
    var isArray = require_isArray();
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    module2.exports = reduce;
  }
});

// node_modules/chevrotain/lib/src/scan/reg_exp_parser.js
var require_reg_exp_parser = __commonJS({
  "node_modules/chevrotain/lib/src/scan/reg_exp_parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.clearRegExpParserCache = exports2.getRegExpAst = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var regExpAstCache = {};
    var regExpParser = new regexp_to_ast_1.RegExpParser();
    function getRegExpAst(regExp) {
      var regExpStr = regExp.toString();
      if (regExpAstCache.hasOwnProperty(regExpStr)) {
        return regExpAstCache[regExpStr];
      } else {
        var regExpAst = regExpParser.pattern(regExpStr);
        regExpAstCache[regExpStr] = regExpAst;
        return regExpAst;
      }
    }
    exports2.getRegExpAst = getRegExpAst;
    function clearRegExpParserCache() {
      regExpAstCache = {};
    }
    exports2.clearRegExpParserCache = clearRegExpParserCache;
  }
});

// node_modules/chevrotain/lib/src/scan/reg_exp.js
var require_reg_exp = __commonJS({
  "node_modules/chevrotain/lib/src/scan/reg_exp.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b5) {
          d2.__proto__ = b5;
        } || function(d2, b5) {
          for (var p in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p))
              d2[p] = b5[p];
        };
        return extendStatics(d, b3);
      };
      return function(d, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d, b3);
        function __() {
          this.constructor = d;
        }
        d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.canMatchCharCode = exports2.firstCharOptimizedIndices = exports2.getOptimizedStartCodesIndices = exports2.failedOptimizationPrefixMsg = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var isArray_1 = __importDefault(require_isArray());
    var every_1 = __importDefault(require_every());
    var forEach_1 = __importDefault(require_forEach());
    var find_1 = __importDefault(require_find());
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var utils_1 = require_api();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var lexer_1 = require_lexer();
    var complementErrorMessage = "Complement Sets are not supported for first char optimization";
    exports2.failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
    function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {
      if (ensureOptimizations === void 0) {
        ensureOptimizations = false;
      }
      try {
        var ast = (0, reg_exp_parser_1.getRegExpAst)(regExp);
        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
        return firstChars;
      } catch (e) {
        if (e.message === complementErrorMessage) {
          if (ensureOptimizations) {
            (0, utils_1.PRINT_WARNING)("".concat(exports2.failedOptimizationPrefixMsg) + "	Unable to optimize: < ".concat(regExp.toString(), " >\n") + "	Complement Sets cannot be automatically optimized.\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
          }
        } else {
          var msgSuffix = "";
          if (ensureOptimizations) {
            msgSuffix = "\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
          }
          (0, utils_1.PRINT_ERROR)("".concat(exports2.failedOptimizationPrefixMsg, "\n") + "	Failed parsing: < ".concat(regExp.toString(), " >\n") + "	Using the regexp-to-ast library version: ".concat(regexp_to_ast_1.VERSION, "\n") + "	Please open an issue at: https://github.com/bd82/regexp-to-ast/issues" + msgSuffix);
        }
      }
      return [];
    }
    exports2.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;
    function firstCharOptimizedIndices(ast, result, ignoreCase) {
      switch (ast.type) {
        case "Disjunction":
          for (var i2 = 0; i2 < ast.value.length; i2++) {
            firstCharOptimizedIndices(ast.value[i2], result, ignoreCase);
          }
          break;
        case "Alternative":
          var terms = ast.value;
          for (var i2 = 0; i2 < terms.length; i2++) {
            var term = terms[i2];
            switch (term.type) {
              case "EndAnchor":
              case "GroupBackReference":
              case "Lookahead":
              case "NegativeLookahead":
              case "StartAnchor":
              case "WordBoundary":
              case "NonWordBoundary":
                continue;
            }
            var atom = term;
            switch (atom.type) {
              case "Character":
                addOptimizedIdxToResult(atom.value, result, ignoreCase);
                break;
              case "Set":
                if (atom.complement === true) {
                  throw Error(complementErrorMessage);
                }
                (0, forEach_1.default)(atom.value, function(code) {
                  if (typeof code === "number") {
                    addOptimizedIdxToResult(code, result, ignoreCase);
                  } else {
                    var range = code;
                    if (ignoreCase === true) {
                      for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {
                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                      }
                    } else {
                      for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {
                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                      }
                      if (range.to >= lexer_1.minOptimizationVal) {
                        var minUnOptVal = range.from >= lexer_1.minOptimizationVal ? range.from : lexer_1.minOptimizationVal;
                        var maxUnOptVal = range.to;
                        var minOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(minUnOptVal);
                        var maxOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(maxUnOptVal);
                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                          result[currOptIdx] = currOptIdx;
                        }
                      }
                    }
                  }
                });
                break;
              case "Group":
                firstCharOptimizedIndices(atom.value, result, ignoreCase);
                break;
              default:
                throw Error("Non Exhaustive Match");
            }
            var isOptionalQuantifier = atom.quantifier !== void 0 && atom.quantifier.atLeast === 0;
            if (atom.type === "Group" && isWholeOptional(atom) === false || atom.type !== "Group" && isOptionalQuantifier === false) {
              break;
            }
          }
          break;
        default:
          throw Error("non exhaustive match!");
      }
      return (0, values_1.default)(result);
    }
    exports2.firstCharOptimizedIndices = firstCharOptimizedIndices;
    function addOptimizedIdxToResult(code, result, ignoreCase) {
      var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(code);
      result[optimizedCharIdx] = optimizedCharIdx;
      if (ignoreCase === true) {
        handleIgnoreCase(code, result);
      }
    }
    function handleIgnoreCase(code, result) {
      var char = String.fromCharCode(code);
      var upperChar = char.toUpperCase();
      if (upperChar !== char) {
        var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));
        result[optimizedCharIdx] = optimizedCharIdx;
      } else {
        var lowerChar = char.toLowerCase();
        if (lowerChar !== char) {
          var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));
          result[optimizedCharIdx] = optimizedCharIdx;
        }
      }
    }
    function findCode(setNode, targetCharCodes) {
      return (0, find_1.default)(setNode.value, function(codeOrRange) {
        if (typeof codeOrRange === "number") {
          return (0, includes_1.default)(targetCharCodes, codeOrRange);
        } else {
          var range_1 = codeOrRange;
          return (0, find_1.default)(targetCharCodes, function(targetCode) {
            return range_1.from <= targetCode && targetCode <= range_1.to;
          }) !== void 0;
        }
      });
    }
    function isWholeOptional(ast) {
      var quantifier = ast.quantifier;
      if (quantifier && quantifier.atLeast === 0) {
        return true;
      }
      if (!ast.value) {
        return false;
      }
      return (0, isArray_1.default)(ast.value) ? (0, every_1.default)(ast.value, isWholeOptional) : isWholeOptional(ast.value);
    }
    var CharCodeFinder = function(_super) {
      __extends(CharCodeFinder2, _super);
      function CharCodeFinder2(targetCharCodes) {
        var _this = _super.call(this) || this;
        _this.targetCharCodes = targetCharCodes;
        _this.found = false;
        return _this;
      }
      CharCodeFinder2.prototype.visitChildren = function(node) {
        if (this.found === true) {
          return;
        }
        switch (node.type) {
          case "Lookahead":
            this.visitLookahead(node);
            return;
          case "NegativeLookahead":
            this.visitNegativeLookahead(node);
            return;
        }
        _super.prototype.visitChildren.call(this, node);
      };
      CharCodeFinder2.prototype.visitCharacter = function(node) {
        if ((0, includes_1.default)(this.targetCharCodes, node.value)) {
          this.found = true;
        }
      };
      CharCodeFinder2.prototype.visitSet = function(node) {
        if (node.complement) {
          if (findCode(node, this.targetCharCodes) === void 0) {
            this.found = true;
          }
        } else {
          if (findCode(node, this.targetCharCodes) !== void 0) {
            this.found = true;
          }
        }
      };
      return CharCodeFinder2;
    }(regexp_to_ast_1.BaseRegExpVisitor);
    function canMatchCharCode(charCodes, pattern) {
      if (pattern instanceof RegExp) {
        var ast = (0, reg_exp_parser_1.getRegExpAst)(pattern);
        var charCodeFinder = new CharCodeFinder(charCodes);
        charCodeFinder.visit(ast);
        return charCodeFinder.found;
      } else {
        return (0, find_1.default)(pattern, function(char) {
          return (0, includes_1.default)(charCodes, char.charCodeAt(0));
        }) !== void 0;
      }
    }
    exports2.canMatchCharCode = canMatchCharCode;
  }
});

// node_modules/chevrotain/lib/src/scan/lexer.js
var require_lexer = __commonJS({
  "node_modules/chevrotain/lib/src/scan/lexer.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b5) {
          d2.__proto__ = b5;
        } || function(d2, b5) {
          for (var p in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p))
              d2[p] = b5[p];
        };
        return extendStatics(d, b3);
      };
      return function(d, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d, b3);
        function __() {
          this.constructor = d;
        }
        d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.charCodeToOptimizedIndex = exports2.minOptimizationVal = exports2.buildLineBreakIssueMessage = exports2.LineTerminatorOptimizedTester = exports2.isShortPattern = exports2.isCustomPattern = exports2.cloneEmptyGroups = exports2.performWarningRuntimeChecks = exports2.performRuntimeChecks = exports2.addStickyFlag = exports2.addStartOfInput = exports2.findUnreachablePatterns = exports2.findModesThatDoNotExist = exports2.findInvalidGroupType = exports2.findDuplicatePatterns = exports2.findUnsupportedFlags = exports2.findStartOfInputAnchor = exports2.findEmptyMatchRegExps = exports2.findEndOfInputAnchor = exports2.findInvalidPatterns = exports2.findMissingPatterns = exports2.validatePatterns = exports2.analyzeTokenTypes = exports2.enableSticky = exports2.disableSticky = exports2.SUPPORT_STICKY = exports2.MODES = exports2.DEFAULT_MODE = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var lexer_public_1 = require_lexer_public();
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var values_1 = __importDefault(require_values());
    var flatten_1 = __importDefault(require_flatten());
    var reject_1 = __importDefault(require_reject());
    var difference_1 = __importDefault(require_difference());
    var indexOf_1 = __importDefault(require_indexOf());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var isString_1 = __importDefault(require_isString());
    var isFunction_1 = __importDefault(require_isFunction());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var find_1 = __importDefault(require_find());
    var has_1 = __importDefault(require_has());
    var keys_1 = __importDefault(require_keys());
    var isRegExp_1 = __importDefault(require_isRegExp());
    var filter_1 = __importDefault(require_filter());
    var defaults_1 = __importDefault(require_defaults());
    var reduce_1 = __importDefault(require_reduce());
    var includes_1 = __importDefault(require_includes());
    var utils_1 = require_api();
    var reg_exp_1 = require_reg_exp();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var PATTERN = "PATTERN";
    exports2.DEFAULT_MODE = "defaultMode";
    exports2.MODES = "modes";
    exports2.SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
    function disableSticky() {
      exports2.SUPPORT_STICKY = false;
    }
    exports2.disableSticky = disableSticky;
    function enableSticky() {
      exports2.SUPPORT_STICKY = true;
    }
    exports2.enableSticky = enableSticky;
    function analyzeTokenTypes(tokenTypes, options) {
      options = (0, defaults_1.default)(options, {
        useSticky: exports2.SUPPORT_STICKY,
        debug: false,
        safeMode: false,
        positionTracking: "full",
        lineTerminatorCharacters: ["\r", "\n"],
        tracer: function(msg, action) {
          return action();
        }
      });
      var tracer = options.tracer;
      tracer("initCharCodeToOptimizedIndexMap", function() {
        initCharCodeToOptimizedIndexMap();
      });
      var onlyRelevantTypes;
      tracer("Reject Lexer.NA", function() {
        onlyRelevantTypes = (0, reject_1.default)(tokenTypes, function(currType) {
          return currType[PATTERN] === lexer_public_1.Lexer.NA;
        });
      });
      var hasCustom = false;
      var allTransformedPatterns;
      tracer("Transform Patterns", function() {
        hasCustom = false;
        allTransformedPatterns = (0, map_1.default)(onlyRelevantTypes, function(currType) {
          var currPattern = currType[PATTERN];
          if ((0, isRegExp_1.default)(currPattern)) {
            var regExpSource = currPattern.source;
            if (regExpSource.length === 1 && regExpSource !== "^" && regExpSource !== "$" && regExpSource !== "." && !currPattern.ignoreCase) {
              return regExpSource;
            } else if (regExpSource.length === 2 && regExpSource[0] === "\\" && !(0, includes_1.default)([
              "d",
              "D",
              "s",
              "S",
              "t",
              "r",
              "n",
              "t",
              "0",
              "c",
              "b",
              "B",
              "f",
              "v",
              "w",
              "W"
            ], regExpSource[1])) {
              return regExpSource[1];
            } else {
              return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);
            }
          } else if ((0, isFunction_1.default)(currPattern)) {
            hasCustom = true;
            return { exec: currPattern };
          } else if (typeof currPattern === "object") {
            hasCustom = true;
            return currPattern;
          } else if (typeof currPattern === "string") {
            if (currPattern.length === 1) {
              return currPattern;
            } else {
              var escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
              var wrappedRegExp = new RegExp(escapedRegExpString);
              return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);
            }
          } else {
            throw Error("non exhaustive match");
          }
        });
      });
      var patternIdxToType;
      var patternIdxToGroup;
      var patternIdxToLongerAltIdxArr;
      var patternIdxToPushMode;
      var patternIdxToPopMode;
      tracer("misc mapping", function() {
        patternIdxToType = (0, map_1.default)(onlyRelevantTypes, function(currType) {
          return currType.tokenTypeIdx;
        });
        patternIdxToGroup = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          var groupName = clazz.GROUP;
          if (groupName === lexer_public_1.Lexer.SKIPPED) {
            return void 0;
          } else if ((0, isString_1.default)(groupName)) {
            return groupName;
          } else if ((0, isUndefined_1.default)(groupName)) {
            return false;
          } else {
            throw Error("non exhaustive match");
          }
        });
        patternIdxToLongerAltIdxArr = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          var longerAltType = clazz.LONGER_ALT;
          if (longerAltType) {
            var longerAltIdxArr = (0, isArray_1.default)(longerAltType) ? (0, map_1.default)(longerAltType, function(type2) {
              return (0, indexOf_1.default)(onlyRelevantTypes, type2);
            }) : [(0, indexOf_1.default)(onlyRelevantTypes, longerAltType)];
            return longerAltIdxArr;
          }
        });
        patternIdxToPushMode = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          return clazz.PUSH_MODE;
        });
        patternIdxToPopMode = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          return (0, has_1.default)(clazz, "POP_MODE");
        });
      });
      var patternIdxToCanLineTerminator;
      tracer("Line Terminator Handling", function() {
        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
        patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function(tokType) {
          return false;
        });
        if (options.positionTracking !== "onlyOffset") {
          patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function(tokType) {
            if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
              return !!tokType.LINE_BREAKS;
            } else {
              return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
            }
          });
        }
      });
      var patternIdxToIsCustom;
      var patternIdxToShort;
      var emptyGroups;
      var patternIdxToConfig;
      tracer("Misc Mapping #2", function() {
        patternIdxToIsCustom = (0, map_1.default)(onlyRelevantTypes, isCustomPattern);
        patternIdxToShort = (0, map_1.default)(allTransformedPatterns, isShortPattern);
        emptyGroups = (0, reduce_1.default)(onlyRelevantTypes, function(acc, clazz) {
          var groupName = clazz.GROUP;
          if ((0, isString_1.default)(groupName) && !(groupName === lexer_public_1.Lexer.SKIPPED)) {
            acc[groupName] = [];
          }
          return acc;
        }, {});
        patternIdxToConfig = (0, map_1.default)(allTransformedPatterns, function(x, idx) {
          return {
            pattern: allTransformedPatterns[idx],
            longerAlt: patternIdxToLongerAltIdxArr[idx],
            canLineTerminator: patternIdxToCanLineTerminator[idx],
            isCustom: patternIdxToIsCustom[idx],
            short: patternIdxToShort[idx],
            group: patternIdxToGroup[idx],
            push: patternIdxToPushMode[idx],
            pop: patternIdxToPopMode[idx],
            tokenTypeIdx: patternIdxToType[idx],
            tokenType: onlyRelevantTypes[idx]
          };
        });
      });
      var canBeOptimized = true;
      var charCodeToPatternIdxToConfig = [];
      if (!options.safeMode) {
        tracer("First Char Optimization", function() {
          charCodeToPatternIdxToConfig = (0, reduce_1.default)(onlyRelevantTypes, function(result, currTokType, idx) {
            if (typeof currTokType.PATTERN === "string") {
              var charCode = currTokType.PATTERN.charCodeAt(0);
              var optimizedIdx = charCodeToOptimizedIndex(charCode);
              addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
            } else if ((0, isArray_1.default)(currTokType.START_CHARS_HINT)) {
              var lastOptimizedIdx_1;
              (0, forEach_1.default)(currTokType.START_CHARS_HINT, function(charOrInt) {
                var charCode2 = typeof charOrInt === "string" ? charOrInt.charCodeAt(0) : charOrInt;
                var currOptimizedIdx = charCodeToOptimizedIndex(charCode2);
                if (lastOptimizedIdx_1 !== currOptimizedIdx) {
                  lastOptimizedIdx_1 = currOptimizedIdx;
                  addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
                }
              });
            } else if ((0, isRegExp_1.default)(currTokType.PATTERN)) {
              if (currTokType.PATTERN.unicode) {
                canBeOptimized = false;
                if (options.ensureOptimizations) {
                  (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "	Unable to analyze < ".concat(currTokType.PATTERN.toString(), " > pattern.\n") + "	The regexp unicode flag is not currently supported by the regexp-to-ast library.\n	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
                }
              } else {
                var optimizedCodes = (0, reg_exp_1.getOptimizedStartCodesIndices)(currTokType.PATTERN, options.ensureOptimizations);
                if ((0, isEmpty_1.default)(optimizedCodes)) {
                  canBeOptimized = false;
                }
                (0, forEach_1.default)(optimizedCodes, function(code) {
                  addToMapOfArrays(result, code, patternIdxToConfig[idx]);
                });
              }
            } else {
              if (options.ensureOptimizations) {
                (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "	TokenType: <".concat(currTokType.name, "> is using a custom token pattern without providing <start_chars_hint> parameter.\n") + "	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");
              }
              canBeOptimized = false;
            }
            return result;
          }, []);
        });
      }
      return {
        emptyGroups,
        patternIdxToConfig,
        charCodeToPatternIdxToConfig,
        hasCustom,
        canBeOptimized
      };
    }
    exports2.analyzeTokenTypes = analyzeTokenTypes;
    function validatePatterns(tokenTypes, validModesNames) {
      var errors = [];
      var missingResult = findMissingPatterns(tokenTypes);
      errors = errors.concat(missingResult.errors);
      var invalidResult = findInvalidPatterns(missingResult.valid);
      var validTokenTypes = invalidResult.valid;
      errors = errors.concat(invalidResult.errors);
      errors = errors.concat(validateRegExpPattern(validTokenTypes));
      errors = errors.concat(findInvalidGroupType(validTokenTypes));
      errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
      errors = errors.concat(findUnreachablePatterns(validTokenTypes));
      return errors;
    }
    exports2.validatePatterns = validatePatterns;
    function validateRegExpPattern(tokenTypes) {
      var errors = [];
      var withRegExpPatterns = (0, filter_1.default)(tokenTypes, function(currTokType) {
        return (0, isRegExp_1.default)(currTokType[PATTERN]);
      });
      errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
      errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
      errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
      errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
      errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
      return errors;
    }
    function findMissingPatterns(tokenTypes) {
      var tokenTypesWithMissingPattern = (0, filter_1.default)(tokenTypes, function(currType) {
        return !(0, has_1.default)(currType, PATTERN);
      });
      var errors = (0, map_1.default)(tokenTypesWithMissingPattern, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- missing static 'PATTERN' property",
          type: lexer_public_1.LexerDefinitionErrorType.MISSING_PATTERN,
          tokenTypes: [currType]
        };
      });
      var valid = (0, difference_1.default)(tokenTypes, tokenTypesWithMissingPattern);
      return { errors, valid };
    }
    exports2.findMissingPatterns = findMissingPatterns;
    function findInvalidPatterns(tokenTypes) {
      var tokenTypesWithInvalidPattern = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        return !(0, isRegExp_1.default)(pattern) && !(0, isFunction_1.default)(pattern) && !(0, has_1.default)(pattern, "exec") && !(0, isString_1.default)(pattern);
      });
      var errors = (0, map_1.default)(tokenTypesWithInvalidPattern, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
          type: lexer_public_1.LexerDefinitionErrorType.INVALID_PATTERN,
          tokenTypes: [currType]
        };
      });
      var valid = (0, difference_1.default)(tokenTypes, tokenTypesWithInvalidPattern);
      return { errors, valid };
    }
    exports2.findInvalidPatterns = findInvalidPatterns;
    var end_of_input = /[^\\][$]/;
    function findEndOfInputAnchor(tokenTypes) {
      var EndAnchorFinder = function(_super) {
        __extends(EndAnchorFinder2, _super);
        function EndAnchorFinder2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.found = false;
          return _this;
        }
        EndAnchorFinder2.prototype.visitEndAnchor = function(node) {
          this.found = true;
        };
        return EndAnchorFinder2;
      }(regexp_to_ast_1.BaseRegExpVisitor);
      var invalidRegex = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        try {
          var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
          var endAnchorVisitor = new EndAnchorFinder();
          endAnchorVisitor.visit(regexpAst);
          return endAnchorVisitor.found;
        } catch (e) {
          return end_of_input.test(pattern.source);
        }
      });
      var errors = (0, map_1.default)(invalidRegex, function(currType) {
        return {
          message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain end of input anchor '$'\n	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findEndOfInputAnchor = findEndOfInputAnchor;
    function findEmptyMatchRegExps(tokenTypes) {
      var matchesEmptyString = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        return pattern.test("");
      });
      var errors = (0, map_1.default)(matchesEmptyString, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' must not match an empty string",
          type: lexer_public_1.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findEmptyMatchRegExps = findEmptyMatchRegExps;
    var start_of_input = /[^\\[][\^]|^\^/;
    function findStartOfInputAnchor(tokenTypes) {
      var StartAnchorFinder = function(_super) {
        __extends(StartAnchorFinder2, _super);
        function StartAnchorFinder2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.found = false;
          return _this;
        }
        StartAnchorFinder2.prototype.visitStartAnchor = function(node) {
          this.found = true;
        };
        return StartAnchorFinder2;
      }(regexp_to_ast_1.BaseRegExpVisitor);
      var invalidRegex = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        try {
          var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
          var startAnchorVisitor = new StartAnchorFinder();
          startAnchorVisitor.visit(regexpAst);
          return startAnchorVisitor.found;
        } catch (e) {
          return start_of_input.test(pattern.source);
        }
      });
      var errors = (0, map_1.default)(invalidRegex, function(currType) {
        return {
          message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain start of input anchor '^'\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findStartOfInputAnchor = findStartOfInputAnchor;
    function findUnsupportedFlags(tokenTypes) {
      var invalidFlags = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        return pattern instanceof RegExp && (pattern.multiline || pattern.global);
      });
      var errors = (0, map_1.default)(invalidFlags, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
          type: lexer_public_1.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findUnsupportedFlags = findUnsupportedFlags;
    function findDuplicatePatterns(tokenTypes) {
      var found = [];
      var identicalPatterns = (0, map_1.default)(tokenTypes, function(outerType) {
        return (0, reduce_1.default)(tokenTypes, function(result, innerType) {
          if (outerType.PATTERN.source === innerType.PATTERN.source && !(0, includes_1.default)(found, innerType) && innerType.PATTERN !== lexer_public_1.Lexer.NA) {
            found.push(innerType);
            result.push(innerType);
            return result;
          }
          return result;
        }, []);
      });
      identicalPatterns = (0, compact_1.default)(identicalPatterns);
      var duplicatePatterns = (0, filter_1.default)(identicalPatterns, function(currIdenticalSet) {
        return currIdenticalSet.length > 1;
      });
      var errors = (0, map_1.default)(duplicatePatterns, function(setOfIdentical) {
        var tokenTypeNames = (0, map_1.default)(setOfIdentical, function(currType) {
          return currType.name;
        });
        var dupPatternSrc = (0, first_1.default)(setOfIdentical).PATTERN;
        return {
          message: "The same RegExp pattern ->".concat(dupPatternSrc, "<-") + "has been used in all of the following Token Types: ".concat(tokenTypeNames.join(", "), " <-"),
          type: lexer_public_1.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
          tokenTypes: setOfIdentical
        };
      });
      return errors;
    }
    exports2.findDuplicatePatterns = findDuplicatePatterns;
    function findInvalidGroupType(tokenTypes) {
      var invalidTypes = (0, filter_1.default)(tokenTypes, function(clazz) {
        if (!(0, has_1.default)(clazz, "GROUP")) {
          return false;
        }
        var group = clazz.GROUP;
        return group !== lexer_public_1.Lexer.SKIPPED && group !== lexer_public_1.Lexer.NA && !(0, isString_1.default)(group);
      });
      var errors = (0, map_1.default)(invalidTypes, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
          type: lexer_public_1.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findInvalidGroupType = findInvalidGroupType;
    function findModesThatDoNotExist(tokenTypes, validModes) {
      var invalidModes = (0, filter_1.default)(tokenTypes, function(clazz) {
        return clazz.PUSH_MODE !== void 0 && !(0, includes_1.default)(validModes, clazz.PUSH_MODE);
      });
      var errors = (0, map_1.default)(invalidModes, function(tokType) {
        var msg = "Token Type: ->".concat(tokType.name, "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->").concat(tokType.PUSH_MODE, "<-") + "which does not exist";
        return {
          message: msg,
          type: lexer_public_1.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
          tokenTypes: [tokType]
        };
      });
      return errors;
    }
    exports2.findModesThatDoNotExist = findModesThatDoNotExist;
    function findUnreachablePatterns(tokenTypes) {
      var errors = [];
      var canBeTested = (0, reduce_1.default)(tokenTypes, function(result, tokType, idx) {
        var pattern = tokType.PATTERN;
        if (pattern === lexer_public_1.Lexer.NA) {
          return result;
        }
        if ((0, isString_1.default)(pattern)) {
          result.push({ str: pattern, idx, tokenType: tokType });
        } else if ((0, isRegExp_1.default)(pattern) && noMetaChar(pattern)) {
          result.push({ str: pattern.source, idx, tokenType: tokType });
        }
        return result;
      }, []);
      (0, forEach_1.default)(tokenTypes, function(tokType, testIdx) {
        (0, forEach_1.default)(canBeTested, function(_a2) {
          var str = _a2.str, idx = _a2.idx, tokenType = _a2.tokenType;
          if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
            var msg = "Token: ->".concat(tokenType.name, "<- can never be matched.\n") + "Because it appears AFTER the Token Type ->".concat(tokType.name, "<-") + "in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE";
            errors.push({
              message: msg,
              type: lexer_public_1.LexerDefinitionErrorType.UNREACHABLE_PATTERN,
              tokenTypes: [tokType, tokenType]
            });
          }
        });
      });
      return errors;
    }
    exports2.findUnreachablePatterns = findUnreachablePatterns;
    function testTokenType(str, pattern) {
      if ((0, isRegExp_1.default)(pattern)) {
        var regExpArray = pattern.exec(str);
        return regExpArray !== null && regExpArray.index === 0;
      } else if ((0, isFunction_1.default)(pattern)) {
        return pattern(str, 0, [], {});
      } else if ((0, has_1.default)(pattern, "exec")) {
        return pattern.exec(str, 0, [], {});
      } else if (typeof pattern === "string") {
        return pattern === str;
      } else {
        throw Error("non exhaustive match");
      }
    }
    function noMetaChar(regExp) {
      var metaChars = [
        ".",
        "\\",
        "[",
        "]",
        "|",
        "^",
        "$",
        "(",
        ")",
        "?",
        "*",
        "+",
        "{"
      ];
      return (0, find_1.default)(metaChars, function(char) {
        return regExp.source.indexOf(char) !== -1;
      }) === void 0;
    }
    function addStartOfInput(pattern) {
      var flags = pattern.ignoreCase ? "i" : "";
      return new RegExp("^(?:".concat(pattern.source, ")"), flags);
    }
    exports2.addStartOfInput = addStartOfInput;
    function addStickyFlag(pattern) {
      var flags = pattern.ignoreCase ? "iy" : "y";
      return new RegExp("".concat(pattern.source), flags);
    }
    exports2.addStickyFlag = addStickyFlag;
    function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
      var errors = [];
      if (!(0, has_1.default)(lexerDefinition, exports2.DEFAULT_MODE)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized without a <" + exports2.DEFAULT_MODE + "> property in its definition\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
        });
      }
      if (!(0, has_1.default)(lexerDefinition, exports2.MODES)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized without a <" + exports2.MODES + "> property in its definition\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
        });
      }
      if ((0, has_1.default)(lexerDefinition, exports2.MODES) && (0, has_1.default)(lexerDefinition, exports2.DEFAULT_MODE) && !(0, has_1.default)(lexerDefinition.modes, lexerDefinition.defaultMode)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized with a ".concat(exports2.DEFAULT_MODE, ": <").concat(lexerDefinition.defaultMode, ">") + "which does not exist\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
        });
      }
      if ((0, has_1.default)(lexerDefinition, exports2.MODES)) {
        (0, forEach_1.default)(lexerDefinition.modes, function(currModeValue, currModeName) {
          (0, forEach_1.default)(currModeValue, function(currTokType, currIdx) {
            if ((0, isUndefined_1.default)(currTokType)) {
              errors.push({
                message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" + "<".concat(currModeName, "> at index: <").concat(currIdx, ">\n"),
                type: lexer_public_1.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
              });
            } else if ((0, has_1.default)(currTokType, "LONGER_ALT")) {
              var longerAlt = (0, isArray_1.default)(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];
              (0, forEach_1.default)(longerAlt, function(currLongerAlt) {
                if (!(0, isUndefined_1.default)(currLongerAlt) && !(0, includes_1.default)(currModeValue, currLongerAlt)) {
                  errors.push({
                    message: "A MultiMode Lexer cannot be initialized with a longer_alt <".concat(currLongerAlt.name, "> on token <").concat(currTokType.name, "> outside of mode <").concat(currModeName, ">\n"),
                    type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
                  });
                }
              });
            }
          });
        });
      }
      return errors;
    }
    exports2.performRuntimeChecks = performRuntimeChecks;
    function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
      var warnings = [];
      var hasAnyLineBreak = false;
      var allTokenTypes = (0, compact_1.default)((0, flatten_1.default)((0, values_1.default)(lexerDefinition.modes)));
      var concreteTokenTypes = (0, reject_1.default)(allTokenTypes, function(currType) {
        return currType[PATTERN] === lexer_public_1.Lexer.NA;
      });
      var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
      if (trackLines) {
        (0, forEach_1.default)(concreteTokenTypes, function(tokType) {
          var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
          if (currIssue !== false) {
            var message = buildLineBreakIssueMessage(tokType, currIssue);
            var warningDescriptor = {
              message,
              type: currIssue.issue,
              tokenType: tokType
            };
            warnings.push(warningDescriptor);
          } else {
            if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
              if (tokType.LINE_BREAKS === true) {
                hasAnyLineBreak = true;
              }
            } else {
              if ((0, reg_exp_1.canMatchCharCode)(terminatorCharCodes, tokType.PATTERN)) {
                hasAnyLineBreak = true;
              }
            }
          }
        });
      }
      if (trackLines && !hasAnyLineBreak) {
        warnings.push({
          message: "Warning: No LINE_BREAKS Found.\n	This Lexer has been defined to track line and column information,\n	But none of the Token Types can be identified as matching a line terminator.\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
        });
      }
      return warnings;
    }
    exports2.performWarningRuntimeChecks = performWarningRuntimeChecks;
    function cloneEmptyGroups(emptyGroups) {
      var clonedResult = {};
      var groupKeys = (0, keys_1.default)(emptyGroups);
      (0, forEach_1.default)(groupKeys, function(currKey) {
        var currGroupValue = emptyGroups[currKey];
        if ((0, isArray_1.default)(currGroupValue)) {
          clonedResult[currKey] = [];
        } else {
          throw Error("non exhaustive match");
        }
      });
      return clonedResult;
    }
    exports2.cloneEmptyGroups = cloneEmptyGroups;
    function isCustomPattern(tokenType) {
      var pattern = tokenType.PATTERN;
      if ((0, isRegExp_1.default)(pattern)) {
        return false;
      } else if ((0, isFunction_1.default)(pattern)) {
        return true;
      } else if ((0, has_1.default)(pattern, "exec")) {
        return true;
      } else if ((0, isString_1.default)(pattern)) {
        return false;
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.isCustomPattern = isCustomPattern;
    function isShortPattern(pattern) {
      if ((0, isString_1.default)(pattern) && pattern.length === 1) {
        return pattern.charCodeAt(0);
      } else {
        return false;
      }
    }
    exports2.isShortPattern = isShortPattern;
    exports2.LineTerminatorOptimizedTester = {
      test: function(text) {
        var len = text.length;
        for (var i2 = this.lastIndex; i2 < len; i2++) {
          var c = text.charCodeAt(i2);
          if (c === 10) {
            this.lastIndex = i2 + 1;
            return true;
          } else if (c === 13) {
            if (text.charCodeAt(i2 + 1) === 10) {
              this.lastIndex = i2 + 2;
            } else {
              this.lastIndex = i2 + 1;
            }
            return true;
          }
        }
        return false;
      },
      lastIndex: 0
    };
    function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
      if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
        return false;
      } else {
        if ((0, isRegExp_1.default)(tokType.PATTERN)) {
          try {
            (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
          } catch (e) {
            return {
              issue: lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
              errMsg: e.message
            };
          }
          return false;
        } else if ((0, isString_1.default)(tokType.PATTERN)) {
          return false;
        } else if (isCustomPattern(tokType)) {
          return { issue: lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
        } else {
          throw Error("non exhaustive match");
        }
      }
    }
    function buildLineBreakIssueMessage(tokType, details) {
      if (details.issue === lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
        return "Warning: unable to identify line terminator usage in pattern.\n" + "	The problem is in the <".concat(tokType.name, "> Token Type\n") + "	 Root cause: ".concat(details.errMsg, ".\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
      } else if (details.issue === lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
        return "Warning: A Custom Token Pattern should specify the <line_breaks> option.\n" + "	The problem is in the <".concat(tokType.name, "> Token Type\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.buildLineBreakIssueMessage = buildLineBreakIssueMessage;
    function getCharCodes(charsOrCodes) {
      var charCodes = (0, map_1.default)(charsOrCodes, function(numOrString) {
        if ((0, isString_1.default)(numOrString)) {
          return numOrString.charCodeAt(0);
        } else {
          return numOrString;
        }
      });
      return charCodes;
    }
    function addToMapOfArrays(map, key, value) {
      if (map[key] === void 0) {
        map[key] = [value];
      } else {
        map[key].push(value);
      }
    }
    exports2.minOptimizationVal = 256;
    var charCodeToOptimizedIdxMap = [];
    function charCodeToOptimizedIndex(charCode) {
      return charCode < exports2.minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];
    }
    exports2.charCodeToOptimizedIndex = charCodeToOptimizedIndex;
    function initCharCodeToOptimizedIndexMap() {
      if ((0, isEmpty_1.default)(charCodeToOptimizedIdxMap)) {
        charCodeToOptimizedIdxMap = new Array(65536);
        for (var i2 = 0; i2 < 65536; i2++) {
          charCodeToOptimizedIdxMap[i2] = i2 > 255 ? 255 + ~~(i2 / 255) : i2;
        }
      }
    }
  }
});

// node_modules/lodash/last.js
var require_last = __commonJS({
  "node_modules/lodash/last.js"(exports2, module2) {
    function last(array) {
      var length2 = array == null ? 0 : array.length;
      return length2 ? array[length2 - 1] : void 0;
    }
    module2.exports = last;
  }
});

// node_modules/chevrotain/lib/src/scan/tokens.js
var require_tokens = __commonJS({
  "node_modules/chevrotain/lib/src/scan/tokens.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTokenType = exports2.hasExtendingTokensTypesMapProperty = exports2.hasExtendingTokensTypesProperty = exports2.hasCategoriesProperty = exports2.hasShortKeyProperty = exports2.singleAssignCategoriesToksMap = exports2.assignCategoriesMapProp = exports2.assignCategoriesTokensProp = exports2.assignTokenDefaultProps = exports2.expandCategories = exports2.augmentTokenTypes = exports2.tokenIdxToClass = exports2.tokenShortNameIdx = exports2.tokenStructuredMatcherNoCategories = exports2.tokenStructuredMatcher = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var flatten_1 = __importDefault(require_flatten());
    var difference_1 = __importDefault(require_difference());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var includes_1 = __importDefault(require_includes());
    var clone_1 = __importDefault(require_clone());
    function tokenStructuredMatcher(tokInstance, tokConstructor) {
      var instanceType = tokInstance.tokenTypeIdx;
      if (instanceType === tokConstructor.tokenTypeIdx) {
        return true;
      } else {
        return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;
      }
    }
    exports2.tokenStructuredMatcher = tokenStructuredMatcher;
    function tokenStructuredMatcherNoCategories(token, tokType) {
      return token.tokenTypeIdx === tokType.tokenTypeIdx;
    }
    exports2.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;
    exports2.tokenShortNameIdx = 1;
    exports2.tokenIdxToClass = {};
    function augmentTokenTypes(tokenTypes) {
      var tokenTypesAndParents = expandCategories(tokenTypes);
      assignTokenDefaultProps(tokenTypesAndParents);
      assignCategoriesMapProp(tokenTypesAndParents);
      assignCategoriesTokensProp(tokenTypesAndParents);
      (0, forEach_1.default)(tokenTypesAndParents, function(tokType) {
        tokType.isParent = tokType.categoryMatches.length > 0;
      });
    }
    exports2.augmentTokenTypes = augmentTokenTypes;
    function expandCategories(tokenTypes) {
      var result = (0, clone_1.default)(tokenTypes);
      var categories = tokenTypes;
      var searching = true;
      while (searching) {
        categories = (0, compact_1.default)((0, flatten_1.default)((0, map_1.default)(categories, function(currTokType) {
          return currTokType.CATEGORIES;
        })));
        var newCategories = (0, difference_1.default)(categories, result);
        result = result.concat(newCategories);
        if ((0, isEmpty_1.default)(newCategories)) {
          searching = false;
        } else {
          categories = newCategories;
        }
      }
      return result;
    }
    exports2.expandCategories = expandCategories;
    function assignTokenDefaultProps(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        if (!hasShortKeyProperty(currTokType)) {
          exports2.tokenIdxToClass[exports2.tokenShortNameIdx] = currTokType;
          currTokType.tokenTypeIdx = exports2.tokenShortNameIdx++;
        }
        if (hasCategoriesProperty(currTokType) && !(0, isArray_1.default)(currTokType.CATEGORIES)) {
          currTokType.CATEGORIES = [currTokType.CATEGORIES];
        }
        if (!hasCategoriesProperty(currTokType)) {
          currTokType.CATEGORIES = [];
        }
        if (!hasExtendingTokensTypesProperty(currTokType)) {
          currTokType.categoryMatches = [];
        }
        if (!hasExtendingTokensTypesMapProperty(currTokType)) {
          currTokType.categoryMatchesMap = {};
        }
      });
    }
    exports2.assignTokenDefaultProps = assignTokenDefaultProps;
    function assignCategoriesTokensProp(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        currTokType.categoryMatches = [];
        (0, forEach_1.default)(currTokType.categoryMatchesMap, function(val, key) {
          currTokType.categoryMatches.push(exports2.tokenIdxToClass[key].tokenTypeIdx);
        });
      });
    }
    exports2.assignCategoriesTokensProp = assignCategoriesTokensProp;
    function assignCategoriesMapProp(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        singleAssignCategoriesToksMap([], currTokType);
      });
    }
    exports2.assignCategoriesMapProp = assignCategoriesMapProp;
    function singleAssignCategoriesToksMap(path, nextNode) {
      (0, forEach_1.default)(path, function(pathNode) {
        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
      });
      (0, forEach_1.default)(nextNode.CATEGORIES, function(nextCategory) {
        var newPath = path.concat(nextNode);
        if (!(0, includes_1.default)(newPath, nextCategory)) {
          singleAssignCategoriesToksMap(newPath, nextCategory);
        }
      });
    }
    exports2.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;
    function hasShortKeyProperty(tokType) {
      return (0, has_1.default)(tokType, "tokenTypeIdx");
    }
    exports2.hasShortKeyProperty = hasShortKeyProperty;
    function hasCategoriesProperty(tokType) {
      return (0, has_1.default)(tokType, "CATEGORIES");
    }
    exports2.hasCategoriesProperty = hasCategoriesProperty;
    function hasExtendingTokensTypesProperty(tokType) {
      return (0, has_1.default)(tokType, "categoryMatches");
    }
    exports2.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;
    function hasExtendingTokensTypesMapProperty(tokType) {
      return (0, has_1.default)(tokType, "categoryMatchesMap");
    }
    exports2.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;
    function isTokenType(tokType) {
      return (0, has_1.default)(tokType, "tokenTypeIdx");
    }
    exports2.isTokenType = isTokenType;
  }
});

// node_modules/chevrotain/lib/src/scan/lexer_errors_public.js
var require_lexer_errors_public = __commonJS({
  "node_modules/chevrotain/lib/src/scan/lexer_errors_public.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultLexerErrorProvider = void 0;
    exports2.defaultLexerErrorProvider = {
      buildUnableToPopLexerModeMessage: function(token) {
        return "Unable to pop Lexer Mode after encountering Token ->".concat(token.image, "<- The Mode Stack is empty");
      },
      buildUnexpectedCharactersMessage: function(fullText, startOffset, length2, line2, column) {
        return "unexpected character: ->".concat(fullText.charAt(startOffset), "<- at offset: ").concat(startOffset, ",") + " skipped ".concat(length2, " characters.");
      }
    };
  }
});

// node_modules/chevrotain/lib/src/scan/lexer_public.js
var require_lexer_public = __commonJS({
  "node_modules/chevrotain/lib/src/scan/lexer_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Lexer = exports2.LexerDefinitionErrorType = void 0;
    var lexer_1 = require_lexer();
    var noop_1 = __importDefault(require_noop());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var isArray_1 = __importDefault(require_isArray());
    var last_1 = __importDefault(require_last());
    var reject_1 = __importDefault(require_reject());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var keys_1 = __importDefault(require_keys());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var identity_1 = __importDefault(require_identity());
    var assign_1 = __importDefault(require_assign());
    var reduce_1 = __importDefault(require_reduce());
    var clone_1 = __importDefault(require_clone());
    var utils_1 = require_api();
    var tokens_1 = require_tokens();
    var lexer_errors_public_1 = require_lexer_errors_public();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var LexerDefinitionErrorType2;
    (function(LexerDefinitionErrorType3) {
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"] = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
    })(LexerDefinitionErrorType2 = exports2.LexerDefinitionErrorType || (exports2.LexerDefinitionErrorType = {}));
    var DEFAULT_LEXER_CONFIG = {
      deferDefinitionErrorsHandling: false,
      positionTracking: "full",
      lineTerminatorsPattern: /\n|\r\n?/g,
      lineTerminatorCharacters: ["\n", "\r"],
      ensureOptimizations: false,
      safeMode: false,
      errorMessageProvider: lexer_errors_public_1.defaultLexerErrorProvider,
      traceInitPerf: false,
      skipValidations: false,
      recoveryEnabled: true
    };
    Object.freeze(DEFAULT_LEXER_CONFIG);
    var Lexer2 = function() {
      function Lexer3(lexerDefinition, config) {
        if (config === void 0) {
          config = DEFAULT_LEXER_CONFIG;
        }
        var _this = this;
        this.lexerDefinition = lexerDefinition;
        this.lexerDefinitionErrors = [];
        this.lexerDefinitionWarning = [];
        this.patternIdxToConfig = {};
        this.charCodeToPatternIdxToConfig = {};
        this.modes = [];
        this.emptyGroups = {};
        this.trackStartLines = true;
        this.trackEndLines = true;
        this.hasCustom = false;
        this.canModeBeOptimized = {};
        this.TRACE_INIT = function(phaseDesc, phaseImpl) {
          if (_this.traceInitPerf === true) {
            _this.traceInitIndent++;
            var indent = new Array(_this.traceInitIndent + 1).join("	");
            if (_this.traceInitIndent < _this.traceInitMaxIdent) {
              console.log("".concat(indent, "--> <").concat(phaseDesc, ">"));
            }
            var _a2 = (0, utils_1.timer)(phaseImpl), time = _a2.time, value = _a2.value;
            var traceMethod = time > 10 ? console.warn : console.log;
            if (_this.traceInitIndent < _this.traceInitMaxIdent) {
              traceMethod("".concat(indent, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
            }
            _this.traceInitIndent--;
            return value;
          } else {
            return phaseImpl();
          }
        };
        if (typeof config === "boolean") {
          throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");
        }
        this.config = (0, assign_1.default)({}, DEFAULT_LEXER_CONFIG, config);
        var traceInitVal = this.config.traceInitPerf;
        if (traceInitVal === true) {
          this.traceInitMaxIdent = Infinity;
          this.traceInitPerf = true;
        } else if (typeof traceInitVal === "number") {
          this.traceInitMaxIdent = traceInitVal;
          this.traceInitPerf = true;
        }
        this.traceInitIndent = -1;
        this.TRACE_INIT("Lexer Constructor", function() {
          var actualDefinition;
          var hasOnlySingleMode = true;
          _this.TRACE_INIT("Lexer Config handling", function() {
            if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
              _this.config.lineTerminatorsPattern = lexer_1.LineTerminatorOptimizedTester;
            } else {
              if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
                throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
              }
            }
            if (config.safeMode && config.ensureOptimizations) {
              throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
            }
            _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);
            _this.trackEndLines = /full/i.test(_this.config.positionTracking);
            if ((0, isArray_1.default)(lexerDefinition)) {
              actualDefinition = {
                modes: { defaultMode: (0, clone_1.default)(lexerDefinition) },
                defaultMode: lexer_1.DEFAULT_MODE
              };
            } else {
              hasOnlySingleMode = false;
              actualDefinition = (0, clone_1.default)(lexerDefinition);
            }
          });
          if (_this.config.skipValidations === false) {
            _this.TRACE_INIT("performRuntimeChecks", function() {
              _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
            });
            _this.TRACE_INIT("performWarningRuntimeChecks", function() {
              _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0, lexer_1.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
            });
          }
          actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};
          (0, forEach_1.default)(actualDefinition.modes, function(currModeValue, currModeName) {
            actualDefinition.modes[currModeName] = (0, reject_1.default)(currModeValue, function(currTokType) {
              return (0, isUndefined_1.default)(currTokType);
            });
          });
          var allModeNames = (0, keys_1.default)(actualDefinition.modes);
          (0, forEach_1.default)(actualDefinition.modes, function(currModDef, currModName) {
            _this.TRACE_INIT("Mode: <".concat(currModName, "> processing"), function() {
              _this.modes.push(currModName);
              if (_this.config.skipValidations === false) {
                _this.TRACE_INIT("validatePatterns", function() {
                  _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.validatePatterns)(currModDef, allModeNames));
                });
              }
              if ((0, isEmpty_1.default)(_this.lexerDefinitionErrors)) {
                (0, tokens_1.augmentTokenTypes)(currModDef);
                var currAnalyzeResult_1;
                _this.TRACE_INIT("analyzeTokenTypes", function() {
                  currAnalyzeResult_1 = (0, lexer_1.analyzeTokenTypes)(currModDef, {
                    lineTerminatorCharacters: _this.config.lineTerminatorCharacters,
                    positionTracking: config.positionTracking,
                    ensureOptimizations: config.ensureOptimizations,
                    safeMode: config.safeMode,
                    tracer: _this.TRACE_INIT
                  });
                });
                _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;
                _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;
                _this.emptyGroups = (0, assign_1.default)({}, _this.emptyGroups, currAnalyzeResult_1.emptyGroups);
                _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;
                _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;
              }
            });
          });
          _this.defaultMode = actualDefinition.defaultMode;
          if (!(0, isEmpty_1.default)(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {
            var allErrMessages = (0, map_1.default)(_this.lexerDefinitionErrors, function(error) {
              return error.message;
            });
            var allErrMessagesString = allErrMessages.join("-----------------------\n");
            throw new Error("Errors detected in definition of Lexer:\n" + allErrMessagesString);
          }
          (0, forEach_1.default)(_this.lexerDefinitionWarning, function(warningDescriptor) {
            (0, utils_1.PRINT_WARNING)(warningDescriptor.message);
          });
          _this.TRACE_INIT("Choosing sub-methods implementations", function() {
            if (lexer_1.SUPPORT_STICKY) {
              _this.chopInput = identity_1.default;
              _this.match = _this.matchWithTest;
            } else {
              _this.updateLastIndex = noop_1.default;
              _this.match = _this.matchWithExec;
            }
            if (hasOnlySingleMode) {
              _this.handleModes = noop_1.default;
            }
            if (_this.trackStartLines === false) {
              _this.computeNewColumn = identity_1.default;
            }
            if (_this.trackEndLines === false) {
              _this.updateTokenEndLineColumnLocation = noop_1.default;
            }
            if (/full/i.test(_this.config.positionTracking)) {
              _this.createTokenInstance = _this.createFullToken;
            } else if (/onlyStart/i.test(_this.config.positionTracking)) {
              _this.createTokenInstance = _this.createStartOnlyToken;
            } else if (/onlyOffset/i.test(_this.config.positionTracking)) {
              _this.createTokenInstance = _this.createOffsetOnlyToken;
            } else {
              throw Error('Invalid <positionTracking> config option: "'.concat(_this.config.positionTracking, '"'));
            }
            if (_this.hasCustom) {
              _this.addToken = _this.addTokenUsingPush;
              _this.handlePayload = _this.handlePayloadWithCustom;
            } else {
              _this.addToken = _this.addTokenUsingMemberAccess;
              _this.handlePayload = _this.handlePayloadNoCustom;
            }
          });
          _this.TRACE_INIT("Failed Optimization Warnings", function() {
            var unOptimizedModes = (0, reduce_1.default)(_this.canModeBeOptimized, function(cannotBeOptimized, canBeOptimized, modeName) {
              if (canBeOptimized === false) {
                cannotBeOptimized.push(modeName);
              }
              return cannotBeOptimized;
            }, []);
            if (config.ensureOptimizations && !(0, isEmpty_1.default)(unOptimizedModes)) {
              throw Error("Lexer Modes: < ".concat(unOptimizedModes.join(", "), " > cannot be optimized.\n") + '	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n	 Or inspect the console log for details on how to resolve these issues.');
            }
          });
          _this.TRACE_INIT("clearRegExpParserCache", function() {
            (0, reg_exp_parser_1.clearRegExpParserCache)();
          });
          _this.TRACE_INIT("toFastProperties", function() {
            (0, utils_1.toFastProperties)(_this);
          });
        });
      }
      Lexer3.prototype.tokenize = function(text, initialMode) {
        if (initialMode === void 0) {
          initialMode = this.defaultMode;
        }
        if (!(0, isEmpty_1.default)(this.lexerDefinitionErrors)) {
          var allErrMessages = (0, map_1.default)(this.lexerDefinitionErrors, function(error) {
            return error.message;
          });
          var allErrMessagesString = allErrMessages.join("-----------------------\n");
          throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + allErrMessagesString);
        }
        return this.tokenizeInternal(text, initialMode);
      };
      Lexer3.prototype.tokenizeInternal = function(text, initialMode) {
        var _this = this;
        var i2, j2, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
        var orgText = text;
        var orgLength = orgText.length;
        var offset = 0;
        var matchedTokensIndex = 0;
        var guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);
        var matchedTokens = new Array(guessedNumberOfTokens);
        var errors = [];
        var line2 = this.trackStartLines ? 1 : void 0;
        var column = this.trackStartLines ? 1 : void 0;
        var groups = (0, lexer_1.cloneEmptyGroups)(this.emptyGroups);
        var trackLines = this.trackStartLines;
        var lineTerminatorPattern = this.config.lineTerminatorsPattern;
        var currModePatternsLength = 0;
        var patternIdxToConfig = [];
        var currCharCodeToPatternIdxToConfig = [];
        var modeStack = [];
        var emptyArray = [];
        Object.freeze(emptyArray);
        var getPossiblePatterns;
        function getPossiblePatternsSlow() {
          return patternIdxToConfig;
        }
        function getPossiblePatternsOptimized(charCode) {
          var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(charCode);
          var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
          if (possiblePatterns === void 0) {
            return emptyArray;
          } else {
            return possiblePatterns;
          }
        }
        var pop_mode = function(popToken) {
          if (modeStack.length === 1 && popToken.tokenType.PUSH_MODE === void 0) {
            var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
            errors.push({
              offset: popToken.startOffset,
              line: popToken.startLine,
              column: popToken.startColumn,
              length: popToken.image.length,
              message: msg_1
            });
          } else {
            modeStack.pop();
            var newMode = (0, last_1.default)(modeStack);
            patternIdxToConfig = _this.patternIdxToConfig[newMode];
            currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];
            currModePatternsLength = patternIdxToConfig.length;
            var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;
            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
              getPossiblePatterns = getPossiblePatternsOptimized;
            } else {
              getPossiblePatterns = getPossiblePatternsSlow;
            }
          }
        };
        function push_mode(newMode) {
          modeStack.push(newMode);
          currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];
          patternIdxToConfig = this.patternIdxToConfig[newMode];
          currModePatternsLength = patternIdxToConfig.length;
          currModePatternsLength = patternIdxToConfig.length;
          var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
          if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
            getPossiblePatterns = getPossiblePatternsOptimized;
          } else {
            getPossiblePatterns = getPossiblePatternsSlow;
          }
        }
        push_mode.call(this, initialMode);
        var currConfig;
        var recoveryEnabled = this.config.recoveryEnabled;
        while (offset < orgLength) {
          matchedImage = null;
          var nextCharCode = orgText.charCodeAt(offset);
          var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
          var chosenPatternsLength = chosenPatternIdxToConfig.length;
          for (i2 = 0; i2 < chosenPatternsLength; i2++) {
            currConfig = chosenPatternIdxToConfig[i2];
            var currPattern = currConfig.pattern;
            payload = null;
            var singleCharCode = currConfig.short;
            if (singleCharCode !== false) {
              if (nextCharCode === singleCharCode) {
                matchedImage = currPattern;
              }
            } else if (currConfig.isCustom === true) {
              match = currPattern.exec(orgText, offset, matchedTokens, groups);
              if (match !== null) {
                matchedImage = match[0];
                if (match.payload !== void 0) {
                  payload = match.payload;
                }
              } else {
                matchedImage = null;
              }
            } else {
              this.updateLastIndex(currPattern, offset);
              matchedImage = this.match(currPattern, text, offset);
            }
            if (matchedImage !== null) {
              longerAlt = currConfig.longerAlt;
              if (longerAlt !== void 0) {
                var longerAltLength = longerAlt.length;
                for (k = 0; k < longerAltLength; k++) {
                  var longerAltConfig = patternIdxToConfig[longerAlt[k]];
                  var longerAltPattern = longerAltConfig.pattern;
                  altPayload = null;
                  if (longerAltConfig.isCustom === true) {
                    match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                    if (match !== null) {
                      matchAltImage = match[0];
                      if (match.payload !== void 0) {
                        altPayload = match.payload;
                      }
                    } else {
                      matchAltImage = null;
                    }
                  } else {
                    this.updateLastIndex(longerAltPattern, offset);
                    matchAltImage = this.match(longerAltPattern, text, offset);
                  }
                  if (matchAltImage && matchAltImage.length > matchedImage.length) {
                    matchedImage = matchAltImage;
                    payload = altPayload;
                    currConfig = longerAltConfig;
                    break;
                  }
                }
              }
              break;
            }
          }
          if (matchedImage !== null) {
            imageLength = matchedImage.length;
            group = currConfig.group;
            if (group !== void 0) {
              tokType = currConfig.tokenTypeIdx;
              newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line2, column, imageLength);
              this.handlePayload(newToken, payload);
              if (group === false) {
                matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
              } else {
                groups[group].push(newToken);
              }
            }
            text = this.chopInput(text, imageLength);
            offset = offset + imageLength;
            column = this.computeNewColumn(column, imageLength);
            if (trackLines === true && currConfig.canLineTerminator === true) {
              var numOfLTsInMatch = 0;
              var foundTerminator = void 0;
              var lastLTEndOffset = void 0;
              lineTerminatorPattern.lastIndex = 0;
              do {
                foundTerminator = lineTerminatorPattern.test(matchedImage);
                if (foundTerminator === true) {
                  lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;
                  numOfLTsInMatch++;
                }
              } while (foundTerminator === true);
              if (numOfLTsInMatch !== 0) {
                line2 = line2 + numOfLTsInMatch;
                column = imageLength - lastLTEndOffset;
                this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line2, column, imageLength);
              }
            }
            this.handleModes(currConfig, pop_mode, push_mode, newToken);
          } else {
            var errorStartOffset = offset;
            var errorLine = line2;
            var errorColumn = column;
            var foundResyncPoint = recoveryEnabled === false;
            while (foundResyncPoint === false && offset < orgLength) {
              text = this.chopInput(text, 1);
              offset++;
              for (j2 = 0; j2 < currModePatternsLength; j2++) {
                var currConfig_1 = patternIdxToConfig[j2];
                var currPattern = currConfig_1.pattern;
                var singleCharCode = currConfig_1.short;
                if (singleCharCode !== false) {
                  if (orgText.charCodeAt(offset) === singleCharCode) {
                    foundResyncPoint = true;
                  }
                } else if (currConfig_1.isCustom === true) {
                  foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
                } else {
                  this.updateLastIndex(currPattern, offset);
                  foundResyncPoint = currPattern.exec(text) !== null;
                }
                if (foundResyncPoint === true) {
                  break;
                }
              }
            }
            errLength = offset - errorStartOffset;
            msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
            errors.push({
              offset: errorStartOffset,
              line: errorLine,
              column: errorColumn,
              length: errLength,
              message: msg
            });
            if (recoveryEnabled === false) {
              break;
            }
          }
        }
        if (!this.hasCustom) {
          matchedTokens.length = matchedTokensIndex;
        }
        return {
          tokens: matchedTokens,
          groups,
          errors
        };
      };
      Lexer3.prototype.handleModes = function(config, pop_mode, push_mode, newToken) {
        if (config.pop === true) {
          var pushMode = config.push;
          pop_mode(newToken);
          if (pushMode !== void 0) {
            push_mode.call(this, pushMode);
          }
        } else if (config.push !== void 0) {
          push_mode.call(this, config.push);
        }
      };
      Lexer3.prototype.chopInput = function(text, length2) {
        return text.substring(length2);
      };
      Lexer3.prototype.updateLastIndex = function(regExp, newLastIndex) {
        regExp.lastIndex = newLastIndex;
      };
      Lexer3.prototype.updateTokenEndLineColumnLocation = function(newToken, group, lastLTIdx, numOfLTsInMatch, line2, column, imageLength) {
        var lastCharIsLT, fixForEndingInLT;
        if (group !== void 0) {
          lastCharIsLT = lastLTIdx === imageLength - 1;
          fixForEndingInLT = lastCharIsLT ? -1 : 0;
          if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
            newToken.endLine = line2 + fixForEndingInLT;
            newToken.endColumn = column - 1 + -fixForEndingInLT;
          }
        }
      };
      Lexer3.prototype.computeNewColumn = function(oldColumn, imageLength) {
        return oldColumn + imageLength;
      };
      Lexer3.prototype.createOffsetOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType) {
        return {
          image,
          startOffset,
          tokenTypeIdx,
          tokenType
        };
      };
      Lexer3.prototype.createStartOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
        return {
          image,
          startOffset,
          startLine,
          startColumn,
          tokenTypeIdx,
          tokenType
        };
      };
      Lexer3.prototype.createFullToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
        return {
          image,
          startOffset,
          endOffset: startOffset + imageLength - 1,
          startLine,
          endLine: startLine,
          startColumn,
          endColumn: startColumn + imageLength - 1,
          tokenTypeIdx,
          tokenType
        };
      };
      Lexer3.prototype.addTokenUsingPush = function(tokenVector, index, tokenToAdd) {
        tokenVector.push(tokenToAdd);
        return index;
      };
      Lexer3.prototype.addTokenUsingMemberAccess = function(tokenVector, index, tokenToAdd) {
        tokenVector[index] = tokenToAdd;
        index++;
        return index;
      };
      Lexer3.prototype.handlePayloadNoCustom = function(token, payload) {
      };
      Lexer3.prototype.handlePayloadWithCustom = function(token, payload) {
        if (payload !== null) {
          token.payload = payload;
        }
      };
      Lexer3.prototype.matchWithTest = function(pattern, text, offset) {
        var found = pattern.test(text);
        if (found === true) {
          return text.substring(offset, pattern.lastIndex);
        }
        return null;
      };
      Lexer3.prototype.matchWithExec = function(pattern, text) {
        var regExpArray = pattern.exec(text);
        return regExpArray !== null ? regExpArray[0] : null;
      };
      Lexer3.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
      Lexer3.NA = /NOT_APPLICABLE/;
      return Lexer3;
    }();
    exports2.Lexer = Lexer2;
  }
});

// node_modules/chevrotain/lib/src/scan/tokens_public.js
var require_tokens_public = __commonJS({
  "node_modules/chevrotain/lib/src/scan/tokens_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenMatcher = exports2.createTokenInstance = exports2.EOF = exports2.createToken = exports2.hasTokenLabel = exports2.tokenName = exports2.tokenLabel = void 0;
    var isString_1 = __importDefault(require_isString());
    var has_1 = __importDefault(require_has());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var lexer_public_1 = require_lexer_public();
    var tokens_1 = require_tokens();
    function tokenLabel2(tokType) {
      if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
      } else {
        return tokType.name;
      }
    }
    exports2.tokenLabel = tokenLabel2;
    function tokenName2(tokType) {
      return tokType.name;
    }
    exports2.tokenName = tokenName2;
    function hasTokenLabel(obj) {
      return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
    }
    exports2.hasTokenLabel = hasTokenLabel;
    var PARENT = "parent";
    var CATEGORIES = "categories";
    var LABEL = "label";
    var GROUP = "group";
    var PUSH_MODE = "push_mode";
    var POP_MODE = "pop_mode";
    var LONGER_ALT = "longer_alt";
    var LINE_BREAKS = "line_breaks";
    var START_CHARS_HINT = "start_chars_hint";
    function createToken2(config) {
      return createTokenInternal(config);
    }
    exports2.createToken = createToken2;
    function createTokenInternal(config) {
      var pattern = config.pattern;
      var tokenType = {};
      tokenType.name = config.name;
      if (!(0, isUndefined_1.default)(pattern)) {
        tokenType.PATTERN = pattern;
      }
      if ((0, has_1.default)(config, PARENT)) {
        throw "The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.";
      }
      if ((0, has_1.default)(config, CATEGORIES)) {
        tokenType.CATEGORIES = config[CATEGORIES];
      }
      (0, tokens_1.augmentTokenTypes)([tokenType]);
      if ((0, has_1.default)(config, LABEL)) {
        tokenType.LABEL = config[LABEL];
      }
      if ((0, has_1.default)(config, GROUP)) {
        tokenType.GROUP = config[GROUP];
      }
      if ((0, has_1.default)(config, POP_MODE)) {
        tokenType.POP_MODE = config[POP_MODE];
      }
      if ((0, has_1.default)(config, PUSH_MODE)) {
        tokenType.PUSH_MODE = config[PUSH_MODE];
      }
      if ((0, has_1.default)(config, LONGER_ALT)) {
        tokenType.LONGER_ALT = config[LONGER_ALT];
      }
      if ((0, has_1.default)(config, LINE_BREAKS)) {
        tokenType.LINE_BREAKS = config[LINE_BREAKS];
      }
      if ((0, has_1.default)(config, START_CHARS_HINT)) {
        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];
      }
      return tokenType;
    }
    exports2.EOF = createToken2({ name: "EOF", pattern: lexer_public_1.Lexer.NA });
    (0, tokens_1.augmentTokenTypes)([exports2.EOF]);
    function createTokenInstance2(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
      return {
        image,
        startOffset,
        endOffset,
        startLine,
        endLine,
        startColumn,
        endColumn,
        tokenTypeIdx: tokType.tokenTypeIdx,
        tokenType: tokType
      };
    }
    exports2.createTokenInstance = createTokenInstance2;
    function tokenMatcher2(token, tokType) {
      return (0, tokens_1.tokenStructuredMatcher)(token, tokType);
    }
    exports2.tokenMatcher = tokenMatcher2;
  }
});

// node_modules/chevrotain/lib/src/parse/errors_public.js
var require_errors_public = __commonJS({
  "node_modules/chevrotain/lib/src/parse/errors_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultGrammarValidatorErrorProvider = exports2.defaultGrammarResolverErrorProvider = exports2.defaultParserErrorProvider = void 0;
    var tokens_public_1 = require_tokens_public();
    var first_1 = __importDefault(require_first2());
    var map_1 = __importDefault(require_map());
    var reduce_1 = __importDefault(require_reduce());
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    exports2.defaultParserErrorProvider = {
      buildMismatchTokenMessage: function(_a2) {
        var expected = _a2.expected, actual = _a2.actual, previous = _a2.previous, ruleName = _a2.ruleName;
        var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);
        var expectedMsg = hasLabel ? "--> ".concat((0, tokens_public_1.tokenLabel)(expected), " <--") : "token of type --> ".concat(expected.name, " <--");
        var msg = "Expecting ".concat(expectedMsg, " but found --> '").concat(actual.image, "' <--");
        return msg;
      },
      buildNotAllInputParsedMessage: function(_a2) {
        var firstRedundant = _a2.firstRedundant, ruleName = _a2.ruleName;
        return "Redundant input, expecting EOF but found: " + firstRedundant.image;
      },
      buildNoViableAltMessage: function(_a2) {
        var expectedPathsPerAlt = _a2.expectedPathsPerAlt, actual = _a2.actual, previous = _a2.previous, customUserDescription = _a2.customUserDescription, ruleName = _a2.ruleName;
        var errPrefix = "Expecting: ";
        var actualText = (0, first_1.default)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
          return errPrefix + customUserDescription + errSuffix;
        } else {
          var allLookAheadPaths = (0, reduce_1.default)(expectedPathsPerAlt, function(result, currAltPaths) {
            return result.concat(currAltPaths);
          }, []);
          var nextValidTokenSequences = (0, map_1.default)(allLookAheadPaths, function(currPath) {
            return "[".concat((0, map_1.default)(currPath, function(currTokenType) {
              return (0, tokens_public_1.tokenLabel)(currTokenType);
            }).join(", "), "]");
          });
          var nextValidSequenceItems = (0, map_1.default)(nextValidTokenSequences, function(itemMsg, idx) {
            return "  ".concat(idx + 1, ". ").concat(itemMsg);
          });
          var calculatedDescription = "one of these possible Token sequences:\n".concat(nextValidSequenceItems.join("\n"));
          return errPrefix + calculatedDescription + errSuffix;
        }
      },
      buildEarlyExitMessage: function(_a2) {
        var expectedIterationPaths = _a2.expectedIterationPaths, actual = _a2.actual, customUserDescription = _a2.customUserDescription, ruleName = _a2.ruleName;
        var errPrefix = "Expecting: ";
        var actualText = (0, first_1.default)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
          return errPrefix + customUserDescription + errSuffix;
        } else {
          var nextValidTokenSequences = (0, map_1.default)(expectedIterationPaths, function(currPath) {
            return "[".concat((0, map_1.default)(currPath, function(currTokenType) {
              return (0, tokens_public_1.tokenLabel)(currTokenType);
            }).join(","), "]");
          });
          var calculatedDescription = "expecting at least one iteration which starts with one of these possible Token sequences::\n  " + "<".concat(nextValidTokenSequences.join(" ,"), ">");
          return errPrefix + calculatedDescription + errSuffix;
        }
      }
    };
    Object.freeze(exports2.defaultParserErrorProvider);
    exports2.defaultGrammarResolverErrorProvider = {
      buildRuleNotFoundError: function(topLevelRule, undefinedRule) {
        var msg = "Invalid grammar, reference to a rule which is not defined: ->" + undefinedRule.nonTerminalName + "<-\ninside top level rule: ->" + topLevelRule.name + "<-";
        return msg;
      }
    };
    exports2.defaultGrammarValidatorErrorProvider = {
      buildDuplicateFoundError: function(topLevelRule, duplicateProds) {
        function getExtraProductionArgument(prod) {
          if (prod instanceof gast_1.Terminal) {
            return prod.terminalType.name;
          } else if (prod instanceof gast_1.NonTerminal) {
            return prod.nonTerminalName;
          } else {
            return "";
          }
        }
        var topLevelName = topLevelRule.name;
        var duplicateProd = (0, first_1.default)(duplicateProds);
        var index = duplicateProd.idx;
        var dslName = (0, gast_2.getProductionDslName)(duplicateProd);
        var extraArgument = getExtraProductionArgument(duplicateProd);
        var hasExplicitIndex = index > 0;
        var msg = "->".concat(dslName).concat(hasExplicitIndex ? index : "", "<- ").concat(extraArgument ? "with argument: ->".concat(extraArgument, "<-") : "", "\n                  appears more than once (").concat(duplicateProds.length, " times) in the top level rule: ->").concat(topLevelName, "<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ");
        msg = msg.replace(/[ \t]+/g, " ");
        msg = msg.replace(/\s\s+/g, "\n");
        return msg;
      },
      buildNamespaceConflictError: function(rule) {
        var errMsg = "Namespace conflict found in grammar.\n" + "The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <".concat(rule.name, ">.\n") + "To resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.";
        return errMsg;
      },
      buildAlternationPrefixAmbiguityError: function(options) {
        var pathMsg = (0, map_1.default)(options.prefixPath, function(currTok) {
          return (0, tokens_public_1.tokenLabel)(currTok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var errMsg = "Ambiguous alternatives: <".concat(options.ambiguityIndices.join(" ,"), "> due to common lookahead prefix\n") + "in <OR".concat(occurrence, "> inside <").concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n") + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.";
        return errMsg;
      },
      buildAlternationAmbiguityError: function(options) {
        var pathMsg = (0, map_1.default)(options.prefixPath, function(currtok) {
          return (0, tokens_public_1.tokenLabel)(currtok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var currMessage = "Ambiguous Alternatives Detected: <".concat(options.ambiguityIndices.join(" ,"), "> in <OR").concat(occurrence, ">") + " inside <".concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n");
        currMessage = currMessage + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.";
        return currMessage;
      },
      buildEmptyRepetitionError: function(options) {
        var dslName = (0, gast_2.getProductionDslName)(options.repetition);
        if (options.repetition.idx !== 0) {
          dslName += options.repetition.idx;
        }
        var errMsg = "The repetition <".concat(dslName, "> within Rule <").concat(options.topLevelRule.name, "> can never consume any tokens.\n") + "This could lead to an infinite loop.";
        return errMsg;
      },
      buildTokenNameError: function(options) {
        return "deprecated";
      },
      buildEmptyAlternationError: function(options) {
        var errMsg = "Ambiguous empty alternative: <".concat(options.emptyChoiceIdx + 1, ">") + " in <OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n") + "Only the last alternative may be an empty alternative.";
        return errMsg;
      },
      buildTooManyAlternativesError: function(options) {
        var errMsg = "An Alternation cannot have more than 256 alternatives:\n" + "<OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n has ").concat(options.alternation.definition.length + 1, " alternatives.");
        return errMsg;
      },
      buildLeftRecursionError: function(options) {
        var ruleName = options.topLevelRule.name;
        var pathNames = (0, map_1.default)(options.leftRecursionPath, function(currRule) {
          return currRule.name;
        });
        var leftRecursivePath = "".concat(ruleName, " --> ").concat(pathNames.concat([ruleName]).join(" --> "));
        var errMsg = "Left Recursion found in grammar.\n" + "rule: <".concat(ruleName, "> can be invoked from itself (directly or indirectly)\n") + "without consuming any Tokens. The grammar path that causes this is: \n ".concat(leftRecursivePath, "\n") + " To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.";
        return errMsg;
      },
      buildInvalidRuleNameError: function(options) {
        return "deprecated";
      },
      buildDuplicateRuleNameError: function(options) {
        var ruleName;
        if (options.topLevelRule instanceof gast_1.Rule) {
          ruleName = options.topLevelRule.name;
        } else {
          ruleName = options.topLevelRule;
        }
        var errMsg = "Duplicate definition, rule: ->".concat(ruleName, "<- is already defined in the grammar: ->").concat(options.grammarName, "<-");
        return errMsg;
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/resolver.js
var require_resolver = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/resolver.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b5) {
          d2.__proto__ = b5;
        } || function(d2, b5) {
          for (var p in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p))
              d2[p] = b5[p];
        };
        return extendStatics(d, b3);
      };
      return function(d, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d, b3);
        function __() {
          this.constructor = d;
        }
        d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GastRefResolverVisitor = exports2.resolveGrammar = void 0;
    var parser_1 = require_parser();
    var forEach_1 = __importDefault(require_forEach());
    var values_1 = __importDefault(require_values());
    var gast_1 = require_api2();
    function resolveGrammar(topLevels, errMsgProvider) {
      var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
      refResolver.resolveRefs();
      return refResolver.errors;
    }
    exports2.resolveGrammar = resolveGrammar;
    var GastRefResolverVisitor = function(_super) {
      __extends(GastRefResolverVisitor2, _super);
      function GastRefResolverVisitor2(nameToTopRule, errMsgProvider) {
        var _this = _super.call(this) || this;
        _this.nameToTopRule = nameToTopRule;
        _this.errMsgProvider = errMsgProvider;
        _this.errors = [];
        return _this;
      }
      GastRefResolverVisitor2.prototype.resolveRefs = function() {
        var _this = this;
        (0, forEach_1.default)((0, values_1.default)(this.nameToTopRule), function(prod) {
          _this.currTopLevel = prod;
          prod.accept(_this);
        });
      };
      GastRefResolverVisitor2.prototype.visitNonTerminal = function(node) {
        var ref = this.nameToTopRule[node.nonTerminalName];
        if (!ref) {
          var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
          this.errors.push({
            message: msg,
            type: parser_1.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
            ruleName: this.currTopLevel.name,
            unresolvedRefName: node.nonTerminalName
          });
        } else {
          node.referencedRule = ref;
        }
      };
      return GastRefResolverVisitor2;
    }(gast_1.GAstVisitor);
    exports2.GastRefResolverVisitor = GastRefResolverVisitor;
  }
});

// node_modules/lodash/_arrayAggregator.js
var require_arrayAggregator = __commonJS({
  "node_modules/lodash/_arrayAggregator.js"(exports2, module2) {
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length2 = array == null ? 0 : array.length;
      while (++index < length2) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    module2.exports = arrayAggregator;
  }
});

// node_modules/lodash/_baseAggregator.js
var require_baseAggregator = __commonJS({
  "node_modules/lodash/_baseAggregator.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    module2.exports = baseAggregator;
  }
});

// node_modules/lodash/_createAggregator.js
var require_createAggregator = __commonJS({
  "node_modules/lodash/_createAggregator.js"(exports2, module2) {
    var arrayAggregator = require_arrayAggregator();
    var baseAggregator = require_baseAggregator();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
      };
    }
    module2.exports = createAggregator;
  }
});

// node_modules/lodash/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/lodash/groupBy.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var createAggregator = require_createAggregator();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });
    module2.exports = groupBy;
  }
});

// node_modules/lodash/flatMap.js
var require_flatMap = __commonJS({
  "node_modules/lodash/flatMap.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    var map = require_map();
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }
    module2.exports = flatMap;
  }
});

// node_modules/lodash/dropRight.js
var require_dropRight = __commonJS({
  "node_modules/lodash/dropRight.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    var toInteger = require_toInteger();
    function dropRight(array, n, guard) {
      var length2 = array == null ? 0 : array.length;
      if (!length2) {
        return [];
      }
      n = guard || n === void 0 ? 1 : toInteger(n);
      n = length2 - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }
    module2.exports = dropRight;
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/interpreter.js
var require_interpreter = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/interpreter.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b5) {
          d2.__proto__ = b5;
        } || function(d2, b5) {
          for (var p in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p))
              d2[p] = b5[p];
        };
        return extendStatics(d, b3);
      };
      return function(d, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d, b3);
        function __() {
          this.constructor = d;
        }
        d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.nextPossibleTokensAfter = exports2.possiblePathsFrom = exports2.NextTerminalAfterAtLeastOneSepWalker = exports2.NextTerminalAfterAtLeastOneWalker = exports2.NextTerminalAfterManySepWalker = exports2.NextTerminalAfterManyWalker = exports2.AbstractNextTerminalAfterProductionWalker = exports2.NextAfterTokenWalker = exports2.AbstractNextPossibleTokensWalker = void 0;
    var rest_1 = require_rest();
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var dropRight_1 = __importDefault(require_dropRight());
    var drop_1 = __importDefault(require_drop());
    var last_1 = __importDefault(require_last());
    var forEach_1 = __importDefault(require_forEach());
    var clone_1 = __importDefault(require_clone());
    var first_2 = require_first();
    var gast_1 = require_api2();
    var AbstractNextPossibleTokensWalker = function(_super) {
      __extends(AbstractNextPossibleTokensWalker2, _super);
      function AbstractNextPossibleTokensWalker2(topProd, path) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.path = path;
        _this.possibleTokTypes = [];
        _this.nextProductionName = "";
        _this.nextProductionOccurrence = 0;
        _this.found = false;
        _this.isAtEndOfPath = false;
        return _this;
      }
      AbstractNextPossibleTokensWalker2.prototype.startWalking = function() {
        this.found = false;
        if (this.path.ruleStack[0] !== this.topProd.name) {
          throw Error("The path does not start with the walker's top Rule!");
        }
        this.ruleStack = (0, clone_1.default)(this.path.ruleStack).reverse();
        this.occurrenceStack = (0, clone_1.default)(this.path.occurrenceStack).reverse();
        this.ruleStack.pop();
        this.occurrenceStack.pop();
        this.updateExpectedNext();
        this.walk(this.topProd);
        return this.possibleTokTypes;
      };
      AbstractNextPossibleTokensWalker2.prototype.walk = function(prod, prevRest) {
        if (prevRest === void 0) {
          prevRest = [];
        }
        if (!this.found) {
          _super.prototype.walk.call(this, prod, prevRest);
        }
      };
      AbstractNextPossibleTokensWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
        if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {
          var fullRest = currRest.concat(prevRest);
          this.updateExpectedNext();
          this.walk(refProd.referencedRule, fullRest);
        }
      };
      AbstractNextPossibleTokensWalker2.prototype.updateExpectedNext = function() {
        if ((0, isEmpty_1.default)(this.ruleStack)) {
          this.nextProductionName = "";
          this.nextProductionOccurrence = 0;
          this.isAtEndOfPath = true;
        } else {
          this.nextProductionName = this.ruleStack.pop();
          this.nextProductionOccurrence = this.occurrenceStack.pop();
        }
      };
      return AbstractNextPossibleTokensWalker2;
    }(rest_1.RestWalker);
    exports2.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;
    var NextAfterTokenWalker = function(_super) {
      __extends(NextAfterTokenWalker2, _super);
      function NextAfterTokenWalker2(topProd, path) {
        var _this = _super.call(this, topProd, path) || this;
        _this.path = path;
        _this.nextTerminalName = "";
        _this.nextTerminalOccurrence = 0;
        _this.nextTerminalName = _this.path.lastTok.name;
        _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;
        return _this;
      }
      NextAfterTokenWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
        if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {
          var fullRest = currRest.concat(prevRest);
          var restProd = new gast_1.Alternative({ definition: fullRest });
          this.possibleTokTypes = (0, first_2.first)(restProd);
          this.found = true;
        }
      };
      return NextAfterTokenWalker2;
    }(AbstractNextPossibleTokensWalker);
    exports2.NextAfterTokenWalker = NextAfterTokenWalker;
    var AbstractNextTerminalAfterProductionWalker = function(_super) {
      __extends(AbstractNextTerminalAfterProductionWalker2, _super);
      function AbstractNextTerminalAfterProductionWalker2(topRule, occurrence) {
        var _this = _super.call(this) || this;
        _this.topRule = topRule;
        _this.occurrence = occurrence;
        _this.result = {
          token: void 0,
          occurrence: void 0,
          isEndOfRule: void 0
        };
        return _this;
      }
      AbstractNextTerminalAfterProductionWalker2.prototype.startWalking = function() {
        this.walk(this.topRule);
        return this.result;
      };
      return AbstractNextTerminalAfterProductionWalker2;
    }(rest_1.RestWalker);
    exports2.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;
    var NextTerminalAfterManyWalker = function(_super) {
      __extends(NextTerminalAfterManyWalker2, _super);
      function NextTerminalAfterManyWalker2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NextTerminalAfterManyWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
        if (manyProd.idx === this.occurrence) {
          var firstAfterMany = (0, first_1.default)(currRest.concat(prevRest));
          this.result.isEndOfRule = firstAfterMany === void 0;
          if (firstAfterMany instanceof gast_1.Terminal) {
            this.result.token = firstAfterMany.terminalType;
            this.result.occurrence = firstAfterMany.idx;
          }
        } else {
          _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);
        }
      };
      return NextTerminalAfterManyWalker2;
    }(AbstractNextTerminalAfterProductionWalker);
    exports2.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;
    var NextTerminalAfterManySepWalker = function(_super) {
      __extends(NextTerminalAfterManySepWalker2, _super);
      function NextTerminalAfterManySepWalker2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NextTerminalAfterManySepWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
        if (manySepProd.idx === this.occurrence) {
          var firstAfterManySep = (0, first_1.default)(currRest.concat(prevRest));
          this.result.isEndOfRule = firstAfterManySep === void 0;
          if (firstAfterManySep instanceof gast_1.Terminal) {
            this.result.token = firstAfterManySep.terminalType;
            this.result.occurrence = firstAfterManySep.idx;
          }
        } else {
          _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);
        }
      };
      return NextTerminalAfterManySepWalker2;
    }(AbstractNextTerminalAfterProductionWalker);
    exports2.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;
    var NextTerminalAfterAtLeastOneWalker = function(_super) {
      __extends(NextTerminalAfterAtLeastOneWalker2, _super);
      function NextTerminalAfterAtLeastOneWalker2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NextTerminalAfterAtLeastOneWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
        if (atLeastOneProd.idx === this.occurrence) {
          var firstAfterAtLeastOne = (0, first_1.default)(currRest.concat(prevRest));
          this.result.isEndOfRule = firstAfterAtLeastOne === void 0;
          if (firstAfterAtLeastOne instanceof gast_1.Terminal) {
            this.result.token = firstAfterAtLeastOne.terminalType;
            this.result.occurrence = firstAfterAtLeastOne.idx;
          }
        } else {
          _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);
        }
      };
      return NextTerminalAfterAtLeastOneWalker2;
    }(AbstractNextTerminalAfterProductionWalker);
    exports2.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker;
    var NextTerminalAfterAtLeastOneSepWalker = function(_super) {
      __extends(NextTerminalAfterAtLeastOneSepWalker2, _super);
      function NextTerminalAfterAtLeastOneSepWalker2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NextTerminalAfterAtLeastOneSepWalker2.prototype.walkAtLeastOneSep = function(atleastOneSepProd, currRest, prevRest) {
        if (atleastOneSepProd.idx === this.occurrence) {
          var firstAfterfirstAfterAtLeastOneSep = (0, first_1.default)(currRest.concat(prevRest));
          this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;
          if (firstAfterfirstAfterAtLeastOneSep instanceof gast_1.Terminal) {
            this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;
            this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
          }
        } else {
          _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);
        }
      };
      return NextTerminalAfterAtLeastOneSepWalker2;
    }(AbstractNextTerminalAfterProductionWalker);
    exports2.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;
    function possiblePathsFrom(targetDef, maxLength, currPath) {
      if (currPath === void 0) {
        currPath = [];
      }
      currPath = (0, clone_1.default)(currPath);
      var result = [];
      var i2 = 0;
      function remainingPathWith(nextDef) {
        return nextDef.concat((0, drop_1.default)(targetDef, i2 + 1));
      }
      function getAlternativesForProd(definition) {
        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
        return result.concat(alternatives);
      }
      while (currPath.length < maxLength && i2 < targetDef.length) {
        var prod = targetDef[i2];
        if (prod instanceof gast_1.Alternative) {
          return getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.NonTerminal) {
          return getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.Option) {
          result = getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.RepetitionMandatory) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: prod.definition
            })
          ]);
          return getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
          var newDef = [
            new gast_1.Alternative({ definition: prod.definition }),
            new gast_1.Repetition({
              definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
            })
          ];
          return getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.RepetitionWithSeparator) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
            })
          ]);
          result = getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.Repetition) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: prod.definition
            })
          ]);
          result = getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.Alternation) {
          (0, forEach_1.default)(prod.definition, function(currAlt) {
            if ((0, isEmpty_1.default)(currAlt.definition) === false) {
              result = getAlternativesForProd(currAlt.definition);
            }
          });
          return result;
        } else if (prod instanceof gast_1.Terminal) {
          currPath.push(prod.terminalType);
        } else {
          throw Error("non exhaustive match");
        }
        i2++;
      }
      result.push({
        partialPath: currPath,
        suffixDef: (0, drop_1.default)(targetDef, i2)
      });
      return result;
    }
    exports2.possiblePathsFrom = possiblePathsFrom;
    function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
      var EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
      var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
      var EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
      var foundCompletePath = false;
      var tokenVectorLength = tokenVector.length;
      var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
      var result = [];
      var possiblePaths = [];
      possiblePaths.push({
        idx: -1,
        def: initialDef,
        ruleStack: [],
        occurrenceStack: []
      });
      while (!(0, isEmpty_1.default)(possiblePaths)) {
        var currPath = possiblePaths.pop();
        if (currPath === EXIT_ALTERNATIVE) {
          if (foundCompletePath && (0, last_1.default)(possiblePaths).idx <= minimalAlternativesIndex) {
            possiblePaths.pop();
          }
          continue;
        }
        var currDef = currPath.def;
        var currIdx = currPath.idx;
        var currRuleStack = currPath.ruleStack;
        var currOccurrenceStack = currPath.occurrenceStack;
        if ((0, isEmpty_1.default)(currDef)) {
          continue;
        }
        var prod = currDef[0];
        if (prod === EXIT_NON_TERMINAL) {
          var nextPath = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: (0, dropRight_1.default)(currRuleStack),
            occurrenceStack: (0, dropRight_1.default)(currOccurrenceStack)
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.Terminal) {
          if (currIdx < tokenVectorLength - 1) {
            var nextIdx = currIdx + 1;
            var actualToken = tokenVector[nextIdx];
            if (tokMatcher(actualToken, prod.terminalType)) {
              var nextPath = {
                idx: nextIdx,
                def: (0, drop_1.default)(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
              };
              possiblePaths.push(nextPath);
            }
          } else if (currIdx === tokenVectorLength - 1) {
            result.push({
              nextTokenType: prod.terminalType,
              nextTokenOccurrence: prod.idx,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            });
            foundCompletePath = true;
          } else {
            throw Error("non exhaustive match");
          }
        } else if (prod instanceof gast_1.NonTerminal) {
          var newRuleStack = (0, clone_1.default)(currRuleStack);
          newRuleStack.push(prod.nonTerminalName);
          var newOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);
          newOccurrenceStack.push(prod.idx);
          var nextPath = {
            idx: currIdx,
            def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0, drop_1.default)(currDef)),
            ruleStack: newRuleStack,
            occurrenceStack: newOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.Option) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var nextPathWith = {
            idx: currIdx,
            def: prod.definition.concat((0, drop_1.default)(currDef)),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.RepetitionMandatory) {
          var secondIteration = new gast_1.Repetition({
            definition: prod.definition,
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));
          var nextPath = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
          var separatorGast = new gast_1.Terminal({
            terminalType: prod.separator
          });
          var secondIteration = new gast_1.Repetition({
            definition: [separatorGast].concat(prod.definition),
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));
          var nextPath = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.RepetitionWithSeparator) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var separatorGast = new gast_1.Terminal({
            terminalType: prod.separator
          });
          var nthRepetition = new gast_1.Repetition({
            definition: [separatorGast].concat(prod.definition),
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));
          var nextPathWith = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.Repetition) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var nthRepetition = new gast_1.Repetition({
            definition: prod.definition,
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));
          var nextPathWith = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.Alternation) {
          for (var i2 = prod.definition.length - 1; i2 >= 0; i2--) {
            var currAlt = prod.definition[i2];
            var currAltPath = {
              idx: currIdx,
              def: currAlt.definition.concat((0, drop_1.default)(currDef)),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(currAltPath);
            possiblePaths.push(EXIT_ALTERNATIVE);
          }
        } else if (prod instanceof gast_1.Alternative) {
          possiblePaths.push({
            idx: currIdx,
            def: prod.definition.concat((0, drop_1.default)(currDef)),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          });
        } else if (prod instanceof gast_1.Rule) {
          possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
        } else {
          throw Error("non exhaustive match");
        }
      }
      return result;
    }
    exports2.nextPossibleTokensAfter = nextPossibleTokensAfter;
    function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
      var newRuleStack = (0, clone_1.default)(currRuleStack);
      newRuleStack.push(topRule.name);
      var newCurrOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);
      newCurrOccurrenceStack.push(1);
      return {
        idx: currIdx,
        def: topRule.definition,
        ruleStack: newRuleStack,
        occurrenceStack: newCurrOccurrenceStack
      };
    }
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/lookahead.js
var require_lookahead = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/lookahead.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b5) {
          d2.__proto__ = b5;
        } || function(d2, b5) {
          for (var p in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p))
              d2[p] = b5[p];
        };
        return extendStatics(d, b3);
      };
      return function(d, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d, b3);
        function __() {
          this.constructor = d;
        }
        d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.areTokenCategoriesNotUsed = exports2.isStrictPrefixOfPath = exports2.containsPath = exports2.getLookaheadPathsForOptionalProd = exports2.getLookaheadPathsForOr = exports2.lookAheadSequenceFromAlternatives = exports2.buildSingleAlternativeLookaheadFunction = exports2.buildAlternativesLookAheadFunc = exports2.buildLookaheadFuncForOptionalProd = exports2.buildLookaheadFuncForOr = exports2.getProdType = exports2.PROD_TYPE = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var flatten_1 = __importDefault(require_flatten());
    var every_1 = __importDefault(require_every());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var reduce_1 = __importDefault(require_reduce());
    var interpreter_1 = require_interpreter();
    var rest_1 = require_rest();
    var tokens_1 = require_tokens();
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    var PROD_TYPE;
    (function(PROD_TYPE2) {
      PROD_TYPE2[PROD_TYPE2["OPTION"] = 0] = "OPTION";
      PROD_TYPE2[PROD_TYPE2["REPETITION"] = 1] = "REPETITION";
      PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
      PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
      PROD_TYPE2[PROD_TYPE2["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
      PROD_TYPE2[PROD_TYPE2["ALTERNATION"] = 5] = "ALTERNATION";
    })(PROD_TYPE = exports2.PROD_TYPE || (exports2.PROD_TYPE = {}));
    function getProdType(prod) {
      if (prod instanceof gast_1.Option) {
        return PROD_TYPE.OPTION;
      } else if (prod instanceof gast_1.Repetition) {
        return PROD_TYPE.REPETITION;
      } else if (prod instanceof gast_1.RepetitionMandatory) {
        return PROD_TYPE.REPETITION_MANDATORY;
      } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
      } else if (prod instanceof gast_1.RepetitionWithSeparator) {
        return PROD_TYPE.REPETITION_WITH_SEPARATOR;
      } else if (prod instanceof gast_1.Alternation) {
        return PROD_TYPE.ALTERNATION;
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.getProdType = getProdType;
    function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
      var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
      var tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
      return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher2, dynamicTokensEnabled);
    }
    exports2.buildLookaheadFuncForOr = buildLookaheadFuncForOr;
    function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
      var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
      var tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
      return lookaheadBuilder(lookAheadPaths[0], tokenMatcher2, dynamicTokensEnabled);
    }
    exports2.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;
    function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher2, dynamicTokensEnabled) {
      var numOfAlts = alts.length;
      var areAllOneTokenLookahead = (0, every_1.default)(alts, function(currAlt) {
        return (0, every_1.default)(currAlt, function(currPath) {
          return currPath.length === 1;
        });
      });
      if (hasPredicates) {
        return function(orAlts) {
          var predicates = (0, map_1.default)(orAlts, function(currAlt2) {
            return currAlt2.GATE;
          });
          for (var t2 = 0; t2 < numOfAlts; t2++) {
            var currAlt = alts[t2];
            var currNumOfPaths = currAlt.length;
            var currPredicate = predicates[t2];
            if (currPredicate !== void 0 && currPredicate.call(this) === false) {
              continue;
            }
            nextPath:
              for (var j2 = 0; j2 < currNumOfPaths; j2++) {
                var currPath = currAlt[j2];
                var currPathLength = currPath.length;
                for (var i2 = 0; i2 < currPathLength; i2++) {
                  var nextToken = this.LA(i2 + 1);
                  if (tokenMatcher2(nextToken, currPath[i2]) === false) {
                    continue nextPath;
                  }
                }
                return t2;
              }
          }
          return void 0;
        };
      } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        var singleTokenAlts = (0, map_1.default)(alts, function(currAlt) {
          return (0, flatten_1.default)(currAlt);
        });
        var choiceToAlt_1 = (0, reduce_1.default)(singleTokenAlts, function(result, currAlt, idx) {
          (0, forEach_1.default)(currAlt, function(currTokType) {
            if (!(0, has_1.default)(result, currTokType.tokenTypeIdx)) {
              result[currTokType.tokenTypeIdx] = idx;
            }
            (0, forEach_1.default)(currTokType.categoryMatches, function(currExtendingType) {
              if (!(0, has_1.default)(result, currExtendingType)) {
                result[currExtendingType] = idx;
              }
            });
          });
          return result;
        }, {});
        return function() {
          var nextToken = this.LA(1);
          return choiceToAlt_1[nextToken.tokenTypeIdx];
        };
      } else {
        return function() {
          for (var t2 = 0; t2 < numOfAlts; t2++) {
            var currAlt = alts[t2];
            var currNumOfPaths = currAlt.length;
            nextPath:
              for (var j2 = 0; j2 < currNumOfPaths; j2++) {
                var currPath = currAlt[j2];
                var currPathLength = currPath.length;
                for (var i2 = 0; i2 < currPathLength; i2++) {
                  var nextToken = this.LA(i2 + 1);
                  if (tokenMatcher2(nextToken, currPath[i2]) === false) {
                    continue nextPath;
                  }
                }
                return t2;
              }
          }
          return void 0;
        };
      }
    }
    exports2.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;
    function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher2, dynamicTokensEnabled) {
      var areAllOneTokenLookahead = (0, every_1.default)(alt, function(currPath) {
        return currPath.length === 1;
      });
      var numOfPaths = alt.length;
      if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        var singleTokensTypes = (0, flatten_1.default)(alt);
        if (singleTokensTypes.length === 1 && (0, isEmpty_1.default)(singleTokensTypes[0].categoryMatches)) {
          var expectedTokenType = singleTokensTypes[0];
          var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;
          return function() {
            return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;
          };
        } else {
          var choiceToAlt_2 = (0, reduce_1.default)(singleTokensTypes, function(result, currTokType, idx) {
            result[currTokType.tokenTypeIdx] = true;
            (0, forEach_1.default)(currTokType.categoryMatches, function(currExtendingType) {
              result[currExtendingType] = true;
            });
            return result;
          }, []);
          return function() {
            var nextToken = this.LA(1);
            return choiceToAlt_2[nextToken.tokenTypeIdx] === true;
          };
        }
      } else {
        return function() {
          nextPath:
            for (var j2 = 0; j2 < numOfPaths; j2++) {
              var currPath = alt[j2];
              var currPathLength = currPath.length;
              for (var i2 = 0; i2 < currPathLength; i2++) {
                var nextToken = this.LA(i2 + 1);
                if (tokenMatcher2(nextToken, currPath[i2]) === false) {
                  continue nextPath;
                }
              }
              return true;
            }
          return false;
        };
      }
    }
    exports2.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;
    var RestDefinitionFinderWalker = function(_super) {
      __extends(RestDefinitionFinderWalker2, _super);
      function RestDefinitionFinderWalker2(topProd, targetOccurrence, targetProdType) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.targetOccurrence = targetOccurrence;
        _this.targetProdType = targetProdType;
        return _this;
      }
      RestDefinitionFinderWalker2.prototype.startWalking = function() {
        this.walk(this.topProd);
        return this.restDef;
      };
      RestDefinitionFinderWalker2.prototype.checkIsTarget = function(node, expectedProdType, currRest, prevRest) {
        if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {
          this.restDef = currRest.concat(prevRest);
          return true;
        }
        return false;
      };
      RestDefinitionFinderWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
          _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);
        }
      };
      RestDefinitionFinderWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
          _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);
        }
      };
      RestDefinitionFinderWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
          _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);
        }
      };
      RestDefinitionFinderWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
          _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);
        }
      };
      RestDefinitionFinderWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
          _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);
        }
      };
      return RestDefinitionFinderWalker2;
    }(rest_1.RestWalker);
    var InsideDefinitionFinderVisitor = function(_super) {
      __extends(InsideDefinitionFinderVisitor2, _super);
      function InsideDefinitionFinderVisitor2(targetOccurrence, targetProdType, targetRef) {
        var _this = _super.call(this) || this;
        _this.targetOccurrence = targetOccurrence;
        _this.targetProdType = targetProdType;
        _this.targetRef = targetRef;
        _this.result = [];
        return _this;
      }
      InsideDefinitionFinderVisitor2.prototype.checkIsTarget = function(node, expectedProdName) {
        if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {
          this.result = node.definition;
        }
      };
      InsideDefinitionFinderVisitor2.prototype.visitOption = function(node) {
        this.checkIsTarget(node, PROD_TYPE.OPTION);
      };
      InsideDefinitionFinderVisitor2.prototype.visitRepetition = function(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION);
      };
      InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatory = function(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
      };
      InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
      };
      InsideDefinitionFinderVisitor2.prototype.visitRepetitionWithSeparator = function(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
      };
      InsideDefinitionFinderVisitor2.prototype.visitAlternation = function(node) {
        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
      };
      return InsideDefinitionFinderVisitor2;
    }(gast_2.GAstVisitor);
    function initializeArrayOfArrays(size2) {
      var result = new Array(size2);
      for (var i2 = 0; i2 < size2; i2++) {
        result[i2] = [];
      }
      return result;
    }
    function pathToHashKeys(path) {
      var keys = [""];
      for (var i2 = 0; i2 < path.length; i2++) {
        var tokType = path[i2];
        var longerKeys = [];
        for (var j2 = 0; j2 < keys.length; j2++) {
          var currShorterKey = keys[j2];
          longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
          for (var t2 = 0; t2 < tokType.categoryMatches.length; t2++) {
            var categoriesKeySuffix = "_" + tokType.categoryMatches[t2];
            longerKeys.push(currShorterKey + categoriesKeySuffix);
          }
        }
        keys = longerKeys;
      }
      return keys;
    }
    function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
      for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
        if (currAltIdx === idx) {
          continue;
        }
        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
          var searchKey = searchPathKeys[searchIdx];
          if (otherAltKnownPathsKeys[searchKey] === true) {
            return false;
          }
        }
      }
      return true;
    }
    function lookAheadSequenceFromAlternatives(altsDefs, k) {
      var partialAlts = (0, map_1.default)(altsDefs, function(currAlt) {
        return (0, interpreter_1.possiblePathsFrom)([currAlt], 1);
      });
      var finalResult = initializeArrayOfArrays(partialAlts.length);
      var altsHashes = (0, map_1.default)(partialAlts, function(currAltPaths) {
        var dict = {};
        (0, forEach_1.default)(currAltPaths, function(item) {
          var keys = pathToHashKeys(item.partialPath);
          (0, forEach_1.default)(keys, function(currKey) {
            dict[currKey] = true;
          });
        });
        return dict;
      });
      var newData = partialAlts;
      for (var pathLength = 1; pathLength <= k; pathLength++) {
        var currDataset = newData;
        newData = initializeArrayOfArrays(currDataset.length);
        var _loop_1 = function(altIdx2) {
          var currAltPathsAndSuffixes = currDataset[altIdx2];
          for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
            var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
            var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
            var prefixKeys = pathToHashKeys(currPathPrefix);
            var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx2);
            if (isUnique || (0, isEmpty_1.default)(suffixDef) || currPathPrefix.length === k) {
              var currAltResult = finalResult[altIdx2];
              if (containsPath(currAltResult, currPathPrefix) === false) {
                currAltResult.push(currPathPrefix);
                for (var j2 = 0; j2 < prefixKeys.length; j2++) {
                  var currKey = prefixKeys[j2];
                  altsHashes[altIdx2][currKey] = true;
                }
              }
            } else {
              var newPartialPathsAndSuffixes = (0, interpreter_1.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);
              newData[altIdx2] = newData[altIdx2].concat(newPartialPathsAndSuffixes);
              (0, forEach_1.default)(newPartialPathsAndSuffixes, function(item) {
                var prefixKeys2 = pathToHashKeys(item.partialPath);
                (0, forEach_1.default)(prefixKeys2, function(key) {
                  altsHashes[altIdx2][key] = true;
                });
              });
            }
          }
        };
        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {
          _loop_1(altIdx);
        }
      }
      return finalResult;
    }
    exports2.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;
    function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
      var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
      ruleGrammar.accept(visitor);
      return lookAheadSequenceFromAlternatives(visitor.result, k);
    }
    exports2.getLookaheadPathsForOr = getLookaheadPathsForOr;
    function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
      var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
      ruleGrammar.accept(insideDefVisitor);
      var insideDef = insideDefVisitor.result;
      var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
      var afterDef = afterDefWalker.startWalking();
      var insideFlat = new gast_1.Alternative({ definition: insideDef });
      var afterFlat = new gast_1.Alternative({ definition: afterDef });
      return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
    }
    exports2.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;
    function containsPath(alternative, searchPath) {
      compareOtherPath:
        for (var i2 = 0; i2 < alternative.length; i2++) {
          var otherPath = alternative[i2];
          if (otherPath.length !== searchPath.length) {
            continue;
          }
          for (var j2 = 0; j2 < otherPath.length; j2++) {
            var searchTok = searchPath[j2];
            var otherTok = otherPath[j2];
            var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;
            if (matchingTokens === false) {
              continue compareOtherPath;
            }
          }
          return true;
        }
      return false;
    }
    exports2.containsPath = containsPath;
    function isStrictPrefixOfPath(prefix, other) {
      return prefix.length < other.length && (0, every_1.default)(prefix, function(tokType, idx) {
        var otherTokType = other[idx];
        return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];
      });
    }
    exports2.isStrictPrefixOfPath = isStrictPrefixOfPath;
    function areTokenCategoriesNotUsed(lookAheadPaths) {
      return (0, every_1.default)(lookAheadPaths, function(singleAltPaths) {
        return (0, every_1.default)(singleAltPaths, function(singlePath) {
          return (0, every_1.default)(singlePath, function(token) {
            return (0, isEmpty_1.default)(token.categoryMatches);
          });
        });
      });
    }
    exports2.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/checks.js
var require_checks = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/checks.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b5) {
          d2.__proto__ = b5;
        } || function(d2, b5) {
          for (var p in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p))
              d2[p] = b5[p];
        };
        return extendStatics(d, b3);
      };
      return function(d, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d, b3);
        function __() {
          this.constructor = d;
        }
        d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkPrefixAlternativesAmbiguities = exports2.validateSomeNonEmptyLookaheadPath = exports2.validateTooManyAlts = exports2.RepetitionCollector = exports2.validateAmbiguousAlternationAlternatives = exports2.validateEmptyOrAlternative = exports2.getFirstNoneTerminal = exports2.validateNoLeftRecursion = exports2.validateRuleIsOverridden = exports2.validateRuleDoesNotAlreadyExist = exports2.OccurrenceValidationCollector = exports2.identifyProductionForDuplicates = exports2.validateGrammar = void 0;
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var drop_1 = __importDefault(require_drop());
    var flatten_1 = __importDefault(require_flatten());
    var filter_1 = __importDefault(require_filter());
    var reject_1 = __importDefault(require_reject());
    var difference_1 = __importDefault(require_difference());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var groupBy_1 = __importDefault(require_groupBy());
    var reduce_1 = __importDefault(require_reduce());
    var pickBy_1 = __importDefault(require_pickBy());
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var flatMap_1 = __importDefault(require_flatMap());
    var clone_1 = __importDefault(require_clone());
    var parser_1 = require_parser();
    var gast_1 = require_api2();
    var lookahead_1 = require_lookahead();
    var interpreter_1 = require_interpreter();
    var gast_2 = require_api2();
    var gast_3 = require_api2();
    var dropRight_1 = __importDefault(require_dropRight());
    var compact_1 = __importDefault(require_compact());
    var tokens_1 = require_tokens();
    function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {
      var duplicateErrors = (0, flatMap_1.default)(topLevels, function(currTopLevel) {
        return validateDuplicateProductions(currTopLevel, errMsgProvider);
      });
      var leftRecursionErrors = (0, flatMap_1.default)(topLevels, function(currTopRule) {
        return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);
      });
      var emptyAltErrors = [];
      var ambiguousAltsErrors = [];
      var emptyRepetitionErrors = [];
      if ((0, isEmpty_1.default)(leftRecursionErrors)) {
        emptyAltErrors = (0, flatMap_1.default)(topLevels, function(currTopRule) {
          return validateEmptyOrAlternative(currTopRule, errMsgProvider);
        });
        ambiguousAltsErrors = (0, flatMap_1.default)(topLevels, function(currTopRule) {
          return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);
        });
        emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);
      }
      var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
      var tooManyAltsErrors = (0, flatMap_1.default)(topLevels, function(curRule) {
        return validateTooManyAlts(curRule, errMsgProvider);
      });
      var duplicateRulesError = (0, flatMap_1.default)(topLevels, function(curRule) {
        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);
      });
      return duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);
    }
    exports2.validateGrammar = validateGrammar;
    function validateDuplicateProductions(topLevelRule, errMsgProvider) {
      var collectorVisitor = new OccurrenceValidationCollector();
      topLevelRule.accept(collectorVisitor);
      var allRuleProductions = collectorVisitor.allProductions;
      var productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);
      var duplicates = (0, pickBy_1.default)(productionGroups, function(currGroup) {
        return currGroup.length > 1;
      });
      var errors = (0, map_1.default)((0, values_1.default)(duplicates), function(currDuplicates) {
        var firstProd = (0, first_1.default)(currDuplicates);
        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
        var dslName = (0, gast_1.getProductionDslName)(firstProd);
        var defError = {
          message: msg,
          type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
          ruleName: topLevelRule.name,
          dslName,
          occurrence: firstProd.idx
        };
        var param = getExtraProductionArgument(firstProd);
        if (param) {
          defError.parameter = param;
        }
        return defError;
      });
      return errors;
    }
    function identifyProductionForDuplicates(prod) {
      return "".concat((0, gast_1.getProductionDslName)(prod), "_#_").concat(prod.idx, "_#_").concat(getExtraProductionArgument(prod));
    }
    exports2.identifyProductionForDuplicates = identifyProductionForDuplicates;
    function getExtraProductionArgument(prod) {
      if (prod instanceof gast_2.Terminal) {
        return prod.terminalType.name;
      } else if (prod instanceof gast_2.NonTerminal) {
        return prod.nonTerminalName;
      } else {
        return "";
      }
    }
    var OccurrenceValidationCollector = function(_super) {
      __extends(OccurrenceValidationCollector2, _super);
      function OccurrenceValidationCollector2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allProductions = [];
        return _this;
      }
      OccurrenceValidationCollector2.prototype.visitNonTerminal = function(subrule) {
        this.allProductions.push(subrule);
      };
      OccurrenceValidationCollector2.prototype.visitOption = function(option) {
        this.allProductions.push(option);
      };
      OccurrenceValidationCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
        this.allProductions.push(manySep);
      };
      OccurrenceValidationCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
        this.allProductions.push(atLeastOne);
      };
      OccurrenceValidationCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
        this.allProductions.push(atLeastOneSep);
      };
      OccurrenceValidationCollector2.prototype.visitRepetition = function(many) {
        this.allProductions.push(many);
      };
      OccurrenceValidationCollector2.prototype.visitAlternation = function(or2) {
        this.allProductions.push(or2);
      };
      OccurrenceValidationCollector2.prototype.visitTerminal = function(terminal) {
        this.allProductions.push(terminal);
      };
      return OccurrenceValidationCollector2;
    }(gast_3.GAstVisitor);
    exports2.OccurrenceValidationCollector = OccurrenceValidationCollector;
    function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
      var errors = [];
      var occurrences = (0, reduce_1.default)(allRules, function(result, curRule) {
        if (curRule.name === rule.name) {
          return result + 1;
        }
        return result;
      }, 0);
      if (occurrences > 1) {
        var errMsg = errMsgProvider.buildDuplicateRuleNameError({
          topLevelRule: rule,
          grammarName: className
        });
        errors.push({
          message: errMsg,
          type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
          ruleName: rule.name
        });
      }
      return errors;
    }
    exports2.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;
    function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
      var errors = [];
      var errMsg;
      if (!(0, includes_1.default)(definedRulesNames, ruleName)) {
        errMsg = "Invalid rule override, rule: ->".concat(ruleName, "<- cannot be overridden in the grammar: ->").concat(className, "<-") + "as it is not defined in any of the super grammars ";
        errors.push({
          message: errMsg,
          type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
          ruleName
        });
      }
      return errors;
    }
    exports2.validateRuleIsOverridden = validateRuleIsOverridden;
    function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {
      if (path === void 0) {
        path = [];
      }
      var errors = [];
      var nextNonTerminals = getFirstNoneTerminal(currRule.definition);
      if ((0, isEmpty_1.default)(nextNonTerminals)) {
        return [];
      } else {
        var ruleName = topRule.name;
        var foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);
        if (foundLeftRecursion) {
          errors.push({
            message: errMsgProvider.buildLeftRecursionError({
              topLevelRule: topRule,
              leftRecursionPath: path
            }),
            type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,
            ruleName
          });
        }
        var validNextSteps = (0, difference_1.default)(nextNonTerminals, path.concat([topRule]));
        var errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, function(currRefRule) {
          var newPath = (0, clone_1.default)(path);
          newPath.push(currRefRule);
          return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
        });
        return errors.concat(errorsFromNextSteps);
      }
    }
    exports2.validateNoLeftRecursion = validateNoLeftRecursion;
    function getFirstNoneTerminal(definition) {
      var result = [];
      if ((0, isEmpty_1.default)(definition)) {
        return result;
      }
      var firstProd = (0, first_1.default)(definition);
      if (firstProd instanceof gast_2.NonTerminal) {
        result.push(firstProd.referencedRule);
      } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {
        result = result.concat(getFirstNoneTerminal(firstProd.definition));
      } else if (firstProd instanceof gast_2.Alternation) {
        result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, function(currSubDef) {
          return getFirstNoneTerminal(currSubDef.definition);
        }));
      } else if (firstProd instanceof gast_2.Terminal) {
      } else {
        throw Error("non exhaustive match");
      }
      var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);
      var hasMore = definition.length > 1;
      if (isFirstOptional && hasMore) {
        var rest = (0, drop_1.default)(definition);
        return result.concat(getFirstNoneTerminal(rest));
      } else {
        return result;
      }
    }
    exports2.getFirstNoneTerminal = getFirstNoneTerminal;
    var OrCollector = function(_super) {
      __extends(OrCollector2, _super);
      function OrCollector2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.alternations = [];
        return _this;
      }
      OrCollector2.prototype.visitAlternation = function(node) {
        this.alternations.push(node);
      };
      return OrCollector2;
    }(gast_3.GAstVisitor);
    function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        var exceptLast = (0, dropRight_1.default)(currOr.definition);
        return (0, flatMap_1.default)(exceptLast, function(currAlternative, currAltIdx) {
          var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);
          if ((0, isEmpty_1.default)(possibleFirstInAlt)) {
            return [
              {
                message: errMsgProvider.buildEmptyAlternationError({
                  topLevelRule,
                  alternation: currOr,
                  emptyChoiceIdx: currAltIdx
                }),
                type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
                ruleName: topLevelRule.name,
                occurrence: currOr.idx,
                alternative: currAltIdx + 1
              }
            ];
          } else {
            return [];
          }
        });
      });
      return errors;
    }
    exports2.validateEmptyOrAlternative = validateEmptyOrAlternative;
    function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      ors = (0, reject_1.default)(ors, function(currOr) {
        return currOr.ignoreAmbiguities === true;
      });
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        var currOccurrence = currOr.idx;
        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
        var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);
      });
      return errors;
    }
    exports2.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;
    var RepetitionCollector = function(_super) {
      __extends(RepetitionCollector2, _super);
      function RepetitionCollector2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allProductions = [];
        return _this;
      }
      RepetitionCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
        this.allProductions.push(manySep);
      };
      RepetitionCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
        this.allProductions.push(atLeastOne);
      };
      RepetitionCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
        this.allProductions.push(atLeastOneSep);
      };
      RepetitionCollector2.prototype.visitRepetition = function(many) {
        this.allProductions.push(many);
      };
      return RepetitionCollector2;
    }(gast_3.GAstVisitor);
    exports2.RepetitionCollector = RepetitionCollector;
    function validateTooManyAlts(topLevelRule, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        if (currOr.definition.length > 255) {
          return [
            {
              message: errMsgProvider.buildTooManyAlternativesError({
                topLevelRule,
                alternation: currOr
              }),
              type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,
              ruleName: topLevelRule.name,
              occurrence: currOr.idx
            }
          ];
        } else {
          return [];
        }
      });
      return errors;
    }
    exports2.validateTooManyAlts = validateTooManyAlts;
    function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
      var errors = [];
      (0, forEach_1.default)(topLevelRules, function(currTopRule) {
        var collectorVisitor = new RepetitionCollector();
        currTopRule.accept(collectorVisitor);
        var allRuleProductions = collectorVisitor.allProductions;
        (0, forEach_1.default)(allRuleProductions, function(currProd) {
          var prodType = (0, lookahead_1.getProdType)(currProd);
          var actualMaxLookahead = currProd.maxLookahead || maxLookahead;
          var currOccurrence = currProd.idx;
          var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);
          var pathsInsideProduction = paths[0];
          if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {
            var errMsg = errMsgProvider.buildEmptyRepetitionError({
              topLevelRule: currTopRule,
              repetition: currProd
            });
            errors.push({
              message: errMsg,
              type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
              ruleName: currTopRule.name
            });
          }
        });
      });
      return errors;
    }
    exports2.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;
    function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
      var foundAmbiguousPaths = [];
      var identicalAmbiguities = (0, reduce_1.default)(alternatives, function(result, currAlt, currAltIdx) {
        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {
          return result;
        }
        (0, forEach_1.default)(currAlt, function(currPath) {
          var altsCurrPathAppearsIn = [currAltIdx];
          (0, forEach_1.default)(alternatives, function(currOtherAlt, currOtherAltIdx) {
            if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) && alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {
              altsCurrPathAppearsIn.push(currOtherAltIdx);
            }
          });
          if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {
            foundAmbiguousPaths.push(currPath);
            result.push({
              alts: altsCurrPathAppearsIn,
              path: currPath
            });
          }
        });
        return result;
      }, []);
      var currErrors = (0, map_1.default)(identicalAmbiguities, function(currAmbDescriptor) {
        var ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, function(currAltIdx) {
          return currAltIdx + 1;
        });
        var currMessage = errMsgProvider.buildAlternationAmbiguityError({
          topLevelRule: rule,
          alternation,
          ambiguityIndices: ambgIndices,
          prefixPath: currAmbDescriptor.path
        });
        return {
          message: currMessage,
          type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,
          ruleName: rule.name,
          occurrence: alternation.idx,
          alternatives: currAmbDescriptor.alts
        };
      });
      return currErrors;
    }
    function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
      var pathsAndIndices = (0, reduce_1.default)(alternatives, function(result, currAlt, idx) {
        var currPathsAndIdx = (0, map_1.default)(currAlt, function(currPath) {
          return { idx, path: currPath };
        });
        return result.concat(currPathsAndIdx);
      }, []);
      var errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, function(currPathAndIdx) {
        var alternativeGast = alternation.definition[currPathAndIdx.idx];
        if (alternativeGast.ignoreAmbiguities === true) {
          return [];
        }
        var targetIdx = currPathAndIdx.idx;
        var targetPath = currPathAndIdx.path;
        var prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, function(searchPathAndIdx) {
          return alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath);
        });
        var currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, function(currAmbPathAndIdx) {
          var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
          var occurrence = alternation.idx === 0 ? "" : alternation.idx;
          var message = errMsgProvider.buildAlternationPrefixAmbiguityError({
            topLevelRule: rule,
            alternation,
            ambiguityIndices: ambgIndices,
            prefixPath: currAmbPathAndIdx.path
          });
          return {
            message,
            type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
            ruleName: rule.name,
            occurrence,
            alternatives: ambgIndices
          };
        });
        return currPathPrefixErrors;
      }));
      return errors;
    }
    exports2.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;
    function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
      var errors = [];
      var tokenNames = (0, map_1.default)(tokenTypes, function(currToken) {
        return currToken.name;
      });
      (0, forEach_1.default)(topLevels, function(currRule) {
        var currRuleName = currRule.name;
        if ((0, includes_1.default)(tokenNames, currRuleName)) {
          var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
          errors.push({
            message: errMsg,
            type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
            ruleName: currRuleName
          });
        }
      });
      return errors;
    }
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js
var require_gast_resolver_public = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateGrammar = exports2.resolveGrammar = void 0;
    var forEach_1 = __importDefault(require_forEach());
    var defaults_1 = __importDefault(require_defaults());
    var resolver_1 = require_resolver();
    var checks_1 = require_checks();
    var errors_public_1 = require_errors_public();
    function resolveGrammar(options) {
      var actualOptions = (0, defaults_1.default)(options, {
        errMsgProvider: errors_public_1.defaultGrammarResolverErrorProvider
      });
      var topRulesTable = {};
      (0, forEach_1.default)(options.rules, function(rule) {
        topRulesTable[rule.name] = rule;
      });
      return (0, resolver_1.resolveGrammar)(topRulesTable, actualOptions.errMsgProvider);
    }
    exports2.resolveGrammar = resolveGrammar;
    function validateGrammar(options) {
      options = (0, defaults_1.default)(options, {
        errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider
      });
      return (0, checks_1.validateGrammar)(options.rules, options.maxLookahead, options.tokenTypes, options.errMsgProvider, options.grammarName);
    }
    exports2.validateGrammar = validateGrammar;
  }
});

// node_modules/chevrotain/lib/src/parse/exceptions_public.js
var require_exceptions_public = __commonJS({
  "node_modules/chevrotain/lib/src/parse/exceptions_public.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b5) {
          d2.__proto__ = b5;
        } || function(d2, b5) {
          for (var p in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p))
              d2[p] = b5[p];
        };
        return extendStatics(d, b3);
      };
      return function(d, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d, b3);
        function __() {
          this.constructor = d;
        }
        d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EarlyExitException = exports2.NotAllInputParsedException = exports2.NoViableAltException = exports2.MismatchedTokenException = exports2.isRecognitionException = void 0;
    var includes_1 = __importDefault(require_includes());
    var MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
    var NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
    var EARLY_EXIT_EXCEPTION = "EarlyExitException";
    var NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
    var RECOGNITION_EXCEPTION_NAMES = [
      MISMATCHED_TOKEN_EXCEPTION,
      NO_VIABLE_ALT_EXCEPTION,
      EARLY_EXIT_EXCEPTION,
      NOT_ALL_INPUT_PARSED_EXCEPTION
    ];
    Object.freeze(RECOGNITION_EXCEPTION_NAMES);
    function isRecognitionException2(error) {
      return (0, includes_1.default)(RECOGNITION_EXCEPTION_NAMES, error.name);
    }
    exports2.isRecognitionException = isRecognitionException2;
    var RecognitionException = function(_super) {
      __extends(RecognitionException2, _super);
      function RecognitionException2(message, token) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        _this.token = token;
        _this.resyncedTokens = [];
        Object.setPrototypeOf(_this, _newTarget.prototype);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_this, _this.constructor);
        }
        return _this;
      }
      return RecognitionException2;
    }(Error);
    var MismatchedTokenException2 = function(_super) {
      __extends(MismatchedTokenException3, _super);
      function MismatchedTokenException3(message, token, previousToken) {
        var _this = _super.call(this, message, token) || this;
        _this.previousToken = previousToken;
        _this.name = MISMATCHED_TOKEN_EXCEPTION;
        return _this;
      }
      return MismatchedTokenException3;
    }(RecognitionException);
    exports2.MismatchedTokenException = MismatchedTokenException2;
    var NoViableAltException2 = function(_super) {
      __extends(NoViableAltException3, _super);
      function NoViableAltException3(message, token, previousToken) {
        var _this = _super.call(this, message, token) || this;
        _this.previousToken = previousToken;
        _this.name = NO_VIABLE_ALT_EXCEPTION;
        return _this;
      }
      return NoViableAltException3;
    }(RecognitionException);
    exports2.NoViableAltException = NoViableAltException2;
    var NotAllInputParsedException2 = function(_super) {
      __extends(NotAllInputParsedException3, _super);
      function NotAllInputParsedException3(message, token) {
        var _this = _super.call(this, message, token) || this;
        _this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
        return _this;
      }
      return NotAllInputParsedException3;
    }(RecognitionException);
    exports2.NotAllInputParsedException = NotAllInputParsedException2;
    var EarlyExitException2 = function(_super) {
      __extends(EarlyExitException3, _super);
      function EarlyExitException3(message, token, previousToken) {
        var _this = _super.call(this, message, token) || this;
        _this.previousToken = previousToken;
        _this.name = EARLY_EXIT_EXCEPTION;
        return _this;
      }
      return EarlyExitException3;
    }(RecognitionException);
    exports2.EarlyExitException = EarlyExitException2;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js
var require_recoverable = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b5) {
          d2.__proto__ = b5;
        } || function(d2, b5) {
          for (var p in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p))
              d2[p] = b5[p];
        };
        return extendStatics(d, b3);
      };
      return function(d, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d, b3);
        function __() {
          this.constructor = d;
        }
        d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attemptInRepetitionRecovery = exports2.Recoverable = exports2.InRuleRecoveryException = exports2.IN_RULE_RECOVERY_EXCEPTION = exports2.EOF_FOLLOW_KEY = void 0;
    var tokens_public_1 = require_tokens_public();
    var isEmpty_1 = __importDefault(require_isEmpty());
    var dropRight_1 = __importDefault(require_dropRight());
    var flatten_1 = __importDefault(require_flatten());
    var map_1 = __importDefault(require_map());
    var find_1 = __importDefault(require_find());
    var has_1 = __importDefault(require_has());
    var includes_1 = __importDefault(require_includes());
    var clone_1 = __importDefault(require_clone());
    var exceptions_public_1 = require_exceptions_public();
    var constants_1 = require_constants();
    var parser_1 = require_parser();
    exports2.EOF_FOLLOW_KEY = {};
    exports2.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
    var InRuleRecoveryException = function(_super) {
      __extends(InRuleRecoveryException2, _super);
      function InRuleRecoveryException2(message) {
        var _this = _super.call(this, message) || this;
        _this.name = exports2.IN_RULE_RECOVERY_EXCEPTION;
        return _this;
      }
      return InRuleRecoveryException2;
    }(Error);
    exports2.InRuleRecoveryException = InRuleRecoveryException;
    var Recoverable = function() {
      function Recoverable2() {
      }
      Recoverable2.prototype.initRecoverable = function(config) {
        this.firstAfterRepMap = {};
        this.resyncFollows = {};
        this.recoveryEnabled = (0, has_1.default)(config, "recoveryEnabled") ? config.recoveryEnabled : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled;
        if (this.recoveryEnabled) {
          this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
        }
      };
      Recoverable2.prototype.getTokenToInsert = function(tokType) {
        var tokToInsert = (0, tokens_public_1.createTokenInstance)(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
        tokToInsert.isInsertedInRecovery = true;
        return tokToInsert;
      };
      Recoverable2.prototype.canTokenTypeBeInsertedInRecovery = function(tokType) {
        return true;
      };
      Recoverable2.prototype.canTokenTypeBeDeletedInRecovery = function(tokType) {
        return true;
      };
      Recoverable2.prototype.tryInRepetitionRecovery = function(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
        var _this = this;
        var reSyncTokType = this.findReSyncTokenType();
        var savedLexerState = this.exportLexerState();
        var resyncedTokens = [];
        var passedResyncPoint = false;
        var nextTokenWithoutResync = this.LA(1);
        var currToken = this.LA(1);
        var generateErrorMessage = function() {
          var previousToken = _this.LA(0);
          var msg = _this.errorMessageProvider.buildMismatchTokenMessage({
            expected: expectedTokType,
            actual: nextTokenWithoutResync,
            previous: previousToken,
            ruleName: _this.getCurrRuleFullName()
          });
          var error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));
          error.resyncedTokens = (0, dropRight_1.default)(resyncedTokens);
          _this.SAVE_ERROR(error);
        };
        while (!passedResyncPoint) {
          if (this.tokenMatcher(currToken, expectedTokType)) {
            generateErrorMessage();
            return;
          } else if (lookAheadFunc.call(this)) {
            generateErrorMessage();
            grammarRule.apply(this, grammarRuleArgs);
            return;
          } else if (this.tokenMatcher(currToken, reSyncTokType)) {
            passedResyncPoint = true;
          } else {
            currToken = this.SKIP_TOKEN();
            this.addToResyncTokens(currToken, resyncedTokens);
          }
        }
        this.importLexerState(savedLexerState);
      };
      Recoverable2.prototype.shouldInRepetitionRecoveryBeTried = function(expectTokAfterLastMatch, nextTokIdx, notStuck) {
        if (notStuck === false) {
          return false;
        }
        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
          return false;
        }
        if (this.isBackTracking()) {
          return false;
        }
        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
          return false;
        }
        return true;
      };
      Recoverable2.prototype.getFollowsForInRuleRecovery = function(tokType, tokIdxInRule) {
        var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
        var follows = this.getNextPossibleTokenTypes(grammarPath);
        return follows;
      };
      Recoverable2.prototype.tryInRuleRecovery = function(expectedTokType, follows) {
        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
          var tokToInsert = this.getTokenToInsert(expectedTokType);
          return tokToInsert;
        }
        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
          var nextTok = this.SKIP_TOKEN();
          this.consumeToken();
          return nextTok;
        }
        throw new InRuleRecoveryException("sad sad panda");
      };
      Recoverable2.prototype.canPerformInRuleRecovery = function(expectedToken, follows) {
        return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);
      };
      Recoverable2.prototype.canRecoverWithSingleTokenInsertion = function(expectedTokType, follows) {
        var _this = this;
        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
          return false;
        }
        if ((0, isEmpty_1.default)(follows)) {
          return false;
        }
        var mismatchedTok = this.LA(1);
        var isMisMatchedTokInFollows = (0, find_1.default)(follows, function(possibleFollowsTokType) {
          return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
        }) !== void 0;
        return isMisMatchedTokInFollows;
      };
      Recoverable2.prototype.canRecoverWithSingleTokenDeletion = function(expectedTokType) {
        if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {
          return false;
        }
        var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
        return isNextTokenWhatIsExpected;
      };
      Recoverable2.prototype.isInCurrentRuleReSyncSet = function(tokenTypeIdx) {
        var followKey = this.getCurrFollowKey();
        var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
        return (0, includes_1.default)(currentRuleReSyncSet, tokenTypeIdx);
      };
      Recoverable2.prototype.findReSyncTokenType = function() {
        var allPossibleReSyncTokTypes = this.flattenFollowSet();
        var nextToken = this.LA(1);
        var k = 2;
        while (true) {
          var foundMatch = (0, find_1.default)(allPossibleReSyncTokTypes, function(resyncTokType) {
            var canMatch = (0, tokens_public_1.tokenMatcher)(nextToken, resyncTokType);
            return canMatch;
          });
          if (foundMatch !== void 0) {
            return foundMatch;
          }
          nextToken = this.LA(k);
          k++;
        }
      };
      Recoverable2.prototype.getCurrFollowKey = function() {
        if (this.RULE_STACK.length === 1) {
          return exports2.EOF_FOLLOW_KEY;
        }
        var currRuleShortName = this.getLastExplicitRuleShortName();
        var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
        var prevRuleShortName = this.getPreviousExplicitRuleShortName();
        return {
          ruleName: this.shortRuleNameToFullName(currRuleShortName),
          idxInCallingRule: currRuleIdx,
          inRule: this.shortRuleNameToFullName(prevRuleShortName)
        };
      };
      Recoverable2.prototype.buildFullFollowKeyStack = function() {
        var _this = this;
        var explicitRuleStack = this.RULE_STACK;
        var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
        return (0, map_1.default)(explicitRuleStack, function(ruleName, idx) {
          if (idx === 0) {
            return exports2.EOF_FOLLOW_KEY;
          }
          return {
            ruleName: _this.shortRuleNameToFullName(ruleName),
            idxInCallingRule: explicitOccurrenceStack[idx],
            inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
          };
        });
      };
      Recoverable2.prototype.flattenFollowSet = function() {
        var _this = this;
        var followStack = (0, map_1.default)(this.buildFullFollowKeyStack(), function(currKey) {
          return _this.getFollowSetFromFollowKey(currKey);
        });
        return (0, flatten_1.default)(followStack);
      };
      Recoverable2.prototype.getFollowSetFromFollowKey = function(followKey) {
        if (followKey === exports2.EOF_FOLLOW_KEY) {
          return [tokens_public_1.EOF];
        }
        var followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;
        return this.resyncFollows[followName];
      };
      Recoverable2.prototype.addToResyncTokens = function(token, resyncTokens) {
        if (!this.tokenMatcher(token, tokens_public_1.EOF)) {
          resyncTokens.push(token);
        }
        return resyncTokens;
      };
      Recoverable2.prototype.reSyncTo = function(tokType) {
        var resyncedTokens = [];
        var nextTok = this.LA(1);
        while (this.tokenMatcher(nextTok, tokType) === false) {
          nextTok = this.SKIP_TOKEN();
          this.addToResyncTokens(nextTok, resyncedTokens);
        }
        return (0, dropRight_1.default)(resyncedTokens);
      };
      Recoverable2.prototype.attemptInRepetitionRecovery = function(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
      };
      Recoverable2.prototype.getCurrentGrammarPath = function(tokType, tokIdxInRule) {
        var pathRuleStack = this.getHumanReadableRuleStack();
        var pathOccurrenceStack = (0, clone_1.default)(this.RULE_OCCURRENCE_STACK);
        var grammarPath = {
          ruleStack: pathRuleStack,
          occurrenceStack: pathOccurrenceStack,
          lastTok: tokType,
          lastTokOccurrence: tokIdxInRule
        };
        return grammarPath;
      };
      Recoverable2.prototype.getHumanReadableRuleStack = function() {
        var _this = this;
        return (0, map_1.default)(this.RULE_STACK, function(currShortName) {
          return _this.shortRuleNameToFullName(currShortName);
        });
      };
      return Recoverable2;
    }();
    exports2.Recoverable = Recoverable;
    function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
      var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
      var firstAfterRepInfo = this.firstAfterRepMap[key];
      if (firstAfterRepInfo === void 0) {
        var currRuleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[currRuleName];
        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);
        firstAfterRepInfo = walker.startWalking();
        this.firstAfterRepMap[key] = firstAfterRepInfo;
      }
      var expectTokAfterLastMatch = firstAfterRepInfo.token;
      var nextTokIdx = firstAfterRepInfo.occurrence;
      var isEndOfRule = firstAfterRepInfo.isEndOfRule;
      if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {
        expectTokAfterLastMatch = tokens_public_1.EOF;
        nextTokIdx = 1;
      }
      if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {
        return;
      }
      if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
      }
    }
    exports2.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/keys.js
var require_keys2 = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/keys.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKeyForAutomaticLookahead = exports2.AT_LEAST_ONE_SEP_IDX = exports2.MANY_SEP_IDX = exports2.AT_LEAST_ONE_IDX = exports2.MANY_IDX = exports2.OPTION_IDX = exports2.OR_IDX = exports2.BITS_FOR_ALT_IDX = exports2.BITS_FOR_RULE_IDX = exports2.BITS_FOR_OCCURRENCE_IDX = exports2.BITS_FOR_METHOD_TYPE = void 0;
    exports2.BITS_FOR_METHOD_TYPE = 4;
    exports2.BITS_FOR_OCCURRENCE_IDX = 8;
    exports2.BITS_FOR_RULE_IDX = 12;
    exports2.BITS_FOR_ALT_IDX = 8;
    exports2.OR_IDX = 1 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.OPTION_IDX = 2 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.MANY_IDX = 3 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.AT_LEAST_ONE_IDX = 4 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.MANY_SEP_IDX = 5 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.AT_LEAST_ONE_SEP_IDX = 6 << exports2.BITS_FOR_OCCURRENCE_IDX;
    function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
      return occurrence | dslMethodIdx | ruleIdx;
    }
    exports2.getKeyForAutomaticLookahead = getKeyForAutomaticLookahead;
    var BITS_START_FOR_ALT_IDX = 32 - exports2.BITS_FOR_ALT_IDX;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js
var require_looksahead = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b5) {
          d2.__proto__ = b5;
        } || function(d2, b5) {
          for (var p in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p))
              d2[p] = b5[p];
        };
        return extendStatics(d, b3);
      };
      return function(d, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d, b3);
        function __() {
          this.constructor = d;
        }
        d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectMethods = exports2.LooksAhead = void 0;
    var lookahead_1 = require_lookahead();
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var parser_1 = require_parser();
    var keys_1 = require_keys2();
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    var LooksAhead = function() {
      function LooksAhead2() {
      }
      LooksAhead2.prototype.initLooksAhead = function(config) {
        this.dynamicTokensEnabled = (0, has_1.default)(config, "dynamicTokensEnabled") ? config.dynamicTokensEnabled : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
        this.maxLookahead = (0, has_1.default)(config, "maxLookahead") ? config.maxLookahead : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
        this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
      };
      LooksAhead2.prototype.preComputeLookaheadFunctions = function(rules) {
        var _this = this;
        (0, forEach_1.default)(rules, function(currRule) {
          _this.TRACE_INIT("".concat(currRule.name, " Rule Lookahead"), function() {
            var _a2 = collectMethods(currRule), alternation = _a2.alternation, repetition = _a2.repetition, option = _a2.option, repetitionMandatory = _a2.repetitionMandatory, repetitionMandatoryWithSeparator = _a2.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a2.repetitionWithSeparator;
            (0, forEach_1.default)(alternation, function(currProd) {
              var prodIdx = currProd.idx === 0 ? "" : currProd.idx;
              _this.TRACE_INIT("".concat((0, gast_2.getProductionDslName)(currProd)).concat(prodIdx), function() {
                var laFunc = (0, lookahead_1.buildLookaheadFuncForOr)(currProd.idx, currRule, currProd.maxLookahead || _this.maxLookahead, currProd.hasPredicates, _this.dynamicTokensEnabled, _this.lookAheadBuilderForAlternatives);
                var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);
                _this.setLaFuncCache(key, laFunc);
              });
            });
            (0, forEach_1.default)(repetition, function(currProd) {
              _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, lookahead_1.PROD_TYPE.REPETITION, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
            });
            (0, forEach_1.default)(option, function(currProd) {
              _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, lookahead_1.PROD_TYPE.OPTION, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
            });
            (0, forEach_1.default)(repetitionMandatory, function(currProd) {
              _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
            });
            (0, forEach_1.default)(repetitionMandatoryWithSeparator, function(currProd) {
              _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
            });
            (0, forEach_1.default)(repetitionWithSeparator, function(currProd) {
              _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_WITH_SEPARATOR, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
            });
          });
        });
      };
      LooksAhead2.prototype.computeLookaheadFunc = function(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
        var _this = this;
        this.TRACE_INIT("".concat(dslMethodName).concat(prodOccurrence === 0 ? "" : prodOccurrence), function() {
          var laFunc = (0, lookahead_1.buildLookaheadFuncForOptionalProd)(prodOccurrence, rule, prodMaxLookahead || _this.maxLookahead, _this.dynamicTokensEnabled, prodType, _this.lookAheadBuilderForOptional);
          var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
          _this.setLaFuncCache(key, laFunc);
        });
      };
      LooksAhead2.prototype.lookAheadBuilderForOptional = function(alt, tokenMatcher2, dynamicTokensEnabled) {
        return (0, lookahead_1.buildSingleAlternativeLookaheadFunction)(alt, tokenMatcher2, dynamicTokensEnabled);
      };
      LooksAhead2.prototype.lookAheadBuilderForAlternatives = function(alts, hasPredicates, tokenMatcher2, dynamicTokensEnabled) {
        return (0, lookahead_1.buildAlternativesLookAheadFunc)(alts, hasPredicates, tokenMatcher2, dynamicTokensEnabled);
      };
      LooksAhead2.prototype.getKeyForAutomaticLookahead = function(dslMethodIdx, occurrence) {
        var currRuleShortName = this.getLastExplicitRuleShortName();
        return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);
      };
      LooksAhead2.prototype.getLaFuncFromCache = function(key) {
        return this.lookAheadFuncsCache.get(key);
      };
      LooksAhead2.prototype.setLaFuncCache = function(key, value) {
        this.lookAheadFuncsCache.set(key, value);
      };
      return LooksAhead2;
    }();
    exports2.LooksAhead = LooksAhead;
    var DslMethodsCollectorVisitor = function(_super) {
      __extends(DslMethodsCollectorVisitor2, _super);
      function DslMethodsCollectorVisitor2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.dslMethods = {
          option: [],
          alternation: [],
          repetition: [],
          repetitionWithSeparator: [],
          repetitionMandatory: [],
          repetitionMandatoryWithSeparator: []
        };
        return _this;
      }
      DslMethodsCollectorVisitor2.prototype.reset = function() {
        this.dslMethods = {
          option: [],
          alternation: [],
          repetition: [],
          repetitionWithSeparator: [],
          repetitionMandatory: [],
          repetitionMandatoryWithSeparator: []
        };
      };
      DslMethodsCollectorVisitor2.prototype.visitOption = function(option) {
        this.dslMethods.option.push(option);
      };
      DslMethodsCollectorVisitor2.prototype.visitRepetitionWithSeparator = function(manySep) {
        this.dslMethods.repetitionWithSeparator.push(manySep);
      };
      DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatory = function(atLeastOne) {
        this.dslMethods.repetitionMandatory.push(atLeastOne);
      };
      DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
      };
      DslMethodsCollectorVisitor2.prototype.visitRepetition = function(many) {
        this.dslMethods.repetition.push(many);
      };
      DslMethodsCollectorVisitor2.prototype.visitAlternation = function(or2) {
        this.dslMethods.alternation.push(or2);
      };
      return DslMethodsCollectorVisitor2;
    }(gast_1.GAstVisitor);
    var collectorVisitor = new DslMethodsCollectorVisitor();
    function collectMethods(rule) {
      collectorVisitor.reset();
      rule.accept(collectorVisitor);
      var dslMethods = collectorVisitor.dslMethods;
      collectorVisitor.reset();
      return dslMethods;
    }
    exports2.collectMethods = collectMethods;
  }
});

// node_modules/chevrotain/lib/src/parse/cst/cst.js
var require_cst = __commonJS({
  "node_modules/chevrotain/lib/src/parse/cst/cst.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addNoneTerminalToCst = exports2.addTerminalToCst = exports2.setNodeLocationFull = exports2.setNodeLocationOnlyOffset = void 0;
    function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
      if (isNaN(currNodeLocation.startOffset) === true) {
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
      } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
      }
    }
    exports2.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;
    function setNodeLocationFull(currNodeLocation, newLocationInfo) {
      if (isNaN(currNodeLocation.startOffset) === true) {
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.startColumn = newLocationInfo.startColumn;
        currNodeLocation.startLine = newLocationInfo.startLine;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
      } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
      }
    }
    exports2.setNodeLocationFull = setNodeLocationFull;
    function addTerminalToCst(node, token, tokenTypeName) {
      if (node.children[tokenTypeName] === void 0) {
        node.children[tokenTypeName] = [token];
      } else {
        node.children[tokenTypeName].push(token);
      }
    }
    exports2.addTerminalToCst = addTerminalToCst;
    function addNoneTerminalToCst(node, ruleName, ruleResult) {
      if (node.children[ruleName] === void 0) {
        node.children[ruleName] = [ruleResult];
      } else {
        node.children[ruleName].push(ruleResult);
      }
    }
    exports2.addNoneTerminalToCst = addNoneTerminalToCst;
  }
});

// node_modules/chevrotain/lib/src/lang/lang_extensions.js
var require_lang_extensions = __commonJS({
  "node_modules/chevrotain/lib/src/lang/lang_extensions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineNameProp = void 0;
    var NAME = "name";
    function defineNameProp(obj, nameValue) {
      Object.defineProperty(obj, NAME, {
        enumerable: false,
        configurable: true,
        writable: false,
        value: nameValue
      });
    }
    exports2.defineNameProp = defineNameProp;
  }
});

// node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js
var require_cst_visitor = __commonJS({
  "node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateMissingCstMethods = exports2.validateVisitor = exports2.CstVisitorDefinitionError = exports2.createBaseVisitorConstructorWithDefaults = exports2.createBaseSemanticVisitorConstructor = exports2.defaultVisit = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var filter_1 = __importDefault(require_filter());
    var keys_1 = __importDefault(require_keys());
    var isFunction_1 = __importDefault(require_isFunction());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var lang_extensions_1 = require_lang_extensions();
    function defaultVisit(ctx, param) {
      var childrenNames = (0, keys_1.default)(ctx);
      var childrenNamesLength = childrenNames.length;
      for (var i2 = 0; i2 < childrenNamesLength; i2++) {
        var currChildName = childrenNames[i2];
        var currChildArray = ctx[currChildName];
        var currChildArrayLength = currChildArray.length;
        for (var j2 = 0; j2 < currChildArrayLength; j2++) {
          var currChild = currChildArray[j2];
          if (currChild.tokenTypeIdx === void 0) {
            this[currChild.name](currChild.children, param);
          }
        }
      }
    }
    exports2.defaultVisit = defaultVisit;
    function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
      var derivedConstructor = function() {
      };
      (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemantics");
      var semanticProto = {
        visit: function(cstNode, param) {
          if ((0, isArray_1.default)(cstNode)) {
            cstNode = cstNode[0];
          }
          if ((0, isUndefined_1.default)(cstNode)) {
            return void 0;
          }
          return this[cstNode.name](cstNode.children, param);
        },
        validateVisitor: function() {
          var semanticDefinitionErrors = validateVisitor(this, ruleNames);
          if (!(0, isEmpty_1.default)(semanticDefinitionErrors)) {
            var errorMessages = (0, map_1.default)(semanticDefinitionErrors, function(currDefError) {
              return currDefError.msg;
            });
            throw Error("Errors Detected in CST Visitor <".concat(this.constructor.name, ">:\n	") + "".concat(errorMessages.join("\n\n").replace(/\n/g, "\n	")));
          }
        }
      };
      derivedConstructor.prototype = semanticProto;
      derivedConstructor.prototype.constructor = derivedConstructor;
      derivedConstructor._RULE_NAMES = ruleNames;
      return derivedConstructor;
    }
    exports2.createBaseSemanticVisitorConstructor = createBaseSemanticVisitorConstructor;
    function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
      var derivedConstructor = function() {
      };
      (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
      var withDefaultsProto = Object.create(baseConstructor.prototype);
      (0, forEach_1.default)(ruleNames, function(ruleName) {
        withDefaultsProto[ruleName] = defaultVisit;
      });
      derivedConstructor.prototype = withDefaultsProto;
      derivedConstructor.prototype.constructor = derivedConstructor;
      return derivedConstructor;
    }
    exports2.createBaseVisitorConstructorWithDefaults = createBaseVisitorConstructorWithDefaults;
    var CstVisitorDefinitionError;
    (function(CstVisitorDefinitionError2) {
      CstVisitorDefinitionError2[CstVisitorDefinitionError2["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
      CstVisitorDefinitionError2[CstVisitorDefinitionError2["MISSING_METHOD"] = 1] = "MISSING_METHOD";
    })(CstVisitorDefinitionError = exports2.CstVisitorDefinitionError || (exports2.CstVisitorDefinitionError = {}));
    function validateVisitor(visitorInstance, ruleNames) {
      var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
      return missingErrors;
    }
    exports2.validateVisitor = validateVisitor;
    function validateMissingCstMethods(visitorInstance, ruleNames) {
      var missingRuleNames = (0, filter_1.default)(ruleNames, function(currRuleName) {
        return (0, isFunction_1.default)(visitorInstance[currRuleName]) === false;
      });
      var errors = (0, map_1.default)(missingRuleNames, function(currRuleName) {
        return {
          msg: "Missing visitor method: <".concat(currRuleName, "> on ").concat(visitorInstance.constructor.name, " CST Visitor."),
          type: CstVisitorDefinitionError.MISSING_METHOD,
          methodName: currRuleName
        };
      });
      return (0, compact_1.default)(errors);
    }
    exports2.validateMissingCstMethods = validateMissingCstMethods;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js
var require_tree_builder = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TreeBuilder = void 0;
    var cst_1 = require_cst();
    var noop_1 = __importDefault(require_noop());
    var has_1 = __importDefault(require_has());
    var keys_1 = __importDefault(require_keys());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var cst_visitor_1 = require_cst_visitor();
    var parser_1 = require_parser();
    var TreeBuilder = function() {
      function TreeBuilder2() {
      }
      TreeBuilder2.prototype.initTreeBuilder = function(config) {
        this.CST_STACK = [];
        this.outputCst = config.outputCst;
        this.nodeLocationTracking = (0, has_1.default)(config, "nodeLocationTracking") ? config.nodeLocationTracking : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;
        if (!this.outputCst) {
          this.cstInvocationStateUpdate = noop_1.default;
          this.cstFinallyStateUpdate = noop_1.default;
          this.cstPostTerminal = noop_1.default;
          this.cstPostNonTerminal = noop_1.default;
          this.cstPostRule = noop_1.default;
        } else {
          if (/full/i.test(this.nodeLocationTracking)) {
            if (this.recoveryEnabled) {
              this.setNodeLocationFromToken = cst_1.setNodeLocationFull;
              this.setNodeLocationFromNode = cst_1.setNodeLocationFull;
              this.cstPostRule = noop_1.default;
              this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
            } else {
              this.setNodeLocationFromToken = noop_1.default;
              this.setNodeLocationFromNode = noop_1.default;
              this.cstPostRule = this.cstPostRuleFull;
              this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
            }
          } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
            if (this.recoveryEnabled) {
              this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;
              this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;
              this.cstPostRule = noop_1.default;
              this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
            } else {
              this.setNodeLocationFromToken = noop_1.default;
              this.setNodeLocationFromNode = noop_1.default;
              this.cstPostRule = this.cstPostRuleOnlyOffset;
              this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
            }
          } else if (/none/i.test(this.nodeLocationTracking)) {
            this.setNodeLocationFromToken = noop_1.default;
            this.setNodeLocationFromNode = noop_1.default;
            this.cstPostRule = noop_1.default;
            this.setInitialNodeLocation = noop_1.default;
          } else {
            throw Error('Invalid <nodeLocationTracking> config option: "'.concat(config.nodeLocationTracking, '"'));
          }
        }
      };
      TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRecovery = function(cstNode) {
        cstNode.location = {
          startOffset: NaN,
          endOffset: NaN
        };
      };
      TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRegular = function(cstNode) {
        cstNode.location = {
          startOffset: this.LA(1).startOffset,
          endOffset: NaN
        };
      };
      TreeBuilder2.prototype.setInitialNodeLocationFullRecovery = function(cstNode) {
        cstNode.location = {
          startOffset: NaN,
          startLine: NaN,
          startColumn: NaN,
          endOffset: NaN,
          endLine: NaN,
          endColumn: NaN
        };
      };
      TreeBuilder2.prototype.setInitialNodeLocationFullRegular = function(cstNode) {
        var nextToken = this.LA(1);
        cstNode.location = {
          startOffset: nextToken.startOffset,
          startLine: nextToken.startLine,
          startColumn: nextToken.startColumn,
          endOffset: NaN,
          endLine: NaN,
          endColumn: NaN
        };
      };
      TreeBuilder2.prototype.cstInvocationStateUpdate = function(fullRuleName) {
        var cstNode = {
          name: fullRuleName,
          children: /* @__PURE__ */ Object.create(null)
        };
        this.setInitialNodeLocation(cstNode);
        this.CST_STACK.push(cstNode);
      };
      TreeBuilder2.prototype.cstFinallyStateUpdate = function() {
        this.CST_STACK.pop();
      };
      TreeBuilder2.prototype.cstPostRuleFull = function(ruleCstNode) {
        var prevToken = this.LA(0);
        var loc = ruleCstNode.location;
        if (loc.startOffset <= prevToken.startOffset === true) {
          loc.endOffset = prevToken.endOffset;
          loc.endLine = prevToken.endLine;
          loc.endColumn = prevToken.endColumn;
        } else {
          loc.startOffset = NaN;
          loc.startLine = NaN;
          loc.startColumn = NaN;
        }
      };
      TreeBuilder2.prototype.cstPostRuleOnlyOffset = function(ruleCstNode) {
        var prevToken = this.LA(0);
        var loc = ruleCstNode.location;
        if (loc.startOffset <= prevToken.startOffset === true) {
          loc.endOffset = prevToken.endOffset;
        } else {
          loc.startOffset = NaN;
        }
      };
      TreeBuilder2.prototype.cstPostTerminal = function(key, consumedToken) {
        var rootCst = this.CST_STACK[this.CST_STACK.length - 1];
        (0, cst_1.addTerminalToCst)(rootCst, consumedToken, key);
        this.setNodeLocationFromToken(rootCst.location, consumedToken);
      };
      TreeBuilder2.prototype.cstPostNonTerminal = function(ruleCstResult, ruleName) {
        var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
        (0, cst_1.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult);
        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
      };
      TreeBuilder2.prototype.getBaseCstVisitorConstructor = function() {
        if ((0, isUndefined_1.default)(this.baseCstVisitorConstructor)) {
          var newBaseCstVisitorConstructor = (0, cst_visitor_1.createBaseSemanticVisitorConstructor)(this.className, (0, keys_1.default)(this.gastProductionsCache));
          this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
          return newBaseCstVisitorConstructor;
        }
        return this.baseCstVisitorConstructor;
      };
      TreeBuilder2.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
        if ((0, isUndefined_1.default)(this.baseCstVisitorWithDefaultsConstructor)) {
          var newConstructor = (0, cst_visitor_1.createBaseVisitorConstructorWithDefaults)(this.className, (0, keys_1.default)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
          this.baseCstVisitorWithDefaultsConstructor = newConstructor;
          return newConstructor;
        }
        return this.baseCstVisitorWithDefaultsConstructor;
      };
      TreeBuilder2.prototype.getLastExplicitRuleShortName = function() {
        var ruleStack = this.RULE_STACK;
        return ruleStack[ruleStack.length - 1];
      };
      TreeBuilder2.prototype.getPreviousExplicitRuleShortName = function() {
        var ruleStack = this.RULE_STACK;
        return ruleStack[ruleStack.length - 2];
      };
      TreeBuilder2.prototype.getLastExplicitRuleOccurrenceIndex = function() {
        var occurrenceStack = this.RULE_OCCURRENCE_STACK;
        return occurrenceStack[occurrenceStack.length - 1];
      };
      return TreeBuilder2;
    }();
    exports2.TreeBuilder = TreeBuilder;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js
var require_lexer_adapter = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerAdapter = void 0;
    var parser_1 = require_parser();
    var LexerAdapter = function() {
      function LexerAdapter2() {
      }
      LexerAdapter2.prototype.initLexerAdapter = function() {
        this.tokVector = [];
        this.tokVectorLength = 0;
        this.currIdx = -1;
      };
      Object.defineProperty(LexerAdapter2.prototype, "input", {
        get: function() {
          return this.tokVector;
        },
        set: function(newInput) {
          if (this.selfAnalysisDone !== true) {
            throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
          }
          this.reset();
          this.tokVector = newInput;
          this.tokVectorLength = newInput.length;
        },
        enumerable: false,
        configurable: true
      });
      LexerAdapter2.prototype.SKIP_TOKEN = function() {
        if (this.currIdx <= this.tokVector.length - 2) {
          this.consumeToken();
          return this.LA(1);
        } else {
          return parser_1.END_OF_FILE;
        }
      };
      LexerAdapter2.prototype.LA = function(howMuch) {
        var soughtIdx = this.currIdx + howMuch;
        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
          return parser_1.END_OF_FILE;
        } else {
          return this.tokVector[soughtIdx];
        }
      };
      LexerAdapter2.prototype.consumeToken = function() {
        this.currIdx++;
      };
      LexerAdapter2.prototype.exportLexerState = function() {
        return this.currIdx;
      };
      LexerAdapter2.prototype.importLexerState = function(newState) {
        this.currIdx = newState;
      };
      LexerAdapter2.prototype.resetLexerState = function() {
        this.currIdx = -1;
      };
      LexerAdapter2.prototype.moveToTerminatedState = function() {
        this.currIdx = this.tokVector.length - 1;
      };
      LexerAdapter2.prototype.getLexerPosition = function() {
        return this.exportLexerState();
      };
      return LexerAdapter2;
    }();
    exports2.LexerAdapter = LexerAdapter;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js
var require_recognizer_api = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecognizerApi = void 0;
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var exceptions_public_1 = require_exceptions_public();
    var parser_1 = require_parser();
    var errors_public_1 = require_errors_public();
    var checks_1 = require_checks();
    var gast_1 = require_api2();
    var RecognizerApi = function() {
      function RecognizerApi2() {
      }
      RecognizerApi2.prototype.ACTION = function(impl) {
        return impl.call(this);
      };
      RecognizerApi2.prototype.consume = function(idx, tokType, options) {
        return this.consumeInternal(tokType, idx, options);
      };
      RecognizerApi2.prototype.subrule = function(idx, ruleToCall, options) {
        return this.subruleInternal(ruleToCall, idx, options);
      };
      RecognizerApi2.prototype.option = function(idx, actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, idx);
      };
      RecognizerApi2.prototype.or = function(idx, altsOrOpts) {
        return this.orInternal(altsOrOpts, idx);
      };
      RecognizerApi2.prototype.many = function(idx, actionORMethodDef) {
        return this.manyInternal(idx, actionORMethodDef);
      };
      RecognizerApi2.prototype.atLeastOne = function(idx, actionORMethodDef) {
        return this.atLeastOneInternal(idx, actionORMethodDef);
      };
      RecognizerApi2.prototype.CONSUME = function(tokType, options) {
        return this.consumeInternal(tokType, 0, options);
      };
      RecognizerApi2.prototype.CONSUME1 = function(tokType, options) {
        return this.consumeInternal(tokType, 1, options);
      };
      RecognizerApi2.prototype.CONSUME2 = function(tokType, options) {
        return this.consumeInternal(tokType, 2, options);
      };
      RecognizerApi2.prototype.CONSUME3 = function(tokType, options) {
        return this.consumeInternal(tokType, 3, options);
      };
      RecognizerApi2.prototype.CONSUME4 = function(tokType, options) {
        return this.consumeInternal(tokType, 4, options);
      };
      RecognizerApi2.prototype.CONSUME5 = function(tokType, options) {
        return this.consumeInternal(tokType, 5, options);
      };
      RecognizerApi2.prototype.CONSUME6 = function(tokType, options) {
        return this.consumeInternal(tokType, 6, options);
      };
      RecognizerApi2.prototype.CONSUME7 = function(tokType, options) {
        return this.consumeInternal(tokType, 7, options);
      };
      RecognizerApi2.prototype.CONSUME8 = function(tokType, options) {
        return this.consumeInternal(tokType, 8, options);
      };
      RecognizerApi2.prototype.CONSUME9 = function(tokType, options) {
        return this.consumeInternal(tokType, 9, options);
      };
      RecognizerApi2.prototype.SUBRULE = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 0, options);
      };
      RecognizerApi2.prototype.SUBRULE1 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 1, options);
      };
      RecognizerApi2.prototype.SUBRULE2 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 2, options);
      };
      RecognizerApi2.prototype.SUBRULE3 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 3, options);
      };
      RecognizerApi2.prototype.SUBRULE4 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 4, options);
      };
      RecognizerApi2.prototype.SUBRULE5 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 5, options);
      };
      RecognizerApi2.prototype.SUBRULE6 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 6, options);
      };
      RecognizerApi2.prototype.SUBRULE7 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 7, options);
      };
      RecognizerApi2.prototype.SUBRULE8 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 8, options);
      };
      RecognizerApi2.prototype.SUBRULE9 = function(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 9, options);
      };
      RecognizerApi2.prototype.OPTION = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 0);
      };
      RecognizerApi2.prototype.OPTION1 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 1);
      };
      RecognizerApi2.prototype.OPTION2 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 2);
      };
      RecognizerApi2.prototype.OPTION3 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 3);
      };
      RecognizerApi2.prototype.OPTION4 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 4);
      };
      RecognizerApi2.prototype.OPTION5 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 5);
      };
      RecognizerApi2.prototype.OPTION6 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 6);
      };
      RecognizerApi2.prototype.OPTION7 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 7);
      };
      RecognizerApi2.prototype.OPTION8 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 8);
      };
      RecognizerApi2.prototype.OPTION9 = function(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 9);
      };
      RecognizerApi2.prototype.OR = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 0);
      };
      RecognizerApi2.prototype.OR1 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 1);
      };
      RecognizerApi2.prototype.OR2 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 2);
      };
      RecognizerApi2.prototype.OR3 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 3);
      };
      RecognizerApi2.prototype.OR4 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 4);
      };
      RecognizerApi2.prototype.OR5 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 5);
      };
      RecognizerApi2.prototype.OR6 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 6);
      };
      RecognizerApi2.prototype.OR7 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 7);
      };
      RecognizerApi2.prototype.OR8 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 8);
      };
      RecognizerApi2.prototype.OR9 = function(altsOrOpts) {
        return this.orInternal(altsOrOpts, 9);
      };
      RecognizerApi2.prototype.MANY = function(actionORMethodDef) {
        this.manyInternal(0, actionORMethodDef);
      };
      RecognizerApi2.prototype.MANY1 = function(actionORMethodDef) {
        this.manyInternal(1, actionORMethodDef);
      };
      RecognizerApi2.prototype.MANY2 = function(actionORMethodDef) {
        this.manyInternal(2, actionORMethodDef);
      };
      RecognizerApi2.prototype.MANY3 = function(actionORMethodDef) {
        this.manyInternal(3, actionORMethodDef);
      };
      RecognizerApi2.prototype.MANY4 = function(actionORMethodDef) {
        this.manyInternal(4, actionORMethodDef);
      };
      RecognizerApi2.prototype.MANY5 = function(actionORMethodDef) {
        this.manyInternal(5, actionORMethodDef);
      };
      RecognizerApi2.prototype.MANY6 = function(actionORMethodDef) {
        this.manyInternal(6, actionORMethodDef);
      };
      RecognizerApi2.prototype.MANY7 = function(actionORMethodDef) {
        this.manyInternal(7, actionORMethodDef);
      };
      RecognizerApi2.prototype.MANY8 = function(actionORMethodDef) {
        this.manyInternal(8, actionORMethodDef);
      };
      RecognizerApi2.prototype.MANY9 = function(actionORMethodDef) {
        this.manyInternal(9, actionORMethodDef);
      };
      RecognizerApi2.prototype.MANY_SEP = function(options) {
        this.manySepFirstInternal(0, options);
      };
      RecognizerApi2.prototype.MANY_SEP1 = function(options) {
        this.manySepFirstInternal(1, options);
      };
      RecognizerApi2.prototype.MANY_SEP2 = function(options) {
        this.manySepFirstInternal(2, options);
      };
      RecognizerApi2.prototype.MANY_SEP3 = function(options) {
        this.manySepFirstInternal(3, options);
      };
      RecognizerApi2.prototype.MANY_SEP4 = function(options) {
        this.manySepFirstInternal(4, options);
      };
      RecognizerApi2.prototype.MANY_SEP5 = function(options) {
        this.manySepFirstInternal(5, options);
      };
      RecognizerApi2.prototype.MANY_SEP6 = function(options) {
        this.manySepFirstInternal(6, options);
      };
      RecognizerApi2.prototype.MANY_SEP7 = function(options) {
        this.manySepFirstInternal(7, options);
      };
      RecognizerApi2.prototype.MANY_SEP8 = function(options) {
        this.manySepFirstInternal(8, options);
      };
      RecognizerApi2.prototype.MANY_SEP9 = function(options) {
        this.manySepFirstInternal(9, options);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE = function(actionORMethodDef) {
        this.atLeastOneInternal(0, actionORMethodDef);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE1 = function(actionORMethodDef) {
        return this.atLeastOneInternal(1, actionORMethodDef);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE2 = function(actionORMethodDef) {
        this.atLeastOneInternal(2, actionORMethodDef);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE3 = function(actionORMethodDef) {
        this.atLeastOneInternal(3, actionORMethodDef);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE4 = function(actionORMethodDef) {
        this.atLeastOneInternal(4, actionORMethodDef);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE5 = function(actionORMethodDef) {
        this.atLeastOneInternal(5, actionORMethodDef);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE6 = function(actionORMethodDef) {
        this.atLeastOneInternal(6, actionORMethodDef);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE7 = function(actionORMethodDef) {
        this.atLeastOneInternal(7, actionORMethodDef);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE8 = function(actionORMethodDef) {
        this.atLeastOneInternal(8, actionORMethodDef);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE9 = function(actionORMethodDef) {
        this.atLeastOneInternal(9, actionORMethodDef);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE_SEP = function(options) {
        this.atLeastOneSepFirstInternal(0, options);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE_SEP1 = function(options) {
        this.atLeastOneSepFirstInternal(1, options);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE_SEP2 = function(options) {
        this.atLeastOneSepFirstInternal(2, options);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE_SEP3 = function(options) {
        this.atLeastOneSepFirstInternal(3, options);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE_SEP4 = function(options) {
        this.atLeastOneSepFirstInternal(4, options);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE_SEP5 = function(options) {
        this.atLeastOneSepFirstInternal(5, options);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE_SEP6 = function(options) {
        this.atLeastOneSepFirstInternal(6, options);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE_SEP7 = function(options) {
        this.atLeastOneSepFirstInternal(7, options);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE_SEP8 = function(options) {
        this.atLeastOneSepFirstInternal(8, options);
      };
      RecognizerApi2.prototype.AT_LEAST_ONE_SEP9 = function(options) {
        this.atLeastOneSepFirstInternal(9, options);
      };
      RecognizerApi2.prototype.RULE = function(name, implementation, config) {
        if (config === void 0) {
          config = parser_1.DEFAULT_RULE_CONFIG;
        }
        if ((0, includes_1.default)(this.definedRulesNames, name)) {
          var errMsg = errors_public_1.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
            topLevelRule: name,
            grammarName: this.className
          });
          var error = {
            message: errMsg,
            type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
            ruleName: name
          };
          this.definitionErrors.push(error);
        }
        this.definedRulesNames.push(name);
        var ruleImplementation = this.defineRule(name, implementation, config);
        this[name] = ruleImplementation;
        return ruleImplementation;
      };
      RecognizerApi2.prototype.OVERRIDE_RULE = function(name, impl, config) {
        if (config === void 0) {
          config = parser_1.DEFAULT_RULE_CONFIG;
        }
        var ruleErrors = (0, checks_1.validateRuleIsOverridden)(name, this.definedRulesNames, this.className);
        this.definitionErrors = this.definitionErrors.concat(ruleErrors);
        var ruleImplementation = this.defineRule(name, impl, config);
        this[name] = ruleImplementation;
        return ruleImplementation;
      };
      RecognizerApi2.prototype.BACKTRACK = function(grammarRule, args) {
        return function() {
          this.isBackTrackingStack.push(1);
          var orgState = this.saveRecogState();
          try {
            grammarRule.apply(this, args);
            return true;
          } catch (e) {
            if ((0, exceptions_public_1.isRecognitionException)(e)) {
              return false;
            } else {
              throw e;
            }
          } finally {
            this.reloadRecogState(orgState);
            this.isBackTrackingStack.pop();
          }
        };
      };
      RecognizerApi2.prototype.getGAstProductions = function() {
        return this.gastProductionsCache;
      };
      RecognizerApi2.prototype.getSerializedGastProductions = function() {
        return (0, gast_1.serializeGrammar)((0, values_1.default)(this.gastProductionsCache));
      };
      return RecognizerApi2;
    }();
    exports2.RecognizerApi = RecognizerApi;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js
var require_recognizer_engine = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecognizerEngine = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var isArray_1 = __importDefault(require_isArray());
    var flatten_1 = __importDefault(require_flatten());
    var every_1 = __importDefault(require_every());
    var uniq_1 = __importDefault(require_uniq());
    var isObject_1 = __importDefault(require_isObject());
    var has_1 = __importDefault(require_has());
    var values_1 = __importDefault(require_values());
    var reduce_1 = __importDefault(require_reduce());
    var clone_1 = __importDefault(require_clone());
    var keys_1 = require_keys2();
    var exceptions_public_1 = require_exceptions_public();
    var lookahead_1 = require_lookahead();
    var interpreter_1 = require_interpreter();
    var parser_1 = require_parser();
    var recoverable_1 = require_recoverable();
    var tokens_public_1 = require_tokens_public();
    var tokens_1 = require_tokens();
    var RecognizerEngine = function() {
      function RecognizerEngine2() {
      }
      RecognizerEngine2.prototype.initRecognizerEngine = function(tokenVocabulary, config) {
        this.className = this.constructor.name;
        this.shortRuleNameToFull = {};
        this.fullRuleNameToShort = {};
        this.ruleShortNameIdx = 256;
        this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;
        this.subruleIdx = 0;
        this.definedRulesNames = [];
        this.tokensMap = {};
        this.isBackTrackingStack = [];
        this.RULE_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
        this.gastProductionsCache = {};
        if ((0, has_1.default)(config, "serializedGrammar")) {
          throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\n	For Further details.");
        }
        if ((0, isArray_1.default)(tokenVocabulary)) {
          if ((0, isEmpty_1.default)(tokenVocabulary)) {
            throw Error("A Token Vocabulary cannot be empty.\n	Note that the first argument for the parser constructor\n	is no longer a Token vector (since v4.0).");
          }
          if (typeof tokenVocabulary[0].startOffset === "number") {
            throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\n	For Further details.");
          }
        }
        if ((0, isArray_1.default)(tokenVocabulary)) {
          this.tokensMap = (0, reduce_1.default)(tokenVocabulary, function(acc, tokType) {
            acc[tokType.name] = tokType;
            return acc;
          }, {});
        } else if ((0, has_1.default)(tokenVocabulary, "modes") && (0, every_1.default)((0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)), tokens_1.isTokenType)) {
          var allTokenTypes_1 = (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes));
          var uniqueTokens = (0, uniq_1.default)(allTokenTypes_1);
          this.tokensMap = (0, reduce_1.default)(uniqueTokens, function(acc, tokType) {
            acc[tokType.name] = tokType;
            return acc;
          }, {});
        } else if ((0, isObject_1.default)(tokenVocabulary)) {
          this.tokensMap = (0, clone_1.default)(tokenVocabulary);
        } else {
          throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
        }
        this.tokensMap["EOF"] = tokens_public_1.EOF;
        var allTokenTypes = (0, has_1.default)(tokenVocabulary, "modes") ? (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)) : (0, values_1.default)(tokenVocabulary);
        var noTokenCategoriesUsed = (0, every_1.default)(allTokenTypes, function(tokenConstructor) {
          return (0, isEmpty_1.default)(tokenConstructor.categoryMatches);
        });
        this.tokenMatcher = noTokenCategoriesUsed ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
        (0, tokens_1.augmentTokenTypes)((0, values_1.default)(this.tokensMap));
      };
      RecognizerEngine2.prototype.defineRule = function(ruleName, impl, config) {
        if (this.selfAnalysisDone) {
          throw Error("Grammar rule <".concat(ruleName, "> may not be defined after the 'performSelfAnalysis' method has been called'\n") + "Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
        }
        var resyncEnabled = (0, has_1.default)(config, "resyncEnabled") ? config.resyncEnabled : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;
        var recoveryValueFunc = (0, has_1.default)(config, "recoveryValueFunc") ? config.recoveryValueFunc : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;
        var shortName = this.ruleShortNameIdx << keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX;
        this.ruleShortNameIdx++;
        this.shortRuleNameToFull[shortName] = ruleName;
        this.fullRuleNameToShort[ruleName] = shortName;
        var invokeRuleWithTry;
        if (this.outputCst === true) {
          invokeRuleWithTry = function invokeRuleWithTry2() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            try {
              this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
              impl.apply(this, args);
              var cst = this.CST_STACK[this.CST_STACK.length - 1];
              this.cstPostRule(cst);
              return cst;
            } catch (e) {
              return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
            } finally {
              this.ruleFinallyStateUpdate();
            }
          };
        } else {
          invokeRuleWithTry = function invokeRuleWithTryCst() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            try {
              this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
              return impl.apply(this, args);
            } catch (e) {
              return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
            } finally {
              this.ruleFinallyStateUpdate();
            }
          };
        }
        var wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });
        return wrappedGrammarRule;
      };
      RecognizerEngine2.prototype.invokeRuleCatch = function(e, resyncEnabledConfig, recoveryValueFunc) {
        var isFirstInvokedRule = this.RULE_STACK.length === 1;
        var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;
        if ((0, exceptions_public_1.isRecognitionException)(e)) {
          var recogError = e;
          if (reSyncEnabled) {
            var reSyncTokType = this.findReSyncTokenType();
            if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
              recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
              if (this.outputCst) {
                var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                partialCstResult.recoveredNode = true;
                return partialCstResult;
              } else {
                return recoveryValueFunc();
              }
            } else {
              if (this.outputCst) {
                var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                partialCstResult.recoveredNode = true;
                recogError.partialCstResult = partialCstResult;
              }
              throw recogError;
            }
          } else if (isFirstInvokedRule) {
            this.moveToTerminatedState();
            return recoveryValueFunc();
          } else {
            throw recogError;
          }
        } else {
          throw e;
        }
      };
      RecognizerEngine2.prototype.optionInternal = function(actionORMethodDef, occurrence) {
        var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);
        return this.optionInternalLogic(actionORMethodDef, occurrence, key);
      };
      RecognizerEngine2.prototype.optionInternalLogic = function(actionORMethodDef, occurrence, key) {
        var _this = this;
        var lookAheadFunc = this.getLaFuncFromCache(key);
        var action;
        if (typeof actionORMethodDef !== "function") {
          action = actionORMethodDef.DEF;
          var predicate_1 = actionORMethodDef.GATE;
          if (predicate_1 !== void 0) {
            var orgLookaheadFunction_1 = lookAheadFunc;
            lookAheadFunc = function() {
              return predicate_1.call(_this) && orgLookaheadFunction_1.call(_this);
            };
          }
        } else {
          action = actionORMethodDef;
        }
        if (lookAheadFunc.call(this) === true) {
          return action.call(this);
        }
        return void 0;
      };
      RecognizerEngine2.prototype.atLeastOneInternal = function(prodOccurrence, actionORMethodDef) {
        var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);
        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
      };
      RecognizerEngine2.prototype.atLeastOneInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
        var _this = this;
        var lookAheadFunc = this.getLaFuncFromCache(key);
        var action;
        if (typeof actionORMethodDef !== "function") {
          action = actionORMethodDef.DEF;
          var predicate_2 = actionORMethodDef.GATE;
          if (predicate_2 !== void 0) {
            var orgLookaheadFunction_2 = lookAheadFunc;
            lookAheadFunc = function() {
              return predicate_2.call(_this) && orgLookaheadFunction_2.call(_this);
            };
          }
        } else {
          action = actionORMethodDef;
        }
        if (lookAheadFunc.call(this) === true) {
          var notStuck = this.doSingleRepetition(action);
          while (lookAheadFunc.call(this) === true && notStuck === true) {
            notStuck = this.doSingleRepetition(action);
          }
        } else {
          throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
        }
        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);
      };
      RecognizerEngine2.prototype.atLeastOneSepFirstInternal = function(prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);
        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
      };
      RecognizerEngine2.prototype.atLeastOneSepFirstInternalLogic = function(prodOccurrence, options, key) {
        var _this = this;
        var action = options.DEF;
        var separator = options.SEP;
        var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
        if (firstIterationLookaheadFunc.call(this) === true) {
          ;
          action.call(this);
          var separatorLookAheadFunc = function() {
            return _this.tokenMatcher(_this.LA(1), separator);
          };
          while (this.tokenMatcher(this.LA(1), separator) === true) {
            this.CONSUME(separator);
            action.call(this);
          }
          this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
            prodOccurrence,
            separator,
            separatorLookAheadFunc,
            action,
            interpreter_1.NextTerminalAfterAtLeastOneSepWalker
          ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);
        } else {
          throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
        }
      };
      RecognizerEngine2.prototype.manyInternal = function(prodOccurrence, actionORMethodDef) {
        var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);
        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
      };
      RecognizerEngine2.prototype.manyInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
        var _this = this;
        var lookaheadFunction = this.getLaFuncFromCache(key);
        var action;
        if (typeof actionORMethodDef !== "function") {
          action = actionORMethodDef.DEF;
          var predicate_3 = actionORMethodDef.GATE;
          if (predicate_3 !== void 0) {
            var orgLookaheadFunction_3 = lookaheadFunction;
            lookaheadFunction = function() {
              return predicate_3.call(_this) && orgLookaheadFunction_3.call(_this);
            };
          }
        } else {
          action = actionORMethodDef;
        }
        var notStuck = true;
        while (lookaheadFunction.call(this) === true && notStuck === true) {
          notStuck = this.doSingleRepetition(action);
        }
        this.attemptInRepetitionRecovery(
          this.manyInternal,
          [prodOccurrence, actionORMethodDef],
          lookaheadFunction,
          keys_1.MANY_IDX,
          prodOccurrence,
          interpreter_1.NextTerminalAfterManyWalker,
          notStuck
        );
      };
      RecognizerEngine2.prototype.manySepFirstInternal = function(prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);
        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
      };
      RecognizerEngine2.prototype.manySepFirstInternalLogic = function(prodOccurrence, options, key) {
        var _this = this;
        var action = options.DEF;
        var separator = options.SEP;
        var firstIterationLaFunc = this.getLaFuncFromCache(key);
        if (firstIterationLaFunc.call(this) === true) {
          action.call(this);
          var separatorLookAheadFunc = function() {
            return _this.tokenMatcher(_this.LA(1), separator);
          };
          while (this.tokenMatcher(this.LA(1), separator) === true) {
            this.CONSUME(separator);
            action.call(this);
          }
          this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
            prodOccurrence,
            separator,
            separatorLookAheadFunc,
            action,
            interpreter_1.NextTerminalAfterManySepWalker
          ], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);
        }
      };
      RecognizerEngine2.prototype.repetitionSepSecondInternal = function(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
        while (separatorLookAheadFunc()) {
          this.CONSUME(separator);
          action.call(this);
        }
        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
          prodOccurrence,
          separator,
          separatorLookAheadFunc,
          action,
          nextTerminalAfterWalker
        ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);
      };
      RecognizerEngine2.prototype.doSingleRepetition = function(action) {
        var beforeIteration = this.getLexerPosition();
        action.call(this);
        var afterIteration = this.getLexerPosition();
        return afterIteration > beforeIteration;
      };
      RecognizerEngine2.prototype.orInternal = function(altsOrOpts, occurrence) {
        var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);
        var alts = (0, isArray_1.default)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;
        var laFunc = this.getLaFuncFromCache(laKey);
        var altIdxToTake = laFunc.call(this, alts);
        if (altIdxToTake !== void 0) {
          var chosenAlternative = alts[altIdxToTake];
          return chosenAlternative.ALT.call(this);
        }
        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
      };
      RecognizerEngine2.prototype.ruleFinallyStateUpdate = function() {
        this.RULE_STACK.pop();
        this.RULE_OCCURRENCE_STACK.pop();
        this.cstFinallyStateUpdate();
        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
          var firstRedundantTok = this.LA(1);
          var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
            firstRedundant: firstRedundantTok,
            ruleName: this.getCurrRuleFullName()
          });
          this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));
        }
      };
      RecognizerEngine2.prototype.subruleInternal = function(ruleToCall, idx, options) {
        var ruleResult;
        try {
          var args = options !== void 0 ? options.ARGS : void 0;
          this.subruleIdx = idx;
          ruleResult = ruleToCall.apply(this, args);
          this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);
          return ruleResult;
        } catch (e) {
          throw this.subruleInternalError(e, options, ruleToCall.ruleName);
        }
      };
      RecognizerEngine2.prototype.subruleInternalError = function(e, options, ruleName) {
        if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== void 0) {
          this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);
          delete e.partialCstResult;
        }
        throw e;
      };
      RecognizerEngine2.prototype.consumeInternal = function(tokType, idx, options) {
        var consumedToken;
        try {
          var nextToken = this.LA(1);
          if (this.tokenMatcher(nextToken, tokType) === true) {
            this.consumeToken();
            consumedToken = nextToken;
          } else {
            this.consumeInternalError(tokType, nextToken, options);
          }
        } catch (eFromConsumption) {
          consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
        }
        this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);
        return consumedToken;
      };
      RecognizerEngine2.prototype.consumeInternalError = function(tokType, nextToken, options) {
        var msg;
        var previousToken = this.LA(0);
        if (options !== void 0 && options.ERR_MSG) {
          msg = options.ERR_MSG;
        } else {
          msg = this.errorMessageProvider.buildMismatchTokenMessage({
            expected: tokType,
            actual: nextToken,
            previous: previousToken,
            ruleName: this.getCurrRuleFullName()
          });
        }
        throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));
      };
      RecognizerEngine2.prototype.consumeInternalRecovery = function(tokType, idx, eFromConsumption) {
        if (this.recoveryEnabled && eFromConsumption.name === "MismatchedTokenException" && !this.isBackTracking()) {
          var follows = this.getFollowsForInRuleRecovery(tokType, idx);
          try {
            return this.tryInRuleRecovery(tokType, follows);
          } catch (eFromInRuleRecovery) {
            if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {
              throw eFromConsumption;
            } else {
              throw eFromInRuleRecovery;
            }
          }
        } else {
          throw eFromConsumption;
        }
      };
      RecognizerEngine2.prototype.saveRecogState = function() {
        var savedErrors = this.errors;
        var savedRuleStack = (0, clone_1.default)(this.RULE_STACK);
        return {
          errors: savedErrors,
          lexerState: this.exportLexerState(),
          RULE_STACK: savedRuleStack,
          CST_STACK: this.CST_STACK
        };
      };
      RecognizerEngine2.prototype.reloadRecogState = function(newState) {
        this.errors = newState.errors;
        this.importLexerState(newState.lexerState);
        this.RULE_STACK = newState.RULE_STACK;
      };
      RecognizerEngine2.prototype.ruleInvocationStateUpdate = function(shortName, fullName, idxInCallingRule) {
        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
        this.RULE_STACK.push(shortName);
        this.cstInvocationStateUpdate(fullName);
      };
      RecognizerEngine2.prototype.isBackTracking = function() {
        return this.isBackTrackingStack.length !== 0;
      };
      RecognizerEngine2.prototype.getCurrRuleFullName = function() {
        var shortName = this.getLastExplicitRuleShortName();
        return this.shortRuleNameToFull[shortName];
      };
      RecognizerEngine2.prototype.shortRuleNameToFullName = function(shortName) {
        return this.shortRuleNameToFull[shortName];
      };
      RecognizerEngine2.prototype.isAtEndOfInput = function() {
        return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);
      };
      RecognizerEngine2.prototype.reset = function() {
        this.resetLexerState();
        this.subruleIdx = 0;
        this.isBackTrackingStack = [];
        this.errors = [];
        this.RULE_STACK = [];
        this.CST_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
      };
      return RecognizerEngine2;
    }();
    exports2.RecognizerEngine = RecognizerEngine;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js
var require_error_handler = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorHandler = void 0;
    var exceptions_public_1 = require_exceptions_public();
    var has_1 = __importDefault(require_has());
    var clone_1 = __importDefault(require_clone());
    var lookahead_1 = require_lookahead();
    var parser_1 = require_parser();
    var ErrorHandler = function() {
      function ErrorHandler2() {
      }
      ErrorHandler2.prototype.initErrorHandler = function(config) {
        this._errors = [];
        this.errorMessageProvider = (0, has_1.default)(config, "errorMessageProvider") ? config.errorMessageProvider : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;
      };
      ErrorHandler2.prototype.SAVE_ERROR = function(error) {
        if ((0, exceptions_public_1.isRecognitionException)(error)) {
          error.context = {
            ruleStack: this.getHumanReadableRuleStack(),
            ruleOccurrenceStack: (0, clone_1.default)(this.RULE_OCCURRENCE_STACK)
          };
          this._errors.push(error);
          return error;
        } else {
          throw Error("Trying to save an Error which is not a RecognitionException");
        }
      };
      Object.defineProperty(ErrorHandler2.prototype, "errors", {
        get: function() {
          return (0, clone_1.default)(this._errors);
        },
        set: function(newErrors) {
          this._errors = newErrors;
        },
        enumerable: false,
        configurable: true
      });
      ErrorHandler2.prototype.raiseEarlyExitException = function(occurrence, prodType, userDefinedErrMsg) {
        var ruleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[ruleName];
        var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);
        var insideProdPaths = lookAheadPathsPerAlternative[0];
        var actualTokens = [];
        for (var i2 = 1; i2 <= this.maxLookahead; i2++) {
          actualTokens.push(this.LA(i2));
        }
        var msg = this.errorMessageProvider.buildEarlyExitMessage({
          expectedIterationPaths: insideProdPaths,
          actual: actualTokens,
          previous: this.LA(0),
          customUserDescription: userDefinedErrMsg,
          ruleName
        });
        throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));
      };
      ErrorHandler2.prototype.raiseNoAltException = function(occurrence, errMsgTypes) {
        var ruleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[ruleName];
        var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);
        var actualTokens = [];
        for (var i2 = 1; i2 <= this.maxLookahead; i2++) {
          actualTokens.push(this.LA(i2));
        }
        var previousToken = this.LA(0);
        var errMsg = this.errorMessageProvider.buildNoViableAltMessage({
          expectedPathsPerAlt: lookAheadPathsPerAlternative,
          actual: actualTokens,
          previous: previousToken,
          customUserDescription: errMsgTypes,
          ruleName: this.getCurrRuleFullName()
        });
        throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));
      };
      return ErrorHandler2;
    }();
    exports2.ErrorHandler = ErrorHandler;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js
var require_context_assist = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContentAssist = void 0;
    var interpreter_1 = require_interpreter();
    var first_1 = __importDefault(require_first2());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var ContentAssist = function() {
      function ContentAssist2() {
      }
      ContentAssist2.prototype.initContentAssist = function() {
      };
      ContentAssist2.prototype.computeContentAssist = function(startRuleName, precedingInput) {
        var startRuleGast = this.gastProductionsCache[startRuleName];
        if ((0, isUndefined_1.default)(startRuleGast)) {
          throw Error("Rule ->".concat(startRuleName, "<- does not exist in this grammar."));
        }
        return (0, interpreter_1.nextPossibleTokensAfter)([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
      };
      ContentAssist2.prototype.getNextPossibleTokenTypes = function(grammarPath) {
        var topRuleName = (0, first_1.default)(grammarPath.ruleStack);
        var gastProductions = this.getGAstProductions();
        var topProduction = gastProductions[topRuleName];
        var nextPossibleTokenTypes = new interpreter_1.NextAfterTokenWalker(topProduction, grammarPath).startWalking();
        return nextPossibleTokenTypes;
      };
      return ContentAssist2;
    }();
    exports2.ContentAssist = ContentAssist;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js
var require_gast_recorder = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GastRecorder = void 0;
    var last_1 = __importDefault(require_last());
    var isArray_1 = __importDefault(require_isArray());
    var some_1 = __importDefault(require_some());
    var forEach_1 = __importDefault(require_forEach());
    var isFunction_1 = __importDefault(require_isFunction());
    var has_1 = __importDefault(require_has());
    var gast_1 = require_api2();
    var lexer_public_1 = require_lexer_public();
    var tokens_1 = require_tokens();
    var tokens_public_1 = require_tokens_public();
    var parser_1 = require_parser();
    var keys_1 = require_keys2();
    var RECORDING_NULL_OBJECT = {
      description: "This Object indicates the Parser is during Recording Phase"
    };
    Object.freeze(RECORDING_NULL_OBJECT);
    var HANDLE_SEPARATOR = true;
    var MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;
    var RFT = (0, tokens_public_1.createToken)({ name: "RECORDING_PHASE_TOKEN", pattern: lexer_public_1.Lexer.NA });
    (0, tokens_1.augmentTokenTypes)([RFT]);
    var RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(
      RFT,
      "This IToken indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
    );
    Object.freeze(RECORDING_PHASE_TOKEN);
    var RECORDING_PHASE_CSTNODE = {
      name: "This CSTNode indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
      children: {}
    };
    var GastRecorder = function() {
      function GastRecorder2() {
      }
      GastRecorder2.prototype.initGastRecorder = function(config) {
        this.recordingProdStack = [];
        this.RECORDING_PHASE = false;
      };
      GastRecorder2.prototype.enableRecording = function() {
        var _this = this;
        this.RECORDING_PHASE = true;
        this.TRACE_INIT("Enable Recording", function() {
          var _loop_1 = function(i3) {
            var idx = i3 > 0 ? i3 : "";
            _this["CONSUME".concat(idx)] = function(arg1, arg2) {
              return this.consumeInternalRecord(arg1, i3, arg2);
            };
            _this["SUBRULE".concat(idx)] = function(arg1, arg2) {
              return this.subruleInternalRecord(arg1, i3, arg2);
            };
            _this["OPTION".concat(idx)] = function(arg1) {
              return this.optionInternalRecord(arg1, i3);
            };
            _this["OR".concat(idx)] = function(arg1) {
              return this.orInternalRecord(arg1, i3);
            };
            _this["MANY".concat(idx)] = function(arg1) {
              this.manyInternalRecord(i3, arg1);
            };
            _this["MANY_SEP".concat(idx)] = function(arg1) {
              this.manySepFirstInternalRecord(i3, arg1);
            };
            _this["AT_LEAST_ONE".concat(idx)] = function(arg1) {
              this.atLeastOneInternalRecord(i3, arg1);
            };
            _this["AT_LEAST_ONE_SEP".concat(idx)] = function(arg1) {
              this.atLeastOneSepFirstInternalRecord(i3, arg1);
            };
          };
          for (var i2 = 0; i2 < 10; i2++) {
            _loop_1(i2);
          }
          _this["consume"] = function(idx, arg1, arg2) {
            return this.consumeInternalRecord(arg1, idx, arg2);
          };
          _this["subrule"] = function(idx, arg1, arg2) {
            return this.subruleInternalRecord(arg1, idx, arg2);
          };
          _this["option"] = function(idx, arg1) {
            return this.optionInternalRecord(arg1, idx);
          };
          _this["or"] = function(idx, arg1) {
            return this.orInternalRecord(arg1, idx);
          };
          _this["many"] = function(idx, arg1) {
            this.manyInternalRecord(idx, arg1);
          };
          _this["atLeastOne"] = function(idx, arg1) {
            this.atLeastOneInternalRecord(idx, arg1);
          };
          _this.ACTION = _this.ACTION_RECORD;
          _this.BACKTRACK = _this.BACKTRACK_RECORD;
          _this.LA = _this.LA_RECORD;
        });
      };
      GastRecorder2.prototype.disableRecording = function() {
        var _this = this;
        this.RECORDING_PHASE = false;
        this.TRACE_INIT("Deleting Recording methods", function() {
          var that = _this;
          for (var i2 = 0; i2 < 10; i2++) {
            var idx = i2 > 0 ? i2 : "";
            delete that["CONSUME".concat(idx)];
            delete that["SUBRULE".concat(idx)];
            delete that["OPTION".concat(idx)];
            delete that["OR".concat(idx)];
            delete that["MANY".concat(idx)];
            delete that["MANY_SEP".concat(idx)];
            delete that["AT_LEAST_ONE".concat(idx)];
            delete that["AT_LEAST_ONE_SEP".concat(idx)];
          }
          delete that["consume"];
          delete that["subrule"];
          delete that["option"];
          delete that["or"];
          delete that["many"];
          delete that["atLeastOne"];
          delete that.ACTION;
          delete that.BACKTRACK;
          delete that.LA;
        });
      };
      GastRecorder2.prototype.ACTION_RECORD = function(impl) {
      };
      GastRecorder2.prototype.BACKTRACK_RECORD = function(grammarRule, args) {
        return function() {
          return true;
        };
      };
      GastRecorder2.prototype.LA_RECORD = function(howMuch) {
        return parser_1.END_OF_FILE;
      };
      GastRecorder2.prototype.topLevelRuleRecord = function(name, def) {
        try {
          var newTopLevelRule = new gast_1.Rule({ definition: [], name });
          newTopLevelRule.name = name;
          this.recordingProdStack.push(newTopLevelRule);
          def.call(this);
          this.recordingProdStack.pop();
          return newTopLevelRule;
        } catch (originalError) {
          if (originalError.KNOWN_RECORDER_ERROR !== true) {
            try {
              originalError.message = originalError.message + '\n	 This error was thrown during the "grammar recording phase" For more info see:\n	https://chevrotain.io/docs/guide/internals.html#grammar-recording';
            } catch (mutabilityError) {
              throw originalError;
            }
          }
          throw originalError;
        }
      };
      GastRecorder2.prototype.optionInternalRecord = function(actionORMethodDef, occurrence) {
        return recordProd.call(this, gast_1.Option, actionORMethodDef, occurrence);
      };
      GastRecorder2.prototype.atLeastOneInternalRecord = function(occurrence, actionORMethodDef) {
        recordProd.call(this, gast_1.RepetitionMandatory, actionORMethodDef, occurrence);
      };
      GastRecorder2.prototype.atLeastOneSepFirstInternalRecord = function(occurrence, options) {
        recordProd.call(this, gast_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);
      };
      GastRecorder2.prototype.manyInternalRecord = function(occurrence, actionORMethodDef) {
        recordProd.call(this, gast_1.Repetition, actionORMethodDef, occurrence);
      };
      GastRecorder2.prototype.manySepFirstInternalRecord = function(occurrence, options) {
        recordProd.call(this, gast_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);
      };
      GastRecorder2.prototype.orInternalRecord = function(altsOrOpts, occurrence) {
        return recordOrProd.call(this, altsOrOpts, occurrence);
      };
      GastRecorder2.prototype.subruleInternalRecord = function(ruleToCall, occurrence, options) {
        assertMethodIdxIsValid(occurrence);
        if (!ruleToCall || (0, has_1.default)(ruleToCall, "ruleName") === false) {
          var error = new Error("<SUBRULE".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a Parser method reference but got: <".concat(JSON.stringify(ruleToCall), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
          error.KNOWN_RECORDER_ERROR = true;
          throw error;
        }
        var prevProd = (0, last_1.default)(this.recordingProdStack);
        var ruleName = ruleToCall.ruleName;
        var newNoneTerminal = new gast_1.NonTerminal({
          idx: occurrence,
          nonTerminalName: ruleName,
          label: options === null || options === void 0 ? void 0 : options.LABEL,
          referencedRule: void 0
        });
        prevProd.definition.push(newNoneTerminal);
        return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;
      };
      GastRecorder2.prototype.consumeInternalRecord = function(tokType, occurrence, options) {
        assertMethodIdxIsValid(occurrence);
        if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {
          var error = new Error("<CONSUME".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a TokenType reference but got: <".concat(JSON.stringify(tokType), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
          error.KNOWN_RECORDER_ERROR = true;
          throw error;
        }
        var prevProd = (0, last_1.default)(this.recordingProdStack);
        var newNoneTerminal = new gast_1.Terminal({
          idx: occurrence,
          terminalType: tokType,
          label: options === null || options === void 0 ? void 0 : options.LABEL
        });
        prevProd.definition.push(newNoneTerminal);
        return RECORDING_PHASE_TOKEN;
      };
      return GastRecorder2;
    }();
    exports2.GastRecorder = GastRecorder;
    function recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {
      if (handleSep === void 0) {
        handleSep = false;
      }
      assertMethodIdxIsValid(occurrence);
      var prevProd = (0, last_1.default)(this.recordingProdStack);
      var grammarAction = (0, isFunction_1.default)(mainProdArg) ? mainProdArg : mainProdArg.DEF;
      var newProd = new prodConstructor({ definition: [], idx: occurrence });
      if (handleSep) {
        newProd.separator = mainProdArg.SEP;
      }
      if ((0, has_1.default)(mainProdArg, "MAX_LOOKAHEAD")) {
        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
      }
      this.recordingProdStack.push(newProd);
      grammarAction.call(this);
      prevProd.definition.push(newProd);
      this.recordingProdStack.pop();
      return RECORDING_NULL_OBJECT;
    }
    function recordOrProd(mainProdArg, occurrence) {
      var _this = this;
      assertMethodIdxIsValid(occurrence);
      var prevProd = (0, last_1.default)(this.recordingProdStack);
      var hasOptions = (0, isArray_1.default)(mainProdArg) === false;
      var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
      var newOrProd = new gast_1.Alternation({
        definition: [],
        idx: occurrence,
        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
      });
      if ((0, has_1.default)(mainProdArg, "MAX_LOOKAHEAD")) {
        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
      }
      var hasPredicates = (0, some_1.default)(alts, function(currAlt) {
        return (0, isFunction_1.default)(currAlt.GATE);
      });
      newOrProd.hasPredicates = hasPredicates;
      prevProd.definition.push(newOrProd);
      (0, forEach_1.default)(alts, function(currAlt) {
        var currAltFlat = new gast_1.Alternative({ definition: [] });
        newOrProd.definition.push(currAltFlat);
        if ((0, has_1.default)(currAlt, "IGNORE_AMBIGUITIES")) {
          currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;
        } else if ((0, has_1.default)(currAlt, "GATE")) {
          currAltFlat.ignoreAmbiguities = true;
        }
        _this.recordingProdStack.push(currAltFlat);
        currAlt.ALT.call(_this);
        _this.recordingProdStack.pop();
      });
      return RECORDING_NULL_OBJECT;
    }
    function getIdxSuffix(idx) {
      return idx === 0 ? "" : "".concat(idx);
    }
    function assertMethodIdxIsValid(idx) {
      if (idx < 0 || idx > MAX_METHOD_IDX) {
        var error = new Error(
          "Invalid DSL Method idx value: <".concat(idx, ">\n	") + "Idx value must be a none negative value smaller than ".concat(MAX_METHOD_IDX + 1)
        );
        error.KNOWN_RECORDER_ERROR = true;
        throw error;
      }
    }
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js
var require_perf_tracer = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PerformanceTracer = void 0;
    var has_1 = __importDefault(require_has());
    var utils_1 = require_api();
    var parser_1 = require_parser();
    var PerformanceTracer = function() {
      function PerformanceTracer2() {
      }
      PerformanceTracer2.prototype.initPerformanceTracer = function(config) {
        if ((0, has_1.default)(config, "traceInitPerf")) {
          var userTraceInitPerf = config.traceInitPerf;
          var traceIsNumber = typeof userTraceInitPerf === "number";
          this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;
          this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;
        } else {
          this.traceInitMaxIdent = 0;
          this.traceInitPerf = parser_1.DEFAULT_PARSER_CONFIG.traceInitPerf;
        }
        this.traceInitIndent = -1;
      };
      PerformanceTracer2.prototype.TRACE_INIT = function(phaseDesc, phaseImpl) {
        if (this.traceInitPerf === true) {
          this.traceInitIndent++;
          var indent = new Array(this.traceInitIndent + 1).join("	");
          if (this.traceInitIndent < this.traceInitMaxIdent) {
            console.log("".concat(indent, "--> <").concat(phaseDesc, ">"));
          }
          var _a2 = (0, utils_1.timer)(phaseImpl), time = _a2.time, value = _a2.value;
          var traceMethod = time > 10 ? console.warn : console.log;
          if (this.traceInitIndent < this.traceInitMaxIdent) {
            traceMethod("".concat(indent, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
          }
          this.traceInitIndent--;
          return value;
        } else {
          return phaseImpl();
        }
      };
      return PerformanceTracer2;
    }();
    exports2.PerformanceTracer = PerformanceTracer;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js
var require_apply_mixins = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.applyMixins = void 0;
    function applyMixins(derivedCtor, baseCtors) {
      baseCtors.forEach(function(baseCtor) {
        var baseProto = baseCtor.prototype;
        Object.getOwnPropertyNames(baseProto).forEach(function(propName) {
          if (propName === "constructor") {
            return;
          }
          var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
          if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {
            Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
          } else {
            derivedCtor.prototype[propName] = baseCtor.prototype[propName];
          }
        });
      });
    }
    exports2.applyMixins = applyMixins;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/parser.js
var require_parser = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/parser.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b5) {
          d2.__proto__ = b5;
        } || function(d2, b5) {
          for (var p in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p))
              d2[p] = b5[p];
        };
        return extendStatics(d, b3);
      };
      return function(d, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d, b3);
        function __() {
          this.constructor = d;
        }
        d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmbeddedActionsParser = exports2.CstParser = exports2.Parser = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.DEFAULT_RULE_CONFIG = exports2.DEFAULT_PARSER_CONFIG = exports2.END_OF_FILE = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var values_1 = __importDefault(require_values());
    var has_1 = __importDefault(require_has());
    var clone_1 = __importDefault(require_clone());
    var utils_1 = require_api();
    var follow_1 = require_follow();
    var tokens_public_1 = require_tokens_public();
    var errors_public_1 = require_errors_public();
    var gast_resolver_public_1 = require_gast_resolver_public();
    var recoverable_1 = require_recoverable();
    var looksahead_1 = require_looksahead();
    var tree_builder_1 = require_tree_builder();
    var lexer_adapter_1 = require_lexer_adapter();
    var recognizer_api_1 = require_recognizer_api();
    var recognizer_engine_1 = require_recognizer_engine();
    var error_handler_1 = require_error_handler();
    var context_assist_1 = require_context_assist();
    var gast_recorder_1 = require_gast_recorder();
    var perf_tracer_1 = require_perf_tracer();
    var apply_mixins_1 = require_apply_mixins();
    exports2.END_OF_FILE = (0, tokens_public_1.createTokenInstance)(tokens_public_1.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
    Object.freeze(exports2.END_OF_FILE);
    exports2.DEFAULT_PARSER_CONFIG = Object.freeze({
      recoveryEnabled: false,
      maxLookahead: 3,
      dynamicTokensEnabled: false,
      outputCst: true,
      errorMessageProvider: errors_public_1.defaultParserErrorProvider,
      nodeLocationTracking: "none",
      traceInitPerf: false,
      skipValidations: false
    });
    exports2.DEFAULT_RULE_CONFIG = Object.freeze({
      recoveryValueFunc: function() {
        return void 0;
      },
      resyncEnabled: true
    });
    var ParserDefinitionErrorType2;
    (function(ParserDefinitionErrorType3) {
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["NO_NON_EMPTY_LOOKAHEAD"] = 10] = "NO_NON_EMPTY_LOOKAHEAD";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["AMBIGUOUS_PREFIX_ALTS"] = 11] = "AMBIGUOUS_PREFIX_ALTS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["TOO_MANY_ALTS"] = 12] = "TOO_MANY_ALTS";
    })(ParserDefinitionErrorType2 = exports2.ParserDefinitionErrorType || (exports2.ParserDefinitionErrorType = {}));
    function EMPTY_ALT2(value) {
      if (value === void 0) {
        value = void 0;
      }
      return function() {
        return value;
      };
    }
    exports2.EMPTY_ALT = EMPTY_ALT2;
    var Parser4 = function() {
      function Parser5(tokenVocabulary, config) {
        this.definitionErrors = [];
        this.selfAnalysisDone = false;
        var that = this;
        that.initErrorHandler(config);
        that.initLexerAdapter();
        that.initLooksAhead(config);
        that.initRecognizerEngine(tokenVocabulary, config);
        that.initRecoverable(config);
        that.initTreeBuilder(config);
        that.initContentAssist();
        that.initGastRecorder(config);
        that.initPerformanceTracer(config);
        if ((0, has_1.default)(config, "ignoredIssues")) {
          throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\n	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n	For further details.");
        }
        this.skipValidations = (0, has_1.default)(config, "skipValidations") ? config.skipValidations : exports2.DEFAULT_PARSER_CONFIG.skipValidations;
      }
      Parser5.performSelfAnalysis = function(parserInstance) {
        throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
      };
      Parser5.prototype.performSelfAnalysis = function() {
        var _this = this;
        this.TRACE_INIT("performSelfAnalysis", function() {
          var defErrorsMsgs;
          _this.selfAnalysisDone = true;
          var className = _this.className;
          _this.TRACE_INIT("toFastProps", function() {
            (0, utils_1.toFastProperties)(_this);
          });
          _this.TRACE_INIT("Grammar Recording", function() {
            try {
              _this.enableRecording();
              (0, forEach_1.default)(_this.definedRulesNames, function(currRuleName) {
                var wrappedRule = _this[currRuleName];
                var originalGrammarAction = wrappedRule["originalGrammarAction"];
                var recordedRuleGast;
                _this.TRACE_INIT("".concat(currRuleName, " Rule"), function() {
                  recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);
                });
                _this.gastProductionsCache[currRuleName] = recordedRuleGast;
              });
            } finally {
              _this.disableRecording();
            }
          });
          var resolverErrors = [];
          _this.TRACE_INIT("Grammar Resolving", function() {
            resolverErrors = (0, gast_resolver_public_1.resolveGrammar)({
              rules: (0, values_1.default)(_this.gastProductionsCache)
            });
            _this.definitionErrors = _this.definitionErrors.concat(resolverErrors);
          });
          _this.TRACE_INIT("Grammar Validations", function() {
            if ((0, isEmpty_1.default)(resolverErrors) && _this.skipValidations === false) {
              var validationErrors = (0, gast_resolver_public_1.validateGrammar)({
                rules: (0, values_1.default)(_this.gastProductionsCache),
                maxLookahead: _this.maxLookahead,
                tokenTypes: (0, values_1.default)(_this.tokensMap),
                errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider,
                grammarName: className
              });
              _this.definitionErrors = _this.definitionErrors.concat(validationErrors);
            }
          });
          if ((0, isEmpty_1.default)(_this.definitionErrors)) {
            if (_this.recoveryEnabled) {
              _this.TRACE_INIT("computeAllProdsFollows", function() {
                var allFollows = (0, follow_1.computeAllProdsFollows)((0, values_1.default)(_this.gastProductionsCache));
                _this.resyncFollows = allFollows;
              });
            }
            _this.TRACE_INIT("ComputeLookaheadFunctions", function() {
              _this.preComputeLookaheadFunctions((0, values_1.default)(_this.gastProductionsCache));
            });
          }
          if (!Parser5.DEFER_DEFINITION_ERRORS_HANDLING && !(0, isEmpty_1.default)(_this.definitionErrors)) {
            defErrorsMsgs = (0, map_1.default)(_this.definitionErrors, function(defError) {
              return defError.message;
            });
            throw new Error("Parser Definition Errors detected:\n ".concat(defErrorsMsgs.join("\n-------------------------------\n")));
          }
        });
      };
      Parser5.DEFER_DEFINITION_ERRORS_HANDLING = false;
      return Parser5;
    }();
    exports2.Parser = Parser4;
    (0, apply_mixins_1.applyMixins)(Parser4, [
      recoverable_1.Recoverable,
      looksahead_1.LooksAhead,
      tree_builder_1.TreeBuilder,
      lexer_adapter_1.LexerAdapter,
      recognizer_engine_1.RecognizerEngine,
      recognizer_api_1.RecognizerApi,
      error_handler_1.ErrorHandler,
      context_assist_1.ContentAssist,
      gast_recorder_1.GastRecorder,
      perf_tracer_1.PerformanceTracer
    ]);
    var CstParser2 = function(_super) {
      __extends(CstParser3, _super);
      function CstParser3(tokenVocabulary, config) {
        if (config === void 0) {
          config = exports2.DEFAULT_PARSER_CONFIG;
        }
        var configClone = (0, clone_1.default)(config);
        configClone.outputCst = true;
        return _super.call(this, tokenVocabulary, configClone) || this;
      }
      return CstParser3;
    }(Parser4);
    exports2.CstParser = CstParser2;
    var EmbeddedActionsParser2 = function(_super) {
      __extends(EmbeddedActionsParser3, _super);
      function EmbeddedActionsParser3(tokenVocabulary, config) {
        if (config === void 0) {
          config = exports2.DEFAULT_PARSER_CONFIG;
        }
        var configClone = (0, clone_1.default)(config);
        configClone.outputCst = false;
        return _super.call(this, tokenVocabulary, configClone) || this;
      }
      return EmbeddedActionsParser3;
    }(Parser4);
    exports2.EmbeddedActionsParser = EmbeddedActionsParser2;
  }
});

// node_modules/@chevrotain/cst-dts-gen/lib/src/model.js
var require_model2 = __commonJS({
  "node_modules/@chevrotain/cst-dts-gen/lib/src/model.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b5) {
          d2.__proto__ = b5;
        } || function(d2, b5) {
          for (var p in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p))
              d2[p] = b5[p];
        };
        return extendStatics(d, b3);
      };
      return function(d, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d, b3);
        function __() {
          this.constructor = d;
        }
        d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildModel = void 0;
    var gast_1 = require_api2();
    var map_1 = __importDefault(require_map());
    var flatten_1 = __importDefault(require_flatten());
    var values_1 = __importDefault(require_values());
    var some_1 = __importDefault(require_some());
    var groupBy_1 = __importDefault(require_groupBy());
    var assign_1 = __importDefault(require_assign());
    function buildModel(productions) {
      var generator = new CstNodeDefinitionGenerator();
      var allRules = (0, values_1.default)(productions);
      return (0, map_1.default)(allRules, function(rule) {
        return generator.visitRule(rule);
      });
    }
    exports2.buildModel = buildModel;
    var CstNodeDefinitionGenerator = function(_super) {
      __extends(CstNodeDefinitionGenerator2, _super);
      function CstNodeDefinitionGenerator2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CstNodeDefinitionGenerator2.prototype.visitRule = function(node) {
        var rawElements = this.visitEach(node.definition);
        var grouped = (0, groupBy_1.default)(rawElements, function(el) {
          return el.propertyName;
        });
        var properties = (0, map_1.default)(grouped, function(group, propertyName) {
          var allNullable = !(0, some_1.default)(group, function(el) {
            return !el.canBeNull;
          });
          var propertyType = group[0].type;
          if (group.length > 1) {
            propertyType = (0, map_1.default)(group, function(g2) {
              return g2.type;
            });
          }
          return {
            name: propertyName,
            type: propertyType,
            optional: allNullable
          };
        });
        return {
          name: node.name,
          properties
        };
      };
      CstNodeDefinitionGenerator2.prototype.visitAlternative = function(node) {
        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
      };
      CstNodeDefinitionGenerator2.prototype.visitOption = function(node) {
        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
      };
      CstNodeDefinitionGenerator2.prototype.visitRepetition = function(node) {
        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
      };
      CstNodeDefinitionGenerator2.prototype.visitRepetitionMandatory = function(node) {
        return this.visitEach(node.definition);
      };
      CstNodeDefinitionGenerator2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
        return this.visitEach(node.definition).concat({
          propertyName: node.separator.name,
          canBeNull: true,
          type: getType(node.separator)
        });
      };
      CstNodeDefinitionGenerator2.prototype.visitRepetitionWithSeparator = function(node) {
        return this.visitEachAndOverrideWith(node.definition, {
          canBeNull: true
        }).concat({
          propertyName: node.separator.name,
          canBeNull: true,
          type: getType(node.separator)
        });
      };
      CstNodeDefinitionGenerator2.prototype.visitAlternation = function(node) {
        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
      };
      CstNodeDefinitionGenerator2.prototype.visitTerminal = function(node) {
        return [
          {
            propertyName: node.label || node.terminalType.name,
            canBeNull: false,
            type: getType(node)
          }
        ];
      };
      CstNodeDefinitionGenerator2.prototype.visitNonTerminal = function(node) {
        return [
          {
            propertyName: node.label || node.nonTerminalName,
            canBeNull: false,
            type: getType(node)
          }
        ];
      };
      CstNodeDefinitionGenerator2.prototype.visitEachAndOverrideWith = function(definition, override) {
        return (0, map_1.default)(this.visitEach(definition), function(definition2) {
          return (0, assign_1.default)({}, definition2, override);
        });
      };
      CstNodeDefinitionGenerator2.prototype.visitEach = function(definition) {
        var _this = this;
        return (0, flatten_1.default)((0, map_1.default)(definition, function(definition2) {
          return _this.visit(definition2);
        }));
      };
      return CstNodeDefinitionGenerator2;
    }(gast_1.GAstVisitor);
    function getType(production) {
      if (production instanceof gast_1.NonTerminal) {
        return {
          kind: "rule",
          name: production.referencedRule.name
        };
      }
      return { kind: "token" };
    }
  }
});

// node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "node_modules/lodash/_castSlice.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    function castSlice(array, start, end) {
      var length2 = array.length;
      end = end === void 0 ? length2 : end;
      return !start && end >= length2 ? array : baseSlice(array, start, end);
    }
    module2.exports = castSlice;
  }
});

// node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "node_modules/lodash/_hasUnicode.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    module2.exports = hasUnicode;
  }
});

// node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "node_modules/lodash/_asciiToArray.js"(exports2, module2) {
    function asciiToArray(string) {
      return string.split("");
    }
    module2.exports = asciiToArray;
  }
});

// node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "node_modules/lodash/_unicodeToArray.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    module2.exports = unicodeToArray;
  }
});

// node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "node_modules/lodash/_stringToArray.js"(exports2, module2) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    module2.exports = stringToArray;
  }
});

// node_modules/lodash/_createCaseFirst.js
var require_createCaseFirst = __commonJS({
  "node_modules/lodash/_createCaseFirst.js"(exports2, module2) {
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString = require_toString();
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module2.exports = createCaseFirst;
  }
});

// node_modules/lodash/upperFirst.js
var require_upperFirst = __commonJS({
  "node_modules/lodash/upperFirst.js"(exports2, module2) {
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module2.exports = upperFirst;
  }
});

// node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js
var require_generate = __commonJS({
  "node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.genDts = void 0;
    var flatten_1 = __importDefault(require_flatten());
    var isArray_1 = __importDefault(require_isArray());
    var map_1 = __importDefault(require_map());
    var reduce_1 = __importDefault(require_reduce());
    var uniq_1 = __importDefault(require_uniq());
    var upperFirst_1 = __importDefault(require_upperFirst());
    function genDts(model, options) {
      var contentParts = [];
      contentParts = contentParts.concat('import type { CstNode, ICstVisitor, IToken } from "chevrotain";');
      contentParts = contentParts.concat((0, flatten_1.default)((0, map_1.default)(model, function(node) {
        return genCstNodeTypes(node);
      })));
      if (options.includeVisitorInterface) {
        contentParts = contentParts.concat(genVisitor(options.visitorInterfaceName, model));
      }
      return contentParts.join("\n\n") + "\n";
    }
    exports2.genDts = genDts;
    function genCstNodeTypes(node) {
      var nodeCstInterface = genNodeInterface(node);
      var nodeChildrenInterface = genNodeChildrenType(node);
      return [nodeCstInterface, nodeChildrenInterface];
    }
    function genNodeInterface(node) {
      var nodeInterfaceName = getNodeInterfaceName(node.name);
      var childrenTypeName = getNodeChildrenTypeName(node.name);
      return "export interface ".concat(nodeInterfaceName, ' extends CstNode {\n  name: "').concat(node.name, '";\n  children: ').concat(childrenTypeName, ";\n}");
    }
    function genNodeChildrenType(node) {
      var typeName = getNodeChildrenTypeName(node.name);
      return "export type ".concat(typeName, " = {\n  ").concat((0, map_1.default)(node.properties, function(property) {
        return genChildProperty(property);
      }).join("\n  "), "\n};");
    }
    function genChildProperty(prop) {
      var typeName = buildTypeString(prop.type);
      return "".concat(prop.name).concat(prop.optional ? "?" : "", ": ").concat(typeName, "[];");
    }
    function genVisitor(name, nodes) {
      return "export interface ".concat(name, "<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ").concat((0, map_1.default)(nodes, function(node) {
        return genVisitorFunction(node);
      }).join("\n  "), "\n}");
    }
    function genVisitorFunction(node) {
      var childrenTypeName = getNodeChildrenTypeName(node.name);
      return "".concat(node.name, "(children: ").concat(childrenTypeName, ", param?: IN): OUT;");
    }
    function buildTypeString(type2) {
      if ((0, isArray_1.default)(type2)) {
        var typeNames = (0, uniq_1.default)((0, map_1.default)(type2, function(t2) {
          return getTypeString(t2);
        }));
        var typeString = (0, reduce_1.default)(typeNames, function(sum, t2) {
          return sum + " | " + t2;
        });
        return "(" + typeString + ")";
      } else {
        return getTypeString(type2);
      }
    }
    function getTypeString(type2) {
      if (type2.kind === "token") {
        return "IToken";
      }
      return getNodeInterfaceName(type2.name);
    }
    function getNodeInterfaceName(ruleName) {
      return (0, upperFirst_1.default)(ruleName) + "CstNode";
    }
    function getNodeChildrenTypeName(ruleName) {
      return (0, upperFirst_1.default)(ruleName) + "CstChildren";
    }
  }
});

// node_modules/@chevrotain/cst-dts-gen/lib/src/api.js
var require_api3 = __commonJS({
  "node_modules/@chevrotain/cst-dts-gen/lib/src/api.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s = arguments[i2];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t2[p] = s[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateCstDts = void 0;
    var model_1 = require_model2();
    var generate_1 = require_generate();
    var defaultOptions = {
      includeVisitorInterface: true,
      visitorInterfaceName: "ICstNodeVisitor"
    };
    function generateCstDts2(productions, options) {
      var effectiveOptions = __assign(__assign({}, defaultOptions), options);
      var model = (0, model_1.buildModel)(productions);
      return (0, generate_1.genDts)(model, effectiveOptions);
    }
    exports2.generateCstDts = generateCstDts2;
  }
});

// node_modules/chevrotain/lib/src/diagrams/render_public.js
var require_render_public = __commonJS({
  "node_modules/chevrotain/lib/src/diagrams/render_public.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createSyntaxDiagramsCode = void 0;
    var version_1 = require_version();
    function createSyntaxDiagramsCode2(grammar, _a2) {
      var _b2 = _a2 === void 0 ? {} : _a2, _c = _b2.resourceBase, resourceBase = _c === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/") : _c, _d = _b2.css, css = _d === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/diagrams.css") : _d;
      var header = '\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset="utf-8">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n';
      var cssHtml = "\n<link rel='stylesheet' href='".concat(css, "'>\n");
      var scripts = "\n<script src='".concat(resourceBase, "vendor/railroad-diagrams.js'><\/script>\n<script src='").concat(resourceBase, "src/diagrams_builder.js'><\/script>\n<script src='").concat(resourceBase, "src/diagrams_behavior.js'><\/script>\n<script src='").concat(resourceBase, "src/main.js'><\/script>\n");
      var diagramsDiv = '\n<div id="diagrams" align="center"></div>    \n';
      var serializedGrammar = "\n<script>\n    window.serializedGrammar = ".concat(JSON.stringify(grammar, null, "  "), ";\n<\/script>\n");
      var initLogic = '\n<script>\n    var diagramsDiv = document.getElementById("diagrams");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n<\/script>\n';
      return header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic;
    }
    exports2.createSyntaxDiagramsCode = createSyntaxDiagramsCode2;
  }
});

// node_modules/chevrotain/lib/src/api.js
var require_api4 = __commonJS({
  "node_modules/chevrotain/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Parser = exports2.createSyntaxDiagramsCode = exports2.clearCache = exports2.generateCstDts = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Rule = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Alternative = exports2.Alternation = exports2.defaultLexerErrorProvider = exports2.NoViableAltException = exports2.NotAllInputParsedException = exports2.MismatchedTokenException = exports2.isRecognitionException = exports2.EarlyExitException = exports2.defaultParserErrorProvider = exports2.tokenName = exports2.tokenMatcher = exports2.tokenLabel = exports2.EOF = exports2.createTokenInstance = exports2.createToken = exports2.LexerDefinitionErrorType = exports2.Lexer = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.EmbeddedActionsParser = exports2.CstParser = exports2.VERSION = void 0;
    var version_1 = require_version();
    Object.defineProperty(exports2, "VERSION", { enumerable: true, get: function() {
      return version_1.VERSION;
    } });
    var parser_1 = require_parser();
    Object.defineProperty(exports2, "CstParser", { enumerable: true, get: function() {
      return parser_1.CstParser;
    } });
    Object.defineProperty(exports2, "EmbeddedActionsParser", { enumerable: true, get: function() {
      return parser_1.EmbeddedActionsParser;
    } });
    Object.defineProperty(exports2, "ParserDefinitionErrorType", { enumerable: true, get: function() {
      return parser_1.ParserDefinitionErrorType;
    } });
    Object.defineProperty(exports2, "EMPTY_ALT", { enumerable: true, get: function() {
      return parser_1.EMPTY_ALT;
    } });
    var lexer_public_1 = require_lexer_public();
    Object.defineProperty(exports2, "Lexer", { enumerable: true, get: function() {
      return lexer_public_1.Lexer;
    } });
    Object.defineProperty(exports2, "LexerDefinitionErrorType", { enumerable: true, get: function() {
      return lexer_public_1.LexerDefinitionErrorType;
    } });
    var tokens_public_1 = require_tokens_public();
    Object.defineProperty(exports2, "createToken", { enumerable: true, get: function() {
      return tokens_public_1.createToken;
    } });
    Object.defineProperty(exports2, "createTokenInstance", { enumerable: true, get: function() {
      return tokens_public_1.createTokenInstance;
    } });
    Object.defineProperty(exports2, "EOF", { enumerable: true, get: function() {
      return tokens_public_1.EOF;
    } });
    Object.defineProperty(exports2, "tokenLabel", { enumerable: true, get: function() {
      return tokens_public_1.tokenLabel;
    } });
    Object.defineProperty(exports2, "tokenMatcher", { enumerable: true, get: function() {
      return tokens_public_1.tokenMatcher;
    } });
    Object.defineProperty(exports2, "tokenName", { enumerable: true, get: function() {
      return tokens_public_1.tokenName;
    } });
    var errors_public_1 = require_errors_public();
    Object.defineProperty(exports2, "defaultParserErrorProvider", { enumerable: true, get: function() {
      return errors_public_1.defaultParserErrorProvider;
    } });
    var exceptions_public_1 = require_exceptions_public();
    Object.defineProperty(exports2, "EarlyExitException", { enumerable: true, get: function() {
      return exceptions_public_1.EarlyExitException;
    } });
    Object.defineProperty(exports2, "isRecognitionException", { enumerable: true, get: function() {
      return exceptions_public_1.isRecognitionException;
    } });
    Object.defineProperty(exports2, "MismatchedTokenException", { enumerable: true, get: function() {
      return exceptions_public_1.MismatchedTokenException;
    } });
    Object.defineProperty(exports2, "NotAllInputParsedException", { enumerable: true, get: function() {
      return exceptions_public_1.NotAllInputParsedException;
    } });
    Object.defineProperty(exports2, "NoViableAltException", { enumerable: true, get: function() {
      return exceptions_public_1.NoViableAltException;
    } });
    var lexer_errors_public_1 = require_lexer_errors_public();
    Object.defineProperty(exports2, "defaultLexerErrorProvider", { enumerable: true, get: function() {
      return lexer_errors_public_1.defaultLexerErrorProvider;
    } });
    var gast_1 = require_api2();
    Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
      return gast_1.Alternation;
    } });
    Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
      return gast_1.Alternative;
    } });
    Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
      return gast_1.NonTerminal;
    } });
    Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
      return gast_1.Option;
    } });
    Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
      return gast_1.Repetition;
    } });
    Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
      return gast_1.RepetitionMandatory;
    } });
    Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
      return gast_1.RepetitionMandatoryWithSeparator;
    } });
    Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
      return gast_1.RepetitionWithSeparator;
    } });
    Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
      return gast_1.Rule;
    } });
    Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
      return gast_1.Terminal;
    } });
    var gast_2 = require_api2();
    Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
      return gast_2.serializeGrammar;
    } });
    Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
      return gast_2.serializeProduction;
    } });
    Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
      return gast_2.GAstVisitor;
    } });
    var cst_dts_gen_1 = require_api3();
    Object.defineProperty(exports2, "generateCstDts", { enumerable: true, get: function() {
      return cst_dts_gen_1.generateCstDts;
    } });
    function clearCache2() {
      console.warn("The clearCache function was 'soft' removed from the Chevrotain API.\n	 It performs no action other than printing this message.\n	 Please avoid using it as it will be completely removed in the future");
    }
    exports2.clearCache = clearCache2;
    var render_public_1 = require_render_public();
    Object.defineProperty(exports2, "createSyntaxDiagramsCode", { enumerable: true, get: function() {
      return render_public_1.createSyntaxDiagramsCode;
    } });
    var Parser4 = function() {
      function Parser5() {
        throw new Error("The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.	\nSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0");
      }
      return Parser5;
    }();
    exports2.Parser = Parser4;
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/three-stdlib/loaders/MD2Loader.js
var _normalData = [[-0.525731, 0, 0.850651], [-0.442863, 0.238856, 0.864188], [-0.295242, 0, 0.955423], [-0.309017, 0.5, 0.809017], [-0.16246, 0.262866, 0.951056], [0, 0, 1], [0, 0.850651, 0.525731], [-0.147621, 0.716567, 0.681718], [0.147621, 0.716567, 0.681718], [0, 0.525731, 0.850651], [0.309017, 0.5, 0.809017], [0.525731, 0, 0.850651], [0.295242, 0, 0.955423], [0.442863, 0.238856, 0.864188], [0.16246, 0.262866, 0.951056], [-0.681718, 0.147621, 0.716567], [-0.809017, 0.309017, 0.5], [-0.587785, 0.425325, 0.688191], [-0.850651, 0.525731, 0], [-0.864188, 0.442863, 0.238856], [-0.716567, 0.681718, 0.147621], [-0.688191, 0.587785, 0.425325], [-0.5, 0.809017, 0.309017], [-0.238856, 0.864188, 0.442863], [-0.425325, 0.688191, 0.587785], [-0.716567, 0.681718, -0.147621], [-0.5, 0.809017, -0.309017], [-0.525731, 0.850651, 0], [0, 0.850651, -0.525731], [-0.238856, 0.864188, -0.442863], [0, 0.955423, -0.295242], [-0.262866, 0.951056, -0.16246], [0, 1, 0], [0, 0.955423, 0.295242], [-0.262866, 0.951056, 0.16246], [0.238856, 0.864188, 0.442863], [0.262866, 0.951056, 0.16246], [0.5, 0.809017, 0.309017], [0.238856, 0.864188, -0.442863], [0.262866, 0.951056, -0.16246], [0.5, 0.809017, -0.309017], [0.850651, 0.525731, 0], [0.716567, 0.681718, 0.147621], [0.716567, 0.681718, -0.147621], [0.525731, 0.850651, 0], [0.425325, 0.688191, 0.587785], [0.864188, 0.442863, 0.238856], [0.688191, 0.587785, 0.425325], [0.809017, 0.309017, 0.5], [0.681718, 0.147621, 0.716567], [0.587785, 0.425325, 0.688191], [0.955423, 0.295242, 0], [1, 0, 0], [0.951056, 0.16246, 0.262866], [0.850651, -0.525731, 0], [0.955423, -0.295242, 0], [0.864188, -0.442863, 0.238856], [0.951056, -0.16246, 0.262866], [0.809017, -0.309017, 0.5], [0.681718, -0.147621, 0.716567], [0.850651, 0, 0.525731], [0.864188, 0.442863, -0.238856], [0.809017, 0.309017, -0.5], [0.951056, 0.16246, -0.262866], [0.525731, 0, -0.850651], [0.681718, 0.147621, -0.716567], [0.681718, -0.147621, -0.716567], [0.850651, 0, -0.525731], [0.809017, -0.309017, -0.5], [0.864188, -0.442863, -0.238856], [0.951056, -0.16246, -0.262866], [0.147621, 0.716567, -0.681718], [0.309017, 0.5, -0.809017], [0.425325, 0.688191, -0.587785], [0.442863, 0.238856, -0.864188], [0.587785, 0.425325, -0.688191], [0.688191, 0.587785, -0.425325], [-0.147621, 0.716567, -0.681718], [-0.309017, 0.5, -0.809017], [0, 0.525731, -0.850651], [-0.525731, 0, -0.850651], [-0.442863, 0.238856, -0.864188], [-0.295242, 0, -0.955423], [-0.16246, 0.262866, -0.951056], [0, 0, -1], [0.295242, 0, -0.955423], [0.16246, 0.262866, -0.951056], [-0.442863, -0.238856, -0.864188], [-0.309017, -0.5, -0.809017], [-0.16246, -0.262866, -0.951056], [0, -0.850651, -0.525731], [-0.147621, -0.716567, -0.681718], [0.147621, -0.716567, -0.681718], [0, -0.525731, -0.850651], [0.309017, -0.5, -0.809017], [0.442863, -0.238856, -0.864188], [0.16246, -0.262866, -0.951056], [0.238856, -0.864188, -0.442863], [0.5, -0.809017, -0.309017], [0.425325, -0.688191, -0.587785], [0.716567, -0.681718, -0.147621], [0.688191, -0.587785, -0.425325], [0.587785, -0.425325, -0.688191], [0, -0.955423, -0.295242], [0, -1, 0], [0.262866, -0.951056, -0.16246], [0, -0.850651, 0.525731], [0, -0.955423, 0.295242], [0.238856, -0.864188, 0.442863], [0.262866, -0.951056, 0.16246], [0.5, -0.809017, 0.309017], [0.716567, -0.681718, 0.147621], [0.525731, -0.850651, 0], [-0.238856, -0.864188, -0.442863], [-0.5, -0.809017, -0.309017], [-0.262866, -0.951056, -0.16246], [-0.850651, -0.525731, 0], [-0.716567, -0.681718, -0.147621], [-0.716567, -0.681718, 0.147621], [-0.525731, -0.850651, 0], [-0.5, -0.809017, 0.309017], [-0.238856, -0.864188, 0.442863], [-0.262866, -0.951056, 0.16246], [-0.864188, -0.442863, 0.238856], [-0.809017, -0.309017, 0.5], [-0.688191, -0.587785, 0.425325], [-0.681718, -0.147621, 0.716567], [-0.442863, -0.238856, 0.864188], [-0.587785, -0.425325, 0.688191], [-0.309017, -0.5, 0.809017], [-0.147621, -0.716567, 0.681718], [-0.425325, -0.688191, 0.587785], [-0.16246, -0.262866, 0.951056], [0.442863, -0.238856, 0.864188], [0.16246, -0.262866, 0.951056], [0.309017, -0.5, 0.809017], [0.147621, -0.716567, 0.681718], [0, -0.525731, 0.850651], [0.425325, -0.688191, 0.587785], [0.587785, -0.425325, 0.688191], [0.688191, -0.587785, 0.425325], [-0.955423, 0.295242, 0], [-0.951056, 0.16246, 0.262866], [-1, 0, 0], [-0.850651, 0, 0.525731], [-0.955423, -0.295242, 0], [-0.951056, -0.16246, 0.262866], [-0.864188, 0.442863, -0.238856], [-0.951056, 0.16246, -0.262866], [-0.809017, 0.309017, -0.5], [-0.864188, -0.442863, -0.238856], [-0.951056, -0.16246, -0.262866], [-0.809017, -0.309017, -0.5], [-0.681718, 0.147621, -0.716567], [-0.681718, -0.147621, -0.716567], [-0.850651, 0, -0.525731], [-0.688191, 0.587785, -0.425325], [-0.587785, 0.425325, -0.688191], [-0.425325, 0.688191, -0.587785], [-0.425325, -0.688191, -0.587785], [-0.587785, -0.425325, -0.688191], [-0.688191, -0.587785, -0.425325]];
var MD2Loader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(buffer2) {
      try {
        onLoad(scope2.parse(buffer2));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(buffer2) {
    const data = new DataView(buffer2);
    const header = {};
    const headerNames = ["ident", "version", "skinwidth", "skinheight", "framesize", "num_skins", "num_vertices", "num_st", "num_tris", "num_glcmds", "num_frames", "offset_skins", "offset_st", "offset_tris", "offset_frames", "offset_glcmds", "offset_end"];
    for (let i2 = 0; i2 < headerNames.length; i2++) {
      header[headerNames[i2]] = data.getInt32(i2 * 4, true);
    }
    if (header.ident !== 844121161 || header.version !== 8) {
      console.error("Not a valid MD2 file");
      return;
    }
    if (header.offset_end !== data.byteLength) {
      console.error("Corrupted MD2 file");
      return;
    }
    const geometry = new BufferGeometry();
    const uvsTemp = [];
    let offset = header.offset_st;
    for (let i2 = 0, l = header.num_st; i2 < l; i2++) {
      const u = data.getInt16(offset + 0, true);
      const v = data.getInt16(offset + 2, true);
      uvsTemp.push(u / header.skinwidth, 1 - v / header.skinheight);
      offset += 4;
    }
    offset = header.offset_tris;
    const vertexIndices = [];
    const uvIndices = [];
    for (let i2 = 0, l = header.num_tris; i2 < l; i2++) {
      vertexIndices.push(data.getUint16(offset + 0, true), data.getUint16(offset + 2, true), data.getUint16(offset + 4, true));
      uvIndices.push(data.getUint16(offset + 6, true), data.getUint16(offset + 8, true), data.getUint16(offset + 10, true));
      offset += 12;
    }
    const translation = new Vector3();
    const scale = new Vector3();
    const string = [];
    const frames = [];
    offset = header.offset_frames;
    for (let i2 = 0, l = header.num_frames; i2 < l; i2++) {
      scale.set(data.getFloat32(offset + 0, true), data.getFloat32(offset + 4, true), data.getFloat32(offset + 8, true));
      translation.set(data.getFloat32(offset + 12, true), data.getFloat32(offset + 16, true), data.getFloat32(offset + 20, true));
      offset += 24;
      for (let j2 = 0; j2 < 16; j2++) {
        const character = data.getUint8(offset + j2, true);
        if (character === 0)
          break;
        string[j2] = character;
      }
      const frame = {
        name: String.fromCharCode.apply(null, string),
        vertices: [],
        normals: []
      };
      offset += 16;
      for (let j2 = 0; j2 < header.num_vertices; j2++) {
        let x = data.getUint8(offset++, true);
        let y = data.getUint8(offset++, true);
        let z = data.getUint8(offset++, true);
        const n = _normalData[data.getUint8(offset++, true)];
        x = x * scale.x + translation.x;
        y = y * scale.y + translation.y;
        z = z * scale.z + translation.z;
        frame.vertices.push(x, z, y);
        frame.normals.push(n[0], n[2], n[1]);
      }
      frames.push(frame);
    }
    const positions = [];
    const normals = [];
    const uvs = [];
    const verticesTemp = frames[0].vertices;
    const normalsTemp = frames[0].normals;
    for (let i2 = 0, l = vertexIndices.length; i2 < l; i2++) {
      const vertexIndex = vertexIndices[i2];
      let stride = vertexIndex * 3;
      const x = verticesTemp[stride];
      const y = verticesTemp[stride + 1];
      const z = verticesTemp[stride + 2];
      positions.push(x, y, z);
      const nx = normalsTemp[stride];
      const ny = normalsTemp[stride + 1];
      const nz = normalsTemp[stride + 2];
      normals.push(nx, ny, nz);
      const uvIndex = uvIndices[i2];
      stride = uvIndex * 2;
      const u = uvsTemp[stride];
      const v = uvsTemp[stride + 1];
      uvs.push(u, v);
    }
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    geometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    const morphPositions = [];
    const morphNormals = [];
    for (let i2 = 0, l = frames.length; i2 < l; i2++) {
      const frame = frames[i2];
      const attributeName = frame.name;
      if (frame.vertices.length > 0) {
        const positions2 = [];
        for (let j2 = 0, jl2 = vertexIndices.length; j2 < jl2; j2++) {
          const vertexIndex = vertexIndices[j2];
          const stride = vertexIndex * 3;
          const x = frame.vertices[stride];
          const y = frame.vertices[stride + 1];
          const z = frame.vertices[stride + 2];
          positions2.push(x, y, z);
        }
        const positionAttribute = new Float32BufferAttribute(positions2, 3);
        positionAttribute.name = attributeName;
        morphPositions.push(positionAttribute);
      }
      if (frame.normals.length > 0) {
        const normals2 = [];
        for (let j2 = 0, jl2 = vertexIndices.length; j2 < jl2; j2++) {
          const vertexIndex = vertexIndices[j2];
          const stride = vertexIndex * 3;
          const nx = frame.normals[stride];
          const ny = frame.normals[stride + 1];
          const nz = frame.normals[stride + 2];
          normals2.push(nx, ny, nz);
        }
        const normalAttribute = new Float32BufferAttribute(normals2, 3);
        normalAttribute.name = attributeName;
        morphNormals.push(normalAttribute);
      }
    }
    geometry.morphAttributes.position = morphPositions;
    geometry.morphAttributes.normal = morphNormals;
    geometry.morphTargetsRelative = false;
    geometry.animations = AnimationClip.CreateClipsFromMorphTargetSequences(frames, 10);
    return geometry;
  }
};

// node_modules/three-stdlib/misc/MorphBlendMesh.js
var MorphBlendMesh = function(geometry, material) {
  Mesh.call(this, geometry, material);
  this.animationsMap = {};
  this.animationsList = [];
  var numFrames = Object.keys(this.morphTargetDictionary).length;
  var name = "__default";
  var startFrame = 0;
  var endFrame = numFrames - 1;
  var fps = numFrames / 1;
  this.createAnimation(name, startFrame, endFrame, fps);
  this.setAnimationWeight(name, 1);
};
MorphBlendMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: MorphBlendMesh,
  createAnimation: function(name, start, end, fps) {
    var animation = {
      start,
      end,
      length: end - start + 1,
      fps,
      duration: (end - start) / fps,
      lastFrame: 0,
      currentFrame: 0,
      active: false,
      time: 0,
      direction: 1,
      weight: 1,
      directionBackwards: false,
      mirroredLoop: false
    };
    this.animationsMap[name] = animation;
    this.animationsList.push(animation);
  },
  autoCreateAnimations: function(fps) {
    var pattern = /([a-z]+)_?(\d+)/i;
    var firstAnimation, frameRanges = {};
    var i2 = 0;
    for (let key in this.morphTargetDictionary) {
      var chunks = key.match(pattern);
      if (chunks && chunks.length > 1) {
        var name = chunks[1];
        if (!frameRanges[name])
          frameRanges[name] = {
            start: Infinity,
            end: -Infinity
          };
        var range = frameRanges[name];
        if (i2 < range.start)
          range.start = i2;
        if (i2 > range.end)
          range.end = i2;
        if (!firstAnimation)
          firstAnimation = name;
      }
      i2++;
    }
    for (let name2 in frameRanges) {
      var range = frameRanges[name2];
      this.createAnimation(name2, range.start, range.end, fps);
    }
    this.firstAnimation = firstAnimation;
  },
  setAnimationDirectionForward: function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.direction = 1;
      animation.directionBackwards = false;
    }
  },
  setAnimationDirectionBackward: function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.direction = -1;
      animation.directionBackwards = true;
    }
  },
  setAnimationFPS: function(name, fps) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.fps = fps;
      animation.duration = (animation.end - animation.start) / animation.fps;
    }
  },
  setAnimationDuration: function(name, duration) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.duration = duration;
      animation.fps = (animation.end - animation.start) / animation.duration;
    }
  },
  setAnimationWeight: function(name, weight) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.weight = weight;
    }
  },
  setAnimationTime: function(name, time) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.time = time;
    }
  },
  getAnimationTime: function(name) {
    var time = 0;
    var animation = this.animationsMap[name];
    if (animation) {
      time = animation.time;
    }
    return time;
  },
  getAnimationDuration: function(name) {
    var duration = -1;
    var animation = this.animationsMap[name];
    if (animation) {
      duration = animation.duration;
    }
    return duration;
  },
  playAnimation: function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.time = 0;
      animation.active = true;
    } else {
      console.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
    }
  },
  stopAnimation: function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.active = false;
    }
  },
  update: function(delta) {
    for (let i2 = 0, il = this.animationsList.length; i2 < il; i2++) {
      var animation = this.animationsList[i2];
      if (!animation.active)
        continue;
      var frameTime = animation.duration / animation.length;
      animation.time += animation.direction * delta;
      if (animation.mirroredLoop) {
        if (animation.time > animation.duration || animation.time < 0) {
          animation.direction *= -1;
          if (animation.time > animation.duration) {
            animation.time = animation.duration;
            animation.directionBackwards = true;
          }
          if (animation.time < 0) {
            animation.time = 0;
            animation.directionBackwards = false;
          }
        }
      } else {
        animation.time = animation.time % animation.duration;
        if (animation.time < 0)
          animation.time += animation.duration;
      }
      var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
      var weight = animation.weight;
      if (keyframe !== animation.currentFrame) {
        this.morphTargetInfluences[animation.lastFrame] = 0;
        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
        this.morphTargetInfluences[keyframe] = 0;
        animation.lastFrame = animation.currentFrame;
        animation.currentFrame = keyframe;
      }
      var mix2 = animation.time % frameTime / frameTime;
      if (animation.directionBackwards)
        mix2 = 1 - mix2;
      if (animation.currentFrame !== animation.lastFrame) {
        this.morphTargetInfluences[animation.currentFrame] = mix2 * weight;
        this.morphTargetInfluences[animation.lastFrame] = (1 - mix2) * weight;
      } else {
        this.morphTargetInfluences[animation.currentFrame] = weight;
      }
    }
  }
});

// node_modules/three-stdlib/misc/MD2CharacterComplex.js
var MD2CharacterComplex = function() {
  var scope2 = this;
  this.scale = 1;
  this.animationFPS = 6;
  this.transitionFrames = 15;
  this.maxSpeed = 275;
  this.maxReverseSpeed = -275;
  this.frontAcceleration = 600;
  this.backAcceleration = 600;
  this.frontDecceleration = 600;
  this.angularSpeed = 2.5;
  this.root = new Object3D();
  this.meshBody = null;
  this.meshWeapon = null;
  this.controls = null;
  this.skinsBody = [];
  this.skinsWeapon = [];
  this.weapons = [];
  this.currentSkin = void 0;
  this.onLoadComplete = function() {
  };
  this.meshes = [];
  this.animations = {};
  this.loadCounter = 0;
  this.speed = 0;
  this.bodyOrientation = 0;
  this.walkSpeed = this.maxSpeed;
  this.crouchSpeed = this.maxSpeed * 0.5;
  this.activeAnimation = null;
  this.oldAnimation = null;
  this.enableShadows = function(enable) {
    for (let i2 = 0; i2 < this.meshes.length; i2++) {
      this.meshes[i2].castShadow = enable;
      this.meshes[i2].receiveShadow = enable;
    }
  };
  this.setVisible = function(enable) {
    for (let i2 = 0; i2 < this.meshes.length; i2++) {
      this.meshes[i2].visible = enable;
      this.meshes[i2].visible = enable;
    }
  };
  this.shareParts = function(original) {
    this.animations = original.animations;
    this.walkSpeed = original.walkSpeed;
    this.crouchSpeed = original.crouchSpeed;
    this.skinsBody = original.skinsBody;
    this.skinsWeapon = original.skinsWeapon;
    var mesh = createPart(original.meshBody.geometry, this.skinsBody[0]);
    mesh.scale.set(this.scale, this.scale, this.scale);
    this.root.position.y = original.root.position.y;
    this.root.add(mesh);
    this.meshBody = mesh;
    this.meshes.push(mesh);
    for (let i2 = 0; i2 < original.weapons.length; i2++) {
      var meshWeapon = createPart(original.weapons[i2].geometry, this.skinsWeapon[i2]);
      meshWeapon.scale.set(this.scale, this.scale, this.scale);
      meshWeapon.visible = false;
      meshWeapon.name = original.weapons[i2].name;
      this.root.add(meshWeapon);
      this.weapons[i2] = meshWeapon;
      this.meshWeapon = meshWeapon;
      this.meshes.push(meshWeapon);
    }
  };
  this.loadParts = function(config) {
    this.animations = config.animations;
    this.walkSpeed = config.walkSpeed;
    this.crouchSpeed = config.crouchSpeed;
    this.loadCounter = config.weapons.length * 2 + config.skins.length + 1;
    var weaponsTextures = [];
    for (let i2 = 0; i2 < config.weapons.length; i2++)
      weaponsTextures[i2] = config.weapons[i2][1];
    this.skinsBody = loadTextures(config.baseUrl + "skins/", config.skins);
    this.skinsWeapon = loadTextures(config.baseUrl + "skins/", weaponsTextures);
    var loader = new MD2Loader();
    loader.load(config.baseUrl + config.body, function(geo) {
      var boundingBox = new Box3();
      boundingBox.setFromBufferAttribute(geo.attributes.position);
      scope2.root.position.y = -scope2.scale * boundingBox.min.y;
      var mesh = createPart(geo, scope2.skinsBody[0]);
      mesh.scale.set(scope2.scale, scope2.scale, scope2.scale);
      scope2.root.add(mesh);
      scope2.meshBody = mesh;
      scope2.meshes.push(mesh);
      checkLoadingComplete();
    });
    var generateCallback = function(index, name) {
      return function(geo) {
        var mesh = createPart(geo, scope2.skinsWeapon[index]);
        mesh.scale.set(scope2.scale, scope2.scale, scope2.scale);
        mesh.visible = false;
        mesh.name = name;
        scope2.root.add(mesh);
        scope2.weapons[index] = mesh;
        scope2.meshWeapon = mesh;
        scope2.meshes.push(mesh);
        checkLoadingComplete();
      };
    };
    for (let i2 = 0; i2 < config.weapons.length; i2++) {
      loader.load(config.baseUrl + config.weapons[i2][0], generateCallback(i2, config.weapons[i2][0]));
    }
  };
  this.setPlaybackRate = function(rate) {
    if (this.meshBody)
      this.meshBody.duration = this.meshBody.baseDuration / rate;
    if (this.meshWeapon)
      this.meshWeapon.duration = this.meshWeapon.baseDuration / rate;
  };
  this.setWireframe = function(wireframeEnabled) {
    if (wireframeEnabled) {
      if (this.meshBody)
        this.meshBody.material = this.meshBody.materialWireframe;
      if (this.meshWeapon)
        this.meshWeapon.material = this.meshWeapon.materialWireframe;
    } else {
      if (this.meshBody)
        this.meshBody.material = this.meshBody.materialTexture;
      if (this.meshWeapon)
        this.meshWeapon.material = this.meshWeapon.materialTexture;
    }
  };
  this.setSkin = function(index) {
    if (this.meshBody && this.meshBody.material.wireframe === false) {
      this.meshBody.material.map = this.skinsBody[index];
      this.currentSkin = index;
    }
  };
  this.setWeapon = function(index) {
    for (let i2 = 0; i2 < this.weapons.length; i2++)
      this.weapons[i2].visible = false;
    var activeWeapon = this.weapons[index];
    if (activeWeapon) {
      activeWeapon.visible = true;
      this.meshWeapon = activeWeapon;
      if (this.activeAnimation) {
        activeWeapon.playAnimation(this.activeAnimation);
        this.meshWeapon.setAnimationTime(this.activeAnimation, this.meshBody.getAnimationTime(this.activeAnimation));
      }
    }
  };
  this.setAnimation = function(animationName) {
    if (animationName === this.activeAnimation || !animationName)
      return;
    if (this.meshBody) {
      this.meshBody.setAnimationWeight(animationName, 0);
      this.meshBody.playAnimation(animationName);
      this.oldAnimation = this.activeAnimation;
      this.activeAnimation = animationName;
      this.blendCounter = this.transitionFrames;
    }
    if (this.meshWeapon) {
      this.meshWeapon.setAnimationWeight(animationName, 0);
      this.meshWeapon.playAnimation(animationName);
    }
  };
  this.update = function(delta) {
    if (this.controls)
      this.updateMovementModel(delta);
    if (this.animations) {
      this.updateBehaviors();
      this.updateAnimations(delta);
    }
  };
  this.updateAnimations = function(delta) {
    var mix2 = 1;
    if (this.blendCounter > 0) {
      mix2 = (this.transitionFrames - this.blendCounter) / this.transitionFrames;
      this.blendCounter -= 1;
    }
    if (this.meshBody) {
      this.meshBody.update(delta);
      this.meshBody.setAnimationWeight(this.activeAnimation, mix2);
      this.meshBody.setAnimationWeight(this.oldAnimation, 1 - mix2);
    }
    if (this.meshWeapon) {
      this.meshWeapon.update(delta);
      this.meshWeapon.setAnimationWeight(this.activeAnimation, mix2);
      this.meshWeapon.setAnimationWeight(this.oldAnimation, 1 - mix2);
    }
  };
  this.updateBehaviors = function() {
    var controls = this.controls;
    var animations = this.animations;
    var moveAnimation, idleAnimation;
    if (controls.crouch) {
      moveAnimation = animations["crouchMove"];
      idleAnimation = animations["crouchIdle"];
    } else {
      moveAnimation = animations["move"];
      idleAnimation = animations["idle"];
    }
    if (controls.jump) {
      moveAnimation = animations["jump"];
      idleAnimation = animations["jump"];
    }
    if (controls.attack) {
      if (controls.crouch) {
        moveAnimation = animations["crouchAttack"];
        idleAnimation = animations["crouchAttack"];
      } else {
        moveAnimation = animations["attack"];
        idleAnimation = animations["attack"];
      }
    }
    if (controls.moveForward || controls.moveBackward || controls.moveLeft || controls.moveRight) {
      if (this.activeAnimation !== moveAnimation) {
        this.setAnimation(moveAnimation);
      }
    }
    if (Math.abs(this.speed) < 0.2 * this.maxSpeed && !(controls.moveLeft || controls.moveRight || controls.moveForward || controls.moveBackward)) {
      if (this.activeAnimation !== idleAnimation) {
        this.setAnimation(idleAnimation);
      }
    }
    if (controls.moveForward) {
      if (this.meshBody) {
        this.meshBody.setAnimationDirectionForward(this.activeAnimation);
        this.meshBody.setAnimationDirectionForward(this.oldAnimation);
      }
      if (this.meshWeapon) {
        this.meshWeapon.setAnimationDirectionForward(this.activeAnimation);
        this.meshWeapon.setAnimationDirectionForward(this.oldAnimation);
      }
    }
    if (controls.moveBackward) {
      if (this.meshBody) {
        this.meshBody.setAnimationDirectionBackward(this.activeAnimation);
        this.meshBody.setAnimationDirectionBackward(this.oldAnimation);
      }
      if (this.meshWeapon) {
        this.meshWeapon.setAnimationDirectionBackward(this.activeAnimation);
        this.meshWeapon.setAnimationDirectionBackward(this.oldAnimation);
      }
    }
  };
  this.updateMovementModel = function(delta) {
    var controls = this.controls;
    if (controls.crouch)
      this.maxSpeed = this.crouchSpeed;
    else
      this.maxSpeed = this.walkSpeed;
    this.maxReverseSpeed = -this.maxSpeed;
    if (controls.moveForward) {
      this.speed = MathUtils.clamp(this.speed + delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed);
    }
    if (controls.moveBackward) {
      this.speed = MathUtils.clamp(this.speed - delta * this.backAcceleration, this.maxReverseSpeed, this.maxSpeed);
    }
    var dir = 1;
    if (controls.moveLeft) {
      this.bodyOrientation += delta * this.angularSpeed;
      this.speed = MathUtils.clamp(this.speed + dir * delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed);
    }
    if (controls.moveRight) {
      this.bodyOrientation -= delta * this.angularSpeed;
      this.speed = MathUtils.clamp(this.speed + dir * delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed);
    }
    if (!(controls.moveForward || controls.moveBackward)) {
      if (this.speed > 0) {
        var k = exponentialEaseOut(this.speed / this.maxSpeed);
        this.speed = MathUtils.clamp(this.speed - k * delta * this.frontDecceleration, 0, this.maxSpeed);
      } else {
        var k = exponentialEaseOut(this.speed / this.maxReverseSpeed);
        this.speed = MathUtils.clamp(this.speed + k * delta * this.backAcceleration, this.maxReverseSpeed, 0);
      }
    }
    var forwardDelta = this.speed * delta;
    this.root.position.x += Math.sin(this.bodyOrientation) * forwardDelta;
    this.root.position.z += Math.cos(this.bodyOrientation) * forwardDelta;
    this.root.rotation.y = this.bodyOrientation;
  };
  function loadTextures(baseUrl, textureUrls) {
    var textureLoader = new TextureLoader();
    var textures = [];
    for (let i2 = 0; i2 < textureUrls.length; i2++) {
      textures[i2] = textureLoader.load(baseUrl + textureUrls[i2], checkLoadingComplete);
      textures[i2].mapping = UVMapping;
      textures[i2].name = textureUrls[i2];
      textures[i2].encoding = sRGBEncoding;
    }
    return textures;
  }
  function createPart(geometry, skinMap) {
    var materialWireframe = new MeshLambertMaterial({
      color: 16755200,
      wireframe: true,
      morphTargets: true,
      morphNormals: true
    });
    var materialTexture = new MeshLambertMaterial({
      color: 16777215,
      wireframe: false,
      map: skinMap,
      morphTargets: true,
      morphNormals: true
    });
    var mesh = new MorphBlendMesh(geometry, materialTexture);
    mesh.rotation.y = -Math.PI / 2;
    mesh.materialTexture = materialTexture;
    mesh.materialWireframe = materialWireframe;
    mesh.autoCreateAnimations(scope2.animationFPS);
    return mesh;
  }
  function checkLoadingComplete() {
    scope2.loadCounter -= 1;
    if (scope2.loadCounter === 0)
      scope2.onLoadComplete();
  }
  function exponentialEaseOut(k) {
    return k === 1 ? 1 : -Math.pow(2, -10 * k) + 1;
  }
};

// node_modules/three-stdlib/math/ConvexHull.js
var Visible = 0;
var Deleted = 1;
var _v1 = new Vector3();
var _line3 = new Line3();
var _plane = new Plane();
var _closestPoint = new Vector3();
var _triangle = new Triangle();
var ConvexHull = class {
  constructor() {
    this.tolerance = -1;
    this.faces = [];
    this.newFaces = [];
    this.assigned = new VertexList();
    this.unassigned = new VertexList();
    this.vertices = [];
  }
  setFromPoints(points) {
    if (points.length >= 4) {
      this.makeEmpty();
      for (let i2 = 0, l = points.length; i2 < l; i2++) {
        this.vertices.push(new VertexNode(points[i2]));
      }
      this.compute();
    }
    return this;
  }
  setFromObject(object) {
    const points = [];
    object.updateMatrixWorld(true);
    object.traverse(function(node) {
      const geometry = node.geometry;
      if (geometry !== void 0) {
        if (geometry.isGeometry) {
          console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");
          return;
        } else if (geometry.isBufferGeometry) {
          const attribute2 = geometry.attributes.position;
          if (attribute2 !== void 0) {
            for (let i2 = 0, l = attribute2.count; i2 < l; i2++) {
              const point = new Vector3();
              point.fromBufferAttribute(attribute2, i2).applyMatrix4(node.matrixWorld);
              points.push(point);
            }
          }
        }
      }
    });
    return this.setFromPoints(points);
  }
  containsPoint(point) {
    const faces = this.faces;
    for (let i2 = 0, l = faces.length; i2 < l; i2++) {
      const face = faces[i2];
      if (face.distanceToPoint(point) > this.tolerance)
        return false;
    }
    return true;
  }
  intersectRay(ray, target) {
    const faces = this.faces;
    let tNear = -Infinity;
    let tFar = Infinity;
    for (let i2 = 0, l = faces.length; i2 < l; i2++) {
      const face = faces[i2];
      const vN = face.distanceToPoint(ray.origin);
      const vD = face.normal.dot(ray.direction);
      if (vN > 0 && vD >= 0)
        return null;
      const t2 = vD !== 0 ? -vN / vD : 0;
      if (t2 <= 0)
        continue;
      if (vD > 0) {
        tFar = Math.min(t2, tFar);
      } else {
        tNear = Math.max(t2, tNear);
      }
      if (tNear > tFar) {
        return null;
      }
    }
    if (tNear !== -Infinity) {
      ray.at(tNear, target);
    } else {
      ray.at(tFar, target);
    }
    return target;
  }
  intersectsRay(ray) {
    return this.intersectRay(ray, _v1) !== null;
  }
  makeEmpty() {
    this.faces = [];
    this.vertices = [];
    return this;
  }
  addVertexToFace(vertex, face) {
    vertex.face = face;
    if (face.outside === null) {
      this.assigned.append(vertex);
    } else {
      this.assigned.insertBefore(face.outside, vertex);
    }
    face.outside = vertex;
    return this;
  }
  removeVertexFromFace(vertex, face) {
    if (vertex === face.outside) {
      if (vertex.next !== null && vertex.next.face === face) {
        face.outside = vertex.next;
      } else {
        face.outside = null;
      }
    }
    this.assigned.remove(vertex);
    return this;
  }
  removeAllVerticesFromFace(face) {
    if (face.outside !== null) {
      const start = face.outside;
      let end = face.outside;
      while (end.next !== null && end.next.face === face) {
        end = end.next;
      }
      this.assigned.removeSubList(start, end);
      start.prev = end.next = null;
      face.outside = null;
      return start;
    }
  }
  deleteFaceVertices(face, absorbingFace) {
    const faceVertices = this.removeAllVerticesFromFace(face);
    if (faceVertices !== void 0) {
      if (absorbingFace === void 0) {
        this.unassigned.appendChain(faceVertices);
      } else {
        let vertex = faceVertices;
        do {
          const nextVertex = vertex.next;
          const distance2 = absorbingFace.distanceToPoint(vertex.point);
          if (distance2 > this.tolerance) {
            this.addVertexToFace(vertex, absorbingFace);
          } else {
            this.unassigned.append(vertex);
          }
          vertex = nextVertex;
        } while (vertex !== null);
      }
    }
    return this;
  }
  resolveUnassignedPoints(newFaces) {
    if (this.unassigned.isEmpty() === false) {
      let vertex = this.unassigned.first();
      do {
        const nextVertex = vertex.next;
        let maxDistance = this.tolerance;
        let maxFace = null;
        for (let i2 = 0; i2 < newFaces.length; i2++) {
          const face = newFaces[i2];
          if (face.mark === Visible) {
            const distance2 = face.distanceToPoint(vertex.point);
            if (distance2 > maxDistance) {
              maxDistance = distance2;
              maxFace = face;
            }
            if (maxDistance > 1e3 * this.tolerance)
              break;
          }
        }
        if (maxFace !== null) {
          this.addVertexToFace(vertex, maxFace);
        }
        vertex = nextVertex;
      } while (vertex !== null);
    }
    return this;
  }
  computeExtremes() {
    const min2 = new Vector3();
    const max3 = new Vector3();
    const minVertices = [];
    const maxVertices = [];
    for (let i2 = 0; i2 < 3; i2++) {
      minVertices[i2] = maxVertices[i2] = this.vertices[0];
    }
    min2.copy(this.vertices[0].point);
    max3.copy(this.vertices[0].point);
    for (let i2 = 0, l = this.vertices.length; i2 < l; i2++) {
      const vertex = this.vertices[i2];
      const point = vertex.point;
      for (let j2 = 0; j2 < 3; j2++) {
        if (point.getComponent(j2) < min2.getComponent(j2)) {
          min2.setComponent(j2, point.getComponent(j2));
          minVertices[j2] = vertex;
        }
      }
      for (let j2 = 0; j2 < 3; j2++) {
        if (point.getComponent(j2) > max3.getComponent(j2)) {
          max3.setComponent(j2, point.getComponent(j2));
          maxVertices[j2] = vertex;
        }
      }
    }
    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min2.x), Math.abs(max3.x)) + Math.max(Math.abs(min2.y), Math.abs(max3.y)) + Math.max(Math.abs(min2.z), Math.abs(max3.z)));
    return {
      min: minVertices,
      max: maxVertices
    };
  }
  computeInitialHull() {
    const vertices = this.vertices;
    const extremes = this.computeExtremes();
    const min2 = extremes.min;
    const max3 = extremes.max;
    let maxDistance = 0;
    let index = 0;
    for (let i2 = 0; i2 < 3; i2++) {
      const distance2 = max3[i2].point.getComponent(i2) - min2[i2].point.getComponent(i2);
      if (distance2 > maxDistance) {
        maxDistance = distance2;
        index = i2;
      }
    }
    const v0 = min2[index];
    const v12 = max3[index];
    let v2;
    let v3;
    maxDistance = 0;
    _line3.set(v0.point, v12.point);
    for (let i2 = 0, l = this.vertices.length; i2 < l; i2++) {
      const vertex = vertices[i2];
      if (vertex !== v0 && vertex !== v12) {
        _line3.closestPointToPoint(vertex.point, true, _closestPoint);
        const distance2 = _closestPoint.distanceToSquared(vertex.point);
        if (distance2 > maxDistance) {
          maxDistance = distance2;
          v2 = vertex;
        }
      }
    }
    maxDistance = -1;
    _plane.setFromCoplanarPoints(v0.point, v12.point, v2.point);
    for (let i2 = 0, l = this.vertices.length; i2 < l; i2++) {
      const vertex = vertices[i2];
      if (vertex !== v0 && vertex !== v12 && vertex !== v2) {
        const distance2 = Math.abs(_plane.distanceToPoint(vertex.point));
        if (distance2 > maxDistance) {
          maxDistance = distance2;
          v3 = vertex;
        }
      }
    }
    const faces = [];
    if (_plane.distanceToPoint(v3.point) < 0) {
      faces.push(Face.create(v0, v12, v2), Face.create(v3, v12, v0), Face.create(v3, v2, v12), Face.create(v3, v0, v2));
      for (let i2 = 0; i2 < 3; i2++) {
        const j2 = (i2 + 1) % 3;
        faces[i2 + 1].getEdge(2).setTwin(faces[0].getEdge(j2));
        faces[i2 + 1].getEdge(1).setTwin(faces[j2 + 1].getEdge(0));
      }
    } else {
      faces.push(Face.create(v0, v2, v12), Face.create(v3, v0, v12), Face.create(v3, v12, v2), Face.create(v3, v2, v0));
      for (let i2 = 0; i2 < 3; i2++) {
        const j2 = (i2 + 1) % 3;
        faces[i2 + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i2) % 3));
        faces[i2 + 1].getEdge(0).setTwin(faces[j2 + 1].getEdge(1));
      }
    }
    for (let i2 = 0; i2 < 4; i2++) {
      this.faces.push(faces[i2]);
    }
    for (let i2 = 0, l = vertices.length; i2 < l; i2++) {
      const vertex = vertices[i2];
      if (vertex !== v0 && vertex !== v12 && vertex !== v2 && vertex !== v3) {
        maxDistance = this.tolerance;
        let maxFace = null;
        for (let j2 = 0; j2 < 4; j2++) {
          const distance2 = this.faces[j2].distanceToPoint(vertex.point);
          if (distance2 > maxDistance) {
            maxDistance = distance2;
            maxFace = this.faces[j2];
          }
        }
        if (maxFace !== null) {
          this.addVertexToFace(vertex, maxFace);
        }
      }
    }
    return this;
  }
  reindexFaces() {
    const activeFaces = [];
    for (let i2 = 0; i2 < this.faces.length; i2++) {
      const face = this.faces[i2];
      if (face.mark === Visible) {
        activeFaces.push(face);
      }
    }
    this.faces = activeFaces;
    return this;
  }
  nextVertexToAdd() {
    if (this.assigned.isEmpty() === false) {
      let eyeVertex, maxDistance = 0;
      const eyeFace = this.assigned.first().face;
      let vertex = eyeFace.outside;
      do {
        const distance2 = eyeFace.distanceToPoint(vertex.point);
        if (distance2 > maxDistance) {
          maxDistance = distance2;
          eyeVertex = vertex;
        }
        vertex = vertex.next;
      } while (vertex !== null && vertex.face === eyeFace);
      return eyeVertex;
    }
  }
  computeHorizon(eyePoint, crossEdge, face, horizon) {
    this.deleteFaceVertices(face);
    face.mark = Deleted;
    let edge;
    if (crossEdge === null) {
      edge = crossEdge = face.getEdge(0);
    } else {
      edge = crossEdge.next;
    }
    do {
      const twinEdge = edge.twin;
      const oppositeFace = twinEdge.face;
      if (oppositeFace.mark === Visible) {
        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {
          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);
        } else {
          horizon.push(edge);
        }
      }
      edge = edge.next;
    } while (edge !== crossEdge);
    return this;
  }
  addAdjoiningFace(eyeVertex, horizonEdge) {
    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());
    this.faces.push(face);
    face.getEdge(-1).setTwin(horizonEdge.twin);
    return face.getEdge(0);
  }
  addNewFaces(eyeVertex, horizon) {
    this.newFaces = [];
    let firstSideEdge = null;
    let previousSideEdge = null;
    for (let i2 = 0; i2 < horizon.length; i2++) {
      const horizonEdge = horizon[i2];
      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);
      if (firstSideEdge === null) {
        firstSideEdge = sideEdge;
      } else {
        sideEdge.next.setTwin(previousSideEdge);
      }
      this.newFaces.push(sideEdge.face);
      previousSideEdge = sideEdge;
    }
    firstSideEdge.next.setTwin(previousSideEdge);
    return this;
  }
  addVertexToHull(eyeVertex) {
    const horizon = [];
    this.unassigned.clear();
    this.removeVertexFromFace(eyeVertex, eyeVertex.face);
    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
    this.addNewFaces(eyeVertex, horizon);
    this.resolveUnassignedPoints(this.newFaces);
    return this;
  }
  cleanup() {
    this.assigned.clear();
    this.unassigned.clear();
    this.newFaces = [];
    return this;
  }
  compute() {
    let vertex;
    this.computeInitialHull();
    while ((vertex = this.nextVertexToAdd()) !== void 0) {
      this.addVertexToHull(vertex);
    }
    this.reindexFaces();
    this.cleanup();
    return this;
  }
};
var Face = class {
  constructor() {
    this.normal = new Vector3();
    this.midpoint = new Vector3();
    this.area = 0;
    this.constant = 0;
    this.outside = null;
    this.mark = Visible;
    this.edge = null;
  }
  static create(a2, b3, c) {
    const face = new Face();
    const e0 = new HalfEdge(a2, face);
    const e1 = new HalfEdge(b3, face);
    const e2 = new HalfEdge(c, face);
    e0.next = e2.prev = e1;
    e1.next = e0.prev = e2;
    e2.next = e1.prev = e0;
    face.edge = e0;
    return face.compute();
  }
  getEdge(i2) {
    let edge = this.edge;
    while (i2 > 0) {
      edge = edge.next;
      i2--;
    }
    while (i2 < 0) {
      edge = edge.prev;
      i2++;
    }
    return edge;
  }
  compute() {
    const a2 = this.edge.tail();
    const b3 = this.edge.head();
    const c = this.edge.next.head();
    _triangle.set(a2.point, b3.point, c.point);
    _triangle.getNormal(this.normal);
    _triangle.getMidpoint(this.midpoint);
    this.area = _triangle.getArea();
    this.constant = this.normal.dot(this.midpoint);
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) - this.constant;
  }
};
var HalfEdge = class {
  constructor(vertex, face) {
    this.vertex = vertex;
    this.prev = null;
    this.next = null;
    this.twin = null;
    this.face = face;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const head2 = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceTo(head2.point);
    }
    return -1;
  }
  lengthSquared() {
    const head2 = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceToSquared(head2.point);
    }
    return -1;
  }
  setTwin(edge) {
    this.twin = edge;
    edge.twin = this;
    return this;
  }
};
var VertexNode = class {
  constructor(point) {
    this.point = point;
    this.prev = null;
    this.next = null;
    this.face = null;
  }
};
var VertexList = class {
  constructor() {
    this.head = null;
    this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    this.head = this.tail = null;
    return this;
  }
  insertBefore(target, vertex) {
    vertex.prev = target.prev;
    vertex.next = target;
    if (vertex.prev === null) {
      this.head = vertex;
    } else {
      vertex.prev.next = vertex;
    }
    target.prev = vertex;
    return this;
  }
  insertAfter(target, vertex) {
    vertex.prev = target;
    vertex.next = target.next;
    if (vertex.next === null) {
      this.tail = vertex;
    } else {
      vertex.next.prev = vertex;
    }
    target.next = vertex;
    return this;
  }
  append(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    vertex.next = null;
    this.tail = vertex;
    return this;
  }
  appendChain(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    while (vertex.next !== null) {
      vertex = vertex.next;
    }
    this.tail = vertex;
    return this;
  }
  remove(vertex) {
    if (vertex.prev === null) {
      this.head = vertex.next;
    } else {
      vertex.prev.next = vertex.next;
    }
    if (vertex.next === null) {
      this.tail = vertex.prev;
    } else {
      vertex.next.prev = vertex.prev;
    }
    return this;
  }
  removeSubList(a2, b3) {
    if (a2.prev === null) {
      this.head = b3.next;
    } else {
      a2.prev.next = b3.next;
    }
    if (b3.next === null) {
      this.tail = a2.prev;
    } else {
      b3.next.prev = a2.prev;
    }
    return this;
  }
  isEmpty() {
    return this.head === null;
  }
};

// node_modules/three-stdlib/geometries/ConvexGeometry.js
var ConvexGeometry = class extends BufferGeometry {
  constructor(points = []) {
    super();
    const vertices = [];
    const normals = [];
    if (ConvexHull === void 0) {
      console.error("THREE.ConvexGeometry: ConvexGeometry relies on ConvexHull");
    }
    const convexHull = new ConvexHull().setFromPoints(points);
    const faces = convexHull.faces;
    for (let i2 = 0; i2 < faces.length; i2++) {
      const face = faces[i2];
      let edge = face.edge;
      do {
        const point = edge.head().point;
        vertices.push(point.x, point.y, point.z);
        normals.push(face.normal.x, face.normal.y, face.normal.z);
        edge = edge.next;
      } while (edge !== face.edge);
    }
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  }
};

// node_modules/three-stdlib/misc/ConvexObjectBreaker.js
var ConvexObjectBreaker = function(minSizeForBreak, smallDelta) {
  this.minSizeForBreak = minSizeForBreak || 1.4;
  this.smallDelta = smallDelta || 1e-4;
  this.tempLine1 = new Line3();
  this.tempPlane1 = new Plane();
  this.tempPlane2 = new Plane();
  this.tempPlane_Cut = new Plane();
  this.tempCM1 = new Vector3();
  this.tempCM2 = new Vector3();
  this.tempVector3 = new Vector3();
  this.tempVector3_2 = new Vector3();
  this.tempVector3_3 = new Vector3();
  this.tempVector3_P0 = new Vector3();
  this.tempVector3_P1 = new Vector3();
  this.tempVector3_P2 = new Vector3();
  this.tempVector3_N0 = new Vector3();
  this.tempVector3_N1 = new Vector3();
  this.tempVector3_AB = new Vector3();
  this.tempVector3_CB = new Vector3();
  this.tempResultObjects = {
    object1: null,
    object2: null
  };
  this.segments = [];
  var n = 30 * 30;
  for (let i2 = 0; i2 < n; i2++)
    this.segments[i2] = false;
};
ConvexObjectBreaker.prototype = {
  constructor: ConvexObjectBreaker,
  prepareBreakableObject: function(object, mass, velocity, angularVelocity, breakable) {
    if (!object.geometry.isBufferGeometry) {
      console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.");
    }
    var userData = object.userData;
    userData.mass = mass;
    userData.velocity = velocity.clone();
    userData.angularVelocity = angularVelocity.clone();
    userData.breakable = breakable;
  },
  subdivideByImpact: function(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {
    var debris = [];
    var tempPlane1 = this.tempPlane1;
    var tempPlane2 = this.tempPlane2;
    this.tempVector3.addVectors(pointOfImpact, normal);
    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);
    var maxTotalIterations = maxRandomIterations + maxRadialIterations;
    var scope2 = this;
    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {
      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {
        debris.push(subObject);
        return;
      }
      var angle = Math.PI;
      if (numIterations === 0) {
        tempPlane2.normal.copy(tempPlane1.normal);
        tempPlane2.constant = tempPlane1.constant;
      } else {
        if (numIterations <= maxRadialIterations) {
          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;
          scope2.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);
          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope2.tempVector3, scope2.tempVector3_2);
        } else {
          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;
          scope2.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);
          scope2.tempVector3_3.copy(normal).add(subObject.position);
          tempPlane2.setFromCoplanarPoints(subObject.position, scope2.tempVector3_3, scope2.tempVector3_2);
        }
      }
      scope2.cutByPlane(subObject, tempPlane2, scope2.tempResultObjects);
      var obj1 = scope2.tempResultObjects.object1;
      var obj2 = scope2.tempResultObjects.object2;
      if (obj1) {
        subdivideRadial(obj1, startAngle, angle, numIterations + 1);
      }
      if (obj2) {
        subdivideRadial(obj2, angle, endAngle, numIterations + 1);
      }
    }
    subdivideRadial(object, 0, 2 * Math.PI, 0);
    return debris;
  },
  cutByPlane: function(object, plane, output) {
    var geometry = object.geometry;
    var coords = geometry.attributes.position.array;
    var normals = geometry.attributes.normal.array;
    var numPoints = coords.length / 3;
    var numFaces = numPoints / 3;
    var indices = geometry.getIndex();
    if (indices) {
      indices = indices.array;
      numFaces = indices.length / 3;
    }
    function getVertexIndex(faceIdx, vert) {
      var idx = faceIdx * 3 + vert;
      return indices ? indices[idx] : idx;
    }
    var points1 = [];
    var points2 = [];
    var delta = this.smallDelta;
    var numPointPairs = numPoints * numPoints;
    for (let i2 = 0; i2 < numPointPairs; i2++)
      this.segments[i2] = false;
    var p0 = this.tempVector3_P0;
    var p1 = this.tempVector3_P1;
    var n0 = this.tempVector3_N0;
    var n1 = this.tempVector3_N1;
    for (let i2 = 0; i2 < numFaces - 1; i2++) {
      var a1 = getVertexIndex(i2, 0);
      var b1 = getVertexIndex(i2, 1);
      var c1 = getVertexIndex(i2, 2);
      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);
      for (let j2 = i2 + 1; j2 < numFaces; j2++) {
        var a2 = getVertexIndex(j2, 0);
        var b22 = getVertexIndex(j2, 1);
        var c2 = getVertexIndex(j2, 2);
        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);
        var coplanar = 1 - n0.dot(n1) < delta;
        if (coplanar) {
          if (a1 === a2 || a1 === b22 || a1 === c2) {
            if (b1 === a2 || b1 === b22 || b1 === c2) {
              this.segments[a1 * numPoints + b1] = true;
              this.segments[b1 * numPoints + a1] = true;
            } else {
              this.segments[c1 * numPoints + a1] = true;
              this.segments[a1 * numPoints + c1] = true;
            }
          } else if (b1 === a2 || b1 === b22 || b1 === c2) {
            this.segments[c1 * numPoints + b1] = true;
            this.segments[b1 * numPoints + c1] = true;
          }
        }
      }
    }
    var localPlane = this.tempPlane_Cut;
    object.updateMatrix();
    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane);
    for (let i2 = 0; i2 < numFaces; i2++) {
      var va = getVertexIndex(i2, 0);
      var vb = getVertexIndex(i2, 1);
      var vc = getVertexIndex(i2, 2);
      for (let segment = 0; segment < 3; segment++) {
        var i0 = segment === 0 ? va : segment === 1 ? vb : vc;
        var i1 = segment === 0 ? vb : segment === 1 ? vc : va;
        var segmentState = this.segments[i0 * numPoints + i1];
        if (segmentState)
          continue;
        this.segments[i0 * numPoints + i1] = true;
        this.segments[i1 * numPoints + i0] = true;
        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);
        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);
        var mark0 = 0;
        var d = localPlane.distanceToPoint(p0);
        if (d > delta) {
          mark0 = 2;
          points2.push(p0.clone());
        } else if (d < -delta) {
          mark0 = 1;
          points1.push(p0.clone());
        } else {
          mark0 = 3;
          points1.push(p0.clone());
          points2.push(p0.clone());
        }
        var mark1 = 0;
        var d = localPlane.distanceToPoint(p1);
        if (d > delta) {
          mark1 = 2;
          points2.push(p1.clone());
        } else if (d < -delta) {
          mark1 = 1;
          points1.push(p1.clone());
        } else {
          mark1 = 3;
          points1.push(p1.clone());
          points2.push(p1.clone());
        }
        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {
          this.tempLine1.start.copy(p0);
          this.tempLine1.end.copy(p1);
          var intersection = new Vector3();
          intersection = localPlane.intersectLine(this.tempLine1, intersection);
          if (intersection === void 0) {
            console.error("Internal error: segment does not intersect plane.");
            output.segmentedObject1 = null;
            output.segmentedObject2 = null;
            return 0;
          }
          points1.push(intersection);
          points2.push(intersection.clone());
        }
      }
    }
    var newMass = object.userData.mass * 0.5;
    this.tempCM1.set(0, 0, 0);
    var radius1 = 0;
    var numPoints1 = points1.length;
    if (numPoints1 > 0) {
      for (let i2 = 0; i2 < numPoints1; i2++)
        this.tempCM1.add(points1[i2]);
      this.tempCM1.divideScalar(numPoints1);
      for (let i2 = 0; i2 < numPoints1; i2++) {
        var p = points1[i2];
        p.sub(this.tempCM1);
        radius1 = Math.max(radius1, p.x, p.y, p.z);
      }
      this.tempCM1.add(object.position);
    }
    this.tempCM2.set(0, 0, 0);
    var radius2 = 0;
    var numPoints2 = points2.length;
    if (numPoints2 > 0) {
      for (let i2 = 0; i2 < numPoints2; i2++)
        this.tempCM2.add(points2[i2]);
      this.tempCM2.divideScalar(numPoints2);
      for (let i2 = 0; i2 < numPoints2; i2++) {
        var p = points2[i2];
        p.sub(this.tempCM2);
        radius2 = Math.max(radius2, p.x, p.y, p.z);
      }
      this.tempCM2.add(object.position);
    }
    var object1 = null;
    var object2 = null;
    var numObjects = 0;
    if (numPoints1 > 4) {
      object1 = new Mesh(new ConvexGeometry(points1), object.material);
      object1.position.copy(this.tempCM1);
      object1.quaternion.copy(object.quaternion);
      this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);
      numObjects++;
    }
    if (numPoints2 > 4) {
      object2 = new Mesh(new ConvexGeometry(points2), object.material);
      object2.position.copy(this.tempCM2);
      object2.quaternion.copy(object.quaternion);
      this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);
      numObjects++;
    }
    output.object1 = object1;
    output.object2 = object2;
    return numObjects;
  }
};
ConvexObjectBreaker.transformFreeVector = function(v, m) {
  var x = v.x, y = v.y, z = v.z;
  var e = m.elements;
  v.x = e[0] * x + e[4] * y + e[8] * z;
  v.y = e[1] * x + e[5] * y + e[9] * z;
  v.z = e[2] * x + e[6] * y + e[10] * z;
  return v;
};
ConvexObjectBreaker.transformFreeVectorInverse = function(v, m) {
  var x = v.x, y = v.y, z = v.z;
  var e = m.elements;
  v.x = e[0] * x + e[1] * y + e[2] * z;
  v.y = e[4] * x + e[5] * y + e[6] * z;
  v.z = e[8] * x + e[9] * y + e[10] * z;
  return v;
};
ConvexObjectBreaker.transformTiedVectorInverse = function(v, m) {
  var x = v.x, y = v.y, z = v.z;
  var e = m.elements;
  v.x = e[0] * x + e[1] * y + e[2] * z - e[12];
  v.y = e[4] * x + e[5] * y + e[6] * z - e[13];
  v.z = e[8] * x + e[9] * y + e[10] * z - e[14];
  return v;
};
ConvexObjectBreaker.transformPlaneToLocalSpace = function() {
  var v12 = new Vector3();
  return function transformPlaneToLocalSpace(plane, m, resultPlane) {
    resultPlane.normal.copy(plane.normal);
    resultPlane.constant = plane.constant;
    var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(v12), m);
    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m);
    resultPlane.constant = -referencePoint.dot(resultPlane.normal);
  };
}();

// node_modules/three-stdlib/misc/GPUComputationRenderer.js
var GPUComputationRenderer = function(sizeX, sizeY, renderer) {
  this.variables = [];
  this.currentTextureIndex = 0;
  var dataType = FloatType;
  var scene = new Scene();
  var camera = new Camera();
  camera.position.z = 1;
  var passThruUniforms = {
    passThruTexture: {
      value: null
    }
  };
  var passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);
  var mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader);
  scene.add(mesh);
  this.setDataType = function(type2) {
    dataType = type2;
    return this;
  };
  this.addVariable = function(variableName, computeFragmentShader, initialValueTexture) {
    var material = this.createShaderMaterial(computeFragmentShader);
    var variable = {
      name: variableName,
      initialValueTexture,
      material,
      dependencies: null,
      renderTargets: [],
      wrapS: null,
      wrapT: null,
      minFilter: NearestFilter,
      magFilter: NearestFilter
    };
    this.variables.push(variable);
    return variable;
  };
  this.setVariableDependencies = function(variable, dependencies) {
    variable.dependencies = dependencies;
  };
  this.init = function() {
    if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has("OES_texture_float") === false) {
      return "No OES_texture_float support for float textures.";
    }
    if (renderer.capabilities.maxVertexTextures === 0) {
      return "No support for vertex shader textures.";
    }
    for (let i2 = 0; i2 < this.variables.length; i2++) {
      var variable = this.variables[i2];
      variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);
      variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);
      this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);
      this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);
      var material = variable.material;
      var uniforms = material.uniforms;
      if (variable.dependencies !== null) {
        for (let d = 0; d < variable.dependencies.length; d++) {
          var depVar = variable.dependencies[d];
          if (depVar.name !== variable.name) {
            var found = false;
            for (let j2 = 0; j2 < this.variables.length; j2++) {
              if (depVar.name === this.variables[j2].name) {
                found = true;
                break;
              }
            }
            if (!found) {
              return "Variable dependency not found. Variable=" + variable.name + ", dependency=" + depVar.name;
            }
          }
          uniforms[depVar.name] = {
            value: null
          };
          material.fragmentShader = "\nuniform sampler2D " + depVar.name + ";\n" + material.fragmentShader;
        }
      }
    }
    this.currentTextureIndex = 0;
    return null;
  };
  this.compute = function() {
    var currentTextureIndex = this.currentTextureIndex;
    var nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;
    for (let i2 = 0, il = this.variables.length; i2 < il; i2++) {
      var variable = this.variables[i2];
      if (variable.dependencies !== null) {
        var uniforms = variable.material.uniforms;
        for (let d = 0, dl = variable.dependencies.length; d < dl; d++) {
          var depVar = variable.dependencies[d];
          uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;
        }
      }
      this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);
    }
    this.currentTextureIndex = nextTextureIndex;
  };
  this.getCurrentRenderTarget = function(variable) {
    return variable.renderTargets[this.currentTextureIndex];
  };
  this.getAlternateRenderTarget = function(variable) {
    return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
  };
  function addResolutionDefine(materialShader) {
    materialShader.defines.resolution = "vec2( " + sizeX.toFixed(1) + ", " + sizeY.toFixed(1) + " )";
  }
  this.addResolutionDefine = addResolutionDefine;
  function createShaderMaterial(computeFragmentShader, uniforms) {
    uniforms = uniforms || {};
    var material = new ShaderMaterial({
      uniforms,
      vertexShader: getPassThroughVertexShader(),
      fragmentShader: computeFragmentShader
    });
    addResolutionDefine(material);
    return material;
  }
  this.createShaderMaterial = createShaderMaterial;
  this.createRenderTarget = function(sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {
    sizeXTexture = sizeXTexture || sizeX;
    sizeYTexture = sizeYTexture || sizeY;
    wrapS = wrapS || ClampToEdgeWrapping;
    wrapT = wrapT || ClampToEdgeWrapping;
    minFilter = minFilter || NearestFilter;
    magFilter = magFilter || NearestFilter;
    var renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {
      wrapS,
      wrapT,
      minFilter,
      magFilter,
      format: RGBAFormat,
      type: dataType,
      depthBuffer: false
    });
    return renderTarget;
  };
  this.createTexture = function() {
    var data = new Float32Array(sizeX * sizeY * 4);
    return new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType);
  };
  this.renderTexture = function(input, output) {
    passThruUniforms.passThruTexture.value = input;
    this.doRenderTarget(passThruShader, output);
    passThruUniforms.passThruTexture.value = null;
  };
  this.doRenderTarget = function(material, output) {
    var currentRenderTarget = renderer.getRenderTarget();
    mesh.material = material;
    renderer.setRenderTarget(output);
    renderer.render(scene, camera);
    mesh.material = passThruShader;
    renderer.setRenderTarget(currentRenderTarget);
  };
  function getPassThroughVertexShader() {
    return "void main()	{\n\n	gl_Position = vec4( position, 1.0 );\n\n}\n";
  }
  function getPassThroughFragmentShader() {
    return "uniform sampler2D passThruTexture;\n\nvoid main() {\n\n	vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n	gl_FragColor = texture2D( passThruTexture, uv );\n\n}\n";
  }
};

// node_modules/three-stdlib/misc/Gyroscope.js
var Gyroscope = function() {
  Object3D.call(this);
};
Gyroscope.prototype = Object.create(Object3D.prototype);
Gyroscope.prototype.constructor = Gyroscope;
Gyroscope.prototype.updateMatrixWorld = function() {
  var translationObject = new Vector3();
  var quaternionObject = new Quaternion();
  var scaleObject = new Vector3();
  var translationWorld = new Vector3();
  var quaternionWorld = new Quaternion();
  var scaleWorld = new Vector3();
  return function updateMatrixWorld(force) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent !== null) {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        this.matrixWorld.decompose(translationWorld, quaternionWorld, scaleWorld);
        this.matrix.decompose(translationObject, quaternionObject, scaleObject);
        this.matrixWorld.compose(translationWorld, quaternionObject, scaleWorld);
      } else {
        this.matrixWorld.copy(this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    for (let i2 = 0, l = this.children.length; i2 < l; i2++) {
      this.children[i2].updateMatrixWorld(force);
    }
  };
}();

// node_modules/three-stdlib/misc/MorphAnimMesh.js
var MorphAnimMesh = function(geometry, material) {
  Mesh.call(this, geometry, material);
  this.type = "MorphAnimMesh";
  this.mixer = new AnimationMixer(this);
  this.activeAction = null;
};
MorphAnimMesh.prototype = Object.create(Mesh.prototype);
MorphAnimMesh.prototype.constructor = MorphAnimMesh;
MorphAnimMesh.prototype.setDirectionForward = function() {
  this.mixer.timeScale = 1;
};
MorphAnimMesh.prototype.setDirectionBackward = function() {
  this.mixer.timeScale = -1;
};
MorphAnimMesh.prototype.playAnimation = function(label2, fps) {
  if (this.activeAction) {
    this.activeAction.stop();
    this.activeAction = null;
  }
  var clip = AnimationClip.findByName(this, label2);
  if (clip) {
    var action = this.mixer.clipAction(clip);
    action.timeScale = clip.tracks.length * fps / clip.duration;
    this.activeAction = action.play();
  } else {
    throw new Error("THREE.MorphAnimMesh: animations[" + label2 + "] undefined in .playAnimation()");
  }
};
MorphAnimMesh.prototype.updateAnimation = function(delta) {
  this.mixer.update(delta);
};
MorphAnimMesh.prototype.copy = function(source) {
  Mesh.prototype.copy.call(this, source);
  this.mixer = new AnimationMixer(this);
  return this;
};

// node_modules/three-stdlib/misc/RollerCoaster.js
var RollerCoasterGeometry = function(curve, divisions) {
  BufferGeometry.call(this);
  var vertices = [];
  var normals = [];
  var colors = [];
  var color1 = [1, 1, 1];
  var color2 = [1, 1, 0];
  var up = new Vector3(0, 1, 0);
  var forward = new Vector3();
  var right = new Vector3();
  var quaternion = new Quaternion();
  var prevQuaternion = new Quaternion();
  prevQuaternion.setFromAxisAngle(up, Math.PI / 2);
  var point = new Vector3();
  var prevPoint = new Vector3();
  prevPoint.copy(curve.getPointAt(0));
  var step2 = [new Vector3(-0.225, 0, 0), new Vector3(0, -0.05, 0), new Vector3(0, -0.175, 0), new Vector3(0, -0.05, 0), new Vector3(0.225, 0, 0), new Vector3(0, -0.175, 0)];
  var PI2 = Math.PI * 2;
  var sides = 5;
  var tube1 = [];
  for (let i2 = 0; i2 < sides; i2++) {
    var angle = i2 / sides * PI2;
    tube1.push(new Vector3(Math.sin(angle) * 0.06, Math.cos(angle) * 0.06, 0));
  }
  var sides = 6;
  var tube2 = [];
  for (let i2 = 0; i2 < sides; i2++) {
    var angle = i2 / sides * PI2;
    tube2.push(new Vector3(Math.sin(angle) * 0.025, Math.cos(angle) * 0.025, 0));
  }
  var vector2 = new Vector3();
  var normal = new Vector3();
  function drawShape(shape, color3) {
    normal.set(0, 0, -1).applyQuaternion(quaternion);
    for (let j2 = 0; j2 < shape.length; j2++) {
      vector2.copy(shape[j2]);
      vector2.applyQuaternion(quaternion);
      vector2.add(point);
      vertices.push(vector2.x, vector2.y, vector2.z);
      normals.push(normal.x, normal.y, normal.z);
      colors.push(color3[0], color3[1], color3[2]);
    }
    normal.set(0, 0, 1).applyQuaternion(quaternion);
    for (let j2 = shape.length - 1; j2 >= 0; j2--) {
      vector2.copy(shape[j2]);
      vector2.applyQuaternion(quaternion);
      vector2.add(point);
      vertices.push(vector2.x, vector2.y, vector2.z);
      normals.push(normal.x, normal.y, normal.z);
      colors.push(color3[0], color3[1], color3[2]);
    }
  }
  var vector1 = new Vector3();
  var vector22 = new Vector3();
  var vector3 = new Vector3();
  var vector4 = new Vector3();
  var normal1 = new Vector3();
  var normal2 = new Vector3();
  var normal3 = new Vector3();
  var normal4 = new Vector3();
  function extrudeShape(shape, offset2, color3) {
    for (let j2 = 0, jl2 = shape.length; j2 < jl2; j2++) {
      var point1 = shape[j2];
      var point2 = shape[(j2 + 1) % jl2];
      vector1.copy(point1).add(offset2);
      vector1.applyQuaternion(quaternion);
      vector1.add(point);
      vector22.copy(point2).add(offset2);
      vector22.applyQuaternion(quaternion);
      vector22.add(point);
      vector3.copy(point2).add(offset2);
      vector3.applyQuaternion(prevQuaternion);
      vector3.add(prevPoint);
      vector4.copy(point1).add(offset2);
      vector4.applyQuaternion(prevQuaternion);
      vector4.add(prevPoint);
      vertices.push(vector1.x, vector1.y, vector1.z);
      vertices.push(vector22.x, vector22.y, vector22.z);
      vertices.push(vector4.x, vector4.y, vector4.z);
      vertices.push(vector22.x, vector22.y, vector22.z);
      vertices.push(vector3.x, vector3.y, vector3.z);
      vertices.push(vector4.x, vector4.y, vector4.z);
      normal1.copy(point1);
      normal1.applyQuaternion(quaternion);
      normal1.normalize();
      normal2.copy(point2);
      normal2.applyQuaternion(quaternion);
      normal2.normalize();
      normal3.copy(point2);
      normal3.applyQuaternion(prevQuaternion);
      normal3.normalize();
      normal4.copy(point1);
      normal4.applyQuaternion(prevQuaternion);
      normal4.normalize();
      normals.push(normal1.x, normal1.y, normal1.z);
      normals.push(normal2.x, normal2.y, normal2.z);
      normals.push(normal4.x, normal4.y, normal4.z);
      normals.push(normal2.x, normal2.y, normal2.z);
      normals.push(normal3.x, normal3.y, normal3.z);
      normals.push(normal4.x, normal4.y, normal4.z);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
    }
  }
  var offset = new Vector3();
  for (let i2 = 1; i2 <= divisions; i2++) {
    point.copy(curve.getPointAt(i2 / divisions));
    up.set(0, 1, 0);
    forward.subVectors(point, prevPoint).normalize();
    right.crossVectors(up, forward).normalize();
    up.crossVectors(forward, right);
    var angle = Math.atan2(forward.x, forward.z);
    quaternion.setFromAxisAngle(up, angle);
    if (i2 % 2 === 0) {
      drawShape(step2, color2);
    }
    extrudeShape(tube1, offset.set(0, -0.125, 0), color2);
    extrudeShape(tube2, offset.set(0.2, 0, 0), color1);
    extrudeShape(tube2, offset.set(-0.2, 0, 0), color1);
    prevPoint.copy(point);
    prevQuaternion.copy(quaternion);
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
  this.setAttribute("normal", new BufferAttribute(new Float32Array(normals), 3));
  this.setAttribute("color", new BufferAttribute(new Float32Array(colors), 3));
};
RollerCoasterGeometry.prototype = Object.create(BufferGeometry.prototype);
var RollerCoasterLiftersGeometry = function(curve, divisions) {
  BufferGeometry.call(this);
  var vertices = [];
  var normals = [];
  var quaternion = new Quaternion();
  var up = new Vector3(0, 1, 0);
  var point = new Vector3();
  var tangent = new Vector3();
  var tube1 = [new Vector3(0, 0.05, -0.05), new Vector3(0, 0.05, 0.05), new Vector3(0, -0.05, 0)];
  var tube2 = [new Vector3(-0.05, 0, 0.05), new Vector3(-0.05, 0, -0.05), new Vector3(0.05, 0, 0)];
  var tube3 = [new Vector3(0.05, 0, -0.05), new Vector3(0.05, 0, 0.05), new Vector3(-0.05, 0, 0)];
  var vector1 = new Vector3();
  var vector2 = new Vector3();
  var vector3 = new Vector3();
  var vector4 = new Vector3();
  var normal1 = new Vector3();
  var normal2 = new Vector3();
  var normal3 = new Vector3();
  var normal4 = new Vector3();
  function extrudeShape(shape, fromPoint2, toPoint2) {
    for (let j2 = 0, jl2 = shape.length; j2 < jl2; j2++) {
      var point1 = shape[j2];
      var point2 = shape[(j2 + 1) % jl2];
      vector1.copy(point1);
      vector1.applyQuaternion(quaternion);
      vector1.add(fromPoint2);
      vector2.copy(point2);
      vector2.applyQuaternion(quaternion);
      vector2.add(fromPoint2);
      vector3.copy(point2);
      vector3.applyQuaternion(quaternion);
      vector3.add(toPoint2);
      vector4.copy(point1);
      vector4.applyQuaternion(quaternion);
      vector4.add(toPoint2);
      vertices.push(vector1.x, vector1.y, vector1.z);
      vertices.push(vector2.x, vector2.y, vector2.z);
      vertices.push(vector4.x, vector4.y, vector4.z);
      vertices.push(vector2.x, vector2.y, vector2.z);
      vertices.push(vector3.x, vector3.y, vector3.z);
      vertices.push(vector4.x, vector4.y, vector4.z);
      normal1.copy(point1);
      normal1.applyQuaternion(quaternion);
      normal1.normalize();
      normal2.copy(point2);
      normal2.applyQuaternion(quaternion);
      normal2.normalize();
      normal3.copy(point2);
      normal3.applyQuaternion(quaternion);
      normal3.normalize();
      normal4.copy(point1);
      normal4.applyQuaternion(quaternion);
      normal4.normalize();
      normals.push(normal1.x, normal1.y, normal1.z);
      normals.push(normal2.x, normal2.y, normal2.z);
      normals.push(normal4.x, normal4.y, normal4.z);
      normals.push(normal2.x, normal2.y, normal2.z);
      normals.push(normal3.x, normal3.y, normal3.z);
      normals.push(normal4.x, normal4.y, normal4.z);
    }
  }
  var fromPoint = new Vector3();
  var toPoint = new Vector3();
  for (let i2 = 1; i2 <= divisions; i2++) {
    point.copy(curve.getPointAt(i2 / divisions));
    tangent.copy(curve.getTangentAt(i2 / divisions));
    var angle = Math.atan2(tangent.x, tangent.z);
    quaternion.setFromAxisAngle(up, angle);
    if (point.y > 10) {
      fromPoint.set(-0.75, -0.35, 0);
      fromPoint.applyQuaternion(quaternion);
      fromPoint.add(point);
      toPoint.set(0.75, -0.35, 0);
      toPoint.applyQuaternion(quaternion);
      toPoint.add(point);
      extrudeShape(tube1, fromPoint, toPoint);
      fromPoint.set(-0.7, -0.3, 0);
      fromPoint.applyQuaternion(quaternion);
      fromPoint.add(point);
      toPoint.set(-0.7, -point.y, 0);
      toPoint.applyQuaternion(quaternion);
      toPoint.add(point);
      extrudeShape(tube2, fromPoint, toPoint);
      fromPoint.set(0.7, -0.3, 0);
      fromPoint.applyQuaternion(quaternion);
      fromPoint.add(point);
      toPoint.set(0.7, -point.y, 0);
      toPoint.applyQuaternion(quaternion);
      toPoint.add(point);
      extrudeShape(tube3, fromPoint, toPoint);
    } else {
      fromPoint.set(0, -0.2, 0);
      fromPoint.applyQuaternion(quaternion);
      fromPoint.add(point);
      toPoint.set(0, -point.y, 0);
      toPoint.applyQuaternion(quaternion);
      toPoint.add(point);
      extrudeShape(tube3, fromPoint, toPoint);
    }
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
  this.setAttribute("normal", new BufferAttribute(new Float32Array(normals), 3));
};
RollerCoasterLiftersGeometry.prototype = Object.create(BufferGeometry.prototype);
var RollerCoasterShadowGeometry = function(curve, divisions) {
  BufferGeometry.call(this);
  var vertices = [];
  var up = new Vector3(0, 1, 0);
  var forward = new Vector3();
  var quaternion = new Quaternion();
  var prevQuaternion = new Quaternion();
  prevQuaternion.setFromAxisAngle(up, Math.PI / 2);
  var point = new Vector3();
  var prevPoint = new Vector3();
  prevPoint.copy(curve.getPointAt(0));
  prevPoint.y = 0;
  var vector1 = new Vector3();
  var vector2 = new Vector3();
  var vector3 = new Vector3();
  var vector4 = new Vector3();
  for (let i2 = 1; i2 <= divisions; i2++) {
    point.copy(curve.getPointAt(i2 / divisions));
    point.y = 0;
    forward.subVectors(point, prevPoint);
    var angle = Math.atan2(forward.x, forward.z);
    quaternion.setFromAxisAngle(up, angle);
    vector1.set(-0.3, 0, 0);
    vector1.applyQuaternion(quaternion);
    vector1.add(point);
    vector2.set(0.3, 0, 0);
    vector2.applyQuaternion(quaternion);
    vector2.add(point);
    vector3.set(0.3, 0, 0);
    vector3.applyQuaternion(prevQuaternion);
    vector3.add(prevPoint);
    vector4.set(-0.3, 0, 0);
    vector4.applyQuaternion(prevQuaternion);
    vector4.add(prevPoint);
    vertices.push(vector1.x, vector1.y, vector1.z);
    vertices.push(vector2.x, vector2.y, vector2.z);
    vertices.push(vector4.x, vector4.y, vector4.z);
    vertices.push(vector2.x, vector2.y, vector2.z);
    vertices.push(vector3.x, vector3.y, vector3.z);
    vertices.push(vector4.x, vector4.y, vector4.z);
    prevPoint.copy(point);
    prevQuaternion.copy(quaternion);
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
};
RollerCoasterShadowGeometry.prototype = Object.create(BufferGeometry.prototype);
var SkyGeometry = function() {
  BufferGeometry.call(this);
  var vertices = [];
  for (let i2 = 0; i2 < 100; i2++) {
    var x = Math.random() * 800 - 400;
    var y = Math.random() * 50 + 50;
    var z = Math.random() * 800 - 400;
    var size2 = Math.random() * 40 + 20;
    vertices.push(x - size2, y, z - size2);
    vertices.push(x + size2, y, z - size2);
    vertices.push(x - size2, y, z + size2);
    vertices.push(x + size2, y, z - size2);
    vertices.push(x + size2, y, z + size2);
    vertices.push(x - size2, y, z + size2);
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
};
SkyGeometry.prototype = Object.create(BufferGeometry.prototype);
var TreesGeometry = function(landscape) {
  BufferGeometry.call(this);
  var vertices = [];
  var colors = [];
  var raycaster = new Raycaster();
  raycaster.ray.direction.set(0, -1, 0);
  for (let i2 = 0; i2 < 2e3; i2++) {
    var x = Math.random() * 500 - 250;
    var z = Math.random() * 500 - 250;
    raycaster.ray.origin.set(x, 50, z);
    var intersections = raycaster.intersectObject(landscape);
    if (intersections.length === 0)
      continue;
    var y = intersections[0].point.y;
    var height = Math.random() * 5 + 0.5;
    var angle = Math.random() * Math.PI * 2;
    vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));
    vertices.push(x, y + height, z);
    vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));
    angle += Math.PI / 2;
    vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));
    vertices.push(x, y + height, z);
    vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));
    var random = Math.random() * 0.1;
    for (let j2 = 0; j2 < 6; j2++) {
      colors.push(0.2 + random, 0.4 + random, 0);
    }
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
  this.setAttribute("color", new BufferAttribute(new Float32Array(colors), 3));
};
TreesGeometry.prototype = Object.create(BufferGeometry.prototype);

// node_modules/three-stdlib/misc/WebGL.js
var webGLAvailable;
var webGL2Available;
function isWebGLAvailable() {
  if (webGLAvailable !== void 0)
    return webGLAvailable;
  try {
    var _gl$getExtension;
    let gl;
    const canvas = document.createElement("canvas");
    webGLAvailable = !!(window.WebGLRenderingContext && (gl = canvas.getContext("webgl")));
    if (gl)
      (_gl$getExtension = gl.getExtension("WEBGL_lose_context")) === null || _gl$getExtension === void 0 ? void 0 : _gl$getExtension.loseContext();
    return webGLAvailable;
  } catch (e) {
    return webGLAvailable = false;
  }
}
function isWebGL2Available() {
  if (webGL2Available !== void 0)
    return webGL2Available;
  try {
    var _gl$getExtension2;
    let gl;
    const canvas = document.createElement("canvas");
    webGL2Available = !!(window.WebGL2RenderingContext && (gl = canvas.getContext("webgl2")));
    if (gl)
      (_gl$getExtension2 = gl.getExtension("WEBGL_lose_context")) === null || _gl$getExtension2 === void 0 ? void 0 : _gl$getExtension2.loseContext();
    return webGL2Available;
  } catch (e) {
    return webGL2Available = false;
  }
}
function getWebGLErrorMessage() {
  return this.getErrorMessage(1);
}
function getWebGL2ErrorMessage() {
  return this.getErrorMessage(2);
}
function getErrorMessage(version) {
  const names = {
    1: "WebGL",
    2: "WebGL 2"
  };
  const contexts = {
    1: window.WebGLRenderingContext,
    2: window.WebGL2RenderingContext
  };
  const element2 = document.createElement("div");
  element2.id = "webglmessage";
  element2.style.fontFamily = "monospace";
  element2.style.fontSize = "13px";
  element2.style.fontWeight = "normal";
  element2.style.textAlign = "center";
  element2.style.background = "#fff";
  element2.style.color = "#000";
  element2.style.padding = "1.5em";
  element2.style.width = "400px";
  element2.style.margin = "5em auto 0";
  let message = 'Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>';
  if (contexts[version]) {
    message = message.replace("$0", "graphics card");
  } else {
    message = message.replace("$0", "browser");
  }
  message = message.replace("$1", names[version]);
  element2.innerHTML = message;
  return element2;
}

// node_modules/three-stdlib/misc/MD2Character.js
var MD2Character = function() {
  var scope2 = this;
  this.scale = 1;
  this.animationFPS = 6;
  this.root = new Object3D();
  this.meshBody = null;
  this.meshWeapon = null;
  this.skinsBody = [];
  this.skinsWeapon = [];
  this.weapons = [];
  this.activeAnimation = null;
  this.mixer = null;
  this.onLoadComplete = function() {
  };
  this.loadCounter = 0;
  this.loadParts = function(config) {
    this.loadCounter = config.weapons.length * 2 + config.skins.length + 1;
    var weaponsTextures = [];
    for (let i2 = 0; i2 < config.weapons.length; i2++)
      weaponsTextures[i2] = config.weapons[i2][1];
    this.skinsBody = loadTextures(config.baseUrl + "skins/", config.skins);
    this.skinsWeapon = loadTextures(config.baseUrl + "skins/", weaponsTextures);
    var loader = new MD2Loader();
    loader.load(config.baseUrl + config.body, function(geo) {
      var boundingBox = new Box3();
      boundingBox.setFromBufferAttribute(geo.attributes.position);
      scope2.root.position.y = -scope2.scale * boundingBox.min.y;
      var mesh = createPart(geo, scope2.skinsBody[0]);
      mesh.scale.set(scope2.scale, scope2.scale, scope2.scale);
      scope2.root.add(mesh);
      scope2.meshBody = mesh;
      scope2.meshBody.clipOffset = 0;
      scope2.activeAnimationClipName = mesh.geometry.animations[0].name;
      scope2.mixer = new AnimationMixer(mesh);
      checkLoadingComplete();
    });
    var generateCallback = function(index, name) {
      return function(geo) {
        var mesh = createPart(geo, scope2.skinsWeapon[index]);
        mesh.scale.set(scope2.scale, scope2.scale, scope2.scale);
        mesh.visible = false;
        mesh.name = name;
        scope2.root.add(mesh);
        scope2.weapons[index] = mesh;
        scope2.meshWeapon = mesh;
        checkLoadingComplete();
      };
    };
    for (let i2 = 0; i2 < config.weapons.length; i2++) {
      loader.load(config.baseUrl + config.weapons[i2][0], generateCallback(i2, config.weapons[i2][0]));
    }
  };
  this.setPlaybackRate = function(rate) {
    if (rate !== 0) {
      this.mixer.timeScale = 1 / rate;
    } else {
      this.mixer.timeScale = 0;
    }
  };
  this.setWireframe = function(wireframeEnabled) {
    if (wireframeEnabled) {
      if (this.meshBody)
        this.meshBody.material = this.meshBody.materialWireframe;
      if (this.meshWeapon)
        this.meshWeapon.material = this.meshWeapon.materialWireframe;
    } else {
      if (this.meshBody)
        this.meshBody.material = this.meshBody.materialTexture;
      if (this.meshWeapon)
        this.meshWeapon.material = this.meshWeapon.materialTexture;
    }
  };
  this.setSkin = function(index) {
    if (this.meshBody && this.meshBody.material.wireframe === false) {
      this.meshBody.material.map = this.skinsBody[index];
    }
  };
  this.setWeapon = function(index) {
    for (let i2 = 0; i2 < this.weapons.length; i2++)
      this.weapons[i2].visible = false;
    var activeWeapon = this.weapons[index];
    if (activeWeapon) {
      activeWeapon.visible = true;
      this.meshWeapon = activeWeapon;
      scope2.syncWeaponAnimation();
    }
  };
  this.setAnimation = function(clipName) {
    if (this.meshBody) {
      if (this.meshBody.activeAction) {
        this.meshBody.activeAction.stop();
        this.meshBody.activeAction = null;
      }
      var action = this.mixer.clipAction(clipName, this.meshBody);
      if (action) {
        this.meshBody.activeAction = action.play();
      }
    }
    scope2.activeClipName = clipName;
    scope2.syncWeaponAnimation();
  };
  this.syncWeaponAnimation = function() {
    var clipName = scope2.activeClipName;
    if (scope2.meshWeapon) {
      if (this.meshWeapon.activeAction) {
        this.meshWeapon.activeAction.stop();
        this.meshWeapon.activeAction = null;
      }
      var action = this.mixer.clipAction(clipName, this.meshWeapon);
      if (action) {
        this.meshWeapon.activeAction = action.syncWith(this.meshBody.activeAction).play();
      }
    }
  };
  this.update = function(delta) {
    if (this.mixer)
      this.mixer.update(delta);
  };
  function loadTextures(baseUrl, textureUrls) {
    var textureLoader = new TextureLoader();
    var textures = [];
    for (let i2 = 0; i2 < textureUrls.length; i2++) {
      textures[i2] = textureLoader.load(baseUrl + textureUrls[i2], checkLoadingComplete);
      textures[i2].mapping = UVMapping;
      textures[i2].name = textureUrls[i2];
      textures[i2].encoding = sRGBEncoding;
    }
    return textures;
  }
  function createPart(geometry, skinMap) {
    var materialWireframe = new MeshLambertMaterial({
      color: 16755200,
      wireframe: true,
      morphTargets: true,
      morphNormals: true
    });
    var materialTexture = new MeshLambertMaterial({
      color: 16777215,
      wireframe: false,
      map: skinMap,
      morphTargets: true,
      morphNormals: true
    });
    var mesh = new Mesh(geometry, materialTexture);
    mesh.rotation.y = -Math.PI / 2;
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mesh.materialTexture = materialTexture;
    mesh.materialWireframe = materialWireframe;
    return mesh;
  }
  function checkLoadingComplete() {
    scope2.loadCounter -= 1;
    if (scope2.loadCounter === 0)
      scope2.onLoadComplete();
  }
};

// node_modules/three-stdlib/misc/VolumeSlice.js
var VolumeSlice = function(volume, index, axis) {
  var slice2 = this;
  this.volume = volume;
  index = index || 0;
  Object.defineProperty(this, "index", {
    get: function() {
      return index;
    },
    set: function(value) {
      index = value;
      slice2.geometryNeedsUpdate = true;
      return index;
    }
  });
  this.axis = axis || "z";
  this.canvas = document.createElement("canvas");
  this.canvasBuffer = document.createElement("canvas");
  this.updateGeometry();
  var canvasMap = new Texture(this.canvas);
  canvasMap.minFilter = LinearFilter;
  canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;
  var material = new MeshBasicMaterial({
    map: canvasMap,
    side: DoubleSide,
    transparent: true
  });
  this.mesh = new Mesh(this.geometry, material);
  this.mesh.matrixAutoUpdate = false;
  this.geometryNeedsUpdate = true;
  this.repaint();
};
VolumeSlice.prototype = {
  constructor: VolumeSlice,
  repaint: function() {
    if (this.geometryNeedsUpdate) {
      this.updateGeometry();
    }
    var iLength = this.iLength, jLength = this.jLength, sliceAccess = this.sliceAccess, volume = this.volume, canvas = this.canvasBuffer, ctx = this.ctxBuffer;
    var imgData = ctx.getImageData(0, 0, iLength, jLength);
    var data = imgData.data;
    var volumeData = volume.data;
    var upperThreshold = volume.upperThreshold;
    var lowerThreshold = volume.lowerThreshold;
    var windowLow = volume.windowLow;
    var windowHigh = volume.windowHigh;
    var pixelCount = 0;
    if (volume.dataType === "label") {
      for (let j2 = 0; j2 < jLength; j2++) {
        for (let i2 = 0; i2 < iLength; i2++) {
          var label2 = volumeData[sliceAccess(i2, j2)];
          label2 = label2 >= this.colorMap.length ? label2 % this.colorMap.length + 1 : label2;
          var color2 = this.colorMap[label2];
          data[4 * pixelCount] = color2 >> 24 & 255;
          data[4 * pixelCount + 1] = color2 >> 16 & 255;
          data[4 * pixelCount + 2] = color2 >> 8 & 255;
          data[4 * pixelCount + 3] = color2 & 255;
          pixelCount++;
        }
      }
    } else {
      for (let j2 = 0; j2 < jLength; j2++) {
        for (let i2 = 0; i2 < iLength; i2++) {
          var value = volumeData[sliceAccess(i2, j2)];
          var alpha = 255;
          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0;
          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));
          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;
          data[4 * pixelCount] = value;
          data[4 * pixelCount + 1] = value;
          data[4 * pixelCount + 2] = value;
          data[4 * pixelCount + 3] = alpha;
          pixelCount++;
        }
      }
    }
    ctx.putImageData(imgData, 0, 0);
    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);
    this.mesh.material.map.needsUpdate = true;
  },
  updateGeometry: function() {
    var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);
    this.sliceAccess = extracted.sliceAccess;
    this.jLength = extracted.jLength;
    this.iLength = extracted.iLength;
    this.matrix = extracted.matrix;
    this.canvas.width = extracted.planeWidth;
    this.canvas.height = extracted.planeHeight;
    this.canvasBuffer.width = this.iLength;
    this.canvasBuffer.height = this.jLength;
    this.ctx = this.canvas.getContext("2d");
    this.ctxBuffer = this.canvasBuffer.getContext("2d");
    if (this.geometry)
      this.geometry.dispose();
    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);
    if (this.mesh) {
      this.mesh.geometry = this.geometry;
      this.mesh.matrix.identity();
      this.mesh.applyMatrix4(this.matrix);
    }
    this.geometryNeedsUpdate = false;
  }
};

// node_modules/three-stdlib/misc/TubePainter.js
function TubePainter() {
  const BUFFER_SIZE = 1e6 * 3;
  const positions = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3);
  positions.usage = DynamicDrawUsage;
  const normals = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3);
  normals.usage = DynamicDrawUsage;
  const colors = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3);
  colors.usage = DynamicDrawUsage;
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", positions);
  geometry.setAttribute("normal", normals);
  geometry.setAttribute("color", colors);
  geometry.drawRange.count = 0;
  const material = new MeshStandardMaterial({
    vertexColors: true
  });
  const mesh = new Mesh(geometry, material);
  mesh.frustumCulled = false;
  function getPoints(size3) {
    const PI2 = Math.PI * 2;
    const sides = 10;
    const array = [];
    const radius = 0.01 * size3;
    for (let i2 = 0; i2 < sides; i2++) {
      const angle = i2 / sides * PI2;
      array.push(new Vector3(Math.sin(angle) * radius, Math.cos(angle) * radius, 0));
    }
    return array;
  }
  const vector1 = new Vector3();
  const vector2 = new Vector3();
  const vector3 = new Vector3();
  const vector4 = new Vector3();
  const color2 = new Color(16777215);
  let size2 = 1;
  function stroke(position1, position2, matrix12, matrix23) {
    if (position1.distanceToSquared(position2) === 0)
      return;
    let count2 = geometry.drawRange.count;
    const points = getPoints(size2);
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      const vertex1 = points[i2];
      const vertex2 = points[(i2 + 1) % il];
      vector1.copy(vertex1).applyMatrix4(matrix23).add(position2);
      vector2.copy(vertex2).applyMatrix4(matrix23).add(position2);
      vector3.copy(vertex2).applyMatrix4(matrix12).add(position1);
      vector4.copy(vertex1).applyMatrix4(matrix12).add(position1);
      vector1.toArray(positions.array, (count2 + 0) * 3);
      vector2.toArray(positions.array, (count2 + 1) * 3);
      vector4.toArray(positions.array, (count2 + 2) * 3);
      vector2.toArray(positions.array, (count2 + 3) * 3);
      vector3.toArray(positions.array, (count2 + 4) * 3);
      vector4.toArray(positions.array, (count2 + 5) * 3);
      vector1.copy(vertex1).applyMatrix4(matrix23).normalize();
      vector2.copy(vertex2).applyMatrix4(matrix23).normalize();
      vector3.copy(vertex2).applyMatrix4(matrix12).normalize();
      vector4.copy(vertex1).applyMatrix4(matrix12).normalize();
      vector1.toArray(normals.array, (count2 + 0) * 3);
      vector2.toArray(normals.array, (count2 + 1) * 3);
      vector4.toArray(normals.array, (count2 + 2) * 3);
      vector2.toArray(normals.array, (count2 + 3) * 3);
      vector3.toArray(normals.array, (count2 + 4) * 3);
      vector4.toArray(normals.array, (count2 + 5) * 3);
      color2.toArray(colors.array, (count2 + 0) * 3);
      color2.toArray(colors.array, (count2 + 1) * 3);
      color2.toArray(colors.array, (count2 + 2) * 3);
      color2.toArray(colors.array, (count2 + 3) * 3);
      color2.toArray(colors.array, (count2 + 4) * 3);
      color2.toArray(colors.array, (count2 + 5) * 3);
      count2 += 6;
    }
    geometry.drawRange.count = count2;
  }
  const up = new Vector3(0, 1, 0);
  const point1 = new Vector3();
  const point2 = new Vector3();
  const matrix1 = new Matrix4();
  const matrix22 = new Matrix4();
  function moveTo(position) {
    point1.copy(position);
    matrix1.lookAt(point2, point1, up);
    point2.copy(position);
    matrix22.copy(matrix1);
  }
  function lineTo(position) {
    point1.copy(position);
    matrix1.lookAt(point2, point1, up);
    stroke(point1, point2, matrix1, matrix22);
    point2.copy(point1);
    matrix22.copy(matrix1);
  }
  function setSize(value) {
    size2 = value;
  }
  let count = 0;
  function update() {
    const start = count;
    const end = geometry.drawRange.count;
    if (start === end)
      return;
    positions.updateRange.offset = start * 3;
    positions.updateRange.count = (end - start) * 3;
    positions.needsUpdate = true;
    normals.updateRange.offset = start * 3;
    normals.updateRange.count = (end - start) * 3;
    normals.needsUpdate = true;
    colors.updateRange.offset = start * 3;
    colors.updateRange.count = (end - start) * 3;
    colors.needsUpdate = true;
    count = geometry.drawRange.count;
  }
  return {
    mesh,
    moveTo,
    lineTo,
    setSize,
    update
  };
}

// node_modules/three-stdlib/misc/Volume.js
var Volume = function(xLength, yLength, zLength, type2, arrayBuffer) {
  if (arguments.length > 0) {
    this.xLength = Number(xLength) || 1;
    this.yLength = Number(yLength) || 1;
    this.zLength = Number(zLength) || 1;
    switch (type2) {
      case "Uint8":
      case "uint8":
      case "uchar":
      case "unsigned char":
      case "uint8_t":
        this.data = new Uint8Array(arrayBuffer);
        break;
      case "Int8":
      case "int8":
      case "signed char":
      case "int8_t":
        this.data = new Int8Array(arrayBuffer);
        break;
      case "Int16":
      case "int16":
      case "short":
      case "short int":
      case "signed short":
      case "signed short int":
      case "int16_t":
        this.data = new Int16Array(arrayBuffer);
        break;
      case "Uint16":
      case "uint16":
      case "ushort":
      case "unsigned short":
      case "unsigned short int":
      case "uint16_t":
        this.data = new Uint16Array(arrayBuffer);
        break;
      case "Int32":
      case "int32":
      case "int":
      case "signed int":
      case "int32_t":
        this.data = new Int32Array(arrayBuffer);
        break;
      case "Uint32":
      case "uint32":
      case "uint":
      case "unsigned int":
      case "uint32_t":
        this.data = new Uint32Array(arrayBuffer);
        break;
      case "longlong":
      case "long long":
      case "long long int":
      case "signed long long":
      case "signed long long int":
      case "int64":
      case "int64_t":
      case "ulonglong":
      case "unsigned long long":
      case "unsigned long long int":
      case "uint64":
      case "uint64_t":
        throw "Error in Volume constructor : this type is not supported in JavaScript";
      case "Float32":
      case "float32":
      case "float":
        this.data = new Float32Array(arrayBuffer);
        break;
      case "Float64":
      case "float64":
      case "double":
        this.data = new Float64Array(arrayBuffer);
        break;
      default:
        this.data = new Uint8Array(arrayBuffer);
    }
    if (this.data.length !== this.xLength * this.yLength * this.zLength) {
      throw "Error in Volume constructor, lengths are not matching arrayBuffer size";
    }
  }
  this.spacing = [1, 1, 1];
  this.offset = [0, 0, 0];
  this.matrix = new Matrix3();
  this.matrix.identity();
  var lowerThreshold = -Infinity;
  Object.defineProperty(this, "lowerThreshold", {
    get: function() {
      return lowerThreshold;
    },
    set: function(value) {
      lowerThreshold = value;
      this.sliceList.forEach(function(slice2) {
        slice2.geometryNeedsUpdate = true;
      });
    }
  });
  var upperThreshold = Infinity;
  Object.defineProperty(this, "upperThreshold", {
    get: function() {
      return upperThreshold;
    },
    set: function(value) {
      upperThreshold = value;
      this.sliceList.forEach(function(slice2) {
        slice2.geometryNeedsUpdate = true;
      });
    }
  });
  this.sliceList = [];
};
Volume.prototype = {
  constructor: Volume,
  getData: function(i2, j2, k) {
    return this.data[k * this.xLength * this.yLength + j2 * this.xLength + i2];
  },
  access: function(i2, j2, k) {
    return k * this.xLength * this.yLength + j2 * this.xLength + i2;
  },
  reverseAccess: function(index) {
    var z = Math.floor(index / (this.yLength * this.xLength));
    var y = Math.floor((index - z * this.yLength * this.xLength) / this.xLength);
    var x = index - z * this.yLength * this.xLength - y * this.xLength;
    return [x, y, z];
  },
  map: function(functionToMap, context) {
    var length2 = this.data.length;
    context = context || this;
    for (let i2 = 0; i2 < length2; i2++) {
      this.data[i2] = functionToMap.call(context, this.data[i2], i2, this.data);
    }
    return this;
  },
  extractPerpendicularPlane: function(axis, RASIndex) {
    var iLength, jLength, sliceAccess, planeMatrix = new Matrix4().identity(), volume = this, planeWidth, planeHeight, firstSpacing, secondSpacing, positionOffset, IJKIndex;
    var axisInIJK = new Vector3(), firstDirection = new Vector3(), secondDirection = new Vector3();
    var dimensions = new Vector3(this.xLength, this.yLength, this.zLength);
    switch (axis) {
      case "x":
        axisInIJK.set(1, 0, 0);
        firstDirection.set(0, 0, -1);
        secondDirection.set(0, -1, 0);
        firstSpacing = this.spacing[2];
        secondSpacing = this.spacing[1];
        IJKIndex = new Vector3(RASIndex, 0, 0);
        planeMatrix.multiply(new Matrix4().makeRotationY(Math.PI / 2));
        positionOffset = (volume.RASDimensions[0] - 1) / 2;
        planeMatrix.setPosition(new Vector3(RASIndex - positionOffset, 0, 0));
        break;
      case "y":
        axisInIJK.set(0, 1, 0);
        firstDirection.set(1, 0, 0);
        secondDirection.set(0, 0, 1);
        firstSpacing = this.spacing[0];
        secondSpacing = this.spacing[2];
        IJKIndex = new Vector3(0, RASIndex, 0);
        planeMatrix.multiply(new Matrix4().makeRotationX(-Math.PI / 2));
        positionOffset = (volume.RASDimensions[1] - 1) / 2;
        planeMatrix.setPosition(new Vector3(0, RASIndex - positionOffset, 0));
        break;
      case "z":
      default:
        axisInIJK.set(0, 0, 1);
        firstDirection.set(1, 0, 0);
        secondDirection.set(0, -1, 0);
        firstSpacing = this.spacing[0];
        secondSpacing = this.spacing[1];
        IJKIndex = new Vector3(0, 0, RASIndex);
        positionOffset = (volume.RASDimensions[2] - 1) / 2;
        planeMatrix.setPosition(new Vector3(0, 0, RASIndex - positionOffset));
        break;
    }
    firstDirection.applyMatrix4(volume.inverseMatrix).normalize();
    firstDirection.argVar = "i";
    secondDirection.applyMatrix4(volume.inverseMatrix).normalize();
    secondDirection.argVar = "j";
    axisInIJK.applyMatrix4(volume.inverseMatrix).normalize();
    iLength = Math.floor(Math.abs(firstDirection.dot(dimensions)));
    jLength = Math.floor(Math.abs(secondDirection.dot(dimensions)));
    planeWidth = Math.abs(iLength * firstSpacing);
    planeHeight = Math.abs(jLength * secondSpacing);
    IJKIndex = Math.abs(Math.round(IJKIndex.applyMatrix4(volume.inverseMatrix).dot(axisInIJK)));
    var base = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)];
    var iDirection = [firstDirection, secondDirection, axisInIJK].find(function(x) {
      return Math.abs(x.dot(base[0])) > 0.9;
    });
    var jDirection = [firstDirection, secondDirection, axisInIJK].find(function(x) {
      return Math.abs(x.dot(base[1])) > 0.9;
    });
    var kDirection = [firstDirection, secondDirection, axisInIJK].find(function(x) {
      return Math.abs(x.dot(base[2])) > 0.9;
    });
    sliceAccess = function(i2, j2) {
      var accessI, accessJ, accessK;
      var si = iDirection === axisInIJK ? IJKIndex : iDirection.argVar === "i" ? i2 : j2;
      var sj = jDirection === axisInIJK ? IJKIndex : jDirection.argVar === "i" ? i2 : j2;
      var sk = kDirection === axisInIJK ? IJKIndex : kDirection.argVar === "i" ? i2 : j2;
      var accessI = iDirection.dot(base[0]) > 0 ? si : volume.xLength - 1 - si;
      var accessJ = jDirection.dot(base[1]) > 0 ? sj : volume.yLength - 1 - sj;
      var accessK = kDirection.dot(base[2]) > 0 ? sk : volume.zLength - 1 - sk;
      return volume.access(accessI, accessJ, accessK);
    };
    return {
      iLength,
      jLength,
      sliceAccess,
      matrix: planeMatrix,
      planeWidth,
      planeHeight
    };
  },
  extractSlice: function(axis, index) {
    var slice2 = new VolumeSlice(this, index, axis);
    this.sliceList.push(slice2);
    return slice2;
  },
  repaintAllSlices: function() {
    this.sliceList.forEach(function(slice2) {
      slice2.repaint();
    });
    return this;
  },
  computeMinMax: function() {
    var min2 = Infinity;
    var max3 = -Infinity;
    var datasize = this.data.length;
    var i2 = 0;
    for (i2 = 0; i2 < datasize; i2++) {
      if (!isNaN(this.data[i2])) {
        var value = this.data[i2];
        min2 = Math.min(min2, value);
        max3 = Math.max(max3, value);
      }
    }
    this.min = min2;
    this.max = max3;
    return [min2, max3];
  }
};

// node_modules/potpack/index.mjs
function potpack(boxes) {
  let area = 0;
  let maxWidth = 0;
  for (const box of boxes) {
    area += box.w * box.h;
    maxWidth = Math.max(maxWidth, box.w);
  }
  boxes.sort((a2, b3) => b3.h - a2.h);
  const startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);
  const spaces = [{ x: 0, y: 0, w: startWidth, h: Infinity }];
  let width = 0;
  let height = 0;
  for (const box of boxes) {
    for (let i2 = spaces.length - 1; i2 >= 0; i2--) {
      const space = spaces[i2];
      if (box.w > space.w || box.h > space.h)
        continue;
      box.x = space.x;
      box.y = space.y;
      height = Math.max(height, box.y + box.h);
      width = Math.max(width, box.x + box.w);
      if (box.w === space.w && box.h === space.h) {
        const last = spaces.pop();
        if (i2 < spaces.length)
          spaces[i2] = last;
      } else if (box.h === space.h) {
        space.x += box.w;
        space.w -= box.w;
      } else if (box.w === space.w) {
        space.y += box.h;
        space.h -= box.h;
      } else {
        spaces.push({
          x: space.x + box.w,
          y: space.y,
          w: space.w - box.w,
          h: box.h
        });
        space.y += box.h;
        space.h -= box.h;
      }
      break;
    }
  }
  return {
    w: width,
    h: height,
    fill: area / (width * height) || 0
  };
}

// node_modules/three-stdlib/misc/ProgressiveLightmap.js
var ProgressiveLightMap = class {
  constructor(renderer, res = 1024) {
    this.renderer = renderer;
    this.res = res;
    this.lightMapContainers = [];
    this.compiled = false;
    this.scene = new Scene();
    this.scene.background = null;
    this.tinyTarget = new WebGLRenderTarget(1, 1);
    this.buffer1Active = false;
    this.firstUpdate = true;
    this.warned = false;
    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType;
    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, {
      type: format
    });
    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, {
      type: format
    });
    this.uvMat = new MeshPhongMaterial();
    this.uvMat.uniforms = {};
    this.uvMat.onBeforeCompile = (shader) => {
      shader.vertexShader = "#define USE_LIGHTMAP\n" + shader.vertexShader.slice(0, -1) + "	gl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }";
      const bodyStart = shader.fragmentShader.indexOf("void main() {");
      shader.fragmentShader = "varying vec2 vUv2;\n" + shader.fragmentShader.slice(0, bodyStart) + "	uniform sampler2D previousShadowMap;\n	uniform float averagingWindow;\n" + shader.fragmentShader.slice(bodyStart - 1, -1) + `
vec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;
				gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);
			}`;
      shader.uniforms.previousShadowMap = {
        value: this.progressiveLightMap1.texture
      };
      shader.uniforms.averagingWindow = {
        value: 100
      };
      this.uvMat.uniforms = shader.uniforms;
      this.uvMat.userData.shader = shader;
      this.compiled = true;
    };
  }
  addObjectsToLightMap(objects) {
    this.uv_boxes = [];
    const padding = 3 / this.res;
    for (let ob = 0; ob < objects.length; ob++) {
      const object = objects[ob];
      if (object.isLight) {
        this.scene.attach(object);
        continue;
      }
      if (!object.geometry.hasAttribute("uv")) {
        console.warn("All lightmap objects need UVs!");
        continue;
      }
      if (this.blurringPlane == null) {
        this._initializeBlurPlane(this.res, this.progressiveLightMap1);
      }
      object.material.lightMap = this.progressiveLightMap2.texture;
      object.material.dithering = true;
      object.castShadow = true;
      object.receiveShadow = true;
      object.renderOrder = 1e3 + ob;
      this.uv_boxes.push({
        w: 1 + padding * 2,
        h: 1 + padding * 2,
        index: ob
      });
      this.lightMapContainers.push({
        basicMat: object.material,
        object
      });
      this.compiled = false;
    }
    const dimensions = potpack(this.uv_boxes);
    this.uv_boxes.forEach((box) => {
      const uv2 = objects[box.index].geometry.getAttribute("uv").clone();
      for (let i2 = 0; i2 < uv2.array.length; i2 += uv2.itemSize) {
        uv2.array[i2] = (uv2.array[i2] + box.x + padding) / dimensions.w;
        uv2.array[i2 + 1] = (uv2.array[i2 + 1] + box.y + padding) / dimensions.h;
      }
      objects[box.index].geometry.setAttribute("uv2", uv2);
      objects[box.index].geometry.getAttribute("uv2").needsUpdate = true;
    });
  }
  update(camera, blendWindow = 100, blurEdges = true) {
    if (this.blurringPlane == null) {
      return;
    }
    const oldTarget = this.renderer.getRenderTarget();
    this.blurringPlane.visible = blurEdges;
    for (let l = 0; l < this.lightMapContainers.length; l++) {
      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;
      this.scene.attach(this.lightMapContainers[l].object);
    }
    if (this.firstUpdate) {
      this.renderer.setRenderTarget(this.tinyTarget);
      this.renderer.render(this.scene, camera);
      this.firstUpdate = false;
    }
    for (let l = 0; l < this.lightMapContainers.length; l++) {
      this.uvMat.uniforms.averagingWindow = {
        value: blendWindow
      };
      this.lightMapContainers[l].object.material = this.uvMat;
      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled;
      this.lightMapContainers[l].object.frustumCulled = false;
    }
    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;
    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;
    this.renderer.setRenderTarget(activeMap);
    this.uvMat.uniforms.previousShadowMap = {
      value: inactiveMap.texture
    };
    this.blurringPlane.material.uniforms.previousShadowMap = {
      value: inactiveMap.texture
    };
    this.buffer1Active = !this.buffer1Active;
    this.renderer.render(this.scene, camera);
    for (let l = 0; l < this.lightMapContainers.length; l++) {
      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled;
      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat;
      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object);
    }
    this.renderer.setRenderTarget(oldTarget);
  }
  showDebugLightmap(visible, position = void 0) {
    if (this.lightMapContainers.length == 0) {
      if (!this.warned) {
        console.warn("Call this after adding the objects!");
        this.warned = true;
      }
      return;
    }
    if (this.labelMesh == null) {
      this.labelMaterial = new MeshBasicMaterial({
        map: this.progressiveLightMap1.texture,
        side: DoubleSide
      });
      this.labelPlane = new PlaneGeometry(100, 100);
      this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial);
      this.labelMesh.position.y = 250;
      this.lightMapContainers[0].object.parent.add(this.labelMesh);
    }
    if (position != void 0) {
      this.labelMesh.position.copy(position);
    }
    this.labelMesh.visible = visible;
  }
  _initializeBlurPlane(res, lightMap = null) {
    const blurMaterial = new MeshBasicMaterial();
    blurMaterial.uniforms = {
      previousShadowMap: {
        value: null
      },
      pixelOffset: {
        value: 1 / res
      },
      polygonOffset: true,
      polygonOffsetFactor: -1,
      polygonOffsetUnits: 3
    };
    blurMaterial.onBeforeCompile = (shader) => {
      shader.vertexShader = "#define USE_UV\n" + shader.vertexShader.slice(0, -1) + "	gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";
      const bodyStart = shader.fragmentShader.indexOf("void main() {");
      shader.fragmentShader = "#define USE_UV\n" + shader.fragmentShader.slice(0, bodyStart) + "	uniform sampler2D previousShadowMap;\n	uniform float pixelOffset;\n" + shader.fragmentShader.slice(bodyStart - 1, -1) + `	gl_FragColor.rgb = (
			  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +
			  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +
			  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +
			  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +
			  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +
			  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +
			  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +
			  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;
		}`;
      shader.uniforms.previousShadowMap = {
        value: lightMap.texture
      };
      shader.uniforms.pixelOffset = {
        value: 0.5 / res
      };
      blurMaterial.uniforms = shader.uniforms;
      blurMaterial.userData.shader = shader;
      this.compiled = true;
    };
    this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial);
    this.blurringPlane.name = "Blurring Plane";
    this.blurringPlane.frustumCulled = false;
    this.blurringPlane.renderOrder = 0;
    this.blurringPlane.material.depthWrite = false;
    this.scene.add(this.blurringPlane);
  }
};

// node_modules/three-stdlib/renderers/CSS2DRenderer.js
var CSS2DObject = function(element2) {
  Object3D.call(this);
  this.element = element2 || document.createElement("div");
  this.element.style.position = "absolute";
  this.addEventListener("removed", function() {
    this.traverse(function(object) {
      if (object.element instanceof Element && object.element.parentNode !== null) {
        object.element.parentNode.removeChild(object.element);
      }
    });
  });
};
CSS2DObject.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: CSS2DObject,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.element = source.element.cloneNode(true);
    return this;
  }
});
var CSS2DRenderer = function() {
  var _this = this;
  var _width, _height;
  var _widthHalf, _heightHalf;
  var vector2 = new Vector3();
  var viewMatrix2 = new Matrix4();
  var viewProjectionMatrix = new Matrix4();
  var cache = {
    objects: /* @__PURE__ */ new WeakMap()
  };
  var domElement = document.createElement("div");
  domElement.style.overflow = "hidden";
  this.domElement = domElement;
  this.getSize = function() {
    return {
      width: _width,
      height: _height
    };
  };
  this.setSize = function(width, height) {
    _width = width;
    _height = height;
    _widthHalf = _width / 2;
    _heightHalf = _height / 2;
    domElement.style.width = width + "px";
    domElement.style.height = height + "px";
  };
  var renderObject = function(object, scene, camera) {
    if (object instanceof CSS2DObject) {
      object.onBeforeRender(_this, scene, camera);
      vector2.setFromMatrixPosition(object.matrixWorld);
      vector2.applyMatrix4(viewProjectionMatrix);
      var element2 = object.element;
      element2.style.transform = "translate(-50%,-50%) translate(" + (vector2.x * _widthHalf + _widthHalf) + "px," + (-vector2.y * _heightHalf + _heightHalf) + "px)";
      element2.style.display = object.visible && vector2.z >= -1 && vector2.z <= 1 ? "" : "none";
      var objectData = {
        distanceToCameraSquared: getDistanceToSquared(camera, object)
      };
      cache.objects.set(object, objectData);
      if (element2.parentNode !== domElement) {
        domElement.appendChild(element2);
      }
      object.onAfterRender(_this, scene, camera);
    }
    for (let i2 = 0, l = object.children.length; i2 < l; i2++) {
      renderObject(object.children[i2], scene, camera);
    }
  };
  var getDistanceToSquared = function() {
    var a2 = new Vector3();
    var b3 = new Vector3();
    return function(object1, object2) {
      a2.setFromMatrixPosition(object1.matrixWorld);
      b3.setFromMatrixPosition(object2.matrixWorld);
      return a2.distanceToSquared(b3);
    };
  }();
  var filterAndFlatten = function(scene) {
    var result = [];
    scene.traverse(function(object) {
      if (object instanceof CSS2DObject)
        result.push(object);
    });
    return result;
  };
  var zOrder = function(scene) {
    var sorted = filterAndFlatten(scene).sort(function(a2, b3) {
      var distanceA = cache.objects.get(a2).distanceToCameraSquared;
      var distanceB = cache.objects.get(b3).distanceToCameraSquared;
      return distanceA - distanceB;
    });
    var zMax = sorted.length;
    for (let i2 = 0, l = sorted.length; i2 < l; i2++) {
      sorted[i2].element.style.zIndex = zMax - i2;
    }
  };
  this.render = function(scene, camera) {
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    viewMatrix2.copy(camera.matrixWorldInverse);
    viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, viewMatrix2);
    renderObject(scene, scene, camera);
    zOrder(scene);
  };
};

// node_modules/three-stdlib/renderers/nodes/core/constants.js
var NodeShaderStage = {
  Vertex: "vertex",
  Fragment: "fragment"
};
var NodeUpdateType = {
  None: "none",
  Frame: "frame",
  Object: "object"
};
var NodeType = {
  Float: "float",
  Vector2: "vec2",
  Vector3: "vec3",
  Vector4: "vec4",
  Matrix3: "mat3",
  Matrix4: "mat4"
};

// node_modules/three-stdlib/renderers/webgpu/constants.js
var GPUPrimitiveTopology = {
  PointList: "point-list",
  LineList: "line-list",
  LineStrip: "line-strip",
  TriangleList: "triangle-list",
  TriangleStrip: "triangle-strip"
};
var GPUCompareFunction = {
  Never: "never",
  Less: "less",
  Equal: "equal",
  LessEqual: "less-equal",
  Greater: "greater",
  NotEqual: "not-equal",
  GreaterEqual: "greater-equal",
  Always: "always"
};
var GPUStoreOp = {
  Store: "store",
  Clear: "clear"
};
var GPULoadOp = {
  Load: "load"
};
var GPUFrontFace = {
  CCW: "ccw",
  CW: "cw"
};
var GPUCullMode = {
  None: "none",
  Front: "front",
  Back: "back"
};
var GPUIndexFormat = {
  Uint16: "uint16",
  Uint32: "uint32"
};
var GPUVertexFormat = {
  Uchar2: "uchar2",
  Uchar4: "uchar4",
  Char2: "char2",
  Char4: "char4",
  Uchar2Norm: "uchar2norm",
  Uchar4Norm: "uchar4norm",
  Char2Norm: "char2norm",
  Char4Norm: "char4norm",
  Ushort2: "ushort2",
  Ushort4: "ushort4",
  Short2: "short2",
  Short4: "short4",
  Ushort2Norm: "ushort2norm",
  Ushort4Norm: "ushort4norm",
  Short2Norm: "short2norm",
  Short4Norm: "short4norm",
  Half2: "half2",
  Half4: "half4",
  Float: "float",
  Float2: "float2",
  Float3: "float3",
  Float4: "float4",
  Uint: "uint",
  Uint2: "uint2",
  Uint3: "uint3",
  Uint4: "uint4",
  Int: "int",
  Int2: "int2",
  Int3: "int3",
  Int4: "int4"
};
var GPUTextureFormat = {
  R8Unorm: "r8unorm",
  R8Snorm: "r8snorm",
  R8Uint: "r8uint",
  R8Sint: "r8sint",
  R16Uint: "r16uint",
  R16Sint: "r16sint",
  R16Float: "r16float",
  RG8Unorm: "rg8unorm",
  RG8Snorm: "rg8snorm",
  RG8Uint: "rg8uint",
  RG8Sint: "rg8sint",
  R32Uint: "r32uint",
  R32Sint: "r32sint",
  R32Float: "r32float",
  RG16Uint: "rg16uint",
  RG16Sint: "rg16sint",
  RG16Float: "rg16float",
  RGBA8Unorm: "rgba8unorm",
  RGBA8UnormSRGB: "rgba8unorm-srgb",
  RGBA8Snorm: "rgba8snorm",
  RGBA8Uint: "rgba8uint",
  RGBA8Sint: "rgba8sint",
  BRGA8Unorm: "bgra8unorm",
  BRGA8UnormSRGB: "bgra8unorm-srgb",
  RGB9E5UFloat: "rgb9e5ufloat",
  RGB10A2Unorm: "rgb10a2unorm",
  RG11B10uFloat: "rgb10a2unorm",
  RG32Uint: "rg32uint",
  RG32Sint: "rg32sint",
  RG32Float: "rg32float",
  RGBA16Uint: "rgba16uint",
  RGBA16Sint: "rgba16sint",
  RGBA16Float: "rgba16float",
  RGBA32Uint: "rgba32uint",
  RGBA32Sint: "rgba32sint",
  RGBA32Float: "rgba32float",
  Stencil8: "stencil8",
  Depth16Unorm: "depth16unorm",
  Depth24Plus: "depth24plus",
  Depth24PlusStencil8: "depth24plus-stencil8",
  Depth32Float: "depth32float",
  BC1RGBAUnorm: "bc1-rgba-unorm",
  BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
  BC2RGBAUnorm: "bc2-rgba-unorm",
  BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
  BC3RGBAUnorm: "bc3-rgba-unorm",
  BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
  BC4RUnorm: "bc4-r-unorm",
  BC4RSNorm: "bc4-r-snorm",
  BC5RGUnorm: "bc5-rg-unorm",
  BC5RGSnorm: "bc5-rg-snorm",
  BC6HRGBUFloat: "bc6h-rgb-ufloat",
  BC6HRGBFloat: "bc6h-rgb-float",
  BC7RGBAUnorm: "bc7-rgba-unorm",
  BC7RGBAUnormSRGB: "bc7-rgba-srgb",
  Depth24UnormStencil8: "depth24unorm-stencil8",
  Depth32FloatStencil8: "depth32float-stencil8"
};
var GPUAddressMode = {
  ClampToEdge: "clamp-to-edge",
  Repeat: "repeat",
  MirrorRepeat: "mirror-repeat"
};
var GPUFilterMode = {
  Linear: "linear",
  Nearest: "nearest"
};
var GPUBlendFactor = {
  Zero: "zero",
  One: "one",
  SrcColor: "src-color",
  OneMinusSrcColor: "one-minus-src-color",
  SrcAlpha: "src-alpha",
  OneMinusSrcAlpha: "one-minus-src-alpha",
  DstColor: "dst-color",
  OneMinusDstColor: "one-minus-dst-color",
  DstAlpha: "dst-alpha",
  OneMinusDstAlpha: "one-minus-dst-alpha",
  SrcAlphaSaturated: "src-alpha-saturated",
  BlendColor: "blend-color",
  OneMinusBlendColor: "one-minus-blend-color"
};
var GPUBlendOperation = {
  Add: "add",
  Subtract: "subtract",
  ReverseSubtract: "reverse-subtract",
  Min: "min",
  Max: "max"
};
var GPUColorWriteFlags = {
  None: 0,
  Red: 1,
  Green: 2,
  Blue: 4,
  Alpha: 8,
  All: 15
};
var GPUStencilOperation = {
  Keep: "keep",
  Zero: "zero",
  Replace: "replace",
  Invert: "invert",
  IncrementClamp: "increment-clamp",
  DecrementClamp: "decrement-clamp",
  IncrementWrap: "increment-wrap",
  DecrementWrap: "decrement-wrap"
};
var GPUBindingType = {
  UniformBuffer: "uniform-buffer",
  StorageBuffer: "storage-buffer",
  ReadonlyStorageBuffer: "readonly-storage-buffer",
  Sampler: "sampler",
  ComparisonSampler: "comparison-sampler",
  SampledTexture: "sampled-texture",
  MultisampledTexture: "multisampled-texture",
  ReadonlyStorageTexture: "readonly-storage-texture",
  WriteonlyStorageTexture: "writeonly-storage-texture"
};
var GPUTextureDimension = {
  OneD: "1d",
  TwoD: "2d",
  ThreeD: "3d"
};
var GPUTextureViewDimension = {
  OneD: "1d",
  TwoD: "2d",
  TwoDArray: "2d-array",
  Cube: "cube",
  CubeArray: "cube-array",
  ThreeD: "3d"
};
var GPUInputStepMode = {
  Vertex: "vertex",
  Instance: "instance"
};
var BlendColorFactor = 211;
var OneMinusBlendColorFactor = 212;

// node_modules/three-stdlib/renderers/webgpu/WebGPUUniform.js
var WebGPUUniform = class {
  constructor(name, value = null) {
    this.name = name;
    this.value = value;
    this.boundary = 0;
    this.itemSize = 0;
    this.offset = 0;
  }
  setValue(value) {
    this.value = value;
  }
  getValue() {
    return this.value;
  }
};
var FloatUniform = class extends WebGPUUniform {
  constructor(name, value = 0) {
    super(name, value);
    this.boundary = 4;
    this.itemSize = 1;
    Object.defineProperty(this, "isFloatUniform", {
      value: true
    });
  }
};
var Vector2Uniform = class extends WebGPUUniform {
  constructor(name, value = new Vector2()) {
    super(name, value);
    this.boundary = 8;
    this.itemSize = 2;
    Object.defineProperty(this, "isVector2Uniform", {
      value: true
    });
  }
};
var Vector3Uniform = class extends WebGPUUniform {
  constructor(name, value = new Vector3()) {
    super(name, value);
    this.boundary = 16;
    this.itemSize = 3;
    Object.defineProperty(this, "isVector3Uniform", {
      value: true
    });
  }
};
var Vector4Uniform = class extends WebGPUUniform {
  constructor(name, value = new Vector4()) {
    super(name, value);
    this.boundary = 16;
    this.itemSize = 4;
    Object.defineProperty(this, "isVector4Uniform", {
      value: true
    });
  }
};
var ColorUniform = class extends WebGPUUniform {
  constructor(name, value = new Color()) {
    super(name, value);
    this.boundary = 16;
    this.itemSize = 3;
    Object.defineProperty(this, "isColorUniform", {
      value: true
    });
  }
};
var Matrix3Uniform = class extends WebGPUUniform {
  constructor(name, value = new Matrix3()) {
    super(name, value);
    this.boundary = 48;
    this.itemSize = 12;
    Object.defineProperty(this, "isMatrix3Uniform", {
      value: true
    });
  }
};
var Matrix4Uniform = class extends WebGPUUniform {
  constructor(name, value = new Matrix4()) {
    super(name, value);
    this.boundary = 64;
    this.itemSize = 16;
    Object.defineProperty(this, "isMatrix4Uniform", {
      value: true
    });
  }
};

// node_modules/three-stdlib/renderers/webgpu/nodes/WebGPUNodeUniform.js
var FloatNodeUniform = class extends FloatUniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector2NodeUniform = class extends Vector2Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector3NodeUniform = class extends Vector3Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector4NodeUniform = class extends Vector4Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var ColorNodeUniform = class extends ColorUniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Matrix3NodeUniform = class extends Matrix3Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Matrix4NodeUniform = class extends Matrix4Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};

// node_modules/three-stdlib/renderers/webgpu/WebGPUBinding.js
var WebGPUBinding = class {
  constructor(name = "") {
    this.name = name;
    this.visibility = null;
    this.type = null;
    this.isShared = false;
  }
  setVisibility(visibility) {
    this.visibility = visibility;
  }
};
var WebGPUBinding_default = WebGPUBinding;

// node_modules/three-stdlib/renderers/webgpu/WebGPUSampledTexture.js
var WebGPUSampledTexture = class extends WebGPUBinding_default {
  constructor(name, texture2) {
    super(name);
    this.texture = texture2;
    this.dimension = GPUTextureViewDimension.TwoD;
    this.type = GPUBindingType.SampledTexture;
    this.visibility = GPUShaderStage.FRAGMENT;
    this.textureGPU = null;
    Object.defineProperty(this, "isSampledTexture", {
      value: true
    });
  }
};
var WebGPUSampledArrayTexture = class extends WebGPUSampledTexture {
  constructor(name) {
    super(name);
    this.dimension = GPUTextureViewDimension.TwoDArray;
    Object.defineProperty(this, "isSampledArrayTexture", {
      value: true
    });
  }
};
var WebGPUSampled3DTexture = class extends WebGPUSampledTexture {
  constructor(name) {
    super(name);
    this.dimension = GPUTextureViewDimension.ThreeD;
    Object.defineProperty(this, "isSampled3DTexture", {
      value: true
    });
  }
};
var WebGPUSampledCubeTexture = class extends WebGPUSampledTexture {
  constructor(name) {
    super(name);
    this.dimension = GPUTextureViewDimension.Cube;
    Object.defineProperty(this, "isSampledCubeTexture", {
      value: true
    });
  }
};

// node_modules/three-stdlib/renderers/CSS3DRenderer.js
var CSS3DObject = function(element2) {
  Object3D.call(this);
  this.element = element2 || document.createElement("div");
  this.element.style.position = "absolute";
  this.element.style.pointerEvents = "auto";
  this.addEventListener("removed", function() {
    this.traverse(function(object) {
      if (object.element instanceof Element && object.element.parentNode !== null) {
        object.element.parentNode.removeChild(object.element);
      }
    });
  });
};
CSS3DObject.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: CSS3DObject,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.element = source.element.cloneNode(true);
    return this;
  }
});
var CSS3DSprite = function(element2) {
  CSS3DObject.call(this, element2);
};
CSS3DSprite.prototype = Object.create(CSS3DObject.prototype);
CSS3DSprite.prototype.constructor = CSS3DSprite;
var CSS3DRenderer = function() {
  var _this = this;
  var _width, _height;
  var _widthHalf, _heightHalf;
  var matrix3 = new Matrix4();
  var cache = {
    camera: {
      fov: 0,
      style: ""
    },
    objects: /* @__PURE__ */ new WeakMap()
  };
  var domElement = document.createElement("div");
  domElement.style.overflow = "hidden";
  this.domElement = domElement;
  var cameraElement = document.createElement("div");
  cameraElement.style.transformStyle = "preserve-3d";
  cameraElement.style.pointerEvents = "none";
  domElement.appendChild(cameraElement);
  this.getSize = function() {
    return {
      width: _width,
      height: _height
    };
  };
  this.setSize = function(width, height) {
    _width = width;
    _height = height;
    _widthHalf = _width / 2;
    _heightHalf = _height / 2;
    domElement.style.width = width + "px";
    domElement.style.height = height + "px";
    cameraElement.style.width = width + "px";
    cameraElement.style.height = height + "px";
  };
  function epsilon(value) {
    return Math.abs(value) < 1e-10 ? 0 : value;
  }
  function getCameraCSSMatrix(matrix4) {
    var elements = matrix4.elements;
    return "matrix3d(" + epsilon(elements[0]) + "," + epsilon(-elements[1]) + "," + epsilon(elements[2]) + "," + epsilon(elements[3]) + "," + epsilon(elements[4]) + "," + epsilon(-elements[5]) + "," + epsilon(elements[6]) + "," + epsilon(elements[7]) + "," + epsilon(elements[8]) + "," + epsilon(-elements[9]) + "," + epsilon(elements[10]) + "," + epsilon(elements[11]) + "," + epsilon(elements[12]) + "," + epsilon(-elements[13]) + "," + epsilon(elements[14]) + "," + epsilon(elements[15]) + ")";
  }
  function getObjectCSSMatrix(matrix4) {
    var elements = matrix4.elements;
    var matrix3d = "matrix3d(" + epsilon(elements[0]) + "," + epsilon(elements[1]) + "," + epsilon(elements[2]) + "," + epsilon(elements[3]) + "," + epsilon(-elements[4]) + "," + epsilon(-elements[5]) + "," + epsilon(-elements[6]) + "," + epsilon(-elements[7]) + "," + epsilon(elements[8]) + "," + epsilon(elements[9]) + "," + epsilon(elements[10]) + "," + epsilon(elements[11]) + "," + epsilon(elements[12]) + "," + epsilon(elements[13]) + "," + epsilon(elements[14]) + "," + epsilon(elements[15]) + ")";
    return "translate(-50%,-50%)" + matrix3d;
  }
  function renderObject(object, scene, camera, cameraCSSMatrix) {
    if (object instanceof CSS3DObject) {
      object.onBeforeRender(_this, scene, camera);
      var style;
      if (object instanceof CSS3DSprite) {
        matrix3.copy(camera.matrixWorldInverse);
        matrix3.transpose();
        matrix3.copyPosition(object.matrixWorld);
        matrix3.scale(object.scale);
        matrix3.elements[3] = 0;
        matrix3.elements[7] = 0;
        matrix3.elements[11] = 0;
        matrix3.elements[15] = 1;
        style = getObjectCSSMatrix(matrix3);
      } else {
        style = getObjectCSSMatrix(object.matrixWorld);
      }
      var element2 = object.element;
      var cachedObject = cache.objects.get(object);
      if (cachedObject === void 0 || cachedObject.style !== style) {
        element2.style.transform = style;
        var objectData = {
          style
        };
        cache.objects.set(object, objectData);
      }
      element2.style.display = object.visible ? "" : "none";
      if (element2.parentNode !== cameraElement) {
        cameraElement.appendChild(element2);
      }
      object.onAfterRender(_this, scene, camera);
    }
    for (let i2 = 0, l = object.children.length; i2 < l; i2++) {
      renderObject(object.children[i2], scene, camera);
    }
  }
  this.render = function(scene, camera) {
    var fov = camera.projectionMatrix.elements[5] * _heightHalf;
    if (cache.camera.fov !== fov) {
      domElement.style.perspective = camera.isPerspectiveCamera ? fov + "px" : "";
      cache.camera.fov = fov;
    }
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    if (camera.isOrthographicCamera) {
      var tx = -(camera.right + camera.left) / 2;
      var ty = (camera.top + camera.bottom) / 2;
    }
    var cameraCSSMatrix = camera.isOrthographicCamera ? "scale(" + fov + ")translate(" + epsilon(tx) + "px," + epsilon(ty) + "px)" + getCameraCSSMatrix(camera.matrixWorldInverse) : "translateZ(" + fov + "px)" + getCameraCSSMatrix(camera.matrixWorldInverse);
    var style = cameraCSSMatrix + "translate(" + _widthHalf + "px," + _heightHalf + "px)";
    if (cache.camera.style !== style) {
      cameraElement.style.transform = style;
      cache.camera.style = style;
    }
    renderObject(scene, scene, camera);
  };
};

// node_modules/three-stdlib/renderers/Projector.js
var RenderableObject = function() {
  this.id = 0;
  this.object = null;
  this.z = 0;
  this.renderOrder = 0;
};
var RenderableFace = function() {
  this.id = 0;
  this.v1 = new RenderableVertex();
  this.v2 = new RenderableVertex();
  this.v3 = new RenderableVertex();
  this.normalModel = new Vector3();
  this.vertexNormalsModel = [new Vector3(), new Vector3(), new Vector3()];
  this.vertexNormalsLength = 0;
  this.color = new Color();
  this.material = null;
  this.uvs = [new Vector2(), new Vector2(), new Vector2()];
  this.z = 0;
  this.renderOrder = 0;
};
var RenderableVertex = function() {
  this.position = new Vector3();
  this.positionWorld = new Vector3();
  this.positionScreen = new Vector4();
  this.visible = true;
};
RenderableVertex.prototype.copy = function(vertex) {
  this.positionWorld.copy(vertex.positionWorld);
  this.positionScreen.copy(vertex.positionScreen);
};
var RenderableLine = function() {
  this.id = 0;
  this.v1 = new RenderableVertex();
  this.v2 = new RenderableVertex();
  this.vertexColors = [new Color(), new Color()];
  this.material = null;
  this.z = 0;
  this.renderOrder = 0;
};
var RenderableSprite = function() {
  this.id = 0;
  this.object = null;
  this.x = 0;
  this.y = 0;
  this.z = 0;
  this.rotation = 0;
  this.scale = new Vector2();
  this.material = null;
  this.renderOrder = 0;
};
var Projector = function() {
  var _object, _objectCount, _objectPool = [], _objectPoolLength = 0, _vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0, _face, _faceCount, _facePool = [], _facePoolLength = 0, _line2, _lineCount, _linePool = [], _linePoolLength = 0, _sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0, _renderData = {
    objects: [],
    lights: [],
    elements: []
  }, _vector3 = new Vector3(), _vector4 = new Vector4(), _clipBox = new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1)), _boundingBox = new Box3(), _points3 = new Array(3), _viewMatrix = new Matrix4(), _viewProjectionMatrix = new Matrix4(), _modelMatrix, _modelViewProjectionMatrix = new Matrix4(), _frustum = new Frustum();
  this.projectVector = function(vector2, camera) {
    console.warn("THREE.Projector: .projectVector() is now vector.project().");
    vector2.project(camera);
  };
  this.unprojectVector = function(vector2, camera) {
    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
    vector2.unproject(camera);
  };
  this.pickingRay = function() {
    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
  };
  var RenderList = function() {
    var normals = [];
    var colors = [];
    var uvs = [];
    var object = null;
    var normalMatrix = new Matrix3();
    function setObject(value) {
      object = value;
      normalMatrix.getNormalMatrix(object.matrixWorld);
      normals.length = 0;
      colors.length = 0;
      uvs.length = 0;
    }
    function projectVertex(vertex) {
      var position = vertex.position;
      var positionWorld2 = vertex.positionWorld;
      var positionScreen = vertex.positionScreen;
      positionWorld2.copy(position).applyMatrix4(_modelMatrix);
      positionScreen.copy(positionWorld2).applyMatrix4(_viewProjectionMatrix);
      var invW = 1 / positionScreen.w;
      positionScreen.x *= invW;
      positionScreen.y *= invW;
      positionScreen.z *= invW;
      vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 && positionScreen.y >= -1 && positionScreen.y <= 1 && positionScreen.z >= -1 && positionScreen.z <= 1;
    }
    function pushVertex(x, y, z) {
      _vertex = getNextVertexInPool();
      _vertex.position.set(x, y, z);
      projectVertex(_vertex);
    }
    function pushNormal(x, y, z) {
      normals.push(x, y, z);
    }
    function pushColor(r, g2, b3) {
      colors.push(r, g2, b3);
    }
    function pushUv(x, y) {
      uvs.push(x, y);
    }
    function checkTriangleVisibility(v12, v2, v3) {
      if (v12.visible === true || v2.visible === true || v3.visible === true)
        return true;
      _points3[0] = v12.positionScreen;
      _points3[1] = v2.positionScreen;
      _points3[2] = v3.positionScreen;
      return _clipBox.intersectsBox(_boundingBox.setFromPoints(_points3));
    }
    function checkBackfaceCulling(v12, v2, v3) {
      return (v3.positionScreen.x - v12.positionScreen.x) * (v2.positionScreen.y - v12.positionScreen.y) - (v3.positionScreen.y - v12.positionScreen.y) * (v2.positionScreen.x - v12.positionScreen.x) < 0;
    }
    function pushLine(a2, b3) {
      var v12 = _vertexPool[a2];
      var v2 = _vertexPool[b3];
      v12.positionScreen.copy(v12.position).applyMatrix4(_modelViewProjectionMatrix);
      v2.positionScreen.copy(v2.position).applyMatrix4(_modelViewProjectionMatrix);
      if (clipLine(v12.positionScreen, v2.positionScreen) === true) {
        v12.positionScreen.multiplyScalar(1 / v12.positionScreen.w);
        v2.positionScreen.multiplyScalar(1 / v2.positionScreen.w);
        _line2 = getNextLineInPool();
        _line2.id = object.id;
        _line2.v1.copy(v12);
        _line2.v2.copy(v2);
        _line2.z = Math.max(v12.positionScreen.z, v2.positionScreen.z);
        _line2.renderOrder = object.renderOrder;
        _line2.material = object.material;
        if (object.material.vertexColors) {
          _line2.vertexColors[0].fromArray(colors, a2 * 3);
          _line2.vertexColors[1].fromArray(colors, b3 * 3);
        }
        _renderData.elements.push(_line2);
      }
    }
    function pushTriangle(a2, b3, c, material) {
      var v12 = _vertexPool[a2];
      var v2 = _vertexPool[b3];
      var v3 = _vertexPool[c];
      if (checkTriangleVisibility(v12, v2, v3) === false)
        return;
      if (material.side === DoubleSide || checkBackfaceCulling(v12, v2, v3) === true) {
        _face = getNextFaceInPool();
        _face.id = object.id;
        _face.v1.copy(v12);
        _face.v2.copy(v2);
        _face.v3.copy(v3);
        _face.z = (v12.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;
        _face.renderOrder = object.renderOrder;
        _vector3.subVectors(v3.position, v2.position);
        _vector4.subVectors(v12.position, v2.position);
        _vector3.cross(_vector4);
        _face.normalModel.copy(_vector3);
        _face.normalModel.applyMatrix3(normalMatrix).normalize();
        for (let i2 = 0; i2 < 3; i2++) {
          var normal = _face.vertexNormalsModel[i2];
          normal.fromArray(normals, arguments[i2] * 3);
          normal.applyMatrix3(normalMatrix).normalize();
          var uv2 = _face.uvs[i2];
          uv2.fromArray(uvs, arguments[i2] * 2);
        }
        _face.vertexNormalsLength = 3;
        _face.material = material;
        if (material.vertexColors) {
          _face.color.fromArray(colors, a2 * 3);
        }
        _renderData.elements.push(_face);
      }
    }
    return {
      setObject,
      projectVertex,
      checkTriangleVisibility,
      checkBackfaceCulling,
      pushVertex,
      pushNormal,
      pushColor,
      pushUv,
      pushLine,
      pushTriangle
    };
  };
  var renderList = new RenderList();
  function projectObject(object) {
    if (object.visible === false)
      return;
    if (object.isLight) {
      _renderData.lights.push(object);
    } else if (object.isMesh || object.isLine || object.isPoints) {
      if (object.material.visible === false)
        return;
      if (object.frustumCulled === true && _frustum.intersectsObject(object) === false)
        return;
      addObject(object);
    } else if (object.isSprite) {
      if (object.material.visible === false)
        return;
      if (object.frustumCulled === true && _frustum.intersectsSprite(object) === false)
        return;
      addObject(object);
    }
    var children = object.children;
    for (let i2 = 0, l = children.length; i2 < l; i2++) {
      projectObject(children[i2]);
    }
  }
  function addObject(object) {
    _object = getNextObjectInPool();
    _object.id = object.id;
    _object.object = object;
    _vector3.setFromMatrixPosition(object.matrixWorld);
    _vector3.applyMatrix4(_viewProjectionMatrix);
    _object.z = _vector3.z;
    _object.renderOrder = object.renderOrder;
    _renderData.objects.push(_object);
  }
  this.projectScene = function(scene, camera, sortObjects, sortElements) {
    _faceCount = 0;
    _lineCount = 0;
    _spriteCount = 0;
    _renderData.elements.length = 0;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    _viewMatrix.copy(camera.matrixWorldInverse);
    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
    _frustum.setFromProjectionMatrix(_viewProjectionMatrix);
    _objectCount = 0;
    _renderData.objects.length = 0;
    _renderData.lights.length = 0;
    projectObject(scene);
    if (sortObjects === true) {
      _renderData.objects.sort(painterSort);
    }
    var objects = _renderData.objects;
    for (let o = 0, ol = objects.length; o < ol; o++) {
      var object = objects[o].object;
      var geometry = object.geometry;
      renderList.setObject(object);
      _modelMatrix = object.matrixWorld;
      _vertexCount = 0;
      if (object.isMesh) {
        if (geometry.isBufferGeometry) {
          var material = object.material;
          var isMultiMaterial = Array.isArray(material);
          var attributes = geometry.attributes;
          var groups = geometry.groups;
          if (attributes.position === void 0)
            continue;
          var positions = attributes.position.array;
          for (let i2 = 0, l = positions.length; i2 < l; i2 += 3) {
            var x = positions[i2];
            var y = positions[i2 + 1];
            var z = positions[i2 + 2];
            if (material.morphTargets === true) {
              var morphTargets = geometry.morphAttributes.position;
              var morphTargetsRelative = geometry.morphTargetsRelative;
              var morphInfluences = object.morphTargetInfluences;
              for (let t2 = 0, tl = morphTargets.length; t2 < tl; t2++) {
                var influence = morphInfluences[t2];
                if (influence === 0)
                  continue;
                var target = morphTargets[t2];
                if (morphTargetsRelative) {
                  x += target.getX(i2 / 3) * influence;
                  y += target.getY(i2 / 3) * influence;
                  z += target.getZ(i2 / 3) * influence;
                } else {
                  x += (target.getX(i2 / 3) - positions[i2]) * influence;
                  y += (target.getY(i2 / 3) - positions[i2 + 1]) * influence;
                  z += (target.getZ(i2 / 3) - positions[i2 + 2]) * influence;
                }
              }
            }
            renderList.pushVertex(x, y, z);
          }
          if (attributes.normal !== void 0) {
            var normals = attributes.normal.array;
            for (let i2 = 0, l = normals.length; i2 < l; i2 += 3) {
              renderList.pushNormal(normals[i2], normals[i2 + 1], normals[i2 + 2]);
            }
          }
          if (attributes.color !== void 0) {
            var colors = attributes.color.array;
            for (let i2 = 0, l = colors.length; i2 < l; i2 += 3) {
              renderList.pushColor(colors[i2], colors[i2 + 1], colors[i2 + 2]);
            }
          }
          if (attributes.uv !== void 0) {
            var uvs = attributes.uv.array;
            for (let i2 = 0, l = uvs.length; i2 < l; i2 += 2) {
              renderList.pushUv(uvs[i2], uvs[i2 + 1]);
            }
          }
          if (geometry.index !== null) {
            var indices = geometry.index.array;
            if (groups.length > 0) {
              for (let g2 = 0; g2 < groups.length; g2++) {
                var group = groups[g2];
                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;
                if (material === void 0)
                  continue;
                for (let i2 = group.start, l = group.start + group.count; i2 < l; i2 += 3) {
                  renderList.pushTriangle(indices[i2], indices[i2 + 1], indices[i2 + 2], material);
                }
              }
            } else {
              for (let i2 = 0, l = indices.length; i2 < l; i2 += 3) {
                renderList.pushTriangle(indices[i2], indices[i2 + 1], indices[i2 + 2], material);
              }
            }
          } else {
            if (groups.length > 0) {
              for (let g2 = 0; g2 < groups.length; g2++) {
                var group = groups[g2];
                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;
                if (material === void 0)
                  continue;
                for (let i2 = group.start, l = group.start + group.count; i2 < l; i2 += 3) {
                  renderList.pushTriangle(i2, i2 + 1, i2 + 2, material);
                }
              }
            } else {
              for (let i2 = 0, l = positions.length / 3; i2 < l; i2 += 3) {
                renderList.pushTriangle(i2, i2 + 1, i2 + 2, material);
              }
            }
          }
        } else if (geometry.isGeometry) {
          console.error("THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.");
          return;
        }
      } else if (object.isLine) {
        _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);
        if (geometry.isBufferGeometry) {
          var attributes = geometry.attributes;
          if (attributes.position !== void 0) {
            var positions = attributes.position.array;
            for (let i2 = 0, l = positions.length; i2 < l; i2 += 3) {
              renderList.pushVertex(positions[i2], positions[i2 + 1], positions[i2 + 2]);
            }
            if (attributes.color !== void 0) {
              var colors = attributes.color.array;
              for (let i2 = 0, l = colors.length; i2 < l; i2 += 3) {
                renderList.pushColor(colors[i2], colors[i2 + 1], colors[i2 + 2]);
              }
            }
            if (geometry.index !== null) {
              var indices = geometry.index.array;
              for (let i2 = 0, l = indices.length; i2 < l; i2 += 2) {
                renderList.pushLine(indices[i2], indices[i2 + 1]);
              }
            } else {
              var step2 = object.isLineSegments ? 2 : 1;
              for (let i2 = 0, l = positions.length / 3 - 1; i2 < l; i2 += step2) {
                renderList.pushLine(i2, i2 + 1);
              }
            }
          }
        } else if (geometry.isGeometry) {
          console.error("THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.");
          return;
        }
      } else if (object.isPoints) {
        _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);
        if (geometry.isGeometry) {
          console.error("THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.");
          return;
        } else if (geometry.isBufferGeometry) {
          var attributes = geometry.attributes;
          if (attributes.position !== void 0) {
            var positions = attributes.position.array;
            for (let i2 = 0, l = positions.length; i2 < l; i2 += 3) {
              _vector4.set(positions[i2], positions[i2 + 1], positions[i2 + 2], 1);
              _vector4.applyMatrix4(_modelViewProjectionMatrix);
              pushPoint(_vector4, object, camera);
            }
          }
        }
      } else if (object.isSprite) {
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);
        _vector4.applyMatrix4(_viewProjectionMatrix);
        pushPoint(_vector4, object, camera);
      }
    }
    if (sortElements === true) {
      _renderData.elements.sort(painterSort);
    }
    return _renderData;
  };
  function pushPoint(_vector42, object, camera) {
    var invW = 1 / _vector42.w;
    _vector42.z *= invW;
    if (_vector42.z >= -1 && _vector42.z <= 1) {
      _sprite = getNextSpriteInPool();
      _sprite.id = object.id;
      _sprite.x = _vector42.x * invW;
      _sprite.y = _vector42.y * invW;
      _sprite.z = _vector42.z;
      _sprite.renderOrder = object.renderOrder;
      _sprite.object = object;
      _sprite.rotation = object.rotation;
      _sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector42.x + camera.projectionMatrix.elements[0]) / (_vector42.w + camera.projectionMatrix.elements[12]));
      _sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector42.y + camera.projectionMatrix.elements[5]) / (_vector42.w + camera.projectionMatrix.elements[13]));
      _sprite.material = object.material;
      _renderData.elements.push(_sprite);
    }
  }
  function getNextObjectInPool() {
    if (_objectCount === _objectPoolLength) {
      var object = new RenderableObject();
      _objectPool.push(object);
      _objectPoolLength++;
      _objectCount++;
      return object;
    }
    return _objectPool[_objectCount++];
  }
  function getNextVertexInPool() {
    if (_vertexCount === _vertexPoolLength) {
      var vertex = new RenderableVertex();
      _vertexPool.push(vertex);
      _vertexPoolLength++;
      _vertexCount++;
      return vertex;
    }
    return _vertexPool[_vertexCount++];
  }
  function getNextFaceInPool() {
    if (_faceCount === _facePoolLength) {
      var face = new RenderableFace();
      _facePool.push(face);
      _facePoolLength++;
      _faceCount++;
      return face;
    }
    return _facePool[_faceCount++];
  }
  function getNextLineInPool() {
    if (_lineCount === _linePoolLength) {
      var line2 = new RenderableLine();
      _linePool.push(line2);
      _linePoolLength++;
      _lineCount++;
      return line2;
    }
    return _linePool[_lineCount++];
  }
  function getNextSpriteInPool() {
    if (_spriteCount === _spritePoolLength) {
      var sprite = new RenderableSprite();
      _spritePool.push(sprite);
      _spritePoolLength++;
      _spriteCount++;
      return sprite;
    }
    return _spritePool[_spriteCount++];
  }
  function painterSort(a2, b3) {
    if (a2.renderOrder !== b3.renderOrder) {
      return a2.renderOrder - b3.renderOrder;
    } else if (a2.z !== b3.z) {
      return b3.z - a2.z;
    } else if (a2.id !== b3.id) {
      return a2.id - b3.id;
    } else {
      return 0;
    }
  }
  function clipLine(s1, s2) {
    var alpha1 = 0, alpha2 = 1, bc1near = s1.z + s1.w, bc2near = s2.z + s2.w, bc1far = -s1.z + s1.w, bc2far = -s2.z + s2.w;
    if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {
      return true;
    } else if (bc1near < 0 && bc2near < 0 || bc1far < 0 && bc2far < 0) {
      return false;
    } else {
      if (bc1near < 0) {
        alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));
      } else if (bc2near < 0) {
        alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));
      }
      if (bc1far < 0) {
        alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));
      } else if (bc2far < 0) {
        alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));
      }
      if (alpha2 < alpha1) {
        return false;
      } else {
        s1.lerp(s2, alpha1);
        s2.lerp(s1, 1 - alpha2);
        return true;
      }
    }
  }
};

// node_modules/three-stdlib/renderers/SVGRenderer.js
var SVGObject = function(node) {
  Object3D.call(this);
  this.node = node;
};
SVGObject.prototype = Object.create(Object3D.prototype);
SVGObject.prototype.constructor = SVGObject;
var SVGRenderer = function() {
  var _this = this, _renderData, _elements, _lights, _projector = new Projector(), _svg = document.createElementNS("http://www.w3.org/2000/svg", "svg"), _svgWidth, _svgHeight, _svgWidthHalf, _svgHeightHalf, _v14, _v23, _v3, _clipBox = new Box2(), _elemBox = new Box2(), _color = new Color(), _diffuseColor = new Color(), _ambientLight = new Color(), _directionalLights = new Color(), _pointLights = new Color(), _clearColor = new Color(), _vector3 = new Vector3(), _centroid = new Vector3(), _normal = new Vector3(), _normalViewMatrix = new Matrix3(), _viewMatrix = new Matrix4(), _viewProjectionMatrix = new Matrix4(), _svgPathPool = [], _svgNode, _pathCount = 0, _currentPath, _currentStyle, _quality = 1, _precision = null;
  this.domElement = _svg;
  this.autoClear = true;
  this.sortObjects = true;
  this.sortElements = true;
  this.overdraw = 0.5;
  this.info = {
    render: {
      vertices: 0,
      faces: 0
    }
  };
  this.setQuality = function(quality) {
    switch (quality) {
      case "high":
        _quality = 1;
        break;
      case "low":
        _quality = 0;
        break;
    }
  };
  this.setClearColor = function(color2) {
    _clearColor.set(color2);
  };
  this.setPixelRatio = function() {
  };
  this.setSize = function(width, height) {
    _svgWidth = width;
    _svgHeight = height;
    _svgWidthHalf = _svgWidth / 2;
    _svgHeightHalf = _svgHeight / 2;
    _svg.setAttribute("viewBox", -_svgWidthHalf + " " + -_svgHeightHalf + " " + _svgWidth + " " + _svgHeight);
    _svg.setAttribute("width", _svgWidth);
    _svg.setAttribute("height", _svgHeight);
    _clipBox.min.set(-_svgWidthHalf, -_svgHeightHalf);
    _clipBox.max.set(_svgWidthHalf, _svgHeightHalf);
  };
  this.getSize = function() {
    return {
      width: _svgWidth,
      height: _svgHeight
    };
  };
  this.setPrecision = function(precision) {
    _precision = precision;
  };
  function removeChildNodes() {
    _pathCount = 0;
    while (_svg.childNodes.length > 0) {
      _svg.removeChild(_svg.childNodes[0]);
    }
  }
  function convert(c) {
    return _precision !== null ? c.toFixed(_precision) : c;
  }
  this.clear = function() {
    removeChildNodes();
    _svg.style.backgroundColor = _clearColor.getStyle();
  };
  this.render = function(scene, camera) {
    if (camera instanceof Camera === false) {
      console.error("THREE.SVGRenderer.render: camera is not an instance of Camera.");
      return;
    }
    var background = scene.background;
    if (background && background.isColor) {
      removeChildNodes();
      _svg.style.backgroundColor = background.getStyle();
    } else if (this.autoClear === true) {
      this.clear();
    }
    _this.info.render.vertices = 0;
    _this.info.render.faces = 0;
    _viewMatrix.copy(camera.matrixWorldInverse);
    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
    _renderData = _projector.projectScene(scene, camera, this.sortObjects, this.sortElements);
    _elements = _renderData.elements;
    _lights = _renderData.lights;
    _normalViewMatrix.getNormalMatrix(camera.matrixWorldInverse);
    calculateLights(_lights);
    _currentPath = "";
    _currentStyle = "";
    for (let e = 0, el = _elements.length; e < el; e++) {
      var element2 = _elements[e];
      var material = element2.material;
      if (material === void 0 || material.opacity === 0)
        continue;
      _elemBox.makeEmpty();
      if (element2 instanceof RenderableSprite) {
        _v14 = element2;
        _v14.x *= _svgWidthHalf;
        _v14.y *= -_svgHeightHalf;
        renderSprite(_v14, element2, material);
      } else if (element2 instanceof RenderableLine) {
        _v14 = element2.v1;
        _v23 = element2.v2;
        _v14.positionScreen.x *= _svgWidthHalf;
        _v14.positionScreen.y *= -_svgHeightHalf;
        _v23.positionScreen.x *= _svgWidthHalf;
        _v23.positionScreen.y *= -_svgHeightHalf;
        _elemBox.setFromPoints([_v14.positionScreen, _v23.positionScreen]);
        if (_clipBox.intersectsBox(_elemBox) === true) {
          renderLine(_v14, _v23, element2, material);
        }
      } else if (element2 instanceof RenderableFace) {
        _v14 = element2.v1;
        _v23 = element2.v2;
        _v3 = element2.v3;
        if (_v14.positionScreen.z < -1 || _v14.positionScreen.z > 1)
          continue;
        if (_v23.positionScreen.z < -1 || _v23.positionScreen.z > 1)
          continue;
        if (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1)
          continue;
        _v14.positionScreen.x *= _svgWidthHalf;
        _v14.positionScreen.y *= -_svgHeightHalf;
        _v23.positionScreen.x *= _svgWidthHalf;
        _v23.positionScreen.y *= -_svgHeightHalf;
        _v3.positionScreen.x *= _svgWidthHalf;
        _v3.positionScreen.y *= -_svgHeightHalf;
        if (this.overdraw > 0) {
          expand(_v14.positionScreen, _v23.positionScreen, this.overdraw);
          expand(_v23.positionScreen, _v3.positionScreen, this.overdraw);
          expand(_v3.positionScreen, _v14.positionScreen, this.overdraw);
        }
        _elemBox.setFromPoints([_v14.positionScreen, _v23.positionScreen, _v3.positionScreen]);
        if (_clipBox.intersectsBox(_elemBox) === true) {
          renderFace3(_v14, _v23, _v3, element2, material);
        }
      }
    }
    flushPath();
    scene.traverseVisible(function(object) {
      if (object instanceof SVGObject) {
        _vector3.setFromMatrixPosition(object.matrixWorld);
        _vector3.applyMatrix4(_viewProjectionMatrix);
        if (_vector3.z < -1 || _vector3.z > 1)
          return;
        var x = _vector3.x * _svgWidthHalf;
        var y = -_vector3.y * _svgHeightHalf;
        var node = object.node;
        node.setAttribute("transform", "translate(" + x + "," + y + ")");
        _svg.appendChild(node);
      }
    });
  };
  function calculateLights(lights) {
    _ambientLight.setRGB(0, 0, 0);
    _directionalLights.setRGB(0, 0, 0);
    _pointLights.setRGB(0, 0, 0);
    for (let l = 0, ll = lights.length; l < ll; l++) {
      var light = lights[l];
      var lightColor = light.color;
      if (light.isAmbientLight) {
        _ambientLight.r += lightColor.r;
        _ambientLight.g += lightColor.g;
        _ambientLight.b += lightColor.b;
      } else if (light.isDirectionalLight) {
        _directionalLights.r += lightColor.r;
        _directionalLights.g += lightColor.g;
        _directionalLights.b += lightColor.b;
      } else if (light.isPointLight) {
        _pointLights.r += lightColor.r;
        _pointLights.g += lightColor.g;
        _pointLights.b += lightColor.b;
      }
    }
  }
  function calculateLight(lights, position, normal, color2) {
    for (let l = 0, ll = lights.length; l < ll; l++) {
      var light = lights[l];
      var lightColor = light.color;
      if (light.isDirectionalLight) {
        var lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld).normalize();
        var amount = normal.dot(lightPosition);
        if (amount <= 0)
          continue;
        amount *= light.intensity;
        color2.r += lightColor.r * amount;
        color2.g += lightColor.g * amount;
        color2.b += lightColor.b * amount;
      } else if (light.isPointLight) {
        var lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld);
        var amount = normal.dot(_vector3.subVectors(lightPosition, position).normalize());
        if (amount <= 0)
          continue;
        amount *= light.distance == 0 ? 1 : 1 - Math.min(position.distanceTo(lightPosition) / light.distance, 1);
        if (amount == 0)
          continue;
        amount *= light.intensity;
        color2.r += lightColor.r * amount;
        color2.g += lightColor.g * amount;
        color2.b += lightColor.b * amount;
      }
    }
  }
  function renderSprite(v12, element2, material) {
    var scaleX = element2.scale.x * _svgWidthHalf;
    var scaleY = element2.scale.y * _svgHeightHalf;
    if (material.isPointsMaterial) {
      scaleX *= material.size;
      scaleY *= material.size;
    }
    var path = "M" + convert(v12.x - scaleX * 0.5) + "," + convert(v12.y - scaleY * 0.5) + "h" + convert(scaleX) + "v" + convert(scaleY) + "h" + convert(-scaleX) + "z";
    var style = "";
    if (material.isSpriteMaterial || material.isPointsMaterial) {
      style = "fill:" + material.color.getStyle() + ";fill-opacity:" + material.opacity;
    }
    addPath(style, path);
  }
  function renderLine(v12, v2, element2, material) {
    var path = "M" + convert(v12.positionScreen.x) + "," + convert(v12.positionScreen.y) + "L" + convert(v2.positionScreen.x) + "," + convert(v2.positionScreen.y);
    if (material.isLineBasicMaterial) {
      var style = "fill:none;stroke:" + material.color.getStyle() + ";stroke-opacity:" + material.opacity + ";stroke-width:" + material.linewidth + ";stroke-linecap:" + material.linecap;
      if (material.isLineDashedMaterial) {
        style = style + ";stroke-dasharray:" + material.dashSize + "," + material.gapSize;
      }
      addPath(style, path);
    }
  }
  function renderFace3(v12, v2, v3, element2, material) {
    _this.info.render.vertices += 3;
    _this.info.render.faces++;
    var path = "M" + convert(v12.positionScreen.x) + "," + convert(v12.positionScreen.y) + "L" + convert(v2.positionScreen.x) + "," + convert(v2.positionScreen.y) + "L" + convert(v3.positionScreen.x) + "," + convert(v3.positionScreen.y) + "z";
    var style = "";
    if (material.isMeshBasicMaterial) {
      _color.copy(material.color);
      if (material.vertexColors) {
        _color.multiply(element2.color);
      }
    } else if (material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial) {
      _diffuseColor.copy(material.color);
      if (material.vertexColors) {
        _diffuseColor.multiply(element2.color);
      }
      _color.copy(_ambientLight);
      _centroid.copy(v12.positionWorld).add(v2.positionWorld).add(v3.positionWorld).divideScalar(3);
      calculateLight(_lights, _centroid, element2.normalModel, _color);
      _color.multiply(_diffuseColor).add(material.emissive);
    } else if (material.isMeshNormalMaterial) {
      _normal.copy(element2.normalModel).applyMatrix3(_normalViewMatrix).normalize();
      _color.setRGB(_normal.x, _normal.y, _normal.z).multiplyScalar(0.5).addScalar(0.5);
    }
    if (material.wireframe) {
      style = "fill:none;stroke:" + _color.getStyle() + ";stroke-opacity:" + material.opacity + ";stroke-width:" + material.wireframeLinewidth + ";stroke-linecap:" + material.wireframeLinecap + ";stroke-linejoin:" + material.wireframeLinejoin;
    } else {
      style = "fill:" + _color.getStyle() + ";fill-opacity:" + material.opacity;
    }
    addPath(style, path);
  }
  function expand(v12, v2, pixels) {
    var x = v2.x - v12.x, y = v2.y - v12.y, det = x * x + y * y, idet;
    if (det === 0)
      return;
    idet = pixels / Math.sqrt(det);
    x *= idet;
    y *= idet;
    v2.x += x;
    v2.y += y;
    v12.x -= x;
    v12.y -= y;
  }
  function addPath(style, path) {
    if (_currentStyle === style) {
      _currentPath += path;
    } else {
      flushPath();
      _currentStyle = style;
      _currentPath = path;
    }
  }
  function flushPath() {
    if (_currentPath) {
      _svgNode = getPathNode(_pathCount++);
      _svgNode.setAttribute("d", _currentPath);
      _svgNode.setAttribute("style", _currentStyle);
      _svg.appendChild(_svgNode);
    }
    _currentPath = "";
    _currentStyle = "";
  }
  function getPathNode(id) {
    if (_svgPathPool[id] == null) {
      _svgPathPool[id] = document.createElementNS("http://www.w3.org/2000/svg", "path");
      if (_quality == 0) {
        _svgPathPool[id].setAttribute("shape-rendering", "crispEdges");
      }
      return _svgPathPool[id];
    }
    return _svgPathPool[id];
  }
};

// node_modules/three-stdlib/textures/FlakesTexture.js
var FlakesTexture = class {
  constructor(width = 512, height = 512) {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext("2d");
    context.fillStyle = "rgb(127,127,255)";
    context.fillRect(0, 0, width, height);
    for (let i2 = 0; i2 < 4e3; i2++) {
      const x = Math.random() * width;
      const y = Math.random() * height;
      const r = Math.random() * 3 + 3;
      let nx = Math.random() * 2 - 1;
      let ny = Math.random() * 2 - 1;
      let nz = 1.5;
      const l = Math.sqrt(nx * nx + ny * ny + nz * nz);
      nx /= l;
      ny /= l;
      nz /= l;
      context.fillStyle = "rgb(" + (nx * 127 + 127) + "," + (ny * 127 + 127) + "," + nz * 255 + ")";
      context.beginPath();
      context.arc(x, y, r, 0, Math.PI * 2);
      context.fill();
    }
    return canvas;
  }
};

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/three-stdlib/modifiers/CurveModifier.js
var CHANNELS = 4;
var TEXTURE_WIDTH = 1024;
var TEXTURE_HEIGHT = 4;
var initSplineTexture = (numberOfCurves = 1) => {
  const dataArray2 = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS);
  const dataTexture = new DataTexture(dataArray2, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, FloatType);
  dataTexture.wrapS = RepeatWrapping;
  dataTexture.wrapT = RepeatWrapping;
  dataTexture.magFilter = NearestFilter;
  dataTexture.needsUpdate = true;
  return dataTexture;
};
var updateSplineTexture = (texture2, splineCurve, offset = 0) => {
  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));
  splineCurve.arcLengthDivisions = numberOfPoints / 2;
  splineCurve.updateArcLengths();
  const points = splineCurve.getSpacedPoints(numberOfPoints);
  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);
  for (let i2 = 0; i2 < numberOfPoints; i2++) {
    const rowOffset = Math.floor(i2 / TEXTURE_WIDTH);
    const rowIndex = i2 % TEXTURE_WIDTH;
    let pt = points[i2];
    setTextureValue(texture2, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);
    pt = frenetFrames.tangents[i2];
    setTextureValue(texture2, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);
    pt = frenetFrames.normals[i2];
    setTextureValue(texture2, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);
    pt = frenetFrames.binormals[i2];
    setTextureValue(texture2, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);
  }
  texture2.needsUpdate = true;
};
var setTextureValue = (texture2, index, x, y, z, o) => {
  const image = texture2.image;
  const {
    data
  } = image;
  const i2 = CHANNELS * TEXTURE_WIDTH * o;
  data[index * CHANNELS + i2 + 0] = x;
  data[index * CHANNELS + i2 + 1] = y;
  data[index * CHANNELS + i2 + 2] = z;
  data[index * CHANNELS + i2 + 3] = 1;
};
var getUniforms = (splineTexture) => ({
  spineTexture: {
    value: splineTexture
  },
  pathOffset: {
    type: "f",
    value: 0
  },
  pathSegment: {
    type: "f",
    value: 1
  },
  spineOffset: {
    type: "f",
    value: 161
  },
  spineLength: {
    type: "f",
    value: 400
  },
  flow: {
    type: "i",
    value: 1
  }
});
function modifyShader(material, uniforms, numberOfCurves = 1) {
  if (material.__ok)
    return;
  material.__ok = true;
  material.onBeforeCompile = (shader) => {
    if (shader.__modified)
      return;
    shader.__modified = true;
    Object.assign(shader.uniforms, uniforms);
    const vertexShader = `
		uniform sampler2D spineTexture;
		uniform float pathOffset;
		uniform float pathSegment;
		uniform float spineOffset;
		uniform float spineLength;
		uniform int flow;

		float textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;
		float textureStacks = ${TEXTURE_HEIGHT / 4}.;

		${shader.vertexShader}
		`.replace("#include <beginnormal_vertex>", "").replace("#include <defaultnormal_vertex>", "").replace("#include <begin_vertex>", "").replace(
      /void\s*main\s*\(\)\s*\{/,
      `
        void main() {
        #include <beginnormal_vertex>

        vec4 worldPos = modelMatrix * vec4(position, 1.);

        bool bend = flow > 0;
        float xWeight = bend ? 0. : 1.;

        #ifdef USE_INSTANCING
        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];
        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];
        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;
        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;
        #else
        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;
        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;
        #endif

        mt = mod(mt, textureStacks);
        float rowOffset = floor(mt);

        #ifdef USE_INSTANCING
        rowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;
        #endif

        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;
        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;
        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;
        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;
        mat3 basis = mat3(a, b, c);

        vec3 transformed = basis
          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)
          + spinePos;

        vec3 transformedNormal = normalMatrix * (basis * objectNormal);
			`
    ).replace(
      "#include <project_vertex>",
      `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
				gl_Position = projectionMatrix * mvPosition;`
    );
    shader.vertexShader = vertexShader;
  };
}
var Flow = class {
  constructor(mesh, numberOfCurves = 1) {
    _defineProperty(this, "curveArray", void 0);
    _defineProperty(this, "curveLengthArray", void 0);
    _defineProperty(this, "object3D", void 0);
    _defineProperty(this, "splineTexure", void 0);
    _defineProperty(this, "uniforms", void 0);
    const obj3D = mesh.clone();
    const splineTexure = initSplineTexture(numberOfCurves);
    const uniforms = getUniforms(splineTexure);
    obj3D.traverse((child) => {
      if (child instanceof Mesh || child instanceof InstancedMesh) {
        child.material = child.material.clone();
        modifyShader(child.material, uniforms, numberOfCurves);
      }
    });
    this.curveArray = new Array(numberOfCurves);
    this.curveLengthArray = new Array(numberOfCurves);
    this.object3D = obj3D;
    this.splineTexure = splineTexure;
    this.uniforms = uniforms;
  }
  updateCurve(index, curve) {
    if (index >= this.curveArray.length)
      throw Error("Index out of range for Flow");
    const curveLength = curve.getLength();
    this.uniforms.spineLength.value = curveLength;
    this.curveLengthArray[index] = curveLength;
    this.curveArray[index] = curve;
    updateSplineTexture(this.splineTexure, curve, index);
  }
  moveAlongCurve(amount) {
    this.uniforms.pathOffset.value += amount;
  }
};
var matrix = new Matrix4();
var InstancedFlow = class extends Flow {
  constructor(count, curveCount, geometry, material) {
    const mesh = new InstancedMesh(geometry, material, count);
    mesh.instanceMatrix.setUsage(DynamicDrawUsage);
    super(mesh, curveCount);
    _defineProperty(this, "offsets", void 0);
    _defineProperty(this, "whichCurve", void 0);
    this.offsets = new Array(count).fill(0);
    this.whichCurve = new Array(count).fill(0);
  }
  writeChanges(index) {
    matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);
    this.object3D.setMatrixAt(index, matrix);
    this.object3D.instanceMatrix.needsUpdate = true;
  }
  moveIndividualAlongCurve(index, offset) {
    this.offsets[index] += offset;
    this.writeChanges(index);
  }
  setCurve(index, curveNo) {
    if (isNaN(curveNo))
      throw Error("curve index being set is Not a Number (NaN)");
    this.whichCurve[index] = curveNo;
    this.writeChanges(index);
  }
};

// node_modules/three-stdlib/utils/BufferGeometryUtils.js
var BufferGeometryUtils_exports = {};
__export(BufferGeometryUtils_exports, {
  computeMorphedAttributes: () => computeMorphedAttributes,
  estimateBytesUsed: () => estimateBytesUsed,
  interleaveAttributes: () => interleaveAttributes,
  mergeBufferAttributes: () => mergeBufferAttributes,
  mergeBufferGeometries: () => mergeBufferGeometries,
  mergeVertices: () => mergeVertices,
  toTrianglesDrawMode: () => toTrianglesDrawMode
});

// node_modules/three-stdlib/types/helpers.js
var getWithKey = (obj, key) => obj[key];

// node_modules/three-stdlib/utils/BufferGeometryUtils.js
var mergeBufferGeometries = (geometries, useGroups) => {
  const isIndexed = geometries[0].index !== null;
  const attributesUsed = new Set(Object.keys(geometries[0].attributes));
  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
  const attributes = {};
  const morphAttributes = {};
  const morphTargetsRelative = geometries[0].morphTargetsRelative;
  const mergedGeometry = new BufferGeometry();
  let offset = 0;
  geometries.forEach((geom, i2) => {
    let attributesCount = 0;
    if (isIndexed !== (geom.index !== null)) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i2 + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
      return null;
    }
    for (let name in geom.attributes) {
      if (!attributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i2 + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
        return null;
      }
      if (attributes[name] === void 0) {
        attributes[name] = [];
      }
      attributes[name].push(geom.attributes[name]);
      attributesCount++;
    }
    if (attributesCount !== attributesUsed.size) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i2 + ". Make sure all geometries have the same number of attributes.");
      return null;
    }
    if (morphTargetsRelative !== geom.morphTargetsRelative) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i2 + ". .morphTargetsRelative must be consistent throughout all geometries.");
      return null;
    }
    for (let name in geom.morphAttributes) {
      if (!morphAttributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i2 + ".  .morphAttributes must be consistent throughout all geometries.");
        return null;
      }
      if (morphAttributes[name] === void 0)
        morphAttributes[name] = [];
      morphAttributes[name].push(geom.morphAttributes[name]);
    }
    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];
    mergedGeometry.userData.mergedUserData.push(geom.userData);
    if (useGroups) {
      let count;
      if (geom.index) {
        count = geom.index.count;
      } else if (geom.attributes.position !== void 0) {
        count = geom.attributes.position.count;
      } else {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i2 + ". The geometry must have either an index or a position attribute");
        return null;
      }
      mergedGeometry.addGroup(offset, count, i2);
      offset += count;
    }
  });
  if (isIndexed) {
    let indexOffset = 0;
    const mergedIndex = [];
    geometries.forEach((geom) => {
      const index = geom.index;
      for (let j2 = 0; j2 < index.count; ++j2) {
        mergedIndex.push(index.getX(j2) + indexOffset);
      }
      indexOffset += geom.attributes.position.count;
    });
    mergedGeometry.setIndex(mergedIndex);
  }
  for (let name in attributes) {
    const mergedAttribute = mergeBufferAttributes(attributes[name]);
    if (!mergedAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + name + " attribute.");
      return null;
    }
    mergedGeometry.setAttribute(name, mergedAttribute);
  }
  for (let name in morphAttributes) {
    const numMorphTargets = morphAttributes[name][0].length;
    if (numMorphTargets === 0)
      break;
    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
    mergedGeometry.morphAttributes[name] = [];
    for (let i2 = 0; i2 < numMorphTargets; ++i2) {
      const morphAttributesToMerge = [];
      for (let j2 = 0; j2 < morphAttributes[name].length; ++j2) {
        morphAttributesToMerge.push(morphAttributes[name][j2][i2]);
      }
      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);
      if (!mergedMorphAttribute) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + name + " morphAttribute.");
        return null;
      }
      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
    }
  }
  return mergedGeometry;
};
var mergeBufferAttributes = (attributes) => {
  let TypedArray = void 0;
  let itemSize = void 0;
  let normalized = void 0;
  let arrayLength = 0;
  attributes.forEach((attr) => {
    if (TypedArray === void 0) {
      TypedArray = attr.array.constructor;
    }
    if (TypedArray !== attr.array.constructor) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
      return null;
    }
    if (itemSize === void 0)
      itemSize = attr.itemSize;
    if (itemSize !== attr.itemSize) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
      return null;
    }
    if (normalized === void 0)
      normalized = attr.normalized;
    if (normalized !== attr.normalized) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
      return null;
    }
    arrayLength += attr.array.length;
  });
  if (TypedArray && itemSize) {
    const array = new TypedArray(arrayLength);
    let offset = 0;
    attributes.forEach((attr) => {
      array.set(attr.array, offset);
      offset += attr.array.length;
    });
    return new BufferAttribute(array, itemSize, normalized);
  }
};
var interleaveAttributes = (attributes) => {
  let TypedArray = void 0;
  let arrayLength = 0;
  let stride = 0;
  for (let i2 = 0, l = attributes.length; i2 < l; ++i2) {
    const attribute2 = attributes[i2];
    if (TypedArray === void 0)
      TypedArray = attribute2.array.constructor;
    if (TypedArray !== attribute2.array.constructor) {
      console.error("AttributeBuffers of different types cannot be interleaved");
      return null;
    }
    arrayLength += attribute2.array.length;
    stride += attribute2.itemSize;
  }
  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);
  let offset = 0;
  const res = [];
  const getters = ["getX", "getY", "getZ", "getW"];
  const setters = ["setX", "setY", "setZ", "setW"];
  for (let j2 = 0, l = attributes.length; j2 < l; j2++) {
    const attribute2 = attributes[j2];
    const itemSize = attribute2.itemSize;
    const count = attribute2.count;
    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute2.normalized);
    res.push(iba);
    offset += itemSize;
    for (let c = 0; c < count; c++) {
      for (let k = 0; k < itemSize; k++) {
        const set = getWithKey(iba, setters[k]);
        const get = getWithKey(attribute2, getters[k]);
        set(c, get(c));
      }
    }
  }
  return res;
};
function estimateBytesUsed(geometry) {
  let mem = 0;
  for (let name in geometry.attributes) {
    const attr = geometry.getAttribute(name);
    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;
  }
  const indices = geometry.getIndex();
  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
  return mem;
}
function mergeVertices(geometry, tolerance = 1e-4) {
  tolerance = Math.max(tolerance, Number.EPSILON);
  const hashToIndex = {};
  const indices = geometry.getIndex();
  const positions = geometry.getAttribute("position");
  const vertexCount = indices ? indices.count : positions.count;
  let nextIndex = 0;
  const attributeNames = Object.keys(geometry.attributes);
  const attrArrays = {};
  const morphAttrsArrays = {};
  const newIndices = [];
  const getters = ["getX", "getY", "getZ", "getW"];
  for (let i2 = 0, l = attributeNames.length; i2 < l; i2++) {
    const name = attributeNames[i2];
    attrArrays[name] = [];
    const morphAttr = geometry.morphAttributes[name];
    if (morphAttr) {
      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);
    }
  }
  const decimalShift = Math.log10(1 / tolerance);
  const shiftMultiplier = Math.pow(10, decimalShift);
  for (let i2 = 0; i2 < vertexCount; i2++) {
    const index = indices ? indices.getX(i2) : i2;
    let hash = "";
    for (let j2 = 0, l = attributeNames.length; j2 < l; j2++) {
      const name = attributeNames[j2];
      const attribute2 = geometry.getAttribute(name);
      const itemSize = attribute2.itemSize;
      for (let k = 0; k < itemSize; k++) {
        hash += `${~~(attribute2[getters[k]](index) * shiftMultiplier)},`;
      }
    }
    if (hash in hashToIndex) {
      newIndices.push(hashToIndex[hash]);
    } else {
      for (let j2 = 0, l = attributeNames.length; j2 < l; j2++) {
        const name = attributeNames[j2];
        const attribute2 = geometry.getAttribute(name);
        const morphAttr = geometry.morphAttributes[name];
        const itemSize = attribute2.itemSize;
        const newarray = attrArrays[name];
        const newMorphArrays = morphAttrsArrays[name];
        for (let k = 0; k < itemSize; k++) {
          const getterFunc = getters[k];
          newarray.push(attribute2[getterFunc](index));
          if (morphAttr) {
            for (let m = 0, ml = morphAttr.length; m < ml; m++) {
              newMorphArrays[m].push(morphAttr[m][getterFunc](index));
            }
          }
        }
      }
      hashToIndex[hash] = nextIndex;
      newIndices.push(nextIndex);
      nextIndex++;
    }
  }
  const result = geometry.clone();
  for (let i2 = 0, l = attributeNames.length; i2 < l; i2++) {
    const name = attributeNames[i2];
    const oldAttribute = geometry.getAttribute(name);
    const buffer2 = new oldAttribute.array.constructor(attrArrays[name]);
    const attribute2 = new BufferAttribute(buffer2, oldAttribute.itemSize, oldAttribute.normalized);
    result.setAttribute(name, attribute2);
    if (name in morphAttrsArrays) {
      for (let j2 = 0; j2 < morphAttrsArrays[name].length; j2++) {
        const oldMorphAttribute = geometry.morphAttributes[name][j2];
        const buffer3 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j2]);
        const morphAttribute = new BufferAttribute(buffer3, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);
        result.morphAttributes[name][j2] = morphAttribute;
      }
    }
  }
  result.setIndex(newIndices);
  return result;
}
function toTrianglesDrawMode(geometry, drawMode) {
  if (drawMode === TrianglesDrawMode) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry;
  }
  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
    let index = geometry.getIndex();
    if (index === null) {
      const indices = [];
      const position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (let i2 = 0; i2 < position.count; i2++) {
          indices.push(i2);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (index) {
      if (drawMode === TriangleFanDrawMode) {
        for (let i2 = 1; i2 <= numberOfTriangles; i2++) {
          newIndices.push(index.getX(0));
          newIndices.push(index.getX(i2));
          newIndices.push(index.getX(i2 + 1));
        }
      } else {
        for (let i2 = 0; i2 < numberOfTriangles; i2++) {
          if (i2 % 2 === 0) {
            newIndices.push(index.getX(i2));
            newIndices.push(index.getX(i2 + 1));
            newIndices.push(index.getX(i2 + 2));
          } else {
            newIndices.push(index.getX(i2 + 2));
            newIndices.push(index.getX(i2 + 1));
            newIndices.push(index.getX(i2));
          }
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry;
  }
}
function computeMorphedAttributes(object) {
  if (object.geometry.isBufferGeometry !== true) {
    console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.");
    return null;
  }
  const _vA2 = new Vector3();
  const _vB2 = new Vector3();
  const _vC2 = new Vector3();
  const _tempA = new Vector3();
  const _tempB = new Vector3();
  const _tempC = new Vector3();
  const _morphA = new Vector3();
  const _morphB = new Vector3();
  const _morphC = new Vector3();
  function _calculateMorphedAttributeData(object2, material2, attribute2, morphAttribute, morphTargetsRelative2, a3, b5, c2, modifiedAttributeArray) {
    _vA2.fromBufferAttribute(attribute2, a3);
    _vB2.fromBufferAttribute(attribute2, b5);
    _vC2.fromBufferAttribute(attribute2, c2);
    const morphInfluences = object2.morphTargetInfluences;
    if (material2.morphTargets && morphAttribute && morphInfluences) {
      _morphA.set(0, 0, 0);
      _morphB.set(0, 0, 0);
      _morphC.set(0, 0, 0);
      for (let i3 = 0, il2 = morphAttribute.length; i3 < il2; i3++) {
        const influence = morphInfluences[i3];
        const morph = morphAttribute[i3];
        if (influence === 0)
          continue;
        _tempA.fromBufferAttribute(morph, a3);
        _tempB.fromBufferAttribute(morph, b5);
        _tempC.fromBufferAttribute(morph, c2);
        if (morphTargetsRelative2) {
          _morphA.addScaledVector(_tempA, influence);
          _morphB.addScaledVector(_tempB, influence);
          _morphC.addScaledVector(_tempC, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(_vA2), influence);
          _morphB.addScaledVector(_tempB.sub(_vB2), influence);
          _morphC.addScaledVector(_tempC.sub(_vC2), influence);
        }
      }
      _vA2.add(_morphA);
      _vB2.add(_morphB);
      _vC2.add(_morphC);
    }
    if (object2.isSkinnedMesh) {
      object2.boneTransform(a3, _vA2);
      object2.boneTransform(b5, _vB2);
      object2.boneTransform(c2, _vC2);
    }
    modifiedAttributeArray[a3 * 3 + 0] = _vA2.x;
    modifiedAttributeArray[a3 * 3 + 1] = _vA2.y;
    modifiedAttributeArray[a3 * 3 + 2] = _vA2.z;
    modifiedAttributeArray[b5 * 3 + 0] = _vB2.x;
    modifiedAttributeArray[b5 * 3 + 1] = _vB2.y;
    modifiedAttributeArray[b5 * 3 + 2] = _vB2.z;
    modifiedAttributeArray[c2 * 3 + 0] = _vC2.x;
    modifiedAttributeArray[c2 * 3 + 1] = _vC2.y;
    modifiedAttributeArray[c2 * 3 + 2] = _vC2.z;
  }
  const geometry = object.geometry;
  const material = object.material;
  let a2, b3, c;
  const index = geometry.index;
  const positionAttribute = geometry.attributes.position;
  const morphPosition = geometry.morphAttributes.position;
  const morphTargetsRelative = geometry.morphTargetsRelative;
  const normalAttribute = geometry.attributes.normal;
  const morphNormal = geometry.morphAttributes.position;
  const groups = geometry.groups;
  const drawRange = geometry.drawRange;
  let i2, j2, il, jl2;
  let group, groupMaterial;
  let start, end;
  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);
  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);
  if (index !== null) {
    if (Array.isArray(material)) {
      for (i2 = 0, il = groups.length; i2 < il; i2++) {
        group = groups[i2];
        groupMaterial = material[group.materialIndex];
        start = Math.max(group.start, drawRange.start);
        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
        for (j2 = start, jl2 = end; j2 < jl2; j2 += 3) {
          a2 = index.getX(j2);
          b3 = index.getX(j2 + 1);
          c = index.getX(j2 + 2);
          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a2, b3, c, modifiedPosition);
          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a2, b3, c, modifiedNormal);
        }
      }
    } else {
      start = Math.max(0, drawRange.start);
      end = Math.min(index.count, drawRange.start + drawRange.count);
      for (i2 = start, il = end; i2 < il; i2 += 3) {
        a2 = index.getX(i2);
        b3 = index.getX(i2 + 1);
        c = index.getX(i2 + 2);
        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a2, b3, c, modifiedPosition);
        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a2, b3, c, modifiedNormal);
      }
    }
  } else if (positionAttribute !== void 0) {
    if (Array.isArray(material)) {
      for (i2 = 0, il = groups.length; i2 < il; i2++) {
        group = groups[i2];
        groupMaterial = material[group.materialIndex];
        start = Math.max(group.start, drawRange.start);
        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
        for (j2 = start, jl2 = end; j2 < jl2; j2 += 3) {
          a2 = j2;
          b3 = j2 + 1;
          c = j2 + 2;
          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a2, b3, c, modifiedPosition);
          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a2, b3, c, modifiedNormal);
        }
      }
    } else {
      start = Math.max(0, drawRange.start);
      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (i2 = start, il = end; i2 < il; i2 += 3) {
        a2 = i2;
        b3 = i2 + 1;
        c = i2 + 2;
        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a2, b3, c, modifiedPosition);
        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a2, b3, c, modifiedNormal);
      }
    }
  }
  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);
  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);
  return {
    positionAttribute,
    normalAttribute,
    morphedPositionAttribute,
    morphedNormalAttribute
  };
}

// node_modules/three-stdlib/modifiers/SimplifyModifier.js
var cb = new Vector3();
var ab = new Vector3();
function pushIfUnique(array, object) {
  if (array.indexOf(object) === -1)
    array.push(object);
}
function removeFromArray(array, object) {
  const k = array.indexOf(object);
  if (k > -1)
    array.splice(k, 1);
}
var Vertex = class {
  constructor(v, id) {
    _defineProperty(this, "position", void 0);
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "faces", void 0);
    _defineProperty(this, "neighbors", void 0);
    _defineProperty(this, "collapseCost", void 0);
    _defineProperty(this, "collapseNeighbor", void 0);
    _defineProperty(this, "minCost", 0);
    _defineProperty(this, "totalCost", 0);
    _defineProperty(this, "costCount", 0);
    this.position = v;
    this.id = id;
    this.faces = [];
    this.neighbors = [];
    this.collapseCost = 0;
    this.collapseNeighbor = null;
  }
  addUniqueNeighbor(vertex) {
    pushIfUnique(this.neighbors, vertex);
  }
  removeIfNonNeighbor(n) {
    const neighbors = this.neighbors;
    const faces = this.faces;
    const offset = neighbors.indexOf(n);
    if (offset === -1)
      return;
    for (let i2 = 0; i2 < faces.length; i2++) {
      if (faces[i2].hasVertex(n))
        return;
    }
    neighbors.splice(offset, 1);
  }
};
var Triangle2 = class {
  constructor(v12, v2, v3, a2, b3, c) {
    _defineProperty(this, "a", void 0);
    _defineProperty(this, "b", void 0);
    _defineProperty(this, "c", void 0);
    _defineProperty(this, "v1", void 0);
    _defineProperty(this, "v2", void 0);
    _defineProperty(this, "v3", void 0);
    _defineProperty(this, "normal", new Vector3());
    this.a = a2;
    this.b = b3;
    this.c = c;
    this.v1 = v12;
    this.v2 = v2;
    this.v3 = v3;
    this.computeNormal();
    v12.faces.push(this);
    v12.addUniqueNeighbor(v2);
    v12.addUniqueNeighbor(v3);
    v2.faces.push(this);
    v2.addUniqueNeighbor(v12);
    v2.addUniqueNeighbor(v3);
    v3.faces.push(this);
    v3.addUniqueNeighbor(v12);
    v3.addUniqueNeighbor(v2);
  }
  computeNormal() {
    const vA = this.v1.position;
    const vB = this.v2.position;
    const vC = this.v3.position;
    cb.subVectors(vC, vB);
    ab.subVectors(vA, vB);
    cb.cross(ab).normalize();
    this.normal.copy(cb);
  }
  hasVertex(v) {
    return v === this.v1 || v === this.v2 || v === this.v3;
  }
  replaceVertex(oldv, newv) {
    if (oldv === this.v1)
      this.v1 = newv;
    else if (oldv === this.v2)
      this.v2 = newv;
    else if (oldv === this.v3)
      this.v3 = newv;
    removeFromArray(oldv.faces, this);
    newv.faces.push(this);
    oldv.removeIfNonNeighbor(this.v1);
    this.v1.removeIfNonNeighbor(oldv);
    oldv.removeIfNonNeighbor(this.v2);
    this.v2.removeIfNonNeighbor(oldv);
    oldv.removeIfNonNeighbor(this.v3);
    this.v3.removeIfNonNeighbor(oldv);
    this.v1.addUniqueNeighbor(this.v2);
    this.v1.addUniqueNeighbor(this.v3);
    this.v2.addUniqueNeighbor(this.v1);
    this.v2.addUniqueNeighbor(this.v3);
    this.v3.addUniqueNeighbor(this.v1);
    this.v3.addUniqueNeighbor(this.v2);
    this.computeNormal();
  }
};
var SimplifyModifier = class {
  constructor() {
    _defineProperty(this, "computeEdgeCollapseCost", (u, v) => {
      const edgelength = v.position.distanceTo(u.position);
      let curvature = 0;
      const sideFaces = [];
      let i2, il = u.faces.length, face, sideFace;
      for (i2 = 0; i2 < il; i2++) {
        face = u.faces[i2];
        if (face.hasVertex(v)) {
          sideFaces.push(face);
        }
      }
      for (i2 = 0; i2 < il; i2++) {
        let minCurvature = 1;
        face = u.faces[i2];
        for (let j2 = 0; j2 < sideFaces.length; j2++) {
          sideFace = sideFaces[j2];
          const dotProd = face.normal.dot(sideFace.normal);
          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);
        }
        curvature = Math.max(curvature, minCurvature);
      }
      const borders = 0;
      if (sideFaces.length < 2) {
        curvature = 1;
      }
      const amt = edgelength * curvature + borders;
      return amt;
    });
    _defineProperty(this, "computeEdgeCostAtVertex", (v) => {
      if (v.neighbors.length === 0) {
        v.collapseNeighbor = null;
        v.collapseCost = -0.01;
        return;
      }
      v.collapseCost = 1e5;
      v.collapseNeighbor = null;
      for (let i2 = 0; i2 < v.neighbors.length; i2++) {
        const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i2]);
        if (!v.collapseNeighbor) {
          v.collapseNeighbor = v.neighbors[i2];
          v.collapseCost = collapseCost;
          v.minCost = collapseCost;
          v.totalCost = 0;
          v.costCount = 0;
        }
        v.costCount++;
        v.totalCost += collapseCost;
        if (collapseCost < v.minCost) {
          v.collapseNeighbor = v.neighbors[i2];
          v.minCost = collapseCost;
        }
      }
      v.collapseCost = v.totalCost / v.costCount;
    });
    _defineProperty(this, "removeFace", (f, faces) => {
      removeFromArray(faces, f);
      if (f.v1)
        removeFromArray(f.v1.faces, f);
      if (f.v2)
        removeFromArray(f.v2.faces, f);
      if (f.v3)
        removeFromArray(f.v3.faces, f);
      const vs = [f.v1, f.v2, f.v3];
      let v12, v2;
      for (let i2 = 0; i2 < 3; i2++) {
        v12 = vs[i2];
        v2 = vs[(i2 + 1) % 3];
        if (!v12 || !v2)
          continue;
        v12.removeIfNonNeighbor(v2);
        v2.removeIfNonNeighbor(v12);
      }
    });
    _defineProperty(this, "collapse", (vertices, faces, u, v) => {
      if (!v) {
        this.removeVertex(u, vertices);
        return;
      }
      let i2;
      const tmpVertices = [];
      for (i2 = 0; i2 < u.neighbors.length; i2++) {
        tmpVertices.push(u.neighbors[i2]);
      }
      for (i2 = u.faces.length - 1; i2 >= 0; i2--) {
        if (u.faces[i2].hasVertex(v)) {
          this.removeFace(u.faces[i2], faces);
        }
      }
      for (i2 = u.faces.length - 1; i2 >= 0; i2--) {
        u.faces[i2].replaceVertex(u, v);
      }
      this.removeVertex(u, vertices);
      for (i2 = 0; i2 < tmpVertices.length; i2++) {
        this.computeEdgeCostAtVertex(tmpVertices[i2]);
      }
    });
    _defineProperty(this, "minimumCostEdge", (vertices) => {
      let least = vertices[0];
      for (let i2 = 0; i2 < vertices.length; i2++) {
        if (vertices[i2].collapseCost < least.collapseCost) {
          least = vertices[i2];
        }
      }
      return least;
    });
    _defineProperty(this, "modify", (geometry, count) => {
      geometry = geometry.clone();
      const attributes = geometry.attributes;
      for (let name in attributes) {
        if (name !== "position")
          geometry.deleteAttribute(name);
      }
      geometry = mergeVertices(geometry);
      const vertices = [];
      const faces = [];
      const positionAttribute = geometry.getAttribute("position");
      for (let i2 = 0; i2 < positionAttribute.count; i2++) {
        const v = new Vector3().fromBufferAttribute(positionAttribute, i2);
        const vertex = new Vertex(v, i2);
        vertices.push(vertex);
      }
      const geomIndex = geometry.getIndex();
      if (geomIndex !== null) {
        for (let i2 = 0; i2 < geomIndex.count; i2 += 3) {
          const a2 = geomIndex.getX(i2);
          const b3 = geomIndex.getX(i2 + 1);
          const c = geomIndex.getX(i2 + 2);
          const triangle = new Triangle2(vertices[a2], vertices[b3], vertices[c], a2, b3, c);
          faces.push(triangle);
        }
      } else {
        for (let i2 = 0; i2 < positionAttribute.count; i2 += 3) {
          const a2 = i2;
          const b3 = i2 + 1;
          const c = i2 + 2;
          const triangle = new Triangle2(vertices[a2], vertices[b3], vertices[c], a2, b3, c);
          faces.push(triangle);
        }
      }
      for (let i2 = 0, il = vertices.length; i2 < il; i2++) {
        this.computeEdgeCostAtVertex(vertices[i2]);
      }
      let nextVertex;
      let z = count;
      while (z--) {
        nextVertex = this.minimumCostEdge(vertices);
        if (!nextVertex) {
          console.log("THREE.SimplifyModifier: No next vertex");
          break;
        } else {
          this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);
        }
      }
      const simplifiedGeometry = new BufferGeometry();
      const position = [];
      let index = [];
      for (let i2 = 0; i2 < vertices.length; i2++) {
        const vertex = vertices[i2].position;
        position.push(vertex.x, vertex.y, vertex.z);
      }
      for (let i2 = 0; i2 < faces.length; i2++) {
        const face = faces[i2];
        const a2 = vertices.indexOf(face.v1);
        const b3 = vertices.indexOf(face.v2);
        const c = vertices.indexOf(face.v3);
        index.push(a2, b3, c);
      }
      simplifiedGeometry.setAttribute("position", new Float32BufferAttribute(position, 3));
      simplifiedGeometry.setIndex(index);
      return simplifiedGeometry;
    });
  }
  removeVertex(v, vertices) {
    console.assert(v.faces.length === 0);
    while (v.neighbors.length) {
      const n = v.neighbors.pop();
      removeFromArray(n.neighbors, v);
    }
    removeFromArray(vertices, v);
  }
};

// node_modules/three-stdlib/modifiers/EdgeSplitModifier.js
var EdgeSplitModifier = class {
  constructor() {
    _defineProperty(this, "A", new Vector3());
    _defineProperty(this, "B", new Vector3());
    _defineProperty(this, "C", new Vector3());
    _defineProperty(this, "positions", []);
    _defineProperty(this, "normals", new Float32Array());
    _defineProperty(this, "indexes", []);
    _defineProperty(this, "pointToIndexMap", []);
    _defineProperty(this, "splitIndexes", []);
    _defineProperty(this, "oldNormals", []);
    _defineProperty(this, "computeNormals", () => {
      this.normals = new Float32Array(this.indexes.length * 3);
      for (let i2 = 0; i2 < this.indexes.length; i2 += 3) {
        let index = this.indexes[i2];
        this.A.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);
        index = this.indexes[i2 + 1];
        this.B.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);
        index = this.indexes[i2 + 2];
        this.C.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);
        this.C.sub(this.B);
        this.A.sub(this.B);
        const normal = this.C.cross(this.A).normalize();
        for (let j2 = 0; j2 < 3; j2++) {
          this.normals[3 * (i2 + j2)] = normal.x;
          this.normals[3 * (i2 + j2) + 1] = normal.y;
          this.normals[3 * (i2 + j2) + 2] = normal.z;
        }
      }
    });
    _defineProperty(this, "mapPositionsToIndexes", () => {
      this.pointToIndexMap = Array(this.positions.length / 3);
      for (let i2 = 0; i2 < this.indexes.length; i2++) {
        const index = this.indexes[i2];
        if (this.pointToIndexMap[index] == null) {
          this.pointToIndexMap[index] = [];
        }
        this.pointToIndexMap[index].push(i2);
      }
    });
    _defineProperty(this, "edgeSplitToGroups", (indexes, cutOff, firstIndex) => {
      this.A.set(this.normals[3 * firstIndex], this.normals[3 * firstIndex + 1], this.normals[3 * firstIndex + 2]).normalize();
      const result = {
        splitGroup: [],
        currentGroup: [firstIndex]
      };
      for (let j2 of indexes) {
        if (j2 !== firstIndex) {
          this.B.set(this.normals[3 * j2], this.normals[3 * j2 + 1], this.normals[3 * j2 + 2]).normalize();
          if (this.B.dot(this.A) < cutOff) {
            result.splitGroup.push(j2);
          } else {
            result.currentGroup.push(j2);
          }
        }
      }
      return result;
    });
    _defineProperty(this, "edgeSplit", (indexes, cutOff, original = null) => {
      if (indexes.length === 0)
        return;
      const groupResults = [];
      for (let index of indexes) {
        groupResults.push(this.edgeSplitToGroups(indexes, cutOff, index));
      }
      let result = groupResults[0];
      for (let groupResult of groupResults) {
        if (groupResult.currentGroup.length > result.currentGroup.length) {
          result = groupResult;
        }
      }
      if (original != null) {
        this.splitIndexes.push({
          original,
          indexes: result.currentGroup
        });
      }
      if (result.splitGroup.length) {
        this.edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);
      }
    });
    _defineProperty(this, "modify", (geometry, cutOffAngle, tryKeepNormals = true) => {
      let hadNormals = false;
      if (geometry.attributes.normal) {
        hadNormals = true;
        geometry = geometry.clone();
        if (tryKeepNormals === true && geometry.index !== null) {
          this.oldNormals = geometry.attributes.normal.array;
        }
        geometry.deleteAttribute("normal");
      }
      if (geometry.index == null) {
        if (BufferGeometryUtils_exports === void 0) {
          throw "THREE.EdgeSplitModifier relies on BufferGeometryUtils";
        }
        geometry = mergeVertices(geometry);
      }
      this.indexes = geometry.index.array;
      this.positions = geometry.getAttribute("position").array;
      this.computeNormals();
      this.mapPositionsToIndexes();
      this.splitIndexes = [];
      for (let vertexIndexes of this.pointToIndexMap) {
        this.edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 1e-3);
      }
      const newAttributes = {};
      for (let name of Object.keys(geometry.attributes)) {
        const oldAttribute = geometry.attributes[name];
        const newArray = new oldAttribute.array.constructor((this.indexes.length + this.splitIndexes.length) * oldAttribute.itemSize);
        newArray.set(oldAttribute.array);
        newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);
      }
      const newIndexes = new Uint32Array(this.indexes.length);
      newIndexes.set(this.indexes);
      for (let i2 = 0; i2 < this.splitIndexes.length; i2++) {
        const split = this.splitIndexes[i2];
        const index = this.indexes[split.original];
        for (let attribute2 of Object.values(newAttributes)) {
          for (let j2 = 0; j2 < attribute2.itemSize; j2++) {
            attribute2.array[(this.indexes.length + i2) * attribute2.itemSize + j2] = attribute2.array[index * attribute2.itemSize + j2];
          }
        }
        for (let j2 of split.indexes) {
          newIndexes[j2] = this.indexes.length + i2;
        }
      }
      geometry = new BufferGeometry();
      geometry.setIndex(new BufferAttribute(newIndexes, 1));
      for (let name of Object.keys(newAttributes)) {
        geometry.setAttribute(name, newAttributes[name]);
      }
      if (hadNormals) {
        geometry.computeVertexNormals();
        if (this.oldNormals !== null) {
          const changedNormals = new Array(this.oldNormals.length / 3).fill(false);
          for (let splitData of this.splitIndexes)
            changedNormals[splitData.original] = true;
          for (let i2 = 0; i2 < changedNormals.length; i2++) {
            if (changedNormals[i2] === false) {
              for (let j2 = 0; j2 < 3; j2++) {
                geometry.attributes.normal.array[3 * i2 + j2] = this.oldNormals[3 * i2 + j2];
              }
            }
          }
        }
      }
      return geometry;
    });
  }
};

// node_modules/three-stdlib/modifiers/TessellateModifier.js
var TessellateModifier = class {
  constructor(maxEdgeLength = 0.1, _maxIterations = 6) {
    _defineProperty(this, "maxEdgeLength", void 0);
    _defineProperty(this, "maxIterations", void 0);
    _defineProperty(this, "modify", (geometry) => {
      if (geometry.index !== null) {
        geometry = geometry.toNonIndexed();
      }
      const maxIterations = this.maxIterations;
      const maxEdgeLengthSquared = this.maxEdgeLength * this.maxEdgeLength;
      const va = new Vector3();
      const vb = new Vector3();
      const vc = new Vector3();
      const vm = new Vector3();
      const vs = [va, vb, vc, vm];
      const na = new Vector3();
      const nb = new Vector3();
      const nc = new Vector3();
      const nm = new Vector3();
      const ns = [na, nb, nc, nm];
      const ca = new Color();
      const cb2 = new Color();
      const cc = new Color();
      const cm = new Color();
      const cs = [ca, cb2, cc, cm];
      const ua = new Vector2();
      const ub = new Vector2();
      const uc = new Vector2();
      const um = new Vector2();
      const us = [ua, ub, uc, um];
      const u2a = new Vector2();
      const u2b = new Vector2();
      const u2c = new Vector2();
      const u2m = new Vector2();
      const u2s = [u2a, u2b, u2c, u2m];
      const attributes = geometry.attributes;
      const hasNormals = attributes.normal !== void 0;
      const hasColors = attributes.color !== void 0;
      const hasUVs = attributes.uv !== void 0;
      const hasUV2s = attributes.uv2 !== void 0;
      let positions = attributes.position.array;
      let normals = hasNormals ? attributes.normal.array : null;
      let colors = hasColors ? attributes.color.array : null;
      let uvs = hasUVs ? attributes.uv.array : null;
      let uv2s = hasUV2s ? attributes.uv2.array : null;
      let positions2 = positions;
      let normals2 = normals;
      let colors2 = colors;
      let uvs2 = uvs;
      let uv2s2 = uv2s;
      let iteration = 0;
      let tessellating = true;
      function addTriangle(a2, b3, c) {
        const v12 = vs[a2];
        const v2 = vs[b3];
        const v3 = vs[c];
        positions2.push(v12.x, v12.y, v12.z);
        positions2.push(v2.x, v2.y, v2.z);
        positions2.push(v3.x, v3.y, v3.z);
        if (hasNormals) {
          const n1 = ns[a2];
          const n2 = ns[b3];
          const n3 = ns[c];
          normals2.push(n1.x, n1.y, n1.z);
          normals2.push(n2.x, n2.y, n2.z);
          normals2.push(n3.x, n3.y, n3.z);
        }
        if (hasColors) {
          const c1 = cs[a2];
          const c2 = cs[b3];
          const c3 = cs[c];
          colors2.push(c1.r, c1.g, c1.b);
          colors2.push(c2.r, c2.g, c2.b);
          colors2.push(c3.r, c3.g, c3.b);
        }
        if (hasUVs) {
          const u1 = us[a2];
          const u2 = us[b3];
          const u3 = us[c];
          uvs2.push(u1.x, u1.y);
          uvs2.push(u2.x, u2.y);
          uvs2.push(u3.x, u3.y);
        }
        if (hasUV2s) {
          const u21 = u2s[a2];
          const u22 = u2s[b3];
          const u23 = u2s[c];
          uv2s2.push(u21.x, u21.y);
          uv2s2.push(u22.x, u22.y);
          uv2s2.push(u23.x, u23.y);
        }
      }
      while (tessellating && iteration < maxIterations) {
        iteration++;
        tessellating = false;
        positions = positions2;
        positions2 = [];
        if (hasNormals) {
          normals = normals2;
          normals2 = [];
        }
        if (hasColors) {
          colors = colors2;
          colors2 = [];
        }
        if (hasUVs) {
          uvs = uvs2;
          uvs2 = [];
        }
        if (hasUV2s) {
          uv2s = uv2s2;
          uv2s2 = [];
        }
        for (let i2 = 0, i22 = 0, il = positions.length; i2 < il; i2 += 9, i22 += 6) {
          va.fromArray(positions, i2 + 0);
          vb.fromArray(positions, i2 + 3);
          vc.fromArray(positions, i2 + 6);
          if (hasNormals && normals) {
            na.fromArray(normals, i2 + 0);
            nb.fromArray(normals, i2 + 3);
            nc.fromArray(normals, i2 + 6);
          }
          if (hasColors && colors) {
            ca.fromArray(colors, i2 + 0);
            cb2.fromArray(colors, i2 + 3);
            cc.fromArray(colors, i2 + 6);
          }
          if (hasUVs && uvs) {
            ua.fromArray(uvs, i22 + 0);
            ub.fromArray(uvs, i22 + 2);
            uc.fromArray(uvs, i22 + 4);
          }
          if (hasUV2s && uv2s) {
            u2a.fromArray(uv2s, i22 + 0);
            u2b.fromArray(uv2s, i22 + 2);
            u2c.fromArray(uv2s, i22 + 4);
          }
          const dab = va.distanceToSquared(vb);
          const dbc = vb.distanceToSquared(vc);
          const dac = va.distanceToSquared(vc);
          if (dab > maxEdgeLengthSquared || dbc > maxEdgeLengthSquared || dac > maxEdgeLengthSquared) {
            tessellating = true;
            if (dab >= dbc && dab >= dac) {
              vm.lerpVectors(va, vb, 0.5);
              if (hasNormals)
                nm.lerpVectors(na, nb, 0.5);
              if (hasColors)
                cm.lerpColors(ca, cb2, 0.5);
              if (hasUVs)
                um.lerpVectors(ua, ub, 0.5);
              if (hasUV2s)
                u2m.lerpVectors(u2a, u2b, 0.5);
              addTriangle(0, 3, 2);
              addTriangle(3, 1, 2);
            } else if (dbc >= dab && dbc >= dac) {
              vm.lerpVectors(vb, vc, 0.5);
              if (hasNormals)
                nm.lerpVectors(nb, nc, 0.5);
              if (hasColors)
                cm.lerpColors(cb2, cc, 0.5);
              if (hasUVs)
                um.lerpVectors(ub, uc, 0.5);
              if (hasUV2s)
                u2m.lerpVectors(u2b, u2c, 0.5);
              addTriangle(0, 1, 3);
              addTriangle(3, 2, 0);
            } else {
              vm.lerpVectors(va, vc, 0.5);
              if (hasNormals)
                nm.lerpVectors(na, nc, 0.5);
              if (hasColors)
                cm.lerpColors(ca, cc, 0.5);
              if (hasUVs)
                um.lerpVectors(ua, uc, 0.5);
              if (hasUV2s)
                u2m.lerpVectors(u2a, u2c, 0.5);
              addTriangle(0, 1, 3);
              addTriangle(3, 1, 2);
            }
          } else {
            addTriangle(0, 1, 2);
          }
        }
      }
      const geometry2 = new BufferGeometry();
      geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
      if (hasNormals) {
        geometry2.setAttribute("normal", new Float32BufferAttribute(normals2, 3));
      }
      if (hasColors) {
        geometry2.setAttribute("color", new Float32BufferAttribute(colors2, 3));
      }
      if (hasUVs) {
        geometry2.setAttribute("uv", new Float32BufferAttribute(uvs2, 2));
      }
      if (hasUV2s) {
        geometry2.setAttribute("uv2", new Float32BufferAttribute(uv2s2, 2));
      }
      return geometry2;
    });
    this.maxEdgeLength = maxEdgeLength;
    this.maxIterations = _maxIterations;
  }
};

// node_modules/three-stdlib/nodes/core/constants.js
var NodeShaderStage2 = {
  Vertex: "vertex",
  Fragment: "fragment"
};
var NodeUpdateType2 = {
  None: "none",
  Frame: "frame",
  Object: "object"
};

// node_modules/three-stdlib/nodes/core/NodeUtils.js
var getNodesKeys = (object) => {
  const props = [];
  for (const name in object) {
    const value = object[name];
    if (value && value.isNode === true) {
      props.push(name);
    }
  }
  return props;
};
var getValueType = (value) => {
  if (typeof value === "number") {
    return "float";
  } else if (typeof value === "boolean") {
    return "bool";
  } else if ((value === null || value === void 0 ? void 0 : value.isVector2) === true) {
    return "vec2";
  } else if ((value === null || value === void 0 ? void 0 : value.isVector3) === true) {
    return "vec3";
  } else if ((value === null || value === void 0 ? void 0 : value.isVector4) === true) {
    return "vec4";
  } else if ((value === null || value === void 0 ? void 0 : value.isMatrix3) === true) {
    return "mat3";
  } else if ((value === null || value === void 0 ? void 0 : value.isMatrix4) === true) {
    return "mat4";
  } else if ((value === null || value === void 0 ? void 0 : value.isColor) === true) {
    return "color";
  }
  return null;
};
var getValueFromType = (type2, ...params) => {
  const last4 = type2 === null || type2 === void 0 ? void 0 : type2.slice(-4);
  if (type2 === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type2 === "bool") {
    return false;
  } else if (type2 === "float" || type2 === "int" || type2 === "uint") {
    return 0;
  }
  return null;
};

// node_modules/three-stdlib/nodes/core/Node.js
var _nodeId = 0;
var Node2 = class {
  constructor(nodeType = null) {
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType2.None;
    this.uuid = MathUtils.generateUUID();
    Object.defineProperty(this, "id", {
      value: _nodeId++
    });
  }
  get type() {
    return this.constructor.name;
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getNodeType() {
    return this.nodeType;
  }
  update() {
    console.warn("Abstract function.");
  }
  generate() {
    console.warn("Abstract function.");
  }
  analyze(builder) {
    const hash = this.getHash(builder);
    const sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode !== void 0 && this !== sharedNode) {
      return sharedNode.analyze(builder);
    }
    const nodeData = builder.getDataFromNode(this);
    nodeData.dependenciesCount = nodeData.dependenciesCount === void 0 ? 1 : nodeData.dependenciesCount + 1;
    const nodeKeys = getNodesKeys(this);
    for (const property of nodeKeys) {
      this[property].analyze(builder);
    }
  }
  build(builder, output = null) {
    const hash = this.getHash(builder);
    const sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode !== void 0 && this !== sharedNode) {
      return sharedNode.build(builder, output);
    }
    builder.addNode(this);
    builder.addStack(this);
    const nodeData = builder.getDataFromNode(this);
    const isGenerateOnce = this.generate.length === 1;
    let snippet = null;
    if (isGenerateOnce) {
      const type2 = this.getNodeType(builder);
      snippet = nodeData.snippet;
      if (snippet === void 0) {
        snippet = this.generate(builder) || "";
        nodeData.snippet = snippet;
      }
      snippet = builder.format(snippet, type2, output);
    } else {
      snippet = this.generate(builder, output) || "";
    }
    builder.removeStack(this);
    return snippet;
  }
  serialize(json) {
    const nodeKeys = getNodesKeys(this);
    if (nodeKeys.length > 0) {
      const inputNodes = {};
      for (const property of nodeKeys) {
        inputNodes[property] = this[property].toJSON(json.meta).uuid;
      }
      json.inputNodes = inputNodes;
    }
  }
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property in json.inputNodes) {
        const uuid = json.inputNodes[property];
        this[property] = nodes[uuid];
      }
    }
  }
  toJSON(meta2) {
    const {
      uuid,
      type: type2
    } = this;
    const isRoot = meta2 === void 0 || typeof meta2 === "string";
    if (isRoot) {
      meta2 = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta2.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type: type2,
        meta: meta2,
        metadata: {
          version: 4.5,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      meta2.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta2.textures);
      const images = extractFromCache(meta2.images);
      const nodes = extractFromCache(meta2.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
Node2.prototype.isNode = true;
var Node_default = Node2;

// node_modules/three-stdlib/nodes/core/InputNode.js
var InputNode = class extends Node_default {
  constructor(value, nodeType = null) {
    super(nodeType);
    this.value = value;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  serialize(data) {
    var _this$value, _this$value$toArray;
    super.serialize(data);
    data.value = ((_this$value = this.value) === null || _this$value === void 0 ? void 0 : (_this$value$toArray = _this$value.toArray) === null || _this$value$toArray === void 0 ? void 0 : _this$value$toArray.call(_this$value)) || this.value;
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
  }
  deserialize(data) {
    var _this$value2, _this$value2$fromArra;
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = getValueFromType(data.valueType);
    this.value = ((_this$value2 = this.value) === null || _this$value2 === void 0 ? void 0 : (_this$value2$fromArra = _this$value2.fromArray) === null || _this$value2$fromArra === void 0 ? void 0 : _this$value2$fromArra.call(_this$value2, data.value)) || data.value;
  }
  generate() {
    console.warn("Abstract function.");
  }
};
InputNode.prototype.isInputNode = true;
var InputNode_default = InputNode;

// node_modules/three-stdlib/nodes/core/UniformNode.js
var UniformNode = class extends InputNode_default {
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  generate(builder, output) {
    const type2 = this.getNodeType(builder);
    const hash = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, builder.shaderStage, sharedNodeType);
    const propertyName = builder.getPropertyName(nodeUniform);
    return builder.format(propertyName, type2, output);
  }
};
UniformNode.prototype.isUniformNode = true;
var UniformNode_default = UniformNode;

// node_modules/three-stdlib/nodes/core/ArrayUniformNode.js
var ArrayUniformNode = class extends UniformNode_default {
  constructor(nodes = []) {
    super();
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return this.nodes[0].getNodeType(builder);
  }
};
ArrayUniformNode.prototype.isArrayUniformNode = true;
var ArrayUniformNode_default = ArrayUniformNode;

// node_modules/three-stdlib/nodes/core/VaryNode.js
var VaryNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const node = this.node;
    const name = this.name;
    const nodeVary = builder.getVaryFromNode(this, type2);
    if (name !== null) {
      nodeVary.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVary, NodeShaderStage2.Vertex);
    builder.flowNodeFromShaderStage(NodeShaderStage2.Vertex, node, type2, propertyName);
    return builder.getPropertyName(nodeVary);
  }
};
var VaryNode_default = VaryNode;

// node_modules/three-stdlib/nodes/core/AttributeNode.js
var AttributeNode = class extends Node_default {
  constructor(attributeName, nodeType) {
    super(nodeType);
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attribute2 = builder.getAttribute(this.getAttributeName(builder), this.getNodeType(builder));
    if (builder.isShaderStage("vertex")) {
      return attribute2.name;
    } else {
      const nodeVary = new VaryNode_default(this);
      return nodeVary.build(builder, attribute2.type);
    }
  }
};
var AttributeNode_default = AttributeNode;

// node_modules/three-stdlib/nodes/core/BypassNode.js
var BypassNode = class extends Node_default {
  constructor(returnNode, callNode) {
    super();
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder, output) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addFlowCode(snippet);
    }
    return this.outputNode.build(builder, output);
  }
};
BypassNode.prototype.isBypassNode = true;
var BypassNode_default = BypassNode;

// node_modules/three-stdlib/nodes/core/CodeNode.js
var CodeNode = class extends Node_default {
  constructor(code = "", nodeType = "code") {
    super(nodeType);
    this.code = code;
    this._includes = [];
  }
  setIncludes(includes) {
    this._includes = includes;
    return this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(builder) {
    const includes = this.getIncludes(builder);
    for (const include of includes) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
};
CodeNode.prototype.isCodeNode = true;
var CodeNode_default = CodeNode;

// node_modules/three-stdlib/nodes/core/ConstNode.js
var ConstNode = class extends InputNode_default {
  generateConst(builder) {
    return builder.getConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output) {
    const type2 = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type2, output);
  }
};
ConstNode.prototype.isConstNode = true;
var ConstNode_default = ConstNode;

// node_modules/three-stdlib/nodes/core/ContextNode.js
var ContextNode = class extends Node_default {
  constructor(node, context = {}) {
    super();
    this.node = node;
    this.context = context;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder, output) {
    const previousContext = builder.getContext();
    builder.setContext(Object.assign({}, builder.context, this.context));
    const snippet = this.node.build(builder, output);
    builder.setContext(previousContext);
    return snippet;
  }
};
ContextNode.prototype.isContextNode = true;
var ContextNode_default = ContextNode;

// node_modules/three-stdlib/nodes/core/TempNode.js
var TempNode = class extends Node_default {
  constructor(type2) {
    super(type2);
  }
  build(builder, output) {
    const type2 = builder.getVectorType(this.getNodeType(builder, output));
    const nodeData = builder.getDataFromNode(this);
    if (builder.context.temp !== false && type2 !== "void " && output !== "void" && nodeData.dependenciesCount > 1) {
      if (nodeData.snippet === void 0) {
        const snippet = super.build(builder, type2);
        const nodeVar = builder.getVarFromNode(this, type2);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
      }
      return builder.format(nodeData.propertyName, type2, output);
    }
    return super.build(builder, output);
  }
};
var TempNode_default = TempNode;

// node_modules/three-stdlib/nodes/core/ExpressionNode.js
var ExpressionNode = class extends TempNode_default {
  constructor(snipped = "", nodeType = "void") {
    super(nodeType);
    this.snipped = snipped;
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const snipped = this.snipped;
    if (type2 === "void") {
      builder.addFlowCode(snipped);
    } else {
      return `( ${snipped} )`;
    }
  }
};
var ExpressionNode_default = ExpressionNode;

// node_modules/three-stdlib/nodes/core/FunctionCallNode.js
var FunctionCallNode = class extends TempNode_default {
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    for (const inputNode of inputs) {
      const node = parameters[inputNode.name];
      if (node !== void 0) {
        params.push(node.build(builder, inputNode.type));
      } else {
        throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
};
var FunctionCallNode_default = FunctionCallNode;

// node_modules/three-stdlib/nodes/core/FunctionNode.js
var FunctionNode = class extends CodeNode_default {
  constructor(code = "") {
    super(code);
    this.keywords = {};
  }
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  call(parameters = {}) {
    return new FunctionCallNode_default(this, parameters);
  }
  generate(builder, output) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type2 = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type2);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    let code = this.getNodeFunction(builder).getCode(propertyName);
    const keywords = this.keywords;
    const keywordsProperties = Object.keys(keywords);
    if (keywordsProperties.length > 0) {
      for (const property of keywordsProperties) {
        const propertyRegExp = new RegExp(`\\b${property}\\b`, "g");
        const nodeProperty = keywords[property].build(builder, "property");
        code = code.replace(propertyRegExp, nodeProperty);
      }
    }
    nodeCode.code = code;
    if (output === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type2, output);
    }
  }
};
var FunctionNode_default = FunctionNode;

// node_modules/three-stdlib/nodes/core/NodeAttribute.js
var NodeAttribute = class {
  constructor(name, type2) {
    this.name = name;
    this.type = type2;
  }
};
NodeAttribute.prototype.isNodeAttribute = true;
var NodeAttribute_default = NodeAttribute;

// node_modules/three-stdlib/nodes/core/NodeUniform.js
var NodeUniform = class {
  constructor(name, type2, node, needsUpdate = void 0) {
    this.name = name;
    this.type = type2;
    this.node = node;
    this.needsUpdate = needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
};
NodeUniform.prototype.isNodeUniform = true;
var NodeUniform_default = NodeUniform;

// node_modules/three-stdlib/nodes/core/NodeVary.js
var NodeVary = class {
  constructor(name, type2) {
    this.name = name;
    this.type = type2;
  }
};
NodeVary.prototype.isNodeVary = true;
var NodeVary_default = NodeVary;

// node_modules/three-stdlib/nodes/core/NodeVar.js
var NodeVar = class {
  constructor(name, type2) {
    this.name = name;
    this.type = type2;
  }
};
NodeVar.prototype.isNodeVar = true;
var NodeVar_default = NodeVar;

// node_modules/three-stdlib/nodes/core/NodeCode.js
var NodeCode = class {
  constructor(name, type2, code = "") {
    this.name = name;
    this.type = type2;
    this.code = code;
    Object.defineProperty(this, "isNodeCode", {
      value: true
    });
  }
};
var NodeCode_default = NodeCode;

// node_modules/three-stdlib/nodes/core/NodeKeywords.js
var NodeKeywords = class {
  constructor() {
    this.keywords = [];
    this.nodes = [];
    this.keywordsCallback = {};
  }
  getNode(name) {
    let node = this.nodes[name];
    if (node === void 0 && this.keywordsCallback[name] !== void 0) {
      node = this.keywordsCallback[name](name);
      this.nodes[name] = node;
    }
    return node;
  }
  addKeyword(name, callback) {
    this.keywords.push(name);
    this.keywordsCallback[name] = callback;
    return this;
  }
  parse(code) {
    const keywordNames = this.keywords;
    const regExp = new RegExp(`\\b${keywordNames.join("\\b|\\b")}\\b`, "g");
    const codeKeywords = code.match(regExp);
    const keywordNodes = [];
    if (codeKeywords !== null) {
      for (const keyword of codeKeywords) {
        const node = this.getNode(keyword);
        if (node !== void 0 && keywordNodes.indexOf(node) === -1) {
          keywordNodes.push(node);
        }
      }
    }
    return keywordNodes;
  }
  include(builder, code) {
    const keywordNodes = this.parse(code);
    for (const keywordNode of keywordNodes) {
      keywordNode.build(builder);
    }
  }
};
var NodeKeywords_default = NodeKeywords;

// node_modules/three-stdlib/nodes/core/NodeBuilder.js
var shaderStages = ["fragment", "vertex"];
var vector = ["x", "y", "z", "w"];
var toFloat = (value) => {
  value = Number(value);
  return value + (value % 1 ? "" : ".0");
};
var NodeBuilder = class {
  constructor(object, renderer, parser) {
    this.object = object;
    this.material = object.material;
    this.renderer = renderer;
    this.parser = parser;
    this.nodes = [];
    this.updateNodes = [];
    this.hashNodes = {};
    this.vertexShader = null;
    this.fragmentShader = null;
    this.flowNodes = {
      vertex: [],
      fragment: []
    };
    this.flowCode = {
      vertex: "",
      fragment: ""
    };
    this.uniforms = {
      vertex: [],
      fragment: [],
      index: 0
    };
    this.codes = {
      vertex: [],
      fragment: []
    };
    this.attributes = [];
    this.varys = [];
    this.vars = {
      vertex: [],
      fragment: []
    };
    this.flow = {
      code: ""
    };
    this.stack = [];
    this.context = {
      keywords: new NodeKeywords_default(),
      material: object.material
    };
    this.nodesData = /* @__PURE__ */ new WeakMap();
    this.flowsData = /* @__PURE__ */ new WeakMap();
    this.shaderStage = null;
    this.node = null;
  }
  addStack(node) {
    this.stack.push(node);
  }
  removeStack(node) {
    const lastStack = this.stack.pop();
    if (lastStack !== node) {
      throw new Error("NodeBuilder: Invalid node stack!");
    }
  }
  setHashNode(node, hash) {
    this.hashNodes[hash] = node;
  }
  addNode(node) {
    if (this.nodes.indexOf(node) === -1) {
      const updateType = node.getUpdateType(this);
      if (updateType !== NodeUpdateType2.None) {
        this.updateNodes.push(node);
      }
      this.nodes.push(node);
      this.setHashNode(node, node.getHash(this));
    }
  }
  getMethod(method) {
    return method;
  }
  getNodeFromHash(hash) {
    return this.hashNodes[hash];
  }
  addFlow(shaderStage, node) {
    this.flowNodes[shaderStage].push(node);
    return node;
  }
  setContext(context) {
    this.context = context;
  }
  getContext() {
    return this.context;
  }
  getTexture() {
    console.warn("Abstract function.");
  }
  getTextureBias() {
    console.warn("Abstract function.");
  }
  getCubeTexture() {
    console.warn("Abstract function.");
  }
  getCubeTextureBias() {
    console.warn("Abstract function.");
  }
  getConst(type2, value) {
    if (type2 === "float")
      return toFloat(value);
    if (type2 === "int")
      return `${Math.round(value)}`;
    if (type2 === "uint")
      return value >= 0 ? `${Math.round(value)}u` : "0u";
    if (type2 === "bool")
      return value ? "true" : "false";
    if (type2 === "color") {
      return `${this.getType("vec3")}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
    }
    const typeLength = this.getTypeLength(type2);
    const componentType = this.getComponentType(type2);
    const getConst = (value2) => this.getConst(componentType, value2);
    if (typeLength === 2) {
      return `${this.getType(type2)}( ${getConst(value.x)}, ${getConst(value.y)} )`;
    } else if (typeLength === 3) {
      return `${this.getType(type2)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;
    } else if (typeLength === 4) {
      return `${this.getType(type2)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;
    }
    throw new Error(`NodeBuilder: Type '${type2}' not found in generate constant attempt.`);
  }
  getType(type2) {
    return type2;
  }
  generateMethod(method) {
    return method;
  }
  getAttribute(name, type2) {
    const attributes = this.attributes;
    for (const attribute3 of attributes) {
      if (attribute3.name === name) {
        return attribute3;
      }
    }
    const attribute2 = new NodeAttribute_default(name, type2);
    attributes.push(attribute2);
    return attribute2;
  }
  getPropertyName(node) {
    return node.name;
  }
  isVector(type2) {
    return /vec\d/.test(type2);
  }
  isMatrix(type2) {
    return /mat\d/.test(type2);
  }
  isReference(type2) {
    return type2 === "void" || type2 === "property" || type2 === "sampler";
  }
  isShaderStage(shaderStage) {
    return this.shaderStage === shaderStage;
  }
  getTextureEncodingFromMap(map) {
    let encoding;
    if (map && map.isTexture) {
      encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      encoding = map.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }
    return encoding;
  }
  getComponentType(type2) {
    type2 = this.getVectorType(type2);
    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type2);
    if (componentType === null)
      return null;
    if (componentType[1] === "b")
      return "bool";
    if (componentType[1] === "i")
      return "int";
    if (componentType[1] === "u")
      return "uint";
    return "float";
  }
  getVectorType(type2) {
    if (type2 === "color")
      return "vec3";
    if (type2 === "texture")
      return "vec4";
    return type2;
  }
  getTypeFromLength(type2) {
    if (type2 === 1)
      return "float";
    if (type2 === 2)
      return "vec2";
    if (type2 === 3)
      return "vec3";
    if (type2 === 4)
      return "vec4";
    return 0;
  }
  getTypeLength(type2) {
    const vecType = this.getVectorType(type2);
    const vecNum = /vec([2-4])/.exec(vecType);
    if (vecNum !== null)
      return Number(vecNum[1]);
    if (vecType === "float" || vecType === "bool" || vecType === "int" || vecType === "uint")
      return 1;
    return 0;
  }
  getVectorFromMatrix(type2) {
    return type2.replace("mat", "vec");
  }
  getDataFromNode(node, shaderStage = this.shaderStage) {
    let nodeData = this.nodesData.get(node);
    if (nodeData === void 0) {
      nodeData = {
        vertex: {},
        fragment: {}
      };
      this.nodesData.set(node, nodeData);
    }
    return shaderStage !== null ? nodeData[shaderStage] : nodeData;
  }
  getUniformFromNode(node, shaderStage, type2) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeUniform = nodeData.uniform;
    if (nodeUniform === void 0) {
      const index = this.uniforms.index++;
      nodeUniform = new NodeUniform_default("nodeUniform" + index, type2, node);
      this.uniforms[shaderStage].push(nodeUniform);
      nodeData.uniform = nodeUniform;
    }
    return nodeUniform;
  }
  getVarFromNode(node, type2, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeVar = nodeData.variable;
    if (nodeVar === void 0) {
      const vars = this.vars[shaderStage];
      const index = vars.length;
      nodeVar = new NodeVar_default("nodeVar" + index, type2);
      vars.push(nodeVar);
      nodeData.variable = nodeVar;
    }
    return nodeVar;
  }
  getVaryFromNode(node, type2) {
    const nodeData = this.getDataFromNode(node, null);
    let nodeVary = nodeData.vary;
    if (nodeVary === void 0) {
      const varys = this.varys;
      const index = varys.length;
      nodeVary = new NodeVary_default("nodeVary" + index, type2);
      varys.push(nodeVary);
      nodeData.vary = nodeVary;
    }
    return nodeVary;
  }
  getCodeFromNode(node, type2, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node);
    let nodeCode = nodeData.code;
    if (nodeCode === void 0) {
      const codes = this.codes[shaderStage];
      const index = codes.length;
      nodeCode = new NodeCode_default("nodeCode" + index, type2);
      codes.push(nodeCode);
      nodeData.code = nodeCode;
    }
    return nodeCode;
  }
  addFlowCode(code) {
    this.flow.code += code;
  }
  getFlowData(shaderStage, node) {
    return this.flowsData.get(node);
  }
  flowNode(node) {
    this.node = node;
    const output = node.getNodeType(this);
    const flowData = this.flowChildNode(node, output);
    this.flowsData.set(node, flowData);
    this.node = null;
    return flowData;
  }
  flowChildNode(node, output = null) {
    const previousFlow = this.flow;
    const flow = {
      code: ""
    };
    this.flow = flow;
    flow.result = node.build(this, output);
    this.flow = previousFlow;
    return flow;
  }
  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {
    const previousShaderStage = this.shaderStage;
    this.setShaderStage(shaderStage);
    const flowData = this.flowChildNode(node, output);
    if (propertyName !== null) {
      flowData.code += `${propertyName} = ${flowData.result};
	`;
    }
    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;
    this.setShaderStage(previousShaderStage);
    return flowData;
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVarys() {
    console.warn("Abstract function.");
  }
  getVars(shaderStage) {
    let snippet = "";
    const vars = this.vars[shaderStage];
    for (let index = 0; index < vars.length; index++) {
      const variable = vars[index];
      snippet += `${variable.type} ${variable.name}; `;
    }
    return snippet;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(shaderStage) {
    const codes = this.codes[shaderStage];
    let code = "";
    for (const nodeCode of codes) {
      code += nodeCode.code + "\n";
    }
    return code;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setShaderStage(shaderStage) {
    this.shaderStage = shaderStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    for (const shaderStage of shaderStages) {
      this.setShaderStage(shaderStage);
      const flowNodes = this.flowNodes[shaderStage];
      for (const node of flowNodes) {
        node.analyze(this);
      }
    }
    if (this.context.vertex && this.context.vertex.isNode) {
      this.flowNodeFromShaderStage("vertex", this.context.vertex);
    }
    for (const shaderStage of shaderStages) {
      this.setShaderStage(shaderStage);
      const flowNodes = this.flowNodes[shaderStage];
      for (const node of flowNodes) {
        this.flowNode(node, shaderStage);
      }
    }
    this.setShaderStage(null);
    this.buildCode();
    return this;
  }
  format(snippet, fromType2, toType) {
    fromType2 = this.getVectorType(fromType2);
    toType = this.getVectorType(toType);
    if (fromType2 === toType || toType === null || this.isReference(toType)) {
      return snippet;
    }
    const fromTypeLength = this.getTypeLength(fromType2);
    const toTypeLength = this.getTypeLength(toType);
    if (fromTypeLength === 0) {
      const vectorType = this.getVectorFromMatrix(fromType2);
      return this.format(`( ${snippet} * ${this.getType(vectorType)}( 1.0 ) )`, vectorType, toType);
    }
    if (toTypeLength === 0) {
      return snippet;
    }
    if (fromTypeLength === toTypeLength) {
      return `${this.getType(toType)}( ${snippet} )`;
    }
    if (fromTypeLength > toTypeLength) {
      return this.format(`${snippet}.${"xyz".slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);
    }
    if (toTypeLength === 4) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType2, "vec3")}, 1.0 )`;
    }
    if (fromTypeLength === 2) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType2, "vec2")}, 0.0 )`;
    }
    return `${this.getType(toType)}( ${snippet} )`;
  }
  getSignature() {
    return `// Three.js r${REVISION} - NodeMaterial System
`;
  }
};
var NodeBuilder_default = NodeBuilder;

// node_modules/three-stdlib/nodes/core/NodeFrame.js
var NodeFrame = class {
  constructor() {
    this.time = 0;
    this.deltaTime = 0;
    this.frameId = 0;
    this.startTime = null;
    this.updateMap = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.material = null;
    this.camera = null;
    this.object = null;
  }
  updateNode(node) {
    if (node.updateType === NodeUpdateType2.Frame) {
      if (this.updateMap.get(node) !== this.frameId) {
        this.updateMap.set(node, this.frameId);
        node.update(this);
      }
    } else if (node.updateType === NodeUpdateType2.Object) {
      node.update(this);
    }
  }
  update() {
    this.frameId++;
    if (this.lastTime === void 0)
      this.lastTime = performance.now();
    this.deltaTime = (performance.now() - this.lastTime) / 1e3;
    this.lastTime = performance.now();
    this.time += this.deltaTime;
  }
};
var NodeFrame_default = NodeFrame;

// node_modules/three-stdlib/nodes/core/NodeFunctionInput.js
var NodeFunctionInput = class {
  constructor(type2, name, count = null, qualifier = "", isConst = false) {
    this.type = type2;
    this.name = name;
    this.count = count;
    this.qualifier = qualifier;
    this.isConst = isConst;
  }
};
NodeFunctionInput.isNodeFunctionInput = true;
var NodeFunctionInput_default = NodeFunctionInput;

// node_modules/three-stdlib/nodes/core/PropertyNode.js
var PropertyNode = class extends Node_default {
  constructor(name = null, nodeType = "vec4") {
    super(nodeType);
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  generate(builder) {
    const nodeVary = builder.getVarFromNode(this, this.getNodeType(builder));
    const name = this.name;
    if (name !== null) {
      nodeVary.name = name;
    }
    return builder.getPropertyName(nodeVary);
  }
};
var PropertyNode_default = PropertyNode;

// node_modules/three-stdlib/nodes/core/VarNode.js
var VarNode = class extends Node_default {
  constructor(node, name = null, nodeType = null) {
    super(nodeType);
    this.node = node;
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return super.getNodeType(builder) || this.node.getNodeType(builder);
  }
  generate(builder) {
    const type2 = builder.getVectorType(this.getNodeType(builder));
    const node = this.node;
    const name = this.name;
    const snippet = node.build(builder, type2);
    const nodeVar = builder.getVarFromNode(this, type2);
    if (name !== null) {
      nodeVar.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVar);
    builder.addFlowCode(`${propertyName} = ${snippet}`);
    return propertyName;
  }
};
VarNode.prototype.isVarNode = true;
var VarNode_default = VarNode;

// node_modules/three-stdlib/nodes/accessors/BufferNode.js
var BufferNode = class extends UniformNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  getInputType() {
    return "buffer";
  }
};
BufferNode.prototype.isBufferNode = true;
var BufferNode_default = BufferNode;

// node_modules/three-stdlib/nodes/accessors/Object3DNode.js
var Object3DNode = class extends Node_default {
  constructor(scope2 = Object3DNode.VIEW_MATRIX, object3d = null) {
    super();
    this.scope = scope2;
    this.object3d = object3d;
    this.updateType = NodeUpdateType2.Object;
    this._uniformNode = new UniformNode_default(null);
  }
  getNodeType() {
    const scope2 = this.scope;
    if (scope2 === Object3DNode.WORLD_MATRIX || scope2 === Object3DNode.VIEW_MATRIX) {
      return "mat4";
    } else if (scope2 === Object3DNode.NORMAL_MATRIX) {
      return "mat3";
    } else if (scope2 === Object3DNode.POSITION || scope2 === Object3DNode.VIEW_POSITION) {
      return "vec3";
    }
  }
  update(frame) {
    const object = this.object3d !== null ? this.object3d : frame.object;
    const uniformNode = this._uniformNode;
    const camera = frame.camera;
    const scope2 = this.scope;
    if (scope2 === Object3DNode.VIEW_MATRIX) {
      uniformNode.value = object.modelViewMatrix;
    } else if (scope2 === Object3DNode.NORMAL_MATRIX) {
      uniformNode.value = object.normalMatrix;
    } else if (scope2 === Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope2 === Object3DNode.POSITION) {
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope2 === Object3DNode.VIEW_POSITION) {
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    }
  }
  generate(builder) {
    const scope2 = this.scope;
    if (scope2 === Object3DNode.WORLD_MATRIX || scope2 === Object3DNode.VIEW_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope2 === Object3DNode.NORMAL_MATRIX) {
      this._uniformNode.nodeType = "mat3";
    } else if (scope2 === Object3DNode.POSITION || scope2 === Object3DNode.VIEW_POSITION) {
      this._uniformNode.nodeType = "vec3";
      this._uniformNode.value = new Vector3();
    }
    return this._uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
_defineProperty(Object3DNode, "VIEW_MATRIX", "viewMatrix");
_defineProperty(Object3DNode, "NORMAL_MATRIX", "normalMatrix");
_defineProperty(Object3DNode, "WORLD_MATRIX", "worldMatrix");
_defineProperty(Object3DNode, "POSITION", "position");
_defineProperty(Object3DNode, "VIEW_POSITION", "viewPosition");
var Object3DNode_default = Object3DNode;

// node_modules/three-stdlib/nodes/accessors/CameraNode.js
var CameraNode = class extends Object3DNode_default {
  constructor(scope2 = CameraNode.POSITION) {
    super(scope2);
  }
  getNodeType(builder) {
    const scope2 = this.scope;
    if (scope2 === CameraNode.PROJECTION_MATRIX) {
      return "mat4";
    }
    return super.getNodeType(builder);
  }
  update(frame) {
    const camera = frame.camera;
    const uniformNode = this._uniformNode;
    const scope2 = this.scope;
    if (scope2 === CameraNode.PROJECTION_MATRIX) {
      uniformNode.value = camera.projectionMatrix;
    } else if (scope2 === CameraNode.VIEW_MATRIX) {
      uniformNode.value = camera.matrixWorldInverse;
    } else {
      this.object3d = camera;
      super.update(frame);
    }
  }
  generate(builder) {
    const scope2 = this.scope;
    if (scope2 === CameraNode.PROJECTION_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    }
    return super.generate(builder);
  }
};
_defineProperty(CameraNode, "PROJECTION_MATRIX", "projectionMatrix");
var CameraNode_default = CameraNode;

// node_modules/three-stdlib/nodes/accessors/UVNode.js
var UVNode = class extends AttributeNode_default {
  constructor(index = 0) {
    super(null, "vec2");
    this.index = index;
  }
  getAttributeName() {
    const index = this.index;
    return "uv" + (index > 0 ? index + 1 : "");
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
UVNode.prototype.isUVNode = true;
var UVNode_default = UVNode;

// node_modules/three-stdlib/nodes/accessors/TextureNode.js
var TextureNode = class extends UniformNode_default {
  constructor(value, uvNode = new UVNode_default(), biasNode = null) {
    super(value, "vec4");
    this.uvNode = uvNode;
    this.biasNode = biasNode;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getInputType() {
    return "texture";
  }
  generate(builder, output) {
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("TextureNode: Need a three.js texture.");
    }
    const textureProperty = super.generate(builder, "texture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let snippet = nodeData.snippet;
      if (snippet === void 0) {
        const uvSnippet = this.uvNode.build(builder, "vec2");
        const biasNode = this.biasNode;
        if (biasNode !== null) {
          const biasSnippet = biasNode.build(builder, "float");
          snippet = builder.getTextureBias(textureProperty, uvSnippet, biasSnippet);
        } else {
          snippet = builder.getTexture(textureProperty, uvSnippet);
        }
        nodeData.snippet = snippet;
      }
      return builder.format(snippet, "vec4", output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
  }
};
TextureNode.prototype.isTextureNode = true;
var TextureNode_default = TextureNode;

// node_modules/three-stdlib/nodes/accessors/ModelNode.js
var ModelNode = class extends Object3DNode_default {
  constructor(scope2 = ModelNode.VIEW_MATRIX) {
    super(scope2);
  }
};
var ModelNode_default = ModelNode;

// node_modules/three-stdlib/nodes/utils/JoinNode.js
var JoinNode = class extends Node_default {
  constructor(nodes = []) {
    super();
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const nodes = this.nodes;
    const snippetValues = [];
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const input = nodes[i2];
      const inputSnippet = input.build(builder);
      snippetValues.push(inputSnippet);
    }
    return `${builder.getType(type2)}( ${snippetValues.join(", ")} )`;
  }
};
var JoinNode_default = JoinNode;

// node_modules/three-stdlib/nodes/utils/SplitNode.js
var SplitNode = class extends Node_default {
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
  }
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vector.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length);
  }
  generate(builder) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    if (nodeTypeLength > 1) {
      let type2 = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type2 = builder.getTypeFromLength(this.getVectorLength());
      }
      const nodeSnippet = node.build(builder, type2);
      return `${nodeSnippet}.${this.components}`;
    } else {
      return node.build(builder);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SplitNode_default = SplitNode;

// node_modules/three-stdlib/nodes/math/OperatorNode.js
var OperatorNode = class extends TempNode_default {
  constructor(op, aNode, bNode, ...params) {
    super();
    this.op = op;
    if (params.length > 0) {
      let finalBNode = bNode;
      for (let i2 = 0; i2 < params.length; i2++) {
        finalBNode = new OperatorNode(op, finalBNode, params[i2]);
      }
      bNode = finalBNode;
    }
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getNodeType(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode.getNodeType(builder);
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "=" || op === "%") {
      return typeA;
    } else if (op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return "int";
    } else if (op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = builder.getTypeLength(output);
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type2 = this.getNodeType(builder, output);
    let typeA = null;
    let typeB = null;
    if (type2 !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode.getNodeType(builder);
      if (op === "=") {
        typeB = typeA;
      } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else {
          typeA = typeB = "float";
        }
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type2;
      }
    } else {
      typeA = typeB = type2;
    }
    const a2 = aNode.build(builder, typeA);
    const b3 = bNode.build(builder, typeB);
    const outputLength = builder.getTypeLength(output);
    if (output !== "void") {
      if (op === "=") {
        builder.addFlowCode(`${a2} ${this.op} ${b3}`);
        return a2;
      } else if (op === ">" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThan")}( ${a2}, ${b3} )`, type2, output);
      } else if (op === "<=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThanEqual")}( ${a2}, ${b3} )`, type2, output);
      } else {
        return builder.format(`( ${a2} ${this.op} ${b3} )`, type2, output);
      }
    } else if (typeA !== "void") {
      return builder.format(`${a2} ${this.op} ${b3}`, type2, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var OperatorNode_default = OperatorNode;

// node_modules/three-stdlib/nodes/math/MathNode.js
var MathNode = class extends TempNode_default {
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.getTypeLength(aType);
    const bLen = builder.getTypeLength(bType);
    const cLen = builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {
      return "float";
    } else if (method === MathNode.CROSS) {
      return "vec3";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output) {
    const method = this.method;
    const type2 = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a2 = this.aNode;
    const b3 = this.bNode;
    const c = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (isWebGL && (method === MathNode.DFDX || method === MathNode.DFDY) && output === "vec3") {
      return new JoinNode_default([new MathNode(method, new SplitNode_default(a2, "x")), new MathNode(method, new SplitNode_default(a2, "y")), new MathNode(method, new SplitNode_default(a2, "z"))]).build(builder);
    } else if (method === MathNode.TRANSFORM_DIRECTION) {
      let tA = a2;
      let tB = b3;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = new ExpressionNode_default(`${builder.getType("vec4")}( ${tB.build(builder, "vec3")}, 0.0 )`, "vec4");
      } else {
        tA = new ExpressionNode_default(`${builder.getType("vec4")}( ${tA.build(builder, "vec3")}, 0.0 )`, "vec4");
      }
      const mulNode = new SplitNode_default(new OperatorNode_default("*", tA, tB), "xyz");
      return new MathNode(MathNode.NORMALIZE, mulNode).build(builder);
    } else if (method === MathNode.SATURATE) {
      return builder.format(`clamp( ${a2.build(builder, inputType)}, 0.0, 1.0 )`, type2, output);
    } else if (method === MathNode.NEGATE) {
      return builder.format("( -" + a2.build(builder, inputType) + " )", type2, output);
    } else if (method === MathNode.INVERT) {
      return builder.format("( 1.0 - " + a2.build(builder, inputType) + " )", type2, output);
    } else {
      const params = [];
      if (method === MathNode.CROSS) {
        params.push(a2.build(builder, type2), b3.build(builder, type2));
      } else if (method === MathNode.STEP) {
        params.push(a2.build(builder, builder.getTypeLength(a2.getNodeType(builder)) === 1 ? "float" : inputType), b3.build(builder, inputType));
      } else if (isWebGL && (method === MathNode.MIN || method === MathNode.MAX) || method === MathNode.MOD) {
        params.push(a2.build(builder, inputType), b3.build(builder, builder.getTypeLength(b3.getNodeType(builder)) === 1 ? "float" : inputType));
      } else if (method === MathNode.REFRACT) {
        params.push(a2.build(builder, inputType), b3.build(builder, inputType), c.build(builder, "float"));
      } else if (method === MathNode.MIX) {
        params.push(a2.build(builder, inputType), b3.build(builder, inputType), c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType));
      } else {
        params.push(a2.build(builder, inputType));
        if (c !== null) {
          params.push(b3.build(builder, inputType), c.build(builder, inputType));
        } else if (b3 !== null) {
          params.push(b3.build(builder, inputType));
        }
      }
      return builder.format(`${builder.getMethod(method)}( ${params.join(", ")} )`, type2, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
_defineProperty(MathNode, "RAD", "radians");
_defineProperty(MathNode, "DEG", "degrees");
_defineProperty(MathNode, "EXP", "exp");
_defineProperty(MathNode, "EXP2", "exp2");
_defineProperty(MathNode, "LOG", "log");
_defineProperty(MathNode, "LOG2", "log2");
_defineProperty(MathNode, "SQRT", "sqrt");
_defineProperty(MathNode, "INV_SQRT", "inversesqrt");
_defineProperty(MathNode, "FLOOR", "floor");
_defineProperty(MathNode, "CEIL", "ceil");
_defineProperty(MathNode, "NORMALIZE", "normalize");
_defineProperty(MathNode, "FRACT", "fract");
_defineProperty(MathNode, "SIN", "sin");
_defineProperty(MathNode, "COS", "cos");
_defineProperty(MathNode, "TAN", "tan");
_defineProperty(MathNode, "ASIN", "asin");
_defineProperty(MathNode, "ACOS", "acos");
_defineProperty(MathNode, "ATAN", "atan");
_defineProperty(MathNode, "ABS", "abs");
_defineProperty(MathNode, "SIGN", "sign");
_defineProperty(MathNode, "LENGTH", "length");
_defineProperty(MathNode, "NEGATE", "negate");
_defineProperty(MathNode, "INVERT", "invert");
_defineProperty(MathNode, "DFDX", "dFdx");
_defineProperty(MathNode, "DFDY", "dFdy");
_defineProperty(MathNode, "SATURATE", "saturate");
_defineProperty(MathNode, "ROUND", "round");
_defineProperty(MathNode, "MIN", "min");
_defineProperty(MathNode, "MAX", "max");
_defineProperty(MathNode, "MOD", "mod");
_defineProperty(MathNode, "STEP", "step");
_defineProperty(MathNode, "REFLECT", "reflect");
_defineProperty(MathNode, "DISTANCE", "distance");
_defineProperty(MathNode, "DOT", "dot");
_defineProperty(MathNode, "CROSS", "cross");
_defineProperty(MathNode, "POW", "pow");
_defineProperty(MathNode, "TRANSFORM_DIRECTION", "transformDirection");
_defineProperty(MathNode, "MIX", "mix");
_defineProperty(MathNode, "CLAMP", "clamp");
_defineProperty(MathNode, "REFRACT", "refract");
_defineProperty(MathNode, "SMOOTHSTEP", "smoothstep");
_defineProperty(MathNode, "FACEFORWARD", "faceforward");
var MathNode_default = MathNode;

// node_modules/three-stdlib/nodes/accessors/PositionNode.js
var PositionNode = class extends Node_default {
  constructor(scope2 = PositionNode.LOCAL) {
    super("vec3");
    this.scope = scope2;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(builder) {
    const scope2 = this.scope;
    let outputNode = null;
    if (scope2 === PositionNode.GEOMETRY) {
      outputNode = new AttributeNode_default("position", "vec3");
    } else if (scope2 === PositionNode.LOCAL) {
      outputNode = new VaryNode_default(new PositionNode(PositionNode.GEOMETRY));
    } else if (scope2 === PositionNode.WORLD) {
      const vertexPositionNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new ModelNode_default(ModelNode_default.WORLD_MATRIX), new PositionNode(PositionNode.LOCAL));
      outputNode = new VaryNode_default(vertexPositionNode);
    } else if (scope2 === PositionNode.VIEW) {
      const vertexPositionNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.VIEW_MATRIX), new PositionNode(PositionNode.LOCAL));
      outputNode = new VaryNode_default(vertexPositionNode);
    } else if (scope2 === PositionNode.VIEW_DIRECTION) {
      const vertexPositionNode = new MathNode_default(MathNode_default.NEGATE, new PositionNode(PositionNode.VIEW));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexPositionNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
_defineProperty(PositionNode, "GEOMETRY", "geometry");
_defineProperty(PositionNode, "LOCAL", "local");
_defineProperty(PositionNode, "WORLD", "world");
_defineProperty(PositionNode, "VIEW", "view");
_defineProperty(PositionNode, "VIEW_DIRECTION", "viewDirection");
var PositionNode_default = PositionNode;

// node_modules/three-stdlib/nodes/accessors/NormalNode.js
var NormalNode = class extends Node_default {
  constructor(scope2 = NormalNode.LOCAL) {
    super("vec3");
    this.scope = scope2;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(builder) {
    const scope2 = this.scope;
    let outputNode = null;
    if (scope2 === NormalNode.GEOMETRY) {
      outputNode = new AttributeNode_default("normal", "vec3");
    } else if (scope2 === NormalNode.LOCAL) {
      outputNode = new VaryNode_default(new NormalNode(NormalNode.GEOMETRY));
    } else if (scope2 === NormalNode.VIEW) {
      const vertexNormalNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.NORMAL_MATRIX), new NormalNode(NormalNode.LOCAL));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexNormalNode));
    } else if (scope2 === NormalNode.WORLD) {
      const vertexNormalNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new NormalNode(NormalNode.VIEW), new CameraNode_default(CameraNode_default.VIEW_MATRIX));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexNormalNode));
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
_defineProperty(NormalNode, "GEOMETRY", "geometry");
_defineProperty(NormalNode, "LOCAL", "local");
_defineProperty(NormalNode, "WORLD", "world");
_defineProperty(NormalNode, "VIEW", "view");
var NormalNode_default = NormalNode;

// node_modules/three-stdlib/nodes/math/CondNode.js
var CondNode = class extends Node_default {
  constructor(node, ifNode, elseNode) {
    super();
    this.node = node;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    const elseType = this.elseNode.getNodeType(builder);
    if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
      return elseType;
    }
    return ifType;
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const context = {
      temp: false
    };
    const nodeProperty = new PropertyNode_default(null, type2).build(builder);
    const nodeSnippet = new ContextNode_default(
      this.node
    ).build(builder, "bool"), ifSnippet = new ContextNode_default(this.ifNode, context).build(builder, type2), elseSnippet = new ContextNode_default(this.elseNode, context).build(builder, type2);
    builder.addFlowCode(`if ( ${nodeSnippet} ) {

		${nodeProperty} = ${ifSnippet};

	} else {

		${nodeProperty} = ${elseSnippet};

	}`);
    return nodeProperty;
  }
};
var CondNode_default = CondNode;

// node_modules/three-stdlib/nodes/utils/ArrayElementNode.js
var ArrayElementNode = class extends Node_default {
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "int");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ArrayElementNode_default = ArrayElementNode;

// node_modules/three-stdlib/nodes/utils/ConvertNode.js
var ConvertNode = class extends Node_default {
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  getNodeType() {
    return this.convertTo;
  }
  generate(builder) {
    const convertTo = this.convertTo;
    const node = this.node;
    if (builder.isReference(convertTo) === false) {
      const convertToSnippet = builder.getType(convertTo);
      const nodeSnippet = node.build(builder, convertTo);
      return `${builder.getVectorType(convertToSnippet)}( ${nodeSnippet} )`;
    } else {
      return node.build(builder, convertTo);
    }
  }
};
var ConvertNode_default = ConvertNode;

// node_modules/three-stdlib/nodes/ShaderNode.js
var NodeHandler = {
  construct(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(new ShaderNodeObjects(inputs), ...params);
  },
  get: function(node, prop) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = prop.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
        return new ShaderNodeObject(new SplitNode_default(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return new ShaderNodeObject(new ArrayElementNode_default(node, uint(Number(prop))));
      }
    }
    return node[prop];
  }
};
var nodeObjects = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj) {
  const type2 = typeof obj;
  if (type2 === "number" || type2 === "boolean") {
    return new ShaderNodeObject(getAutoTypedConstNode(obj));
  } else if (type2 === "object") {
    if (obj.isNode === true) {
      let nodeObject2 = nodeObjects.get(obj);
      if (nodeObject2 === void 0) {
        nodeObject2 = new Proxy(obj, NodeHandler);
        nodeObjects.set(obj, nodeObject2);
        nodeObjects.set(nodeObject2, nodeObject2);
      }
      return nodeObject2;
    }
  }
  return obj;
};
var ShaderNodeObjects = function(objects) {
  for (const name in objects) {
    objects[name] = new ShaderNodeObject(objects[name]);
  }
  return objects;
};
var getShaderNodeArray = (array) => {
  const len = array.length;
  for (let i2 = 0; i2 < len; i2++) {
    array[i2] = new ShaderNodeObject(array[i2]);
  }
  return array;
};
var ShaderNodeProxy = function(NodeClass, scope2 = null, factor = null) {
  if (scope2 === null) {
    return (...params) => {
      return new ShaderNodeObject(new NodeClass(...getShaderNodeArray(params)));
    };
  } else if (factor === null) {
    return (...params) => {
      return new ShaderNodeObject(new NodeClass(scope2, ...getShaderNodeArray(params)));
    };
  } else {
    factor = new ShaderNodeObject(factor);
    return (...params) => {
      return new ShaderNodeObject(new NodeClass(scope2, ...getShaderNodeArray(params), factor));
    };
  }
};
var ShaderNodeScript = function(jsFunc) {
  return (inputs, builder) => {
    new ShaderNodeObjects(inputs);
    return new ShaderNodeObject(jsFunc(inputs, builder));
  };
};
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (let bool2 of bools)
  boolsCacheMap.set(bool2, new ConstNode_default(bool2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (let uint2 of uints)
  uintsCacheMap.set(uint2, new ConstNode_default(uint2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode_default(el.value, "int")));
for (let int2 of ints)
  intsCacheMap.set(int2, new ConstNode_default(int2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode_default(el.value)));
for (let float2 of floats)
  floatsCacheMap.set(float2, new ConstNode_default(float2));
for (let float2 of floats)
  floatsCacheMap.set(-float2, new ConstNode_default(-float2));
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getAutoTypedConstNode = (value) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode_default(value);
  }
};
var ConvertType = function(type2, cacheMap = null) {
  return (...params) => {
    if (params.length === 0) {
      return nodeObject(new ConstNode_default(getValueFromType(type2), type2));
    } else {
      if (type2 === "color" && params[0].isNode !== true) {
        params = [getValueFromType(type2, ...params)];
      }
      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
        return cacheMap.get(params[0]);
      }
      const nodes = params.map(getAutoTypedConstNode);
      return nodeObject(new ConvertNode_default(nodes.length === 1 ? nodes[0] : new JoinNode_default(nodes), type2));
    }
  };
};
var ShaderNode = new Proxy(ShaderNodeScript, NodeHandler);
var nodeObject = (val) => {
  return new ShaderNodeObject(val);
};
var uniform = (value) => {
  var _value$node;
  value = value.isNode === true ? ((_value$node = value.node) === null || _value$node === void 0 ? void 0 : _value$node.value) || value.value : value;
  return nodeObject(new UniformNode_default(value, value.nodeType));
};
var label = (node, name) => {
  node = nodeObject(node);
  if (node.isVarNode === true) {
    node.name = name;
    return node;
  }
  return nodeObject(new VarNode_default(node, name));
};
var temp = (node) => nodeObject(new VarNode_default(nodeObject(node)));
var color = new ConvertType("color");
var float = new ConvertType("float", floatsCacheMap);
var int = new ConvertType("int", intsCacheMap);
var uint = new ConvertType("uint", uintsCacheMap);
var bool = new ConvertType("bool", boolsCacheMap);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat3 = new ConvertType("mat3");
var imat3 = new ConvertType("imat3");
var umat3 = new ConvertType("umat3");
var bmat3 = new ConvertType("bmat3");
var mat4 = new ConvertType("mat4");
var imat4 = new ConvertType("imat4");
var umat4 = new ConvertType("umat4");
var bmat4 = new ConvertType("bmat4");
var join = (...params) => nodeObject(new JoinNode_default(getShaderNodeArray(params)));
var uv = (...params) => nodeObject(new UVNode_default(...params));
var attribute = (...params) => nodeObject(new AttributeNode_default(...params));
var buffer = (...params) => nodeObject(new BufferNode_default(...params));
var texture = (...params) => nodeObject(new TextureNode_default(...params));
var sampler = (texture2) => nodeObject(new ConvertNode_default(texture2.isNode === true ? texture2 : new TextureNode_default(texture2), "sampler"));
var cond = (...params) => nodeObject(new CondNode_default(...getShaderNodeArray(params)));
var addTo = (varNode, ...params) => {
  varNode.node = add(varNode.node, ...getShaderNodeArray(params));
  return nodeObject(varNode);
};
var add = new ShaderNodeProxy(OperatorNode_default, "+");
var sub = new ShaderNodeProxy(OperatorNode_default, "-");
var mul = new ShaderNodeProxy(OperatorNode_default, "*");
var div = new ShaderNodeProxy(OperatorNode_default, "/");
var remainder = new ShaderNodeProxy(OperatorNode_default, "%");
var equal = new ShaderNodeProxy(OperatorNode_default, "==");
var assign = new ShaderNodeProxy(OperatorNode_default, "=");
var lessThan = new ShaderNodeProxy(OperatorNode_default, "<");
var greaterThan = new ShaderNodeProxy(OperatorNode_default, ">");
var lessThanEqual = new ShaderNodeProxy(OperatorNode_default, "<=");
var greaterThanEqual = new ShaderNodeProxy(OperatorNode_default, ">=");
var and = new ShaderNodeProxy(OperatorNode_default, "&&");
var or = new ShaderNodeProxy(OperatorNode_default, "||");
var xor = new ShaderNodeProxy(OperatorNode_default, "^^");
var bitAnd = new ShaderNodeProxy(OperatorNode_default, "&");
var bitOr = new ShaderNodeProxy(OperatorNode_default, "|");
var bitXor = new ShaderNodeProxy(OperatorNode_default, "^");
var shiftLeft = new ShaderNodeProxy(OperatorNode_default, "<<");
var shiftRight = new ShaderNodeProxy(OperatorNode_default, ">>");
var element = new ShaderNodeProxy(ArrayElementNode_default);
var normalGeometry = new ShaderNodeObject(new NormalNode_default(NormalNode_default.GEOMETRY));
var normalLocal = new ShaderNodeObject(new NormalNode_default(NormalNode_default.LOCAL));
var normalWorld = new ShaderNodeObject(new NormalNode_default(NormalNode_default.WORLD));
var normalView = new ShaderNodeObject(new NormalNode_default(NormalNode_default.VIEW));
var transformedNormalView = new ShaderNodeObject(new VarNode_default(new NormalNode_default(NormalNode_default.VIEW), "TransformedNormalView", "vec3"));
var positionLocal = new ShaderNodeObject(new PositionNode_default(PositionNode_default.LOCAL));
var positionWorld = new ShaderNodeObject(new PositionNode_default(PositionNode_default.WORLD));
var positionView = new ShaderNodeObject(new PositionNode_default(PositionNode_default.VIEW));
var positionViewDirection = new ShaderNodeObject(new PositionNode_default(PositionNode_default.VIEW_DIRECTION));
var viewMatrix = new ShaderNodeObject(new ModelNode_default(ModelNode_default.VIEW_MATRIX));
var cameraPosition = new ShaderNodeObject(new CameraNode_default(CameraNode_default.POSITION));
var diffuseColor = new ShaderNodeObject(new PropertyNode_default("DiffuseColor", "vec4"));
var roughness = new ShaderNodeObject(new PropertyNode_default("Roughness", "float"));
var metalness = new ShaderNodeObject(new PropertyNode_default("Metalness", "float"));
var alphaTest = new ShaderNodeObject(new PropertyNode_default("AlphaTest", "float"));
var specularColor = new ShaderNodeObject(new PropertyNode_default("SpecularColor", "color"));
var abs = new ShaderNodeProxy(MathNode_default, "abs");
var acos = new ShaderNodeProxy(MathNode_default, "acos");
var asin = new ShaderNodeProxy(MathNode_default, "asin");
var atan = new ShaderNodeProxy(MathNode_default, "atan");
var ceil = new ShaderNodeProxy(MathNode_default, "ceil");
var clamp = new ShaderNodeProxy(MathNode_default, "clamp");
var cos = new ShaderNodeProxy(MathNode_default, "cos");
var cross = new ShaderNodeProxy(MathNode_default, "cross");
var degrees = new ShaderNodeProxy(MathNode_default, "degrees");
var dFdx = new ShaderNodeProxy(MathNode_default, "dFdx");
var dFdy = new ShaderNodeProxy(MathNode_default, "dFdy");
var distance = new ShaderNodeProxy(MathNode_default, "distance");
var dot = new ShaderNodeProxy(MathNode_default, "dot");
var exp = new ShaderNodeProxy(MathNode_default, "exp");
var exp2 = new ShaderNodeProxy(MathNode_default, "exp2");
var faceforward = new ShaderNodeProxy(MathNode_default, "faceforward");
var floor = new ShaderNodeProxy(MathNode_default, "floor");
var fract = new ShaderNodeProxy(MathNode_default, "fract");
var invert = new ShaderNodeProxy(MathNode_default, "invert");
var inversesqrt = new ShaderNodeProxy(MathNode_default, "inversesqrt");
var length = new ShaderNodeProxy(MathNode_default, "length");
var log = new ShaderNodeProxy(MathNode_default, "log");
var log2 = new ShaderNodeProxy(MathNode_default, "log2");
var max = new ShaderNodeProxy(MathNode_default, "max");
var min = new ShaderNodeProxy(MathNode_default, "min");
var mix = new ShaderNodeProxy(MathNode_default, "mix");
var mod = new ShaderNodeProxy(MathNode_default, "mod");
var negate = new ShaderNodeProxy(MathNode_default, "negate");
var normalize = new ShaderNodeProxy(MathNode_default, "normalize");
var pow = new ShaderNodeProxy(MathNode_default, "pow");
var pow2 = new ShaderNodeProxy(MathNode_default, "pow", 2);
var pow3 = new ShaderNodeProxy(MathNode_default, "pow", 3);
var pow4 = new ShaderNodeProxy(MathNode_default, "pow", 4);
var radians = new ShaderNodeProxy(MathNode_default, "radians");
var reflect = new ShaderNodeProxy(MathNode_default, "reflect");
var refract = new ShaderNodeProxy(MathNode_default, "refract");
var round = new ShaderNodeProxy(MathNode_default, "round");
var saturate = new ShaderNodeProxy(MathNode_default, "saturate");
var sign = new ShaderNodeProxy(MathNode_default, "sign");
var sin = new ShaderNodeProxy(MathNode_default, "sin");
var smoothstep = new ShaderNodeProxy(MathNode_default, "smoothstep");
var sqrt = new ShaderNodeProxy(MathNode_default, "sqrt");
var step = new ShaderNodeProxy(MathNode_default, "step");
var tan = new ShaderNodeProxy(MathNode_default, "tan");
var transformDirection = new ShaderNodeProxy(MathNode_default, "transformDirection");
var EPSILON = float(1e-6);
var INFINITY = float(1e6);

// node_modules/three-stdlib/nodes/accessors/ReflectNode.js
var ReflectNode = class extends Node_default {
  constructor(scope2 = ReflectNode.CUBE) {
    super("vec3");
    this.scope = scope2;
  }
  getHash() {
    return `reflect-${this.scope}`;
  }
  generate(builder) {
    const scope2 = this.scope;
    if (scope2 === ReflectNode.VECTOR) {
      const cameraToFrag = normalize(sub(positionWorld, cameraPosition));
      const reflectVec = reflect(cameraToFrag, normalWorld);
      return reflectVec.build(builder);
    } else if (scope2 === ReflectNode.CUBE) {
      const reflectVec = nodeObject(new ReflectNode(ReflectNode.VECTOR));
      const cubeUV = join(negate(reflectVec.x), reflectVec.yz);
      return cubeUV.build(builder);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
_defineProperty(ReflectNode, "VECTOR", "vector");
_defineProperty(ReflectNode, "CUBE", "cube");
var ReflectNode_default = ReflectNode;

// node_modules/three-stdlib/nodes/accessors/CubeTextureNode.js
var CubeTextureNode = class extends TextureNode_default {
  constructor(value, uvNode = new ReflectNode_default(), biasNode = null) {
    super(value, uvNode, biasNode);
  }
  getInputType() {
    return "cubeTexture";
  }
  generate(builder, output) {
    const texture2 = this.value;
    if (!texture2 || texture2.isCubeTexture !== true) {
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    }
    const textureProperty = UniformNode_default.prototype.generate.call(this, builder, "cubeTexture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let snippet = nodeData.snippet;
      if (snippet === void 0) {
        const uvSnippet = this.uvNode.build(builder, "vec3");
        const biasNode = this.biasNode;
        if (biasNode !== null) {
          const biasSnippet = biasNode.build(builder, "float");
          snippet = builder.getCubeTextureBias(textureProperty, uvSnippet, biasSnippet);
        } else {
          snippet = builder.getCubeTexture(textureProperty, uvSnippet);
        }
        nodeData.snippet = snippet;
      }
      return builder.format(snippet, "vec4", output);
    }
  }
};
CubeTextureNode.prototype.isCubeTextureNode = true;
var CubeTextureNode_default = CubeTextureNode;

// node_modules/three-stdlib/nodes/accessors/ReferenceNode.js
var ReferenceNode = class extends Node_default {
  constructor(property, uniformType, object = null) {
    super();
    this.property = property;
    this.uniformType = uniformType;
    this.object = object;
    this.node = null;
    this.updateType = NodeUpdateType2.Object;
    this.setNodeType(uniformType);
  }
  setNodeType(uniformType) {
    this.node = new UniformNode_default(null, uniformType);
    this.nodeType = uniformType;
    if (uniformType === "color") {
      this.nodeType = "vec3";
    } else if (uniformType === "texture") {
      this.nodeType = "vec4";
    }
  }
  getNodeType() {
    return this.uniformType;
  }
  update(frame) {
    const object = this.object !== null ? this.object : frame.object;
    const value = object[this.property];
    this.node.value = value;
  }
  generate(builder) {
    return this.node.build(builder, this.getNodeType(builder));
  }
};
var ReferenceNode_default = ReferenceNode;

// node_modules/three-stdlib/nodes/accessors/MaterialReferenceNode.js
var MaterialReferenceNode = class extends ReferenceNode_default {
  constructor(property, inputType, material = null) {
    super(property, inputType, material);
    this.material = material;
  }
  update(frame) {
    this.object = this.material !== null ? this.material : frame.material;
    super.update(frame);
  }
};
var MaterialReferenceNode_default = MaterialReferenceNode;

// node_modules/three-stdlib/nodes/accessors/MaterialNode.js
var MaterialNode = class extends Node_default {
  constructor(scope2 = MaterialNode.COLOR) {
    super();
    this.scope = scope2;
  }
  getNodeType(builder) {
    const scope2 = this.scope;
    const material = builder.context.material;
    if (scope2 === MaterialNode.COLOR) {
      return material.map !== null ? "vec4" : "vec3";
    } else if (scope2 === MaterialNode.OPACITY) {
      return "float";
    } else if (scope2 === MaterialNode.SPECULAR) {
      return "vec3";
    } else if (scope2 === MaterialNode.ROUGHNESS || scope2 === MaterialNode.METALNESS) {
      return "float";
    }
  }
  generate(builder, output) {
    const material = builder.context.material;
    const scope2 = this.scope;
    let node = null;
    if (scope2 === MaterialNode.ALPHA_TEST) {
      node = new MaterialReferenceNode_default("alphaTest", "float");
    } else if (scope2 === MaterialNode.COLOR) {
      const colorNode = new MaterialReferenceNode_default("color", "color");
      if (material.map !== null && material.map !== void 0 && material.map.isTexture === true) {
        node = new OperatorNode_default("*", colorNode, new MaterialReferenceNode_default("map", "texture"));
      } else {
        node = colorNode;
      }
    } else if (scope2 === MaterialNode.OPACITY) {
      const opacityNode = new MaterialReferenceNode_default("opacity", "float");
      if (material.alphaMap !== null && material.alphaMap !== void 0 && material.alphaMap.isTexture === true) {
        node = new OperatorNode_default("*", opacityNode, new MaterialReferenceNode_default("alphaMap", "texture"));
      } else {
        node = opacityNode;
      }
    } else if (scope2 === MaterialNode.SPECULAR) {
      const specularColorNode = new MaterialReferenceNode_default("specularColor", "color");
      if (material.specularColorMap !== null && material.specularColorMap !== void 0 && material.specularColorMap.isTexture === true) {
        node = new OperatorNode_default("*", specularColorNode, new MaterialReferenceNode_default("specularColorMap", "texture"));
      } else {
        node = specularColorNode;
      }
    } else {
      const outputType = this.getNodeType(builder);
      node = new MaterialReferenceNode_default(scope2, outputType);
    }
    return node.build(builder, output);
  }
};
_defineProperty(MaterialNode, "ALPHA_TEST", "alphaTest");
_defineProperty(MaterialNode, "COLOR", "color");
_defineProperty(MaterialNode, "OPACITY", "opacity");
_defineProperty(MaterialNode, "SPECULAR", "specular");
_defineProperty(MaterialNode, "ROUGHNESS", "roughness");
_defineProperty(MaterialNode, "METALNESS", "metalness");
var MaterialNode_default = MaterialNode;

// node_modules/three-stdlib/nodes/accessors/ModelViewProjectionNode.js
var ModelViewProjectionNode = class extends Node_default {
  constructor(position = new PositionNode_default()) {
    super("vec4");
    this.position = position;
  }
  generate(builder) {
    const position = this.position;
    const mvpMatrix = new OperatorNode_default("*", new CameraNode_default(CameraNode_default.PROJECTION_MATRIX), new ModelNode_default(ModelNode_default.VIEW_MATRIX));
    const mvpNode = new OperatorNode_default("*", mvpMatrix, position);
    return mvpNode.build(builder);
  }
};
var ModelViewProjectionNode_default = ModelViewProjectionNode;

// node_modules/three-stdlib/nodes/accessors/PointUVNode.js
var PointUVNode = class extends Node_default {
  constructor() {
    super("vec2");
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
PointUVNode.prototype.isPointUVNode = true;
var PointUVNode_default = PointUVNode;

// node_modules/three-stdlib/nodes/accessors/SkinningNode.js
var Skinning = new ShaderNode((inputs, builder) => {
  const {
    index,
    weight,
    bindMatrix,
    bindMatrixInverse,
    boneMatrices
  } = inputs;
  const boneMatX = element(boneMatrices, index.x);
  const boneMatY = element(boneMatrices, index.y);
  const boneMatZ = element(boneMatrices, index.z);
  const boneMatW = element(boneMatrices, index.w);
  const skinVertex = mul(bindMatrix, positionLocal);
  const skinned = add(mul(mul(boneMatX, skinVertex), weight.x), mul(mul(boneMatY, skinVertex), weight.y), mul(mul(boneMatZ, skinVertex), weight.z), mul(mul(boneMatW, skinVertex), weight.w));
  const skinPosition = mul(bindMatrixInverse, skinned).xyz;
  let skinMatrix = add(mul(weight.x, boneMatX), mul(weight.y, boneMatY), mul(weight.z, boneMatZ), mul(weight.w, boneMatW));
  skinMatrix = mul(mul(bindMatrixInverse, skinMatrix), bindMatrix);
  const skinNormal = transformDirection(skinMatrix, normalLocal).xyz;
  assign(positionLocal, skinPosition).build(builder);
  assign(normalLocal, skinNormal).build(builder);
});
var SkinningNode = class extends Node_default {
  constructor(skinnedMesh) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.updateType = NodeUpdateType2.Object;
    this.skinIndexNode = attribute("skinIndex", "uvec4");
    this.skinWeightNode = attribute("skinWeight", "vec4");
    this.bindMatrixNode = uniform(mat4(skinnedMesh.bindMatrix));
    this.bindMatrixInverseNode = uniform(mat4(skinnedMesh.bindMatrixInverse));
    this.boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
  }
  generate(builder) {
    Skinning({
      index: this.skinIndexNode,
      weight: this.skinWeightNode,
      bindMatrix: this.bindMatrixNode,
      bindMatrixInverse: this.bindMatrixInverseNode,
      boneMatrices: this.boneMatricesNode
    }, builder);
  }
  update() {
    this.skinnedMesh.skeleton.update();
  }
};
var SkinningNode_default = SkinningNode;

// node_modules/three-stdlib/nodes/display/ColorSpaceNode.js
var LinearToLinear = new ShaderNode((inputs) => {
  return inputs.value;
});
var LinearTosRGB = new ShaderNode((inputs) => {
  const {
    value
  } = inputs;
  const rgb = value.rgb;
  const a2 = sub(mul(pow(value.rgb, vec3(0.41666)), 1.055), vec3(0.055));
  const b3 = mul(rgb, 12.92);
  const factor = vec3(lessThanEqual(rgb, vec3(31308e-7)));
  const rgbResult = mix(a2, b3, factor);
  return join(rgbResult.r, rgbResult.g, rgbResult.b, value.a);
});
var EncodingLib = {
  LinearToLinear,
  LinearTosRGB
};
var ColorSpaceNode = class extends Node_default {
  constructor(method, node) {
    super("vec4");
    this.method = method;
    this.node = node;
  }
  fromEncoding(encoding) {
    let method = null;
    if (encoding === LinearEncoding) {
      method = "Linear";
    } else if (encoding === sRGBEncoding) {
      method = "sRGB";
    }
    this.method = "LinearTo" + method;
    return this;
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const method = this.method;
    const node = this.node;
    if (method !== ColorSpaceNode.LINEAR_TO_LINEAR) {
      const encodingFunctionNode = EncodingLib[method];
      return encodingFunctionNode({
        value: node
      }).build(builder, type2);
    } else {
      return node.build(builder, type2);
    }
  }
};
_defineProperty(ColorSpaceNode, "LINEAR_TO_LINEAR", "LinearToLinear");
_defineProperty(ColorSpaceNode, "LINEAR_TO_SRGB", "LinearTosRGB");
var ColorSpaceNode_default = ColorSpaceNode;

// node_modules/three-stdlib/nodes/display/NormalMapNode.js
var perturbNormal2ArbNode = new ShaderNode((inputs) => {
  const {
    eye_pos,
    surf_norm,
    mapN,
    faceDirection,
    uv: uv2
  } = inputs;
  const q0 = dFdx(eye_pos.xyz);
  const q1 = dFdy(eye_pos.xyz);
  const st0 = dFdx(uv2.st);
  const st1 = dFdy(uv2.st);
  const N = surf_norm;
  const q1perp = cross(q1, N);
  const q0perp = cross(N, q0);
  const T = add(mul(q1perp, st0.x), mul(q0perp, st1.x));
  const B2 = add(mul(q1perp, st0.y), mul(q0perp, st1.y));
  const det = max(dot(T, T), dot(B2, B2));
  const scale = cond(equal(det, 0), 0, mul(faceDirection, inversesqrt(det)));
  return normalize(add(mul(T, mul(mapN.x, scale)), mul(B2, mul(mapN.y, scale)), mul(N, mapN.z)));
});
var NormalMapNode = class extends TempNode_default {
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const {
      normalMapType,
      scaleNode
    } = this;
    const normalOP = mul(this.node, 2);
    let normalMap = sub(normalOP, 1);
    if (scaleNode !== null) {
      const normalMapScale = mul(normalMap.xy, scaleNode);
      normalMap = join(normalMapScale, normalMap.z);
    }
    if (normalMapType === ObjectSpaceNormalMap) {
      const vertexNormalNode = mul(new ModelNode_default(ModelNode_default.NORMAL_MATRIX), normalMap);
      const normal = normalize(vertexNormalNode);
      return normal.build(builder, type2);
    } else if (normalMapType === TangentSpaceNormalMap) {
      const perturbNormal2ArbCall = perturbNormal2ArbNode({
        eye_pos: positionView,
        surf_norm: normalView,
        mapN: normalMap,
        faceDirection: 1,
        uv: uv()
      });
      return perturbNormal2ArbCall.build(builder, type2);
    }
  }
};
var NormalMapNode_default = NormalMapNode;

// node_modules/three-stdlib/nodes/functions/BSDFs.js
var F_Schlick = new ShaderNode((inputs) => {
  const {
    f0,
    f90,
    dotVH
  } = inputs;
  const fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));
  return add(mul(f0, sub(1, fresnel)), mul(f90, fresnel));
});
var BRDF_Lambert = new ShaderNode((inputs) => {
  return mul(1 / Math.PI, inputs.diffuseColor);
});
var getDistanceAttenuation = new ShaderNode((inputs) => {
  const {
    lightDistance,
    cutoffDistance,
    decayExponent
  } = inputs;
  return cond(and(greaterThan(cutoffDistance, 0), greaterThan(decayExponent, 0)), pow(saturate(add(div(negate(lightDistance), cutoffDistance), 1)), decayExponent), 1);
});
var V_GGX_SmithCorrelated = new ShaderNode((inputs) => {
  const {
    alpha,
    dotNL,
    dotNV
  } = inputs;
  const a2 = pow2(alpha);
  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1, a2), pow2(dotNV)))));
  const gl = mul(dotNV, sqrt(add(a2, mul(sub(1, a2), pow2(dotNL)))));
  return div(0.5, max(add(gv, gl), EPSILON));
});
var D_GGX = new ShaderNode((inputs) => {
  const {
    alpha,
    dotNH
  } = inputs;
  const a2 = pow2(alpha);
  const denom = add(mul(pow2(dotNH), sub(a2, 1)), 1);
  return mul(1 / Math.PI, div(a2, pow2(denom)));
});
var BRDF_GGX = new ShaderNode((inputs) => {
  const {
    lightDirection,
    f0,
    f90,
    roughness: roughness2
  } = inputs;
  const alpha = pow2(roughness2);
  const halfDir = normalize(add(lightDirection, positionViewDirection));
  const dotNL = saturate(dot(transformedNormalView, lightDirection));
  const dotNV = saturate(dot(transformedNormalView, positionViewDirection));
  const dotNH = saturate(dot(transformedNormalView, halfDir));
  const dotVH = saturate(dot(positionViewDirection, halfDir));
  const F = F_Schlick({
    f0,
    f90,
    dotVH
  });
  const V = V_GGX_SmithCorrelated({
    alpha,
    dotNL,
    dotNV
  });
  const D = D_GGX({
    alpha,
    dotNH
  });
  return mul(F, mul(V, D));
});
var RE_Direct_Physical = new ShaderNode((inputs) => {
  const {
    lightDirection,
    lightColor,
    directDiffuse,
    directSpecular
  } = inputs;
  const dotNL = saturate(dot(transformedNormalView, lightDirection));
  let irradiance = mul(dotNL, lightColor);
  irradiance = mul(irradiance, Math.PI);
  addTo(directDiffuse, mul(irradiance, BRDF_Lambert({
    diffuseColor: diffuseColor.rgb
  })));
  addTo(directSpecular, mul(irradiance, BRDF_GGX({
    lightDirection,
    f0: specularColor,
    f90: 1,
    roughness
  })));
});
var PhysicalLightingModel = new ShaderNode((inputs) => {
  RE_Direct_Physical(inputs);
});

// node_modules/three-stdlib/nodes/lights/LightContextNode.js
var LightContextNode = class extends ContextNode_default {
  constructor(node) {
    super(node);
  }
  getNodeType() {
    return "vec3";
  }
  generate(builder) {
    const material = builder.material;
    let lightingModel = null;
    if (material.isMeshStandardMaterial === true) {
      lightingModel = PhysicalLightingModel;
    }
    const directDiffuse = new VarNode_default(new UniformNode_default(new Vector3()), "DirectDiffuse", "vec3");
    const directSpecular = new VarNode_default(new UniformNode_default(new Vector3()), "DirectSpecular", "vec3");
    this.context.directDiffuse = directDiffuse;
    this.context.directSpecular = directSpecular;
    if (lightingModel !== null) {
      this.context.lightingModel = lightingModel;
    }
    const type2 = this.getNodeType(builder);
    super.generate(builder, type2);
    const totalLight = new OperatorNode_default("+", directDiffuse, directSpecular);
    return totalLight.build(builder, type2);
  }
};
var LightContextNode_default = LightContextNode;

// node_modules/three-stdlib/nodes/lights/LightNode.js
var LightNode = class extends Node_default {
  constructor(light = null) {
    super("vec3");
    this.updateType = NodeUpdateType2.Object;
    this.light = light;
    this._colorNode = new UniformNode_default(new Color());
    this._lightCutoffDistanceNode = new UniformNode_default(0);
    this._lightDecayExponentNode = new UniformNode_default(0);
  }
  getHash() {
    return this.light.uuid;
  }
  update() {
    this._colorNode.value.copy(this.light.color).multiplyScalar(this.light.intensity);
    this._lightCutoffDistanceNode.value = this.light.distance;
    this._lightDecayExponentNode.value = this.light.decay;
  }
  generate(builder) {
    const lightPositionView = new Object3DNode_default(Object3DNode_default.VIEW_POSITION);
    const positionView2 = new PositionNode_default(PositionNode_default.VIEW);
    const lVector = new OperatorNode_default("-", lightPositionView, positionView2);
    const lightDirection = new MathNode_default(MathNode_default.NORMALIZE, lVector);
    const lightDistance = new MathNode_default(MathNode_default.LENGTH, lVector);
    const lightAttenuation = getDistanceAttenuation({
      lightDistance,
      cutoffDistance: this._lightCutoffDistanceNode,
      decayExponent: this._lightDecayExponentNode
    });
    const lightColor = new OperatorNode_default("*", this._colorNode, lightAttenuation);
    lightPositionView.object3d = this.light;
    const lightingModelFunction = builder.context.lightingModel;
    if (lightingModelFunction !== void 0) {
      const directDiffuse = builder.context.directDiffuse;
      const directSpecular = builder.context.directSpecular;
      lightingModelFunction({
        lightDirection,
        lightColor,
        directDiffuse,
        directSpecular
      }, builder);
    }
  }
};
var LightNode_default = LightNode;

// node_modules/three-stdlib/nodes/lights/LightsNode.js
var sortLights = (lights) => {
  return lights.sort((a2, b3) => a2.id - b3.id);
};
var LightsNode = class extends Node_default {
  constructor(lightNodes = []) {
    super("vec3");
    this.lightNodes = lightNodes;
    this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  generate(builder) {
    const lightNodes = this.lightNodes;
    for (const lightNode of lightNodes) {
      lightNode.build(builder);
    }
    return "vec3( 0.0 )";
  }
  getHash() {
    if (this._hash === null) {
      let hash = "";
      const lightNodes = this.lightNodes;
      for (const lightNode of lightNodes) {
        hash += lightNode.light.uuid + " ";
      }
      this._hash = hash;
    }
    return this._hash;
  }
  getLightNodeByHash(hash) {
    const lightNodes = this.lightNodes;
    for (const lightNode of lightNodes) {
      if (lightNode.light.uuid === hash) {
        return lightNode;
      }
    }
    return null;
  }
  fromLights(lights) {
    const lightNodes = [];
    lights = sortLights(lights);
    for (const light of lights) {
      let lightNode = this.getLightNodeByHash(light.uuid);
      if (lightNode === null) {
        lightNode = new LightNode_default(light);
      }
      lightNodes.push(lightNode);
    }
    this.lightNodes = lightNodes;
    this._hash = null;
    return this;
  }
};
var LightsNode_default = LightsNode;

// node_modules/three-stdlib/nodes/utils/SpriteSheetUVNode.js
var SpriteSheetUVNode = class extends Node_default {
  constructor(countNode, uvNode = new UVNode_default(), frameNode = new ConstNode_default(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  generate(builder) {
    const count = this.countNode;
    const uv2 = this.uvNode;
    const frame = this.frameNode;
    const one = new ConstNode_default(1);
    const width = new SplitNode_default(count, "x");
    const height = new SplitNode_default(count, "y");
    const total = new OperatorNode_default("*", width, height);
    const roundFrame = new MathNode_default(MathNode_default.FLOOR, new MathNode_default(MathNode_default.MOD, frame, total));
    const frameNum = new OperatorNode_default("+", roundFrame, one);
    const cell = new MathNode_default(MathNode_default.MOD, roundFrame, width);
    const row = new MathNode_default(MathNode_default.CEIL, new OperatorNode_default("/", frameNum, width));
    const rowInv = new OperatorNode_default("-", height, row);
    const scale = new OperatorNode_default("/", one, count);
    const uvFrameOffset = new JoinNode_default([new OperatorNode_default("*", cell, new SplitNode_default(scale, "x")), new OperatorNode_default("*", rowInv, new SplitNode_default(scale, "y"))]);
    const uvScale = new OperatorNode_default("*", uv2, scale);
    const uvFrame = new OperatorNode_default("+", uvScale, uvFrameOffset);
    return uvFrame.build(builder, this.getNodeType(builder));
  }
};
var SpriteSheetUVNode_default = SpriteSheetUVNode;

// node_modules/three-stdlib/nodes/utils/MatcapUVNode.js
var MatcapUVNode = class extends TempNode_default {
  constructor() {
    super("vec2");
  }
  generate(builder) {
    const x = normalize(join(positionViewDirection.z, 0, negate(positionViewDirection.x)));
    const y = cross(positionViewDirection, x);
    const uv2 = add(mul(join(dot(x, transformedNormalView), dot(y, transformedNormalView)), 0.495), 0.5);
    return uv2.build(builder, this.getNodeType(builder));
  }
};
var MatcapUVNode_default = MatcapUVNode;

// node_modules/three-stdlib/nodes/utils/TimerNode.js
var TimerNode = class extends UniformNode_default {
  constructor(scope2 = TimerNode.LOCAL) {
    super(0);
    this.scope = scope2;
    this.scale = 1;
    this.updateType = NodeUpdateType2.Frame;
  }
  update(frame) {
    const scope2 = this.scope;
    const scale = this.scale;
    if (scope2 === TimerNode.LOCAL) {
      this.value += frame.deltaTime * scale;
    } else if (scope2 === TimerNode.DELTA) {
      this.value = frame.deltaTime * scale;
    } else {
      this.value = frame.time * scale;
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
    data.scale = this.scale;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
    this.scale = data.scale;
  }
};
_defineProperty(TimerNode, "LOCAL", "local");
_defineProperty(TimerNode, "GLOBAL", "global");
_defineProperty(TimerNode, "DELTA", "delta");
var TimerNode_default = TimerNode;

// node_modules/three-stdlib/nodes/utils/OscNode.js
var OscNode = class extends Node_default {
  constructor(method = OscNode.SINE, timeNode = new TimerNode_default()) {
    super();
    this.method = method;
    this.timeNode = timeNode;
  }
  getNodeType(builder) {
    return this.timeNode.getNodeType(builder);
  }
  generate(builder) {
    const method = this.method;
    const timeNode = this.timeNode;
    let outputNode = null;
    if (method === OscNode.SINE) {
      outputNode = add(mul(sin(mul(add(timeNode, 0.75), Math.PI * 2)), 0.5), 0.5);
    } else if (method === OscNode.SQUARE) {
      outputNode = round(fract(timeNode));
    } else if (method === OscNode.TRIANGLE) {
      outputNode = abs(sub(1, mul(fract(add(timeNode, 0.5)), 2)));
    } else if (method === OscNode.SAWTOOTH) {
      outputNode = fract(timeNode);
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
_defineProperty(OscNode, "SINE", "sine");
_defineProperty(OscNode, "SQUARE", "square");
_defineProperty(OscNode, "TRIANGLE", "triangle");
_defineProperty(OscNode, "SAWTOOTH", "sawtooth");
var OscNode_default = OscNode;

// node_modules/three-stdlib/nodes/loaders/NodeLoader.js
var NodeLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (text) => {
      try {
        onLoad(this.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        this.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parseNodes(json) {
    const nodes = {};
    if (json !== void 0) {
      for (const nodeJSON of json) {
        const {
          uuid,
          type: type2
        } = nodeJSON;
        nodes[uuid] = fromType(type2);
        nodes[uuid].uuid = uuid;
      }
      const meta2 = {
        nodes,
        textures: this.textures
      };
      for (const nodeJSON of json) {
        nodeJSON.meta = meta2;
        const node = nodes[nodeJSON.uuid];
        node.deserialize(nodeJSON);
        delete nodeJSON.meta;
      }
    }
    return nodes;
  }
  parse(json) {
    const node = fromType(type);
    node.uuid = json.uuid;
    const nodes = this.parseNodes(json.inputNodes);
    const meta2 = {
      nodes,
      textures: this.textures
    };
    json.meta = meta2;
    node.deserialize(json);
    delete json.meta;
    return node;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
};
var NodeLoader_default = NodeLoader;

// node_modules/three-stdlib/nodes/loaders/NodeMaterialLoader.js
var NodeMaterialLoader = class extends MaterialLoader {
  constructor(manager) {
    super(manager);
    this.nodes = {};
  }
  parse(json) {
    const material = super.parse(json);
    const nodes = this.nodes;
    const inputNodes = json.inputNodes;
    for (const property in inputNodes) {
      const uuid = inputNodes[property];
      material[property] = nodes[uuid];
    }
    return material;
  }
  setNodes(value) {
    this.nodes = value;
    return this;
  }
};
var NodeMaterialLoader_default = NodeMaterialLoader;

// node_modules/three-stdlib/nodes/loaders/NodeObjectLoader.js
var NodeObjectLoader = class extends ObjectLoader {
  constructor(manager) {
    super(manager);
    this._nodesJSON = null;
  }
  parse(json, onLoad) {
    this._nodesJSON = json.nodes;
    const data = super.parse(json, onLoad);
    this._nodesJSON = null;
    return data;
  }
  parseNodes(json, textures) {
    if (json !== void 0) {
      const loader = new NodeLoader_default();
      loader.setTextures(textures);
      return loader.parseNodes(json);
    }
    return {};
  }
  parseMaterials(json, textures) {
    const materials = {};
    if (json !== void 0) {
      const nodes = this.parseNodes(this._nodesJSON, textures);
      const loader = new NodeMaterialLoader_default();
      loader.setTextures(textures);
      loader.setNodes(nodes);
      for (let i2 = 0, l = json.length; i2 < l; i2++) {
        const data = json[i2];
        materials[data.uuid] = loader.parse(data);
      }
    }
    return materials;
  }
};
var NodeObjectLoader_default = NodeObjectLoader;

// node_modules/three-stdlib/nodes/procedural/CheckerNode.js
var checkerShaderNode = new ShaderNode((inputs) => {
  const uv2 = mul(inputs.uv, 2);
  const cx = floor(uv2.x);
  const cy = floor(uv2.y);
  const result = mod(add(cx, cy), 2);
  return sign(result);
});
var CheckerNode = class extends Node_default {
  constructor(uvNode = uv()) {
    super("float");
    this.uvNode = uvNode;
  }
  generate(builder) {
    return checkerShaderNode({
      uv: this.uvNode
    }).build(builder);
  }
};
var CheckerNode_default = CheckerNode;

// node_modules/three-stdlib/nodes/fog/FogNode.js
var FogNode = class extends Node_default {
  constructor(colorNode, factorNode) {
    super("float");
    this.colorNode = colorNode;
    this.factorNode = factorNode;
  }
  generate(builder) {
    return this.factorNode.build(builder, "float");
  }
};
FogNode.prototype.isFogNode = true;
var FogNode_default = FogNode;

// node_modules/three-stdlib/nodes/fog/FogRangeNode.js
var FogRangeNode = class extends FogNode_default {
  constructor(colorNode, nearNode, farNode) {
    super(colorNode);
    this.nearNode = nearNode;
    this.farNode = farNode;
  }
  generate(builder) {
    this.factorNode = smoothstep(this.nearNode, this.farNode, negate(positionView.z));
    return super.generate(builder);
  }
};
FogRangeNode.prototype.isFogRangeNode = true;
var FogRangeNode_default = FogRangeNode;

// node_modules/three-stdlib/nodes/Nodes.js
var nodeLib = {
  ArrayUniformNode: ArrayUniformNode_default,
  AttributeNode: AttributeNode_default,
  BypassNode: BypassNode_default,
  CodeNode: CodeNode_default,
  ContextNode: ContextNode_default,
  ConstNode: ConstNode_default,
  ExpressionNode: ExpressionNode_default,
  FunctionCallNode: FunctionCallNode_default,
  FunctionNode: FunctionNode_default,
  Node: Node_default,
  NodeAttribute: NodeAttribute_default,
  NodeBuilder: NodeBuilder_default,
  NodeCode: NodeCode_default,
  NodeFrame: NodeFrame_default,
  NodeFunctionInput: NodeFunctionInput_default,
  NodeKeywords: NodeKeywords_default,
  NodeUniform: NodeUniform_default,
  NodeVar: NodeVar_default,
  NodeVary: NodeVary_default,
  PropertyNode: PropertyNode_default,
  TempNode: TempNode_default,
  UniformNode: UniformNode_default,
  VarNode: VarNode_default,
  VaryNode: VaryNode_default,
  BufferNode: BufferNode_default,
  CameraNode: CameraNode_default,
  CubeTextureNode: CubeTextureNode_default,
  MaterialNode: MaterialNode_default,
  MaterialReferenceNode: MaterialReferenceNode_default,
  ModelNode: ModelNode_default,
  ModelViewProjectionNode: ModelViewProjectionNode_default,
  NormalNode: NormalNode_default,
  Object3DNode: Object3DNode_default,
  PointUVNode: PointUVNode_default,
  PositionNode: PositionNode_default,
  ReferenceNode: ReferenceNode_default,
  ReflectNode: ReflectNode_default,
  SkinningNode: SkinningNode_default,
  TextureNode: TextureNode_default,
  UVNode: UVNode_default,
  ColorSpaceNode: ColorSpaceNode_default,
  NormalMapNode: NormalMapNode_default,
  MathNode: MathNode_default,
  OperatorNode: OperatorNode_default,
  CondNode: CondNode_default,
  LightContextNode: LightContextNode_default,
  LightNode: LightNode_default,
  LightsNode: LightsNode_default,
  ArrayElementNode: ArrayElementNode_default,
  ConvertNode: ConvertNode_default,
  JoinNode: JoinNode_default,
  SplitNode: SplitNode_default,
  SpriteSheetUVNode: SpriteSheetUVNode_default,
  MatcapUVNode: MatcapUVNode_default,
  OscNode: OscNode_default,
  TimerNode: TimerNode_default,
  CheckerNode: CheckerNode_default,
  FogNode: FogNode_default,
  FogRangeNode: FogRangeNode_default,
  NodeLoader: NodeLoader_default,
  NodeObjectLoader: NodeObjectLoader_default,
  NodeMaterialLoader: NodeMaterialLoader_default
};
var fromType = (type2) => {
  return new nodeLib[type2]();
};

// node_modules/three-stdlib/exporters/GLTFExporter.js
var GLTFExporter = class {
  constructor() {
    _defineProperty(this, "pluginCallbacks", void 0);
    this.pluginCallbacks = [];
    this.register(function(writer) {
      return new GLTFLightExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsUnlitExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsPBRSpecularGlossiness(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsTransmissionExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsVolumeExtension(writer);
    });
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(input, onDone, options) {
    const writer = new GLTFWriter();
    const plugins = [];
    for (let i2 = 0, il = this.pluginCallbacks.length; i2 < il; i2++) {
      plugins.push(this.pluginCallbacks[i2](writer));
    }
    writer.setPlugins(plugins);
    writer.write(input, onDone, options);
  }
};
_defineProperty(GLTFExporter, "Utils", {
  insertKeyframe: function(track, time) {
    const tolerance = 1e-3;
    const valueSize = track.getValueSize();
    const times = new track.TimeBufferType(track.times.length + 1);
    const values = new track.ValueBufferType(track.values.length + valueSize);
    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));
    let index;
    if (track.times.length === 0) {
      times[0] = time;
      for (let i2 = 0; i2 < valueSize; i2++) {
        values[i2] = 0;
      }
      index = 0;
    } else if (time < track.times[0]) {
      if (Math.abs(track.times[0] - time) < tolerance)
        return 0;
      times[0] = time;
      times.set(track.times, 1);
      values.set(interpolant.evaluate(time), 0);
      values.set(track.values, valueSize);
      index = 0;
    } else if (time > track.times[track.times.length - 1]) {
      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {
        return track.times.length - 1;
      }
      times[times.length - 1] = time;
      times.set(track.times, 0);
      values.set(track.values, 0);
      values.set(interpolant.evaluate(time), track.values.length);
      index = times.length - 1;
    } else {
      for (let i2 = 0; i2 < track.times.length; i2++) {
        if (Math.abs(track.times[i2] - time) < tolerance)
          return i2;
        if (track.times[i2] < time && track.times[i2 + 1] > time) {
          times.set(track.times.slice(0, i2 + 1), 0);
          times[i2 + 1] = time;
          times.set(track.times.slice(i2 + 1), i2 + 2);
          values.set(track.values.slice(0, (i2 + 1) * valueSize), 0);
          values.set(interpolant.evaluate(time), (i2 + 1) * valueSize);
          values.set(track.values.slice((i2 + 1) * valueSize), (i2 + 2) * valueSize);
          index = i2 + 1;
          break;
        }
      }
    }
    track.times = times;
    track.values = values;
    return index;
  },
  mergeMorphTargetTracks: function(clip, root) {
    const tracks = [];
    const mergedTracks = {};
    const sourceTracks = clip.tracks;
    for (let i2 = 0; i2 < sourceTracks.length; ++i2) {
      let sourceTrack = sourceTracks[i2];
      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);
      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);
      if (sourceTrackBinding.propertyName !== "morphTargetInfluences" || sourceTrackBinding.propertyIndex === void 0) {
        tracks.push(sourceTrack);
        continue;
      }
      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {
        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        }
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.");
        sourceTrack = sourceTrack.clone();
        sourceTrack.setInterpolation(InterpolateLinear);
      }
      const targetCount = sourceTrackNode.morphTargetInfluences.length;
      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];
      if (targetIndex === void 0) {
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + sourceTrackBinding.propertyIndex);
      }
      let mergedTrack;
      if (mergedTracks[sourceTrackNode.uuid] === void 0) {
        mergedTrack = sourceTrack.clone();
        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);
        for (let j2 = 0; j2 < mergedTrack.times.length; j2++) {
          values[j2 * targetCount + targetIndex] = mergedTrack.values[j2];
        }
        mergedTrack.name = (sourceTrackBinding.nodeName || "") + ".morphTargetInfluences";
        mergedTrack.values = values;
        mergedTracks[sourceTrackNode.uuid] = mergedTrack;
        tracks.push(mergedTrack);
        continue;
      }
      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));
      mergedTrack = mergedTracks[sourceTrackNode.uuid];
      for (let j2 = 0; j2 < mergedTrack.times.length; j2++) {
        mergedTrack.values[j2 * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j2]);
      }
      for (let j2 = 0; j2 < sourceTrack.times.length; j2++) {
        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j2]);
        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j2];
      }
    }
    clip.tracks = tracks;
    return clip;
  }
});
var WEBGL_CONSTANTS = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123,
  FLOAT: 5126,
  UNSIGNED_INT: 5125,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
};
var THREE_TO_WEBGL = {};
THREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;
THREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;
THREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;
THREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;
THREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;
THREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;
THREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;
THREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;
THREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;
var PATH_PROPERTIES = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
};
var GLB_HEADER_BYTES = 12;
var GLB_HEADER_MAGIC = 1179937895;
var GLB_VERSION = 2;
var GLB_CHUNK_PREFIX_BYTES = 8;
var GLB_CHUNK_TYPE_JSON = 1313821514;
var GLB_CHUNK_TYPE_BIN = 5130562;
var GLTFWriter = class {
  constructor() {
    _defineProperty(this, "plugins", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "pending", void 0);
    _defineProperty(this, "buffers", void 0);
    _defineProperty(this, "byteOffset", void 0);
    _defineProperty(this, "nodeMap", void 0);
    _defineProperty(this, "skins", void 0);
    _defineProperty(this, "extensionsUsed", void 0);
    _defineProperty(this, "uids", void 0);
    _defineProperty(this, "uid", void 0);
    _defineProperty(this, "json", void 0);
    _defineProperty(this, "cache", void 0);
    _defineProperty(this, "cachedCanvas", void 0);
    this.plugins = [];
    this.options = {};
    this.pending = [];
    this.buffers = [];
    this.byteOffset = 0;
    this.nodeMap = /* @__PURE__ */ new Map();
    this.skins = [];
    this.extensionsUsed = {};
    this.uids = /* @__PURE__ */ new Map();
    this.uid = 0;
    this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter"
      }
    };
    this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
    this.cachedCanvas = null;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  write(input, onDone, options) {
    this.options = Object.assign({}, {
      binary: false,
      trs: false,
      onlyVisible: true,
      truncateDrawRange: true,
      embedImages: true,
      maxTextureSize: Infinity,
      animations: [],
      includeCustomExtensions: false
    }, options);
    if (this.options.animations !== void 0 && this.options.animations.length > 0) {
      this.options.trs = true;
    }
    this.processInput(input);
    const writer = this;
    Promise.all(this.pending).then(() => {
      const buffers = writer.buffers;
      const json = writer.json;
      const options2 = writer.options;
      const extensionsUsed = writer.extensionsUsed;
      const blob = new Blob(buffers, {
        type: "application/octet-stream"
      });
      const extensionsUsedList = Object.keys(extensionsUsed);
      if (extensionsUsedList.length > 0)
        json.extensionsUsed = extensionsUsedList;
      if (json.buffers && json.buffers.length > 0)
        json.buffers[0].byteLength = blob.size;
      if (options2.binary) {
        const reader = new window.FileReader();
        reader.readAsArrayBuffer(blob);
        reader.onloadend = () => {
          if (reader.result !== null && typeof reader.result !== "string") {
            const binaryChunk = this.getPaddedArrayBuffer(reader.result);
            const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);
            const jsonChunk = this.getPaddedArrayBuffer(this.stringToArrayBuffer(JSON.stringify(json)), 32);
            const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);
            const header = new ArrayBuffer(GLB_HEADER_BYTES);
            const headerView = new DataView(header);
            headerView.setUint32(0, GLB_HEADER_MAGIC, true);
            headerView.setUint32(4, GLB_VERSION, true);
            const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
            headerView.setUint32(8, totalByteLength, true);
            const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {
              type: "application/octet-stream"
            });
            const glbReader = new window.FileReader();
            glbReader.readAsArrayBuffer(glbBlob);
            glbReader.onloadend = function() {
              if (glbReader.result !== null && typeof glbReader.result !== "string") {
                onDone(glbReader.result);
              }
            };
          }
        };
      } else {
        if (json.buffers && json.buffers.length > 0) {
          const reader = new window.FileReader();
          reader.readAsDataURL(blob);
          reader.onloadend = function() {
            const base64data = reader.result;
            if (json.buffers !== void 0 && base64data !== null) {
              json.buffers[0].uri = base64data;
              onDone(json);
            }
          };
        } else {
          onDone(json);
        }
      }
    });
  }
  serializeUserData(object, objectDef) {
    if (Object.keys(object.userData).length === 0)
      return;
    const options = this.options;
    const extensionsUsed = this.extensionsUsed;
    try {
      const json = JSON.parse(JSON.stringify(object.userData));
      if (options.includeCustomExtensions && json.gltfExtensions) {
        if (objectDef.extensions === void 0)
          objectDef.extensions = {};
        for (const extensionName in json.gltfExtensions) {
          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];
          extensionsUsed[extensionName] = true;
        }
        delete json.gltfExtensions;
      }
      if (Object.keys(json).length > 0)
        objectDef.extras = json;
    } catch (error) {
      if (error instanceof Error) {
        console.warn("THREE.GLTFExporter: userData of '" + object.name + "' won't be serialized because of JSON.stringify error - " + error.message);
      }
    }
  }
  getUID(object) {
    if (!this.uids.has(object))
      this.uids.set(object, this.uid++);
    return this.uids.get(object);
  }
  isNormalizedNormalAttribute(normal) {
    const cache = this.cache;
    if (cache.attributesNormalized.has(normal))
      return false;
    const v = new Vector3();
    for (let i2 = 0, il = normal.count; i2 < il; i2++) {
      if (Math.abs(v.fromBufferAttribute(normal, i2).length() - 1) > 5e-4)
        return false;
    }
    return true;
  }
  createNormalizedNormalAttribute(normal) {
    const cache = this.cache;
    if (cache.attributesNormalized.has(normal))
      return cache.attributesNormalized.get(normal);
    const attribute2 = normal.clone();
    const v = new Vector3();
    for (let i2 = 0, il = attribute2.count; i2 < il; i2++) {
      v.fromBufferAttribute(attribute2, i2);
      if (v.x === 0 && v.y === 0 && v.z === 0) {
        v.setX(1);
      } else {
        v.normalize();
      }
      attribute2.setXYZ(i2, v.x, v.y, v.z);
    }
    cache.attributesNormalized.set(normal, attribute2);
    return attribute2;
  }
  applyTextureTransform(mapDef, texture2) {
    let didTransform = false;
    const transformDef = {};
    if (texture2.offset.x !== 0 || texture2.offset.y !== 0) {
      transformDef.offset = texture2.offset.toArray();
      didTransform = true;
    }
    if (texture2.rotation !== 0) {
      transformDef.rotation = texture2.rotation;
      didTransform = true;
    }
    if (texture2.repeat.x !== 1 || texture2.repeat.y !== 1) {
      transformDef.scale = texture2.repeat.toArray();
      didTransform = true;
    }
    if (didTransform) {
      mapDef.extensions = mapDef.extensions || {};
      mapDef.extensions["KHR_texture_transform"] = transformDef;
      this.extensionsUsed["KHR_texture_transform"] = true;
    }
  }
  processBuffer(buffer2) {
    const json = this.json;
    const buffers = this.buffers;
    if (!json.buffers)
      json.buffers = [{
        byteLength: 0
      }];
    buffers.push(buffer2);
    return 0;
  }
  processBufferView(attribute2, componentType, start, count, target) {
    const json = this.json;
    if (!json.bufferViews)
      json.bufferViews = [];
    let componentSize;
    if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {
      componentSize = 1;
    } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {
      componentSize = 2;
    } else {
      componentSize = 4;
    }
    const byteLength = this.getPaddedBufferSize(count * attribute2.itemSize * componentSize);
    const dataView = new DataView(new ArrayBuffer(byteLength));
    let offset = 0;
    for (let i2 = start; i2 < start + count; i2++) {
      for (let a2 = 0; a2 < attribute2.itemSize; a2++) {
        let value;
        if (attribute2.itemSize > 4) {
          value = attribute2.array[i2 * attribute2.itemSize + a2];
        } else {
          if (a2 === 0)
            value = attribute2.getX(i2);
          else if (a2 === 1)
            value = attribute2.getY(i2);
          else if (a2 === 2)
            value = attribute2.getZ(i2);
          else if (a2 === 3)
            value = attribute2.getW(i2);
        }
        if (value !== void 0) {
          if (componentType === WEBGL_CONSTANTS.FLOAT) {
            dataView.setFloat32(offset, value, true);
          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {
            dataView.setUint32(offset, value, true);
          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {
            dataView.setUint16(offset, value, true);
          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {
            dataView.setUint8(offset, value);
          }
        }
        offset += componentSize;
      }
    }
    const bufferViewDef = {
      buffer: this.processBuffer(dataView.buffer),
      byteOffset: this.byteOffset,
      byteLength
    };
    if (target !== void 0)
      bufferViewDef.target = target;
    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {
      bufferViewDef.byteStride = attribute2.itemSize * componentSize;
    }
    this.byteOffset += byteLength;
    json.bufferViews.push(bufferViewDef);
    const output = {
      id: json.bufferViews.length - 1,
      byteLength: 0
    };
    return output;
  }
  processBufferViewImage(blob) {
    const writer = this;
    const json = writer.json;
    if (!json.bufferViews)
      json.bufferViews = [];
    return new Promise((resolve) => {
      const reader = new window.FileReader();
      reader.readAsArrayBuffer(blob);
      reader.onloadend = () => {
        if (reader.result !== null && typeof reader.result !== "string" && json.bufferViews !== void 0) {
          const buffer2 = this.getPaddedArrayBuffer(reader.result);
          const bufferViewDef = {
            buffer: writer.processBuffer(buffer2),
            byteOffset: writer.byteOffset,
            byteLength: buffer2.byteLength
          };
          writer.byteOffset += buffer2.byteLength;
          resolve(json.bufferViews.push(bufferViewDef) - 1);
        }
      };
    });
  }
  processAccessor(attribute2, geometry, start, count) {
    const options = this.options;
    const json = this.json;
    const types = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      16: "MAT4"
    };
    let componentType;
    if (attribute2.array.constructor === Float32Array) {
      componentType = WEBGL_CONSTANTS.FLOAT;
    } else if (attribute2.array.constructor === Uint32Array) {
      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;
    } else if (attribute2.array.constructor === Uint16Array) {
      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;
    } else if (attribute2.array.constructor === Uint8Array) {
      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
    }
    if (start === void 0)
      start = 0;
    if (count === void 0)
      count = attribute2.count;
    if (options.truncateDrawRange && geometry !== void 0 && geometry.index === null) {
      const end = start + count;
      const end2 = geometry.drawRange.count === Infinity ? attribute2.count : geometry.drawRange.start + geometry.drawRange.count;
      start = Math.max(start, geometry.drawRange.start);
      count = Math.min(end, end2) - start;
      if (count < 0)
        count = 0;
    }
    if (count === 0)
      return null;
    const minMax = this.getMinMax(attribute2, start, count);
    let bufferViewTarget;
    if (geometry !== void 0) {
      bufferViewTarget = attribute2 === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;
    }
    if (bufferViewTarget !== void 0) {
      const bufferView = this.processBufferView(attribute2, componentType, start, count, bufferViewTarget);
      const accessorDef = {
        bufferView: bufferView.id,
        byteOffset: bufferView.byteOffset,
        componentType,
        count,
        max: minMax.max,
        min: minMax.min,
        type: types[attribute2.itemSize]
      };
      if (attribute2.normalized)
        accessorDef.normalized = true;
      if (!json.accessors)
        json.accessors = [];
      return json.accessors.push(accessorDef) - 1;
    }
  }
  processImage(image, format, flipY) {
    const writer = this;
    const cache = writer.cache;
    const json = writer.json;
    const options = writer.options;
    const pending = writer.pending;
    if (!cache.images.has(image))
      cache.images.set(image, {});
    const cachedImages = cache.images.get(image);
    const mimeType = format === RGBAFormat ? "image/png" : "image/jpeg";
    const key = mimeType + ":flipY/" + flipY.toString();
    if (cachedImages !== void 0 && cachedImages[key] !== void 0)
      return cachedImages[key];
    if (!json.images)
      json.images = [];
    const imageDef = {
      mimeType
    };
    if (options.embedImages && options.maxTextureSize !== void 0) {
      const canvas = this.cachedCanvas = this.cachedCanvas || document.createElement("canvas");
      canvas.width = Math.min(image.width, options.maxTextureSize);
      canvas.height = Math.min(image.height, options.maxTextureSize);
      const ctx = canvas.getContext("2d");
      if (flipY) {
        ctx === null || ctx === void 0 ? void 0 : ctx.translate(0, canvas.height);
        ctx === null || ctx === void 0 ? void 0 : ctx.scale(1, -1);
      }
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && image instanceof OffscreenCanvas || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      } else {
        if (format !== RGBAFormat) {
          console.error("GLTFExporter: Only RGBA format is supported.");
        }
        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {
          console.warn("GLTFExporter: Image size is bigger than maxTextureSize", image);
        }
        const data = new Uint8ClampedArray(image.height * image.width * 4);
        if (image instanceof ImageData) {
          for (let i2 = 0; i2 < data.length; i2 += 4) {
            data[i2 + 0] = image.data[i2 + 0];
            data[i2 + 1] = image.data[i2 + 1];
            data[i2 + 2] = image.data[i2 + 2];
            data[i2 + 3] = image.data[i2 + 3];
          }
        }
        ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);
      }
      if (options.binary) {
        pending.push(new Promise(function(resolve) {
          canvas.toBlob(function(blob) {
            if (blob !== null) {
              writer.processBufferViewImage(blob).then(function(bufferViewIndex) {
                imageDef.bufferView = bufferViewIndex;
                resolve();
              });
            }
          }, mimeType);
        }));
      } else {
        imageDef.uri = canvas.toDataURL(mimeType);
      }
    } else if (image instanceof Image) {
      imageDef.uri = image.src;
    }
    const index = json.images.push(imageDef) - 1;
    if (cachedImages !== void 0)
      cachedImages[key] = index;
    return index;
  }
  processSampler(map) {
    const json = this.json;
    if (!json.samplers)
      json.samplers = [];
    const samplerDef = {
      magFilter: THREE_TO_WEBGL[map.magFilter],
      minFilter: THREE_TO_WEBGL[map.minFilter],
      wrapS: THREE_TO_WEBGL[map.wrapS],
      wrapT: THREE_TO_WEBGL[map.wrapT]
    };
    return json.samplers.push(samplerDef) - 1;
  }
  processTexture(map) {
    const cache = this.cache;
    const json = this.json;
    if (cache.textures.has(map))
      return cache.textures.get(map);
    if (!json.textures)
      json.textures = [];
    const textureDef = {
      sampler: this.processSampler(map),
      source: this.processImage(map.image, map.format, map.flipY)
    };
    if (map.name)
      textureDef.name = map.name;
    this._invokeAll(function(ext) {
      ext.writeTexture && ext.writeTexture(map, textureDef);
    });
    const index = json.textures.push(textureDef) - 1;
    cache.textures.set(map, index);
    return index;
  }
  processMaterial(material) {
    const cache = this.cache;
    const json = this.json;
    if (cache.materials.has(material))
      return cache.materials.get(material);
    if (material instanceof ShaderMaterial && material.isShaderMaterial) {
      console.warn("GLTFExporter: THREE.ShaderMaterial not supported.");
      return null;
    }
    if (!json.materials)
      json.materials = [];
    const materialDef = {
      pbrMetallicRoughness: {}
    };
    if (!(material instanceof MeshStandardMaterial && material.isMeshStandardMaterial && material instanceof MeshBasicMaterial && material.isMeshBasicMaterial)) {
      console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    }
    if (material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) {
      const color2 = material.color.toArray().concat([material.opacity]);
      if (!this.equalArray(color2, [1, 1, 1, 1])) {
        materialDef.pbrMetallicRoughness.baseColorFactor = color2;
      }
    }
    if (material instanceof MeshStandardMaterial && material.isMeshStandardMaterial) {
      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;
      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;
    } else {
      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;
      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;
    }
    if (material instanceof MeshStandardMaterial && material.metalnessMap || material instanceof MeshStandardMaterial && material.roughnessMap) {
      if (material.metalnessMap === material.roughnessMap && material.metalnessMap !== null) {
        const metalRoughMapDef = {
          index: this.processTexture(material.metalnessMap)
        };
        this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);
        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;
      } else {
        console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");
      }
    }
    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.map) {
      const baseColorMapDef = {
        index: this.processTexture(material.map)
      };
      this.applyTextureTransform(baseColorMapDef, material.map);
      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;
    }
    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.emissive) {
      const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);
      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);
      if (maxEmissiveComponent > 1) {
        emissive.multiplyScalar(1 / maxEmissiveComponent);
        console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited");
      }
      if (maxEmissiveComponent > 0) {
        materialDef.emissiveFactor = emissive.toArray();
      }
      if (material.emissiveMap) {
        const emissiveMapDef = {
          index: this.processTexture(material.emissiveMap)
        };
        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);
        materialDef.emissiveTexture = emissiveMapDef;
      }
    }
    if ((material instanceof MeshMatcapMaterial || material instanceof MeshNormalMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.normalMap) {
      const normalMapDef = {
        index: this.processTexture(material.normalMap)
      };
      if (material.normalScale && material.normalScale.x !== 1) {
        normalMapDef.scale = material.normalScale.x;
      }
      this.applyTextureTransform(normalMapDef, material.normalMap);
      materialDef.normalTexture = normalMapDef;
    }
    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.aoMap) {
      const occlusionMapDef = {
        index: this.processTexture(material.aoMap),
        texCoord: 1
      };
      if (material.aoMapIntensity !== 1) {
        occlusionMapDef.strength = material.aoMapIntensity;
      }
      this.applyTextureTransform(occlusionMapDef, material.aoMap);
      materialDef.occlusionTexture = occlusionMapDef;
    }
    if (material.transparent) {
      materialDef.alphaMode = "BLEND";
    } else {
      if (material.alphaTest > 0) {
        materialDef.alphaMode = "MASK";
        materialDef.alphaCutoff = material.alphaTest;
      }
    }
    if (material.side === DoubleSide)
      materialDef.doubleSided = true;
    if (material.name !== "")
      materialDef.name = material.name;
    this.serializeUserData(material, materialDef);
    this._invokeAll(function(ext) {
      ext.writeMaterial && ext.writeMaterial(material, materialDef);
    });
    const index = json.materials.push(materialDef) - 1;
    cache.materials.set(material, index);
    return index;
  }
  processMesh(mesh) {
    const cache = this.cache;
    const json = this.json;
    const meshCacheKeyParts = [mesh.geometry.uuid];
    if (Array.isArray(mesh.material)) {
      for (let i2 = 0, l = mesh.material.length; i2 < l; i2++) {
        meshCacheKeyParts.push(mesh.material[i2].uuid);
      }
    } else {
      meshCacheKeyParts.push(mesh.material.uuid);
    }
    const meshCacheKey = meshCacheKeyParts.join(":");
    if (cache.meshes.has(meshCacheKey))
      return cache.meshes.get(meshCacheKey);
    const geometry = mesh.geometry;
    let mode;
    if (mesh instanceof LineSegments && mesh.isLineSegments) {
      mode = WEBGL_CONSTANTS.LINES;
    } else if (mesh instanceof LineLoop && mesh.isLineLoop) {
      mode = WEBGL_CONSTANTS.LINE_LOOP;
    } else if (mesh instanceof Line && mesh.isLine) {
      mode = WEBGL_CONSTANTS.LINE_STRIP;
    } else if (mesh instanceof Points && mesh.isPoints) {
      mode = WEBGL_CONSTANTS.POINTS;
    } else {
      mode = (mesh.material instanceof MeshBasicMaterial || mesh.material instanceof MeshDepthMaterial || mesh.material instanceof MeshLambertMaterial || mesh.material instanceof MeshNormalMaterial || mesh.material instanceof MeshPhongMaterial || mesh.material instanceof MeshStandardMaterial || mesh.material instanceof MeshToonMaterial || mesh.material instanceof ShaderMaterial) && mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;
    }
    if (!geometry.isBufferGeometry) {
      throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");
    }
    const meshDef = {};
    const attributes = {};
    const primitives = [];
    const targets = [];
    const nameConversion = {
      uv: "TEXCOORD_0",
      uv2: "TEXCOORD_1",
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    };
    const originalNormal = geometry.getAttribute("normal");
    if (originalNormal !== void 0 && !(originalNormal instanceof InterleavedBufferAttribute) && !this.isNormalizedNormalAttribute(originalNormal)) {
      console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.");
      geometry.setAttribute("normal", this.createNormalizedNormalAttribute(originalNormal));
    }
    let modifiedAttribute = null;
    for (let attributeName in geometry.attributes) {
      if (attributeName.substr(0, 5) === "morph")
        continue;
      const attribute2 = geometry.attributes[attributeName];
      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();
      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;
      if (!validVertexAttributes.test(attributeName))
        attributeName = "_" + attributeName;
      if (cache.attributes.has(this.getUID(attribute2))) {
        attributes[attributeName] = cache.attributes.get(this.getUID(attribute2));
        continue;
      }
      modifiedAttribute = null;
      const array = attribute2.array;
      if (attributeName === "JOINTS_0" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {
        console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.');
        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute2.itemSize, attribute2.normalized);
      }
      const accessor = modifiedAttribute !== null && this.processAccessor(modifiedAttribute || attribute2, geometry);
      if (accessor) {
        attributes[attributeName] = accessor;
        cache.attributes.set(this.getUID(attribute2), accessor);
      }
    }
    if (originalNormal !== void 0)
      geometry.setAttribute("normal", originalNormal);
    if (Object.keys(attributes).length === 0)
      return null;
    if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {
      const weights = [];
      const targetNames = [];
      const reverseDictionary = {};
      if (mesh.morphTargetDictionary !== void 0) {
        for (const key in mesh.morphTargetDictionary) {
          reverseDictionary[mesh.morphTargetDictionary[key]] = key;
        }
      }
      for (let i2 = 0; i2 < mesh.morphTargetInfluences.length; ++i2) {
        const target = {};
        let warned = false;
        for (const attributeName in geometry.morphAttributes) {
          if (attributeName !== "position" && attributeName !== "normal") {
            if (!warned) {
              console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported.");
              warned = true;
            }
            continue;
          }
          const attribute2 = geometry.morphAttributes[attributeName][i2];
          const gltfAttributeName = attributeName.toUpperCase();
          const baseAttribute = geometry.attributes[attributeName];
          if (cache.attributes.has(this.getUID(attribute2))) {
            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute2));
            continue;
          }
          const relativeAttribute = attribute2.clone();
          if (!geometry.morphTargetsRelative) {
            for (let j2 = 0, jl2 = attribute2.count; j2 < jl2; j2++) {
              relativeAttribute.setXYZ(j2, attribute2.getX(j2) - baseAttribute.getX(j2), attribute2.getY(j2) - baseAttribute.getY(j2), attribute2.getZ(j2) - baseAttribute.getZ(j2));
            }
          }
          const accessor = this.processAccessor(relativeAttribute, geometry);
          if (accessor != void 0) {
            target[gltfAttributeName] = accessor;
          }
          cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);
        }
        targets.push(target);
        weights.push(mesh.morphTargetInfluences[i2]);
        if (mesh.morphTargetDictionary !== void 0)
          targetNames.push(reverseDictionary[i2]);
      }
      meshDef.weights = weights;
      if (targetNames.length > 0) {
        meshDef.extras = {};
        meshDef.extras.targetNames = targetNames;
      }
    }
    const isMultiMaterial = Array.isArray(mesh.material);
    if (isMultiMaterial && geometry.groups.length === 0)
      return null;
    const materials = isMultiMaterial ? mesh.material : [mesh.material];
    const groups = isMultiMaterial ? geometry.groups : [{
      materialIndex: 0,
      start: void 0,
      count: void 0
    }];
    for (let i2 = 0, il = groups.length; i2 < il; i2++) {
      const primitive = {
        mode,
        attributes
      };
      if (geometry instanceof Object3D || geometry instanceof Material) {
        this.serializeUserData(geometry, primitive);
      }
      if (targets.length > 0)
        primitive.targets = targets;
      if (geometry.index !== null) {
        let cacheKey = this.getUID(geometry.index);
        if (groups[i2].start !== void 0 || groups[i2].count !== void 0) {
          cacheKey += `:${groups[i2].start}:${groups[i2].count}`;
        }
        if (cache.attributes.has(cacheKey)) {
          primitive.indices = cache.attributes.get(cacheKey);
        } else {
          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i2].start, groups[i2].count);
          cache.attributes.set(cacheKey, primitive.indices);
        }
        if (primitive.indices === null)
          delete primitive.indices;
      }
      const materialIndex = groups[i2].materialIndex;
      if (materialIndex !== void 0 && Array.isArray(materials)) {
        const targetMaterials = materials[materialIndex];
        if (!Array.isArray(targetMaterials)) {
          const material = this.processMaterial(targetMaterials);
          if (material !== null)
            primitive.material = material;
          primitives.push(primitive);
        }
      }
    }
    meshDef.primitives = primitives;
    if (!json.meshes)
      json.meshes = [];
    this._invokeAll(function(ext) {
      ext.writeMesh && ext.writeMesh(mesh, meshDef);
    });
    const index = json.meshes.push(meshDef) - 1;
    cache.meshes.set(meshCacheKey, index);
    return index;
  }
  processCamera(camera) {
    const json = this.json;
    if (!json.cameras)
      json.cameras = [];
    const isOrtho = camera instanceof OrthographicCamera && camera.isOrthographicCamera;
    const cameraDef = {
      type: isOrtho ? "orthographic" : "perspective"
    };
    if (camera instanceof OrthographicCamera && isOrtho) {
      cameraDef.orthographic = {
        xmag: camera.right * 2,
        ymag: camera.top * 2,
        zfar: camera.far <= 0 ? 1e-3 : camera.far,
        znear: camera.near < 0 ? 0 : camera.near
      };
    } else if (camera instanceof PerspectiveCamera) {
      cameraDef.perspective = {
        aspectRatio: camera.aspect,
        yfov: MathUtils.degToRad(camera.fov),
        zfar: camera.far <= 0 ? 1e-3 : camera.far,
        znear: camera.near < 0 ? 0 : camera.near
      };
    }
    if (camera.name !== "")
      cameraDef.name = camera.type;
    return json.cameras.push(cameraDef) - 1;
  }
  processAnimation(clip, root) {
    const json = this.json;
    const nodeMap = this.nodeMap;
    if (!json.animations)
      json.animations = [];
    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);
    const tracks = clip.tracks;
    const channels = [];
    const samplers = [];
    for (let i2 = 0; i2 < tracks.length; ++i2) {
      const track = tracks[i2];
      const trackBinding = PropertyBinding.parseTrackName(track.name);
      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);
      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];
      if (trackBinding.objectName === "bones") {
        if (trackNode.isSkinnedMesh) {
          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);
        } else {
          trackNode = void 0;
        }
      }
      if (!trackNode || !trackProperty) {
        console.warn('THREE.GLTFExporter: Could not export animation track "%s".', track.name);
        return null;
      }
      const inputItemSize = 1;
      let outputItemSize = track.values.length / track.times.length;
      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {
        outputItemSize /= trackNode.morphTargetInfluences.length;
      }
      let interpolation;
      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        interpolation = "CUBICSPLINE";
        outputItemSize /= 3;
      } else if (track.getInterpolation() === InterpolateDiscrete) {
        interpolation = "STEP";
      } else {
        interpolation = "LINEAR";
      }
      samplers.push({
        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),
        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),
        interpolation
      });
      channels.push({
        sampler: samplers.length - 1,
        target: {
          node: nodeMap.get(trackNode),
          path: trackProperty
        }
      });
    }
    json.animations.push({
      name: clip.name || "clip_" + json.animations.length,
      samplers,
      channels
    });
    return json.animations.length - 1;
  }
  processSkin(object) {
    const json = this.json;
    const nodeMap = this.nodeMap;
    if (json.nodes !== void 0 && object instanceof SkinnedMesh) {
      const node = json.nodes[nodeMap.get(object)];
      const skeleton = object.skeleton;
      if (skeleton === void 0)
        return null;
      const rootJoint = object.skeleton.bones[0];
      if (rootJoint === void 0)
        return null;
      const joints = [];
      const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);
      const temporaryBoneInverse = new Matrix4();
      for (let i2 = 0; i2 < skeleton.bones.length; ++i2) {
        joints.push(nodeMap.get(skeleton.bones[i2]));
        temporaryBoneInverse.copy(skeleton.boneInverses[i2]);
        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i2 * 16);
      }
      if (json.skins === void 0)
        json.skins = [];
      json.skins.push({
        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),
        joints,
        skeleton: nodeMap.get(rootJoint)
      });
      const skinIndex = node.skin = json.skins.length - 1;
      return skinIndex;
    } else {
      return null;
    }
  }
  processNode(object) {
    const json = this.json;
    const options = this.options;
    const nodeMap = this.nodeMap;
    if (!json.nodes)
      json.nodes = [];
    const nodeDef = {};
    if (options.trs) {
      const rotation = object.quaternion.toArray();
      const position = object.position.toArray();
      const scale = object.scale.toArray();
      if (!this.equalArray(rotation, [0, 0, 0, 1])) {
        nodeDef.rotation = rotation;
      }
      if (!this.equalArray(position, [0, 0, 0])) {
        nodeDef.translation = position;
      }
      if (!this.equalArray(scale, [1, 1, 1])) {
        nodeDef.scale = scale;
      }
    } else {
      if (object.matrixAutoUpdate) {
        object.updateMatrix();
      }
      if (!this.isIdentityMatrix(object.matrix)) {
        nodeDef.matrix = object.matrix.elements;
      }
    }
    if (object.name !== "")
      nodeDef.name = String(object.name);
    this.serializeUserData(object, nodeDef);
    if ((object instanceof Mesh && object.isMesh || object instanceof Line && object.isLine || object instanceof Points && object.isPoints) && object instanceof Mesh) {
      const meshIndex = this.processMesh(object);
      if (meshIndex !== null)
        nodeDef.mesh = meshIndex;
    } else if (object instanceof Camera && object.isCamera) {
      nodeDef.camera = this.processCamera(object);
    }
    if (object instanceof SkinnedMesh && object.isSkinnedMesh)
      this.skins.push(object);
    if (object.children.length > 0) {
      const children = [];
      for (let i2 = 0, l = object.children.length; i2 < l; i2++) {
        const child = object.children[i2];
        if (child.visible || !options.onlyVisible) {
          const nodeIndex2 = this.processNode(child);
          if (nodeIndex2 !== null)
            children.push(nodeIndex2);
        }
      }
      if (children.length > 0)
        nodeDef.children = children;
    }
    this._invokeAll(function(ext) {
      ext.writeNode && ext.writeNode(object, nodeDef);
    });
    const nodeIndex = json.nodes.push(nodeDef) - 1;
    nodeMap.set(object, nodeIndex);
    return nodeIndex;
  }
  processScene(scene) {
    const json = this.json;
    const options = this.options;
    if (!json.scenes) {
      json.scenes = [];
      json.scene = 0;
    }
    const sceneDef = {};
    if (scene.name !== "")
      sceneDef.name = scene.name;
    json.scenes.push(sceneDef);
    const nodes = [];
    for (let i2 = 0, l = scene.children.length; i2 < l; i2++) {
      const child = scene.children[i2];
      if (child.visible || !options.onlyVisible) {
        const nodeIndex = this.processNode(child);
        if (nodeIndex !== null)
          nodes.push(nodeIndex);
      }
    }
    if (nodes.length > 0)
      sceneDef.nodes = nodes;
    this.serializeUserData(scene, sceneDef);
  }
  processObjects(objects) {
    const scene = new Scene();
    scene.name = "AuxScene";
    for (let i2 = 0; i2 < objects.length; i2++) {
      scene.children.push(objects[i2]);
    }
    this.processScene(scene);
  }
  processInput(input) {
    const options = this.options;
    input = input instanceof Array ? input : [input];
    this._invokeAll(function(ext) {
      ext.beforeParse && ext.beforeParse(input);
    });
    const objectsWithoutScene = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const inputScene = input[i2];
      if (inputScene instanceof Scene) {
        this.processScene(inputScene);
      } else {
        objectsWithoutScene.push(input[i2]);
      }
    }
    if (objectsWithoutScene.length > 0)
      this.processObjects(objectsWithoutScene);
    for (let i2 = 0; i2 < this.skins.length; ++i2) {
      this.processSkin(this.skins[i2]);
    }
    for (let i2 = 0; options.animations !== void 0 && i2 < options.animations.length; ++i2) {
      this.processAnimation(options.animations[i2], input[0]);
    }
    this._invokeAll(function(ext) {
      ext.afterParse && ext.afterParse(input);
    });
  }
  _invokeAll(func) {
    for (let i2 = 0, il = this.plugins.length; i2 < il; i2++) {
      func(this.plugins[i2]);
    }
  }
  equalArray(array1, array2) {
    return array1.length === array2.length && array1.every(function(element2, index) {
      return element2 === array2[index];
    });
  }
  stringToArrayBuffer(text) {
    if (window.TextEncoder !== void 0) {
      return new TextEncoder().encode(text).buffer;
    }
    const array = new Uint8Array(new ArrayBuffer(text.length));
    for (let i2 = 0, il = text.length; i2 < il; i2++) {
      const value = text.charCodeAt(i2);
      array[i2] = value > 255 ? 32 : value;
    }
    return array.buffer;
  }
  isIdentityMatrix(matrix3) {
    return this.equalArray(matrix3.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  getMinMax(attribute2, start, count) {
    const output = {
      min: new Array(attribute2.itemSize).fill(Number.POSITIVE_INFINITY),
      max: new Array(attribute2.itemSize).fill(Number.NEGATIVE_INFINITY)
    };
    for (let i2 = start; i2 < start + count; i2++) {
      for (let a2 = 0; a2 < attribute2.itemSize; a2++) {
        let value;
        if (attribute2.itemSize > 4) {
          value = attribute2.array[i2 * attribute2.itemSize + a2];
        } else {
          if (a2 === 0)
            value = attribute2.getX(i2);
          else if (a2 === 1)
            value = attribute2.getY(i2);
          else if (a2 === 2)
            value = attribute2.getZ(i2);
          else if (a2 === 3)
            value = attribute2.getW(i2);
        }
        if (value !== void 0) {
          output.min[a2] = Math.min(output.min[a2], value);
          output.max[a2] = Math.max(output.max[a2], value);
        }
      }
    }
    return output;
  }
  getPaddedBufferSize(bufferSize) {
    return Math.ceil(bufferSize / 4) * 4;
  }
  getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {
    const paddedLength = this.getPaddedBufferSize(arrayBuffer.byteLength);
    if (paddedLength !== arrayBuffer.byteLength) {
      const array = new Uint8Array(paddedLength);
      array.set(new Uint8Array(arrayBuffer));
      if (paddingByte !== 0) {
        for (let i2 = arrayBuffer.byteLength; i2 < paddedLength; i2++) {
          array[i2] = paddingByte;
        }
      }
      return array.buffer;
    }
    return arrayBuffer;
  }
};
var GLTFLightExtension = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_lights_punctual";
  }
  writeNode(light, nodeDef) {
    if (!light.isLight)
      return;
    if (!(light instanceof DirectionalLight && light.isDirectionalLight) && !(light instanceof PointLight && light.isPointLight) && !(light instanceof SpotLight && light.isSpotLight)) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", light);
      return;
    }
    const writer = this.writer;
    const json = writer.json;
    const extensionsUsed = writer.extensionsUsed;
    const lightDef = {};
    if (light.name)
      lightDef.name = light.name;
    lightDef.color = light.color.toArray();
    lightDef.intensity = light.intensity;
    if (light instanceof DirectionalLight && light.isDirectionalLight) {
      lightDef.type = "directional";
    } else if (light instanceof PointLight && light.isPointLight) {
      lightDef.type = "point";
      if (light.distance > 0)
        lightDef.range = light.distance;
    } else if (light instanceof SpotLight && light.isSpotLight) {
      lightDef.type = "spot";
      if (light.distance > 0)
        lightDef.range = light.distance;
      lightDef.spot = {};
      lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;
      lightDef.spot.outerConeAngle = light.angle;
    }
    if (!(light instanceof DirectionalLight) && light.decay !== void 0 && light.decay !== 2) {
      console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.");
    }
    if (!(light instanceof PointLight) && light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {
      console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.");
    }
    if (!extensionsUsed[this.name]) {
      json.extensions = json.extensions || {};
      json.extensions[this.name] = {
        lights: []
      };
      extensionsUsed[this.name] = true;
    }
    if (json.extensions !== void 0) {
      const lights = json.extensions[this.name].lights;
      lights.push(lightDef);
      nodeDef.extensions = nodeDef.extensions || {};
      nodeDef.extensions[this.name] = {
        light: lights.length - 1
      };
    }
  }
};
var GLTFMaterialsUnlitExtension = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_materials_unlit";
  }
  writeMaterial(material, materialDef) {
    if (!(material instanceof MeshBasicMaterial && material.isMeshBasicMaterial)) {
      return;
    }
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = {};
    extensionsUsed[this.name] = true;
    materialDef.pbrMetallicRoughness.metallicFactor = 0;
    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
};
var GLTFMaterialsPBRSpecularGlossiness = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_materials_pbrSpecularGlossiness";
  }
  writeMaterial(material, materialDef) {
    if (!material.isGLTFSpecularGlossinessMaterial)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (materialDef.pbrMetallicRoughness.baseColorFactor) {
      extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;
    }
    if (material instanceof MeshPhongMaterial) {
      const specularFactor = [1, 1, 1];
      material.specular.toArray(specularFactor, 0);
      extensionDef.specularFactor = specularFactor;
      extensionDef.glossinessFactor = material.glossiness;
    }
    if (materialDef.pbrMetallicRoughness.baseColorTexture) {
      extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;
    }
    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial) && material.specularMap) {
      const specularMapDef = {
        index: writer.processTexture(material.specularMap)
      };
      writer.applyTextureTransform(specularMapDef, material.specularMap);
      extensionDef.specularGlossinessTexture = specularMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsTransmissionExtension = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_materials_transmission";
  }
  writeMaterial(material, materialDef) {
    if (!(material instanceof MeshPhysicalMaterial && material.isMeshPhysicalMaterial) || material.transmission === 0) {
      return;
    }
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.transmissionFactor = material.transmission;
    if (material.transmissionMap) {
      const transmissionMapDef = {
        index: writer.processTexture(material.transmissionMap)
      };
      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);
      extensionDef.transmissionTexture = transmissionMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsVolumeExtension = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_materials_volume";
  }
  writeMaterial(material, materialDef) {
    if (!(material instanceof MeshPhysicalMaterial && material.isMeshPhysicalMaterial) || material.thickness === 0) {
      return;
    }
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.thickness = material.thickness;
    if (material.thicknessMap) {
      const thicknessMapDef = {
        index: writer.processTexture(material.thicknessMap)
      };
      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);
      extensionDef.thicknessTexture = thicknessMapDef;
    }
    extensionDef.attenuationDistance = material.attenuationDistance;
    extensionDef.attenuationColor = material.attenuationTint.toArray();
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};

// node_modules/fflate/esm/browser.js
var ch2 = {};
var wk = function(c, id, msg, transfer, cb2) {
  var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([c], { type: "text/javascript" }))));
  w.onerror = function(e) {
    return cb2(e.error, null);
  };
  w.onmessage = function(e) {
    return cb2(null, e.data);
  };
  w.postMessage(msg, transfer);
  return w;
};
var u8 = Uint8Array;
var u16 = Uint16Array;
var u32 = Uint32Array;
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b3 = new u16(31);
  for (var i2 = 0; i2 < 31; ++i2) {
    b3[i2] = start += 1 << eb[i2 - 1];
  }
  var r = new u32(b3[30]);
  for (var i2 = 1; i2 < 30; ++i2) {
    for (var j2 = b3[i2]; j2 < b3[i2 + 1]; ++j2) {
      r[j2] = j2 - b3[i2] << 5 | i2;
    }
  }
  return [b3, r];
};
var _a = freb(fleb, 2);
var fl = _a[0];
var revfl = _a[1];
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b[0];
var revfd = _b[1];
var rev = new u16(32768);
for (i2 = 0; i2 < 32768; ++i2) {
  x = (i2 & 43690) >>> 1 | (i2 & 21845) << 1;
  x = (x & 52428) >>> 2 | (x & 13107) << 2;
  x = (x & 61680) >>> 4 | (x & 3855) << 4;
  rev[i2] = ((x & 65280) >>> 8 | (x & 255) << 8) >>> 1;
}
var x;
var i2;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i2 = 0;
  var l = new u16(mb);
  for (; i2 < s; ++i2)
    ++l[cd[i2] - 1];
  var le = new u16(mb);
  for (i2 = 0; i2 < mb; ++i2) {
    le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0; i2 < s; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v = le[cd[i2] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i2 = 0; i2 < s; ++i2) {
      if (cd[i2]) {
        co[i2] = rev[le[cd[i2] - 1]++] >>> 15 - cd[i2];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i2 = 0; i2 < 144; ++i2)
  flt[i2] = 8;
var i2;
for (i2 = 144; i2 < 256; ++i2)
  flt[i2] = 9;
var i2;
for (i2 = 256; i2 < 280; ++i2)
  flt[i2] = 7;
var i2;
for (i2 = 280; i2 < 288; ++i2)
  flt[i2] = 8;
var i2;
var fdt = new u8(32);
for (i2 = 0; i2 < 32; ++i2)
  fdt[i2] = 5;
var i2;
var flm = hMap(flt, 9, 0);
var flrm = hMap(flt, 9, 1);
var fdm = hMap(fdt, 5, 0);
var fdrm = hMap(fdt, 5, 1);
var max2 = function(a2) {
  var m = a2[0];
  for (var i2 = 1; i2 < a2.length; ++i2) {
    if (a2[i2] > m)
      m = a2[i2];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p / 8 | 0) + (p & 7 && 1);
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
  n.set(v.subarray(s, e));
  return n;
};
var inflt = function(dat, buf, st) {
  var sl = dat.length;
  if (!sl || st && !st.l && sl < 5)
    return buf || new u8(0);
  var noBuf = !buf || st;
  var noSt = !st || st.i;
  if (!st)
    st = {};
  if (!buf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      st.f = final = bits(dat, pos, 1);
      var type2 = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type2) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t2 = s + l;
        if (t2 > sl) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t2), bt);
        st.b = bt += l, st.p = pos = t2 * 8;
        continue;
      } else if (type2 == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type2 == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0; i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max2(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0; i2 < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >>> 4;
          if (s < 16) {
            ldt[i2++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i2++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max2(lt);
        dbt = max2(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        throw "invalid block type";
      if (pos > tbts) {
        if (noSt)
          throw "unexpected EOF";
        break;
      }
    }
    if (noBuf)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          throw "unexpected EOF";
        break;
      }
      if (!c)
        throw "invalid length/literal";
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add2 = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b3 = fleb[i2];
          add2 = bits(dat, pos, (1 << b3) - 1) + fl[i2];
          pos += b3;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
        if (!d)
          throw "invalid distance";
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b3 = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b3) - 1, pos += b3;
        }
        if (pos > tbts) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt + 131072);
        var end = bt + add2;
        for (; bt < end; bt += 4) {
          buf[bt] = buf[bt - dt];
          buf[bt + 1] = buf[bt + 1 - dt];
          buf[bt + 2] = buf[bt + 2 - dt];
          buf[bt + 3] = buf[bt + 3 - dt];
        }
        bt = end;
      }
    }
    st.l = lm, st.p = lpos, st.b = bt;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt == buf.length ? buf : slc(buf, 0, bt);
};
var wbits = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >>> 8;
};
var wbits16 = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >>> 8;
  d[o + 2] |= v >>> 16;
};
var hTree = function(d, mb) {
  var t2 = [];
  for (var i2 = 0; i2 < d.length; ++i2) {
    if (d[i2])
      t2.push({ s: i2, f: d[i2] });
  }
  var s = t2.length;
  var t22 = t2.slice();
  if (!s)
    return [et, 0];
  if (s == 1) {
    var v = new u8(t2[0].s + 1);
    v[t2[0].s] = 1;
    return [v, 1];
  }
  t2.sort(function(a2, b3) {
    return a2.f - b3.f;
  });
  t2.push({ s: -1, f: 25001 });
  var l = t2[0], r = t2[1], i0 = 0, i1 = 1, i22 = 2;
  t2[0] = { s: -1, f: l.f + r.f, l, r };
  while (i1 != s - 1) {
    l = t2[t2[i0].f < t2[i22].f ? i0++ : i22++];
    r = t2[i0 != i1 && t2[i0].f < t2[i22].f ? i0++ : i22++];
    t2[i1++] = { s: -1, f: l.f + r.f, l, r };
  }
  var maxSym = t22[0].s;
  for (var i2 = 1; i2 < s; ++i2) {
    if (t22[i2].s > maxSym)
      maxSym = t22[i2].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t2[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i2 = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a2, b3) {
      return tr[b3.s] - tr[a2.s] || a2.f - b3.f;
    });
    for (; i2 < s; ++i2) {
      var i2_1 = t22[i2].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>>= lft;
    while (dt > 0) {
      var i2_2 = t22[i2].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i2;
    }
    for (; i2 >= 0 && dt; --i2) {
      var i2_3 = t22[i2].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return [new u8(tr), mbt];
};
var ln = function(n, l, d) {
  return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
};
var lc = function(c) {
  var s = c.length;
  while (s && !c[--s])
    ;
  var cl = new u16(++s);
  var cli = 0, cln = c[0], cls = 1;
  var w = function(v) {
    cl[cli++] = v;
  };
  for (var i2 = 1; i2 <= s; ++i2) {
    if (c[i2] == cln && i2 != s)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w(32754);
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (; cls > 6; cls -= 6)
          w(8304);
        if (cls > 2)
          w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w(cln);
      cls = 1;
      cln = c[i2];
    }
  }
  return [cl.subarray(0, cli), s];
};
var clen = function(cf, cl) {
  var l = 0;
  for (var i2 = 0; i2 < cl.length; ++i2)
    l += cf[i2] * cl[i2];
  return l;
};
var wfblk = function(out, pos, dat) {
  var s = dat.length;
  var o = shft(pos + 2);
  out[o] = s & 255;
  out[o + 1] = s >>> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;
  for (var i2 = 0; i2 < s; ++i2)
    out[o + i2 + 4] = dat[i2];
  return (o + 4 + s) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2[0], mlb = _a2[1];
  var _b2 = hTree(df, 15), ddt = _b2[0], mdb = _b2[1];
  var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
  var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
  var lcfreq = new u16(19);
  for (var i2 = 0; i2 < lclt.length; ++i2)
    lcfreq[lclt[i2] & 31]++;
  for (var i2 = 0; i2 < lcdt.length; ++i2)
    lcfreq[lcdt[i2] & 31]++;
  var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
  if (flen <= ftlen && flen <= dtlen)
    return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;
    for (var i2 = 0; i2 < nlcc; ++i2)
      wbits(out, p + 3 * i2, lct[clim[i2]]);
    p += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];
      for (var i2 = 0; i2 < clct.length; ++i2) {
        var len = clct[i2] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15)
          wbits(out, p, clct[i2] >>> 5 & 127), p += clct[i2] >>> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i2 = 0; i2 < li; ++i2) {
    if (syms[i2] > 255) {
      var len = syms[i2] >>> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7)
        wbits(out, p, syms[i2] >>> 23 & 31), p += fleb[len];
      var dst = syms[i2] & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3)
        wbits16(out, p, syms[i2] >>> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[syms[i2]]), p += ll[syms[i2]];
    }
  }
  wbits16(out, p, lm[256]);
  return p + ll[256];
};
var deo = new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = new u8(0);
var dflt = function(dat, lvl, plvl, pre, post2, lst) {
  var s = dat.length;
  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post2);
  var w = o.subarray(pre, o.length - post2);
  var pos = 0;
  if (!lvl || s < 8) {
    for (var i2 = 0; i2 <= s; i2 += 65535) {
      var e = i2 + 65535;
      if (e < s) {
        pos = wfblk(w, pos, dat.subarray(i2, e));
      } else {
        w[i2] = lst;
        pos = wfblk(w, pos, dat.subarray(i2, s));
      }
    }
  } else {
    var opt = deo[lvl - 1];
    var n = opt >>> 13, c = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = new u16(32768), head2 = new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i3) {
      return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
    };
    var syms = new u32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i2 = 0, li = 0, wi = 0, bs = 0;
    for (; i2 < s; ++i2) {
      var hv = hsh(i2);
      var imod = i2 & 32767, pimod = head2[hv];
      prev[imod] = pimod;
      head2[hv] = imod;
      if (wi <= i2) {
        var rem = s - i2;
        if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
          li = lc_1 = eb = 0, bs = i2;
          for (var j2 = 0; j2 < 286; ++j2)
            lf[j2] = 0;
          for (var j2 = 0; j2 < 30; ++j2)
            df[j2] = 0;
        }
        var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i2 - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i2);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i2 + l] == dat[i2 + l - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                ;
              if (nl > l) {
                l = nl, d = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j2 = 0; j2 < mmd; ++j2) {
                  var ti = i2 - dif + j2 + 32768 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti + 32768 & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod + 32768 & 32767;
          }
        }
        if (d) {
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
          var lin = revfl[l] & 31, din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i2 + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i2];
          ++lf[dat[i2]];
        }
      }
    }
    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
    if (!lst && pos & 7)
      pos = wfblk(w, pos + 1, et);
  }
  return slc(o, 0, pre + shft(pos) + post2);
};
var crct = function() {
  var t2 = new Int32Array(256);
  for (var i2 = 0; i2 < 256; ++i2) {
    var c = i2, k = 9;
    while (--k)
      c = (c & 1 && -306674912) ^ c >>> 1;
    t2[i2] = c;
  }
  return t2;
}();
var crc = function() {
  var c = -1;
  return {
    p: function(d) {
      var cr = c;
      for (var i2 = 0; i2 < d.length; ++i2)
        cr = crct[cr & 255 ^ d[i2]] ^ cr >>> 8;
      c = cr;
    },
    d: function() {
      return ~c;
    }
  };
};
var adler = function() {
  var a2 = 1, b3 = 0;
  return {
    p: function(d) {
      var n = a2, m = b3;
      var l = d.length;
      for (var i2 = 0; i2 != l; ) {
        var e = Math.min(i2 + 2655, l);
        for (; i2 < e; ++i2)
          m += n += d[i2];
        n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
      }
      a2 = n, b3 = m;
    },
    d: function() {
      a2 %= 65521, b3 %= 65521;
      return (a2 & 255) << 24 | a2 >>> 8 << 16 | (b3 & 255) << 8 | b3 >>> 8;
    }
  };
};
var dopt = function(dat, opt, pre, post2, st) {
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post2, !st);
};
var mrg = function(a2, b3) {
  var o = {};
  for (var k in a2)
    o[k] = a2[k];
  for (var k in b3)
    o[k] = b3[k];
  return o;
};
var wcln = function(fn, fnStr, td2) {
  var dt = fn();
  var st = fn.toString();
  var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/ /g, "").split(",");
  for (var i2 = 0; i2 < dt.length; ++i2) {
    var v = dt[i2], k = ks[i2];
    if (typeof v == "function") {
      fnStr += ";" + k + "=";
      var st_1 = v.toString();
      if (v.prototype) {
        if (st_1.indexOf("[native code]") != -1) {
          var spInd = st_1.indexOf(" ", 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
        } else {
          fnStr += st_1;
          for (var t2 in v.prototype)
            fnStr += ";" + k + ".prototype." + t2 + "=" + v.prototype[t2].toString();
        }
      } else
        fnStr += st_1;
    } else
      td2[k] = v;
  }
  return [fnStr, td2];
};
var ch = [];
var cbfs = function(v) {
  var tl = [];
  for (var k in v) {
    if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)
      tl.push((v[k] = new v[k].constructor(v[k])).buffer);
  }
  return tl;
};
var wrkr = function(fns, init, id, cb2) {
  var _a2;
  if (!ch[id]) {
    var fnStr = "", td_1 = {}, m = fns.length - 1;
    for (var i2 = 0; i2 < m; ++i2)
      _a2 = wcln(fns[i2], fnStr, td_1), fnStr = _a2[0], td_1 = _a2[1];
    ch[id] = wcln(fns[m], fnStr, td_1);
  }
  var td2 = mrg({}, ch[id][1]);
  return wk(ch[id][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb2);
};
var bInflt = function() {
  return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max2, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8];
};
var bDflt = function() {
  return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
};
var gze = function() {
  return [gzh, gzhl, wbytes, crc, crct];
};
var guze = function() {
  return [gzs, gzl];
};
var zle = function() {
  return [zlh, wbytes, adler];
};
var zule = function() {
  return [zlv];
};
var pbf = function(msg) {
  return postMessage(msg, [msg.buffer]);
};
var gu8 = function(o) {
  return o && o.size && new u8(o.size);
};
var astrm = function(strm) {
  strm.ondata = function(dat, final) {
    return postMessage([dat, final], [dat.buffer]);
  };
  return function(ev) {
    return strm.push(ev.data[0], ev.data[1]);
  };
};
var astrmify = function(fns, strm, opts, init, id) {
  var t2;
  var w = wrkr(fns, init, id, function(err, dat) {
    if (err)
      w.terminate(), strm.ondata.call(strm, err);
    else {
      if (dat[1])
        w.terminate();
      strm.ondata.call(strm, err, dat[0], dat[1]);
    }
  });
  w.postMessage(opts);
  strm.push = function(d, f) {
    if (t2)
      throw "stream finished";
    if (!strm.ondata)
      throw "no stream handler";
    w.postMessage([d, t2 = f], [d.buffer]);
  };
  strm.terminate = function() {
    w.terminate();
  };
};
var b2 = function(d, b3) {
  return d[b3] | d[b3 + 1] << 8;
};
var b4 = function(d, b3) {
  return (d[b3] | d[b3 + 1] << 8 | d[b3 + 2] << 16 | d[b3 + 3] << 24) >>> 0;
};
var b8 = function(d, b3) {
  return b4(d, b3) + b4(d, b3 + 4) * 4294967296;
};
var wbytes = function(d, b3, v) {
  for (; v; ++b3)
    d[b3] = v, v >>>= 8;
};
var gzh = function(c, o) {
  var fn = o.filename;
  c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
  if (o.mtime != 0)
    wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
  if (fn) {
    c[3] = 8;
    for (var i2 = 0; i2 <= fn.length; ++i2)
      c[i2 + 10] = fn.charCodeAt(i2);
  }
};
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    throw "invalid gzip data";
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += d[10] | (d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
var gzhl = function(o) {
  return 10 + (o.filename && o.filename.length + 1 || 0);
};
var zlh = function(c, o) {
  var lv = o.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c[0] = 120, c[1] = fl2 << 6 | (fl2 ? 32 - 2 * fl2 : 1);
};
var zlv = function(d) {
  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    throw "invalid zlib data";
  if (d[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function AsyncCmpStrm(opts, cb2) {
  if (!cb2 && typeof opts == "function")
    cb2 = opts, opts = {};
  this.ondata = cb2;
  return opts;
}
var Deflate = function() {
  function Deflate2(opts, cb2) {
    if (!cb2 && typeof opts == "function")
      cb2 = opts, opts = {};
    this.ondata = cb2;
    this.o = opts || {};
  }
  Deflate2.prototype.p = function(c, f) {
    this.ondata(dopt(c, this.o, 0, 0, !f), f);
  };
  Deflate2.prototype.push = function(chunk, final) {
    if (this.d)
      throw "stream finished";
    if (!this.ondata)
      throw "no stream handler";
    this.d = final;
    this.p(chunk, final || false);
  };
  return Deflate2;
}();
var AsyncDeflate = function() {
  function AsyncDeflate2(opts, cb2) {
    astrmify([
      bDflt,
      function() {
        return [astrm, Deflate];
      }
    ], this, AsyncCmpStrm.call(this, opts, cb2), function(ev) {
      var strm = new Deflate(ev.data);
      onmessage = astrm(strm);
    }, 6);
  }
  return AsyncDeflate2;
}();
function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
var Inflate = function() {
  function Inflate2(cb2) {
    this.s = {};
    this.p = new u8(0);
    this.ondata = cb2;
  }
  Inflate2.prototype.e = function(c) {
    if (this.d)
      throw "stream finished";
    if (!this.ondata)
      throw "no stream handler";
    var l = this.p.length;
    var n = new u8(l + c.length);
    n.set(this.p), n.set(c, l), this.p = n;
  };
  Inflate2.prototype.c = function(final) {
    this.d = this.s.i = final || false;
    var bts = this.s.b;
    var dt = inflt(this.p, this.o, this.s);
    this.ondata(slc(dt, bts, this.s.b), this.d);
    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  Inflate2.prototype.push = function(chunk, final) {
    this.e(chunk), this.c(final);
  };
  return Inflate2;
}();
var AsyncInflate = function() {
  function AsyncInflate2(cb2) {
    this.ondata = cb2;
    astrmify([
      bInflt,
      function() {
        return [astrm, Inflate];
      }
    ], this, 0, function() {
      var strm = new Inflate();
      onmessage = astrm(strm);
    }, 7);
  }
  return AsyncInflate2;
}();
function inflateSync(data, out) {
  return inflt(data, out);
}
var Gzip = function() {
  function Gzip2(opts, cb2) {
    this.c = crc();
    this.l = 0;
    this.v = 1;
    Deflate.call(this, opts, cb2);
  }
  Gzip2.prototype.push = function(chunk, final) {
    Deflate.prototype.push.call(this, chunk, final);
  };
  Gzip2.prototype.p = function(c, f) {
    this.c.p(c);
    this.l += c.length;
    var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);
    if (this.v)
      gzh(raw, this.o), this.v = 0;
    if (f)
      wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
    this.ondata(raw, f);
  };
  return Gzip2;
}();
var AsyncGzip = function() {
  function AsyncGzip2(opts, cb2) {
    astrmify([
      bDflt,
      gze,
      function() {
        return [astrm, Deflate, Gzip];
      }
    ], this, AsyncCmpStrm.call(this, opts, cb2), function(ev) {
      var strm = new Gzip(ev.data);
      onmessage = astrm(strm);
    }, 8);
  }
  return AsyncGzip2;
}();
var Gunzip = function() {
  function Gunzip2(cb2) {
    this.v = 1;
    Inflate.call(this, cb2);
  }
  Gunzip2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    if (this.v) {
      var s = this.p.length > 3 ? gzs(this.p) : 4;
      if (s >= this.p.length && !final)
        return;
      this.p = this.p.subarray(s), this.v = 0;
    }
    if (final) {
      if (this.p.length < 8)
        throw "invalid gzip stream";
      this.p = this.p.subarray(0, -8);
    }
    Inflate.prototype.c.call(this, final);
  };
  return Gunzip2;
}();
var AsyncGunzip = function() {
  function AsyncGunzip2(cb2) {
    this.ondata = cb2;
    astrmify([
      bInflt,
      guze,
      function() {
        return [astrm, Inflate, Gunzip];
      }
    ], this, 0, function() {
      var strm = new Gunzip();
      onmessage = astrm(strm);
    }, 9);
  }
  return AsyncGunzip2;
}();
function gunzipSync(data, out) {
  return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));
}
var Zlib = function() {
  function Zlib2(opts, cb2) {
    this.c = adler();
    this.v = 1;
    Deflate.call(this, opts, cb2);
  }
  Zlib2.prototype.push = function(chunk, final) {
    Deflate.prototype.push.call(this, chunk, final);
  };
  Zlib2.prototype.p = function(c, f) {
    this.c.p(c);
    var raw = dopt(c, this.o, this.v && 2, f && 4, !f);
    if (this.v)
      zlh(raw, this.o), this.v = 0;
    if (f)
      wbytes(raw, raw.length - 4, this.c.d());
    this.ondata(raw, f);
  };
  return Zlib2;
}();
var AsyncZlib = function() {
  function AsyncZlib2(opts, cb2) {
    astrmify([
      bDflt,
      zle,
      function() {
        return [astrm, Deflate, Zlib];
      }
    ], this, AsyncCmpStrm.call(this, opts, cb2), function(ev) {
      var strm = new Zlib(ev.data);
      onmessage = astrm(strm);
    }, 10);
  }
  return AsyncZlib2;
}();
var Unzlib = function() {
  function Unzlib2(cb2) {
    this.v = 1;
    Inflate.call(this, cb2);
  }
  Unzlib2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    if (this.v) {
      if (this.p.length < 2 && !final)
        return;
      this.p = this.p.subarray(2), this.v = 0;
    }
    if (final) {
      if (this.p.length < 4)
        throw "invalid zlib stream";
      this.p = this.p.subarray(0, -4);
    }
    Inflate.prototype.c.call(this, final);
  };
  return Unzlib2;
}();
var AsyncUnzlib = function() {
  function AsyncUnzlib2(cb2) {
    this.ondata = cb2;
    astrmify([
      bInflt,
      zule,
      function() {
        return [astrm, Inflate, Unzlib];
      }
    ], this, 0, function() {
      var strm = new Unzlib();
      onmessage = astrm(strm);
    }, 11);
  }
  return AsyncUnzlib2;
}();
function unzlibSync(data, out) {
  return inflt((zlv(data), data.subarray(2, -4)), out);
}
var Decompress = function() {
  function Decompress2(cb2) {
    this.G = Gunzip;
    this.I = Inflate;
    this.Z = Unzlib;
    this.ondata = cb2;
  }
  Decompress2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      throw "no stream handler";
    if (!this.s) {
      if (this.p && this.p.length) {
        var n = new u8(this.p.length + chunk.length);
        n.set(this.p), n.set(chunk, this.p.length);
      } else
        this.p = chunk;
      if (this.p.length > 2) {
        var _this_1 = this;
        var cb2 = function() {
          _this_1.ondata.apply(_this_1, arguments);
        };
        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb2) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb2) : new this.Z(cb2);
        this.s.push(this.p, final);
        this.p = null;
      }
    } else
      this.s.push(chunk, final);
  };
  return Decompress2;
}();
var AsyncDecompress = function() {
  function AsyncDecompress2(cb2) {
    this.G = AsyncGunzip;
    this.I = AsyncInflate;
    this.Z = AsyncUnzlib;
    this.ondata = cb2;
  }
  AsyncDecompress2.prototype.push = function(chunk, final) {
    Decompress.prototype.push.call(this, chunk, final);
  };
  return AsyncDecompress2;
}();
var fltn = function(d, p, t2, o) {
  for (var k in d) {
    var val = d[k], n = p + k;
    if (val instanceof u8)
      t2[n] = [val, o];
    else if (Array.isArray(val))
      t2[n] = [val[0], mrg(o, val[1])];
    else
      fltn(val, n + "/", t2, o);
  }
};
var te = typeof TextEncoder != "undefined" && new TextEncoder();
var td = typeof TextDecoder != "undefined" && new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}
var dutf8 = function(d) {
  for (var r = "", i2 = 0; ; ) {
    var c = d[i2++];
    var eb = (c > 127) + (c > 223) + (c > 239);
    if (i2 + eb > d.length)
      return [r, slc(d, i2 - 1)];
    if (!eb)
      r += String.fromCharCode(c);
    else if (eb == 3) {
      c = ((c & 15) << 18 | (d[i2++] & 63) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
    } else if (eb & 1)
      r += String.fromCharCode((c & 31) << 6 | d[i2++] & 63);
    else
      r += String.fromCharCode((c & 15) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63);
  }
};
var DecodeUTF8 = function() {
  function DecodeUTF82(cb2) {
    this.ondata = cb2;
    if (tds)
      this.t = new TextDecoder();
    else
      this.p = et;
  }
  DecodeUTF82.prototype.push = function(chunk, final) {
    if (!this.ondata)
      throw "no callback";
    final = !!final;
    if (this.t) {
      this.ondata(this.t.decode(chunk, { stream: true }), final);
      if (final) {
        if (this.t.decode().length)
          throw "invalid utf-8 data";
        this.t = null;
      }
      return;
    }
    if (!this.p)
      throw "stream finished";
    var dat = new u8(this.p.length + chunk.length);
    dat.set(this.p);
    dat.set(chunk, this.p.length);
    var _a2 = dutf8(dat), ch3 = _a2[0], np = _a2[1];
    if (final) {
      if (np.length)
        throw "invalid utf-8 data";
      this.p = null;
    } else
      this.p = np;
    this.ondata(ch3, final);
  };
  return DecodeUTF82;
}();
var EncodeUTF8 = function() {
  function EncodeUTF82(cb2) {
    this.ondata = cb2;
  }
  EncodeUTF82.prototype.push = function(chunk, final) {
    if (!this.ondata)
      throw "no callback";
    if (this.d)
      throw "stream finished";
    this.ondata(strToU8(chunk), this.d = final || false);
  };
  return EncodeUTF82;
}();
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i2 = 0; i2 < str.length; ++i2)
      ar_1[i2] = str.charCodeAt(i2);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;
  var w = function(v) {
    ar[ai++] = v;
  };
  for (var i2 = 0; i2 < l; ++i2) {
    if (ai + 5 > ar.length) {
      var n = new u8(ai + 8 + (l - i2 << 1));
      n.set(ar);
      ar = n;
    }
    var c = str.charCodeAt(i2);
    if (c < 128 || latin1)
      w(c);
    else if (c < 2048)
      w(192 | c >> 6), w(128 | c & 63);
    else if (c > 55295 && c < 57344)
      c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i2) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
    else
      w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
  }
  return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r = "";
    for (var i2 = 0; i2 < dat.length; i2 += 16384)
      r += String.fromCharCode.apply(null, dat.subarray(i2, i2 + 16384));
    return r;
  } else if (td)
    return td.decode(dat);
  else {
    var _a2 = dutf8(dat), out = _a2[0], ext = _a2[1];
    if (ext.length)
      throw "invalid utf-8 data";
    return out;
  }
}
var dbf = function(l) {
  return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
};
var slzh = function(d, b3) {
  return b3 + 30 + b2(d, b3 + 26) + b2(d, b3 + 28);
};
var zh = function(d, b3, z) {
  var fnl = b2(d, b3 + 28), fn = strFromU8(d.subarray(b3 + 46, b3 + 46 + fnl), !(b2(d, b3 + 8) & 2048)), es = b3 + 46 + fnl, bs = b4(d, b3 + 20);
  var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b3 + 24), b4(d, b3 + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];
  return [b2(d, b3 + 10), sc, su, fn, es + b2(d, b3 + 30) + b2(d, b3 + 32), off];
};
var z64e = function(d, b3) {
  for (; b2(d, b3) != 1; b3 += 4 + b2(d, b3 + 2))
    ;
  return [b8(d, b3 + 12), b8(d, b3 + 4), b8(d, b3 + 20)];
};
var exfl = function(ex) {
  var le = 0;
  if (ex) {
    for (var k in ex) {
      var l = ex[k].length;
      if (l > 65535)
        throw "extra field too long";
      le += l + 4;
    }
  }
  return le;
};
var wzh = function(d, b3, f, fn, u, c, ce, co) {
  var fl2 = fn.length, ex = f.extra, col = co && co.length;
  var exl = exfl(ex);
  wbytes(d, b3, ce != null ? 33639248 : 67324752), b3 += 4;
  if (ce != null)
    d[b3++] = 20, d[b3++] = f.os;
  d[b3] = 20, b3 += 2;
  d[b3++] = f.flag << 1 | (c == null && 8), d[b3++] = u && 8;
  d[b3++] = f.compression & 255, d[b3++] = f.compression >> 8;
  var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
  if (y < 0 || y > 119)
    throw "date not in range 1980-2099";
  wbytes(d, b3, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b3 += 4;
  if (c != null) {
    wbytes(d, b3, f.crc);
    wbytes(d, b3 + 4, c);
    wbytes(d, b3 + 8, f.size);
  }
  wbytes(d, b3 + 12, fl2);
  wbytes(d, b3 + 14, exl), b3 += 16;
  if (ce != null) {
    wbytes(d, b3, col);
    wbytes(d, b3 + 6, f.attrs);
    wbytes(d, b3 + 10, ce), b3 += 14;
  }
  d.set(fn, b3);
  b3 += fl2;
  if (exl) {
    for (var k in ex) {
      var exf = ex[k], l = exf.length;
      wbytes(d, b3, +k);
      wbytes(d, b3 + 2, l);
      d.set(exf, b3 + 4), b3 += 4 + l;
    }
  }
  if (col)
    d.set(co, b3), b3 += col;
  return b3;
};
var wzf = function(o, b3, c, d, e) {
  wbytes(o, b3, 101010256);
  wbytes(o, b3 + 8, c);
  wbytes(o, b3 + 10, c);
  wbytes(o, b3 + 12, d);
  wbytes(o, b3 + 16, e);
};
var ZipPassThrough = function() {
  function ZipPassThrough2(filename) {
    this.filename = filename;
    this.c = crc();
    this.size = 0;
    this.compression = 0;
  }
  ZipPassThrough2.prototype.process = function(chunk, final) {
    this.ondata(null, chunk, final);
  };
  ZipPassThrough2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      throw "no callback - add to ZIP archive before pushing";
    this.c.p(chunk);
    this.size += chunk.length;
    if (final)
      this.crc = this.c.d();
    this.process(chunk, final || false);
  };
  return ZipPassThrough2;
}();
var ZipDeflate = function() {
  function ZipDeflate2(filename, opts) {
    var _this_1 = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new Deflate(opts, function(dat, final) {
      _this_1.ondata(null, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
  }
  ZipDeflate2.prototype.process = function(chunk, final) {
    try {
      this.d.push(chunk, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  ZipDeflate2.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return ZipDeflate2;
}();
var AsyncZipDeflate = function() {
  function AsyncZipDeflate2(filename, opts) {
    var _this_1 = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new AsyncDeflate(opts, function(err, dat, final) {
      _this_1.ondata(err, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
    this.terminate = this.d.terminate;
  }
  AsyncZipDeflate2.prototype.process = function(chunk, final) {
    this.d.push(chunk, final);
  };
  AsyncZipDeflate2.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return AsyncZipDeflate2;
}();
var Zip = function() {
  function Zip2(cb2) {
    this.ondata = cb2;
    this.u = [];
    this.d = 1;
  }
  Zip2.prototype.add = function(file) {
    var _this_1 = this;
    if (this.d & 2)
      throw "stream finished";
    var f = strToU8(file.filename), fl2 = f.length;
    var com = file.comment, o = com && strToU8(com);
    var u = fl2 != file.filename.length || o && com.length != o.length;
    var hl = fl2 + exfl(file.extra) + 30;
    if (fl2 > 65535)
      throw "filename too long";
    var header = new u8(hl);
    wzh(header, 0, file, f, u);
    var chks = [header];
    var pAll = function() {
      for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {
        var chk = chks_1[_i];
        _this_1.ondata(null, chk, false);
      }
      chks = [];
    };
    var tr = this.d;
    this.d = 0;
    var ind = this.u.length;
    var uf = mrg(file, {
      f,
      u,
      o,
      t: function() {
        if (file.terminate)
          file.terminate();
      },
      r: function() {
        pAll();
        if (tr) {
          var nxt = _this_1.u[ind + 1];
          if (nxt)
            nxt.r();
          else
            _this_1.d = 1;
        }
        tr = 1;
      }
    });
    var cl = 0;
    file.ondata = function(err, dat, final) {
      if (err) {
        _this_1.ondata(err, dat, final);
        _this_1.terminate();
      } else {
        cl += dat.length;
        chks.push(dat);
        if (final) {
          var dd = new u8(16);
          wbytes(dd, 0, 134695760);
          wbytes(dd, 4, file.crc);
          wbytes(dd, 8, cl);
          wbytes(dd, 12, file.size);
          chks.push(dd);
          uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;
          if (tr)
            uf.r();
          tr = 1;
        } else if (tr)
          pAll();
      }
    };
    this.u.push(uf);
  };
  Zip2.prototype.end = function() {
    var _this_1 = this;
    if (this.d & 2) {
      if (this.d & 1)
        throw "stream finishing";
      throw "stream finished";
    }
    if (this.d)
      this.e();
    else
      this.u.push({
        r: function() {
          if (!(_this_1.d & 1))
            return;
          _this_1.u.splice(-1, 1);
          _this_1.e();
        },
        t: function() {
        }
      });
    this.d = 3;
  };
  Zip2.prototype.e = function() {
    var bt = 0, l = 0, tl = 0;
    for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
      var f = _a2[_i];
      tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
    }
    var out = new u8(tl + 22);
    for (var _b2 = 0, _c = this.u; _b2 < _c.length; _b2++) {
      var f = _c[_b2];
      wzh(out, bt, f, f.f, f.u, f.c, l, f.o);
      bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
    }
    wzf(out, bt, this.u.length, tl, l);
    this.ondata(null, out, true);
    this.d = 2;
  };
  Zip2.prototype.terminate = function() {
    for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
      var f = _a2[_i];
      f.t();
    }
    this.d = 2;
  };
  return Zip2;
}();
function zipSync(data, opts) {
  if (!opts)
    opts = {};
  var r = {};
  var files = [];
  fltn(data, "", r, opts);
  var o = 0;
  var tot = 0;
  for (var fn in r) {
    var _a2 = r[fn], file = _a2[0], p = _a2[1];
    var compression = p.level == 0 ? 0 : 8;
    var f = strToU8(fn), s = f.length;
    var com = p.comment, m = com && strToU8(com), ms = m && m.length;
    var exl = exfl(p.extra);
    if (s > 65535)
      throw "filename too long";
    var d = compression ? deflateSync(file, p) : file, l = d.length;
    var c = crc();
    c.p(file);
    files.push(mrg(p, {
      size: file.length,
      crc: c.d(),
      c: d,
      f,
      m,
      u: s != fn.length || m && com.length != ms,
      o,
      compression
    }));
    o += 30 + s + exl + l;
    tot += 76 + 2 * (s + exl) + (ms || 0) + l;
  }
  var out = new u8(tot + 22), oe = o, cdl = tot - o;
  for (var i2 = 0; i2 < files.length; ++i2) {
    var f = files[i2];
    wzh(out, f.o, f, f.f, f.u, f.c.length);
    var badd = 30 + f.f.length + exfl(f.extra);
    out.set(f.c, f.o + badd);
    wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
  }
  wzf(out, o, files.length, cdl, oe);
  return out;
}
var UnzipPassThrough = function() {
  function UnzipPassThrough2() {
  }
  UnzipPassThrough2.prototype.push = function(data, final) {
    this.ondata(null, data, final);
  };
  UnzipPassThrough2.compression = 0;
  return UnzipPassThrough2;
}();
var UnzipInflate = function() {
  function UnzipInflate2() {
    var _this_1 = this;
    this.i = new Inflate(function(dat, final) {
      _this_1.ondata(null, dat, final);
    });
  }
  UnzipInflate2.prototype.push = function(data, final) {
    try {
      this.i.push(data, final);
    } catch (e) {
      this.ondata(e, data, final);
    }
  };
  UnzipInflate2.compression = 8;
  return UnzipInflate2;
}();
var AsyncUnzipInflate = function() {
  function AsyncUnzipInflate2(_, sz) {
    var _this_1 = this;
    if (sz < 32e4) {
      this.i = new Inflate(function(dat, final) {
        _this_1.ondata(null, dat, final);
      });
    } else {
      this.i = new AsyncInflate(function(err, dat, final) {
        _this_1.ondata(err, dat, final);
      });
      this.terminate = this.i.terminate;
    }
  }
  AsyncUnzipInflate2.prototype.push = function(data, final) {
    if (this.i.terminate)
      data = slc(data, 0);
    this.i.push(data, final);
  };
  AsyncUnzipInflate2.compression = 8;
  return AsyncUnzipInflate2;
}();
var Unzip = function() {
  function Unzip2(cb2) {
    this.onfile = cb2;
    this.k = [];
    this.o = {
      0: UnzipPassThrough
    };
    this.p = et;
  }
  Unzip2.prototype.push = function(chunk, final) {
    var _this_1 = this;
    if (!this.onfile)
      throw "no callback";
    if (!this.p)
      throw "stream finished";
    if (this.c > 0) {
      var len = Math.min(this.c, chunk.length);
      var toAdd = chunk.subarray(0, len);
      this.c -= len;
      if (this.d)
        this.d.push(toAdd, !this.c);
      else
        this.k[0].push(toAdd);
      chunk = chunk.subarray(len);
      if (chunk.length)
        return this.push(chunk, final);
    } else {
      var f = 0, i2 = 0, is = void 0, buf = void 0;
      if (!this.p.length)
        buf = chunk;
      else if (!chunk.length)
        buf = this.p;
      else {
        buf = new u8(this.p.length + chunk.length);
        buf.set(this.p), buf.set(chunk, this.p.length);
      }
      var l = buf.length, oc = this.c, add2 = oc && this.d;
      var _loop_2 = function() {
        var _a2;
        var sig = b4(buf, i2);
        if (sig == 67324752) {
          f = 1, is = i2;
          this_1.d = null;
          this_1.c = 0;
          var bf = b2(buf, i2 + 6), cmp_1 = b2(buf, i2 + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i2 + 26), es = b2(buf, i2 + 28);
          if (l > i2 + 30 + fnl + es) {
            var chks_2 = [];
            this_1.k.unshift(chks_2);
            f = 2;
            var sc_1 = b4(buf, i2 + 18), su_1 = b4(buf, i2 + 22);
            var fn_1 = strFromU8(buf.subarray(i2 + 30, i2 += 30 + fnl), !u);
            if (sc_1 == 4294967295) {
              _a2 = dd ? [-2] : z64e(buf, i2), sc_1 = _a2[0], su_1 = _a2[1];
            } else if (dd)
              sc_1 = -1;
            i2 += es;
            this_1.c = sc_1;
            var d_1;
            var file_1 = {
              name: fn_1,
              compression: cmp_1,
              start: function() {
                if (!file_1.ondata)
                  throw "no callback";
                if (!sc_1)
                  file_1.ondata(null, et, true);
                else {
                  var ctr = _this_1.o[cmp_1];
                  if (!ctr)
                    throw "unknown compression type " + cmp_1;
                  d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                  d_1.ondata = function(err, dat3, final2) {
                    file_1.ondata(err, dat3, final2);
                  };
                  for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {
                    var dat2 = chks_3[_i];
                    d_1.push(dat2, false);
                  }
                  if (_this_1.k[0] == chks_2 && _this_1.c)
                    _this_1.d = d_1;
                  else
                    d_1.push(et, true);
                }
              },
              terminate: function() {
                if (d_1 && d_1.terminate)
                  d_1.terminate();
              }
            };
            if (sc_1 >= 0)
              file_1.size = sc_1, file_1.originalSize = su_1;
            this_1.onfile(file_1);
          }
          return "break";
        } else if (oc) {
          if (sig == 134695760) {
            is = i2 += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
            return "break";
          } else if (sig == 33639248) {
            is = i2 -= 4, f = 3, this_1.c = 0;
            return "break";
          }
        }
      };
      var this_1 = this;
      for (; i2 < l - 4; ++i2) {
        var state_1 = _loop_2();
        if (state_1 === "break")
          break;
      }
      this.p = et;
      if (oc < 0) {
        var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i2);
        if (add2)
          add2.push(dat, !!f);
        else
          this.k[+(f == 2)].push(dat);
      }
      if (f & 2)
        return this.push(buf.subarray(i2), final);
      this.p = buf.subarray(i2);
    }
    if (final) {
      if (this.c)
        throw "invalid zip file";
      this.p = null;
    }
  };
  Unzip2.prototype.register = function(decoder) {
    this.o[decoder.compression] = decoder;
  };
  return Unzip2;
}();
function unzipSync(data) {
  var files = {};
  var e = data.length - 22;
  for (; b4(data, e) != 101010256; --e) {
    if (!e || data.length - e > 65558)
      throw "invalid zip file";
  }
  ;
  var c = b2(data, e + 8);
  if (!c)
    return {};
  var o = b4(data, e + 16);
  var z = o == 4294967295;
  if (z) {
    e = b4(data, e - 12);
    if (b4(data, e) != 101075792)
      throw "invalid zip file";
    c = b4(data, e + 32);
    o = b4(data, e + 48);
  }
  for (var i2 = 0; i2 < c; ++i2) {
    var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b3 = slzh(data, off);
    o = no;
    if (!c_2)
      files[fn] = slc(data, b3, b3 + sc);
    else if (c_2 == 8)
      files[fn] = inflateSync(data.subarray(b3, b3 + sc), new u8(su));
    else
      throw "unknown compression type " + c_2;
  }
  return files;
}

// node_modules/three-stdlib/exporters/USDZExporter.js
var USDZExporter = class {
  constructor() {
    _defineProperty(this, "PRECISION", 7);
    _defineProperty(this, "materials", void 0);
    _defineProperty(this, "textures", void 0);
    _defineProperty(this, "files", void 0);
    this.materials = {};
    this.textures = {};
    this.files = {};
  }
  async parse(scene) {
    const modelFileName = "model.usda";
    this.files[modelFileName] = null;
    let output = this.buildHeader();
    scene.traverseVisible((object) => {
      if (object instanceof Mesh && object.isMesh && object.material.isMeshStandardMaterial) {
        const geometry = object.geometry;
        const material = object.material;
        const geometryFileName = "geometries/Geometry_" + geometry.id + ".usd";
        if (!(geometryFileName in this.files)) {
          const meshObject = this.buildMeshObject(geometry);
          this.files[geometryFileName] = this.buildUSDFileAsString(meshObject);
        }
        if (!(material.uuid in this.materials)) {
          this.materials[material.uuid] = material;
        }
        output += this.buildXform(object, geometry, material);
      }
    });
    output += this.buildMaterials(this.materials);
    this.files[modelFileName] = strToU8(output);
    output = null;
    for (const id in this.textures) {
      const texture2 = this.textures[id];
      const color2 = id.split("_")[1];
      const isRGBA = texture2.format === 1023;
      const canvas = this.imageToCanvas(texture2.image, color2);
      const blob = await new Promise((resolve) => canvas === null || canvas === void 0 ? void 0 : canvas.toBlob(resolve, isRGBA ? "image/png" : "image/jpeg", 1));
      if (blob) {
        this.files[`textures/Texture_${id}.${isRGBA ? "png" : "jpg"}`] = new Uint8Array(await blob.arrayBuffer());
      }
    }
    let offset = 0;
    for (const filename in this.files) {
      const file = this.files[filename];
      const headerSize = 34 + filename.length;
      offset += headerSize;
      const offsetMod64 = offset & 63;
      if (offsetMod64 !== 4 && file !== null && file instanceof Uint8Array) {
        const padLength = 64 - offsetMod64;
        const padding = new Uint8Array(padLength);
        this.files[filename] = [file, {
          extra: {
            12345: padding
          }
        }];
      }
      if (file && typeof file.length === "number") {
        offset = file.length;
      }
    }
    return zipSync(this.files, {
      level: 0
    });
  }
  imageToCanvas(image, color2) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && image instanceof OffscreenCanvas || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const scale = 1024 / Math.max(image.width, image.height);
      const canvas = document.createElement("canvas");
      canvas.width = image.width * Math.min(1, scale);
      canvas.height = image.height * Math.min(1, scale);
      const context = canvas.getContext("2d");
      context === null || context === void 0 ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);
      if (color2 !== void 0) {
        const hex = parseInt(color2, 16);
        const r = (hex >> 16 & 255) / 255;
        const g2 = (hex >> 8 & 255) / 255;
        const b3 = (hex & 255) / 255;
        const imagedata = context === null || context === void 0 ? void 0 : context.getImageData(0, 0, canvas.width, canvas.height);
        if (imagedata) {
          const data = imagedata === null || imagedata === void 0 ? void 0 : imagedata.data;
          for (let i2 = 0; i2 < data.length; i2 += 4) {
            data[i2 + 0] = data[i2 + 0] * r;
            data[i2 + 1] = data[i2 + 1] * g2;
            data[i2 + 2] = data[i2 + 2] * b3;
          }
          context === null || context === void 0 ? void 0 : context.putImageData(imagedata, 0, 0);
        }
      }
      return canvas;
    }
  }
  buildHeader() {
    return `#usda 1.0
(
    customLayerData = {
        string creator = "Three.js USDZExporter"
    }
    metersPerUnit = 1
    upAxis = "Y"
)
`;
  }
  buildUSDFileAsString(dataToInsert) {
    let output = this.buildHeader();
    output += dataToInsert;
    return strToU8(output);
  }
  buildXform(object, geometry, material) {
    const name = "Object_" + object.id;
    const transform = this.buildMatrix(object.matrixWorld);
    if (object.matrixWorld.determinant() < 0) {
      console.warn("THREE.USDZExporter: USDZ does not support negative scales", object);
    }
    return `def Xform "${name}" (
    prepend references = @./geometries/Geometry_${geometry.id}.usd@</Geometry>
)
{
    matrix4d xformOp:transform = ${transform}
    uniform token[] xformOpOrder = ["xformOp:transform"]
    rel material:binding = </Materials/Material_${material.id}>
}
`;
  }
  buildMatrix(matrix3) {
    const array = matrix3.elements;
    return `( ${this.buildMatrixRow(array, 0)}, ${this.buildMatrixRow(array, 4)}, ${this.buildMatrixRow(array, 8)}, ${this.buildMatrixRow(array, 12)} )`;
  }
  buildMatrixRow(array, offset) {
    return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;
  }
  buildMeshObject(geometry) {
    const mesh = this.buildMesh(geometry);
    return `
def "Geometry"
{
  ${mesh}
}
`;
  }
  buildMesh(geometry) {
    const name = "Geometry";
    const attributes = geometry.attributes;
    const count = attributes.position.count;
    return `
    def Mesh "${name}"
    {
        int[] faceVertexCounts = [${this.buildMeshVertexCount(geometry)}]
        int[] faceVertexIndices = [${this.buildMeshVertexIndices(geometry)}]
        normal3f[] normals = [${this.buildVector3Array(attributes.normal, count)}] (
            interpolation = "vertex"
        )
        point3f[] points = [${this.buildVector3Array(attributes.position, count)}]
        float2[] primvars:st = [${this.buildVector2Array(attributes.uv, count)}] (
            interpolation = "vertex"
        )
        uniform token subdivisionScheme = "none"
    }
`;
  }
  buildMeshVertexCount(geometry) {
    const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;
    return Array(count / 3).fill(3).join(", ");
  }
  buildMeshVertexIndices(geometry) {
    if (geometry.index !== null) {
      return geometry.index.array.join(", ");
    }
    const array = [];
    const length2 = geometry.attributes.position.count;
    for (let i2 = 0; i2 < length2; i2++) {
      array.push(i2);
    }
    return array.join(", ");
  }
  buildVector3Array(attribute2, count) {
    if (attribute2 === void 0) {
      console.warn("USDZExporter: Normals missing.");
      return Array(count).fill("(0, 0, 0)").join(", ");
    }
    const array = [];
    const data = attribute2.array;
    for (let i2 = 0; i2 < data.length; i2 += 3) {
      array.push(`(${data[i2 + 0].toPrecision(this.PRECISION)}, ${data[i2 + 1].toPrecision(this.PRECISION)}, ${data[i2 + 2].toPrecision(this.PRECISION)})`);
    }
    return array.join(", ");
  }
  buildVector2Array(attribute2, count) {
    if (attribute2 === void 0) {
      console.warn("USDZExporter: UVs missing.");
      return Array(count).fill("(0, 0)").join(", ");
    }
    const array = [];
    const data = attribute2.array;
    for (let i2 = 0; i2 < data.length; i2 += 2) {
      array.push(`(${data[i2 + 0].toPrecision(this.PRECISION)}, ${1 - data[i2 + 1].toPrecision(this.PRECISION)})`);
    }
    return array.join(", ");
  }
  buildMaterials(materials) {
    const array = [];
    for (const uuid in materials) {
      const material = materials[uuid];
      array.push(this.buildMaterial(material));
    }
    return `def "Materials"
{
${array.join("")}
}
`;
  }
  buildMaterial(material) {
    const pad = "            ";
    const inputs = [];
    const samplers = [];
    if (material.map !== null) {
      inputs.push(`${pad}color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`);
      samplers.push(this.buildTexture(material, material.map, "diffuse", material.color));
    } else {
      inputs.push(`${pad}color3f inputs:diffuseColor = ${this.buildColor(material.color)}`);
    }
    if (material.emissiveMap !== null) {
      inputs.push(`${pad}color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`);
      samplers.push(this.buildTexture(material, material.emissiveMap, "emissive"));
    } else if (material.emissive.getHex() > 0) {
      inputs.push(`${pad}color3f inputs:emissiveColor = ${this.buildColor(material.emissive)}`);
    }
    if (material.normalMap !== null) {
      inputs.push(`${pad}normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`);
      samplers.push(this.buildTexture(material, material.normalMap, "normal"));
    }
    if (material.aoMap !== null) {
      inputs.push(`${pad}float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`);
      samplers.push(this.buildTexture(material, material.aoMap, "occlusion"));
    }
    if (material.roughnessMap !== null && material.roughness === 1) {
      inputs.push(`${pad}float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`);
      samplers.push(this.buildTexture(material, material.roughnessMap, "roughness"));
    } else {
      inputs.push(`${pad}float inputs:roughness = ${material.roughness}`);
    }
    if (material.metalnessMap !== null && material.metalness === 1) {
      inputs.push(`${pad}float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`);
      samplers.push(this.buildTexture(material, material.metalnessMap, "metallic"));
    } else {
      inputs.push(`${pad}float inputs:metallic = ${material.metalness}`);
    }
    inputs.push(`${pad}float inputs:opacity = ${material.opacity}`);
    if (material instanceof MeshPhysicalMaterial) {
      inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`);
      inputs.push(`${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`);
      inputs.push(`${pad}float inputs:ior = ${material.ior}`);
    }
    return `
    def Material "Material_${material.id}"
    {
        def Shader "PreviewSurface"
        {
            uniform token info:id = "UsdPreviewSurface"
${inputs.join("\n")}
            int inputs:useSpecularWorkflow = 0
            token outputs:surface
        }
        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>
        token inputs:frame:stPrimvarName = "st"
        def Shader "uvReader_st"
        {
            uniform token info:id = "UsdPrimvarReader_float2"
            token inputs:varname.connect = </Materials/Material_${material.id}.inputs:frame:stPrimvarName>
            float2 inputs:fallback = (0.0, 0.0)
            float2 outputs:result
        }
${samplers.join("\n")}
    }
`;
  }
  buildTexture(material, texture2, mapType, color2) {
    const id = texture2.id + (color2 ? "_" + color2.getHexString() : "");
    const isRGBA = texture2.format === 1023;
    this.textures[id] = texture2;
    return `
      def Shader "Transform2d_${mapType}" (
          sdrMetadata = {
              string role = "math"
          }
      )
      {
          uniform token info:id = "UsdTransform2d"
          float2 inputs:in.connect = </Materials/Material_${material.id}/uvReader_st.outputs:result>
          float2 inputs:scale = ${this.buildVector2(texture2.repeat)}
          float2 inputs:translation = ${this.buildVector2(texture2.offset)}
          float2 outputs:result
      }
      def Shader "Texture_${texture2.id}_${mapType}"
      {
          uniform token info:id = "UsdUVTexture"
          asset inputs:file = @textures/Texture_${id}.${isRGBA ? "png" : "jpg"}@
          float2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>
          token inputs:wrapS = "repeat"
          token inputs:wrapT = "repeat"
          float outputs:r
          float outputs:g
          float outputs:b
          float3 outputs:rgb
      }`;
  }
  buildColor(color2) {
    return `(${color2.r}, ${color2.g}, ${color2.b})`;
  }
  buildVector2(vector2) {
    return `(${vector2.x}, ${vector2.y})`;
  }
};

// node_modules/three-stdlib/exporters/PLYExporter.js
var PLYExporter = class {
  parse(object, onDone, options) {
    if (onDone && typeof onDone === "object") {
      console.warn('THREE.PLYExporter: The options parameter is now the third argument to the "parse" function. See the documentation for the new API.');
      options = onDone;
      onDone = void 0;
    }
    const defaultOptions = {
      binary: false,
      excludeAttributes: [],
      littleEndian: false
    };
    options = Object.assign(defaultOptions, options);
    const excludeAttributes = options.excludeAttributes;
    let includeNormals = false;
    let includeColors = false;
    let includeUVs = false;
    let vertexCount = 0;
    let faceCount = 0;
    object.traverse(function(child) {
      if (child instanceof Mesh && child.isMesh) {
        const mesh = child;
        const geometry = mesh.geometry;
        if (!geometry.isBufferGeometry) {
          throw new Error("THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.");
        }
        const vertices = geometry.getAttribute("position");
        const normals = geometry.getAttribute("normal");
        const uvs = geometry.getAttribute("uv");
        const colors = geometry.getAttribute("color");
        const indices = geometry.getIndex();
        if (vertices === void 0) {
          return;
        }
        vertexCount += vertices.count;
        faceCount += indices ? indices.count / 3 : vertices.count / 3;
        if (normals !== void 0)
          includeNormals = true;
        if (uvs !== void 0)
          includeUVs = true;
        if (colors !== void 0)
          includeColors = true;
      }
    });
    const includeIndices = (excludeAttributes === null || excludeAttributes === void 0 ? void 0 : excludeAttributes.indexOf("index")) === -1;
    includeNormals = includeNormals && (excludeAttributes === null || excludeAttributes === void 0 ? void 0 : excludeAttributes.indexOf("normal")) === -1;
    includeColors = includeColors && (excludeAttributes === null || excludeAttributes === void 0 ? void 0 : excludeAttributes.indexOf("color")) === -1;
    includeUVs = includeUVs && (excludeAttributes === null || excludeAttributes === void 0 ? void 0 : excludeAttributes.indexOf("uv")) === -1;
    if (includeIndices && faceCount !== Math.floor(faceCount)) {
      console.error("PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3.");
      return null;
    }
    const indexByteCount = 4;
    let header = `ply
format ${options.binary ? options.littleEndian ? "binary_little_endian" : "binary_big_endian" : "ascii"} 1.0
element vertex ${vertexCount}
property float x
property float y
property float z
`;
    if (includeNormals) {
      header += "property float nx\nproperty float ny\nproperty float nz\n";
    }
    if (includeUVs) {
      header += "property float s\nproperty float t\n";
    }
    if (includeColors) {
      header += "property uchar red\nproperty uchar green\nproperty uchar blue\n";
    }
    if (includeIndices) {
      header += `${`element face ${faceCount}
`}property list uchar int vertex_index
`;
    }
    header += "end_header\n";
    const vertex = new Vector3();
    const normalMatrixWorld = new Matrix3();
    let result = null;
    if (options.binary) {
      const headerBin = new TextEncoder().encode(header);
      const vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0));
      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;
      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));
      new Uint8Array(output.buffer).set(headerBin, 0);
      let vOffset = headerBin.length;
      let fOffset = headerBin.length + vertexListLength;
      let writtenVertices = 0;
      this.traverseMeshes(object, function(mesh, geometry) {
        const vertices = geometry.getAttribute("position");
        const normals = geometry.getAttribute("normal");
        const uvs = geometry.getAttribute("uv");
        const colors = geometry.getAttribute("color");
        const indices = geometry.getIndex();
        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);
        for (let i2 = 0, l = vertices.count; i2 < l; i2++) {
          vertex.x = vertices.getX(i2);
          vertex.y = vertices.getY(i2);
          vertex.z = vertices.getZ(i2);
          vertex.applyMatrix4(mesh.matrixWorld);
          output.setFloat32(vOffset, vertex.x, options.littleEndian);
          vOffset += 4;
          output.setFloat32(vOffset, vertex.y, options.littleEndian);
          vOffset += 4;
          output.setFloat32(vOffset, vertex.z, options.littleEndian);
          vOffset += 4;
          if (includeNormals) {
            if (normals != null) {
              vertex.x = normals.getX(i2);
              vertex.y = normals.getY(i2);
              vertex.z = normals.getZ(i2);
              vertex.applyMatrix3(normalMatrixWorld).normalize();
              output.setFloat32(vOffset, vertex.x, options.littleEndian);
              vOffset += 4;
              output.setFloat32(vOffset, vertex.y, options.littleEndian);
              vOffset += 4;
              output.setFloat32(vOffset, vertex.z, options.littleEndian);
              vOffset += 4;
            } else {
              output.setFloat32(vOffset, 0, options.littleEndian);
              vOffset += 4;
              output.setFloat32(vOffset, 0, options.littleEndian);
              vOffset += 4;
              output.setFloat32(vOffset, 0, options.littleEndian);
              vOffset += 4;
            }
          }
          if (includeUVs) {
            if (uvs != null) {
              output.setFloat32(vOffset, uvs.getX(i2), options.littleEndian);
              vOffset += 4;
              output.setFloat32(vOffset, uvs.getY(i2), options.littleEndian);
              vOffset += 4;
            } else if (!includeUVs) {
              output.setFloat32(vOffset, 0, options.littleEndian);
              vOffset += 4;
              output.setFloat32(vOffset, 0, options.littleEndian);
              vOffset += 4;
            }
          }
          if (includeColors) {
            if (colors != null) {
              output.setUint8(vOffset, Math.floor(colors.getX(i2) * 255));
              vOffset += 1;
              output.setUint8(vOffset, Math.floor(colors.getY(i2) * 255));
              vOffset += 1;
              output.setUint8(vOffset, Math.floor(colors.getZ(i2) * 255));
              vOffset += 1;
            } else {
              output.setUint8(vOffset, 255);
              vOffset += 1;
              output.setUint8(vOffset, 255);
              vOffset += 1;
              output.setUint8(vOffset, 255);
              vOffset += 1;
            }
          }
        }
        if (includeIndices) {
          if (indices !== null) {
            for (let i2 = 0, l = indices.count; i2 < l; i2 += 3) {
              output.setUint8(fOffset, 3);
              fOffset += 1;
              output.setUint32(fOffset, indices.getX(i2 + 0) + writtenVertices, options.littleEndian);
              fOffset += indexByteCount;
              output.setUint32(fOffset, indices.getX(i2 + 1) + writtenVertices, options.littleEndian);
              fOffset += indexByteCount;
              output.setUint32(fOffset, indices.getX(i2 + 2) + writtenVertices, options.littleEndian);
              fOffset += indexByteCount;
            }
          } else {
            for (let i2 = 0, l = vertices.count; i2 < l; i2 += 3) {
              output.setUint8(fOffset, 3);
              fOffset += 1;
              output.setUint32(fOffset, writtenVertices + i2, options.littleEndian);
              fOffset += indexByteCount;
              output.setUint32(fOffset, writtenVertices + i2 + 1, options.littleEndian);
              fOffset += indexByteCount;
              output.setUint32(fOffset, writtenVertices + i2 + 2, options.littleEndian);
              fOffset += indexByteCount;
            }
          }
        }
        writtenVertices += vertices.count;
      });
      result = output.buffer;
    } else {
      let writtenVertices = 0;
      let vertexList = "";
      let faceList = "";
      this.traverseMeshes(object, function(mesh, geometry) {
        const vertices = geometry.getAttribute("position");
        const normals = geometry.getAttribute("normal");
        const uvs = geometry.getAttribute("uv");
        const colors = geometry.getAttribute("color");
        const indices = geometry.getIndex();
        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);
        for (let i2 = 0, l = vertices.count; i2 < l; i2++) {
          vertex.x = vertices.getX(i2);
          vertex.y = vertices.getY(i2);
          vertex.z = vertices.getZ(i2);
          vertex.applyMatrix4(mesh.matrixWorld);
          let line2 = vertex.x + " " + vertex.y + " " + vertex.z;
          if (includeNormals) {
            if (normals != null) {
              vertex.x = normals.getX(i2);
              vertex.y = normals.getY(i2);
              vertex.z = normals.getZ(i2);
              vertex.applyMatrix3(normalMatrixWorld).normalize();
              line2 += " " + vertex.x + " " + vertex.y + " " + vertex.z;
            } else {
              line2 += " 0 0 0";
            }
          }
          if (includeUVs) {
            if (uvs != null) {
              line2 += " " + uvs.getX(i2) + " " + uvs.getY(i2);
            } else if (includeUVs) {
              line2 += " 0 0";
            }
          }
          if (includeColors) {
            if (colors != null) {
              line2 += " " + Math.floor(colors.getX(i2) * 255) + " " + Math.floor(colors.getY(i2) * 255) + " " + Math.floor(colors.getZ(i2) * 255);
            } else {
              line2 += " 255 255 255";
            }
          }
          vertexList += line2 + "\n";
        }
        if (includeIndices) {
          if (indices !== null) {
            for (let i2 = 0, l = indices.count; i2 < l; i2 += 3) {
              faceList += `3 ${indices.getX(i2 + 0) + writtenVertices}`;
              faceList += ` ${indices.getX(i2 + 1) + writtenVertices}`;
              faceList += ` ${indices.getX(i2 + 2) + writtenVertices}
`;
            }
          } else {
            for (let i2 = 0, l = vertices.count; i2 < l; i2 += 3) {
              faceList += `3 ${writtenVertices + i2} ${writtenVertices + i2 + 1} ${writtenVertices + i2 + 2}
`;
            }
          }
          faceCount += indices ? indices.count / 3 : vertices.count / 3;
        }
        writtenVertices += vertices.count;
      });
      result = `${header}${vertexList}${includeIndices ? `${faceList}
` : "\n"}`;
    }
    if (typeof onDone === "function") {
      requestAnimationFrame(() => onDone && onDone(typeof result === "string" ? result : ""));
    }
    return result;
  }
  traverseMeshes(object, cb2) {
    object.traverse(function(child) {
      if (child instanceof Mesh && child.isMesh) {
        const mesh = child;
        const geometry = mesh.geometry;
        if (!geometry.isBufferGeometry) {
          throw new Error("THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.");
        }
        if (geometry.hasAttribute("position")) {
          cb2(mesh, geometry);
        }
      }
    });
  }
};

// node_modules/three-stdlib/exporters/DRACOExporter.js
var DRACOExporter = class {
  parse(object, options = {
    decodeSpeed: 5,
    encodeSpeed: 5,
    encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,
    quantization: [16, 8, 8, 8, 8],
    exportUvs: true,
    exportNormals: true,
    exportColor: false
  }) {
    if (object instanceof BufferGeometry && object.isBufferGeometry) {
      throw new Error("DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.");
    }
    if (DracoEncoderModule === void 0) {
      throw new Error("THREE.DRACOExporter: required the draco_encoder to work.");
    }
    const geometry = object.geometry;
    const dracoEncoder = DracoEncoderModule();
    const encoder = new dracoEncoder.Encoder();
    let builder;
    let dracoObject;
    if (!geometry.isBufferGeometry) {
      throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.");
    }
    if (object instanceof Mesh && object.isMesh) {
      builder = new dracoEncoder.MeshBuilder();
      dracoObject = new dracoEncoder.Mesh();
      const vertices = geometry.getAttribute("position");
      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);
      const faces = geometry.getIndex();
      if (faces !== null) {
        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);
      } else {
        const faces2 = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);
        for (let i2 = 0; i2 < faces2.length; i2++) {
          faces2[i2] = i2;
        }
        builder.AddFacesToMesh(dracoObject, vertices.count, faces2);
      }
      if (options.exportNormals) {
        const normals = geometry.getAttribute("normal");
        if (normals !== void 0) {
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);
        }
      }
      if (options.exportUvs) {
        const uvs = geometry.getAttribute("uv");
        if (uvs !== void 0) {
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);
        }
      }
      if (options.exportColor) {
        const colors = geometry.getAttribute("color");
        if (colors !== void 0) {
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);
        }
      }
    } else if (object instanceof Points && object.isPoints) {
      builder = new dracoEncoder.PointCloudBuilder();
      dracoObject = new dracoEncoder.PointCloud();
      const vertices = geometry.getAttribute("position");
      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);
      if (options.exportColor) {
        const colors = geometry.getAttribute("color");
        if (colors !== void 0) {
          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);
        }
      }
    } else {
      throw new Error("DRACOExporter: Unsupported object type.");
    }
    const encodedData = new dracoEncoder.DracoInt8Array();
    const encodeSpeed = options.encodeSpeed !== void 0 ? options.encodeSpeed : 5;
    const decodeSpeed = options.decodeSpeed !== void 0 ? options.decodeSpeed : 5;
    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed);
    if (options.encoderMethod !== void 0) {
      encoder.SetEncodingMethod(options.encoderMethod);
    }
    if (options.quantization !== void 0) {
      for (let i2 = 0; i2 < 5; i2++) {
        if (options.quantization[i2] !== void 0) {
          encoder.SetAttributeQuantization(i2, options.quantization[i2]);
        }
      }
    }
    let length2;
    if (object instanceof Mesh && object.isMesh) {
      length2 = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);
    } else {
      length2 = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);
    }
    dracoEncoder.destroy(dracoObject);
    if (length2 === 0) {
      throw new Error("THREE.DRACOExporter: Draco encoding failed.");
    }
    const outputData = new Int8Array(new ArrayBuffer(length2));
    for (let i2 = 0; i2 < length2; i2++) {
      outputData[i2] = encodedData.GetValue(i2);
    }
    dracoEncoder.destroy(encodedData);
    dracoEncoder.destroy(encoder);
    dracoEncoder.destroy(builder);
    return outputData;
  }
};
_defineProperty(DRACOExporter, "MESH_EDGEBREAKER_ENCODING", 1);
_defineProperty(DRACOExporter, "MESH_SEQUENTIAL_ENCODING", 0);
_defineProperty(DRACOExporter, "POINT_CLOUD", 0);
_defineProperty(DRACOExporter, "TRIANGULAR_MESH", 1);
_defineProperty(DRACOExporter, "INVALID", -1);
_defineProperty(DRACOExporter, "POSITION", 0);
_defineProperty(DRACOExporter, "NORMAL", 1);
_defineProperty(DRACOExporter, "COLOR", 2);
_defineProperty(DRACOExporter, "TEX_COORD", 3);
_defineProperty(DRACOExporter, "GENERIC", 4);

// node_modules/three-stdlib/exporters/ColladaExporter.js
var ColladaExporter = class {
  constructor() {
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "geometryInfo", void 0);
    _defineProperty(this, "materialMap", void 0);
    _defineProperty(this, "imageMap", void 0);
    _defineProperty(this, "textures", void 0);
    _defineProperty(this, "libraryImages", void 0);
    _defineProperty(this, "libraryGeometries", void 0);
    _defineProperty(this, "libraryEffects", void 0);
    _defineProperty(this, "libraryMaterials", void 0);
    _defineProperty(this, "canvas", void 0);
    _defineProperty(this, "ctx", void 0);
    _defineProperty(this, "transMat", void 0);
    _defineProperty(this, "getFuncs", ["getX", "getY", "getZ", "getW"]);
    this.options = {
      version: "1.4.1",
      author: null,
      textureDirectory: "",
      upAxis: "Y_UP",
      unitName: null,
      unitMeter: null
    };
    this.geometryInfo = /* @__PURE__ */ new WeakMap();
    this.materialMap = /* @__PURE__ */ new WeakMap();
    this.imageMap = /* @__PURE__ */ new WeakMap();
    this.textures = [];
    this.libraryImages = [];
    this.libraryGeometries = [];
    this.libraryEffects = [];
    this.libraryMaterials = [];
    this.canvas = null;
    this.ctx = null;
    this.transMat = null;
  }
  parse(object, onDone, options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {
      console.error("ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.");
      return null;
    }
    if (this.options.unitName !== null && this.options.unitMeter === null) {
      console.error("ColladaExporter: unitMeter needs to be specified if unitName is specified.");
      return null;
    }
    if (this.options.unitMeter !== null && this.options.unitName === null) {
      console.error("ColladaExporter: unitName needs to be specified if unitMeter is specified.");
      return null;
    }
    if (this.options.textureDirectory !== "") {
      this.options.textureDirectory = `${this.options.textureDirectory}/`.replace(/\\/g, "/").replace(/\/+/g, "/");
    }
    if (this.options.version !== "1.4.1" && this.options.version !== "1.5.0") {
      console.warn(`ColladaExporter : Version ${this.options.version} not supported for export. Only 1.4.1 and 1.5.0.`);
      return null;
    }
    const libraryVisualScenes = this.processObject(object);
    const specLink = this.options.version === "1.4.1" ? "http://www.collada.org/2005/11/COLLADASchema" : "https://www.khronos.org/collada/";
    let dae = `<?xml version="1.0" encoding="UTF-8" standalone="no" ?>${`<COLLADA xmlns="${specLink}" version="${this.options.version}">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${this.options.author !== null ? `<author>${this.options.author}</author>` : ""}</contributor>${`<created>${new Date().toISOString()}</created>`}${`<modified>${new Date().toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`;
    dae += `<library_images>${this.libraryImages.join("")}</library_images>`;
    dae += `<library_effects>${this.libraryEffects.join("")}</library_effects>`;
    dae += `<library_materials>${this.libraryMaterials.join("")}</library_materials>`;
    dae += `<library_geometries>${this.libraryGeometries.join("")}</library_geometries>`;
    dae += `<library_visual_scenes><visual_scene id="Scene" name="scene">${libraryVisualScenes}</visual_scene></library_visual_scenes>`;
    dae += '<scene><instance_visual_scene url="#Scene"/></scene>';
    dae += "</COLLADA>";
    const res = {
      data: this.format(dae),
      textures: this.textures
    };
    if (typeof onDone === "function") {
      requestAnimationFrame(() => onDone(res));
    }
    return res;
  }
  format(urdf) {
    var _urdf$match$map$join, _urdf$match;
    const IS_END_TAG = /^<\//;
    const IS_SELF_CLOSING = /(\?>$)|(\/>$)/;
    const HAS_TEXT = /<[^>]+>[^<]*<\/[^<]+>/;
    const pad = (ch3, num) => num > 0 ? ch3 + pad(ch3, num - 1) : "";
    let tagnum = 0;
    return (_urdf$match$map$join = (_urdf$match = urdf.match(/(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g)) === null || _urdf$match === void 0 ? void 0 : _urdf$match.map((tag) => {
      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {
        tagnum--;
      }
      const res = `${pad("  ", tagnum)}${tag}`;
      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {
        tagnum++;
      }
      return res;
    }).join("\n")) != null ? _urdf$match$map$join : "";
  }
  base64ToBuffer(str) {
    const b3 = atob(str);
    const buf = new Uint8Array(b3.length);
    for (let i2 = 0, l = buf.length; i2 < l; i2++) {
      buf[i2] = b3.charCodeAt(i2);
    }
    return buf;
  }
  imageToData(image, ext) {
    var _this$ctx;
    this.canvas = this.canvas || document.createElement("canvas");
    this.ctx = this.ctx || this.canvas.getContext("2d");
    this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width;
    this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height;
    (_this$ctx = this.ctx) === null || _this$ctx === void 0 ? void 0 : _this$ctx.drawImage(image, 0, 0);
    const base64data = this.canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\/(png|jpg);base64,/, "");
    return this.base64ToBuffer(base64data);
  }
  attrBufferToArray(attr) {
    if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {
      const TypedArrayConstructor = attr.array.constructor;
      const arr = new TypedArrayConstructor(attr.count * attr.itemSize);
      const size2 = attr.itemSize;
      for (let i2 = 0, l = attr.count; i2 < l; i2++) {
        for (let j2 = 0; j2 < size2; j2++) {
          arr[i2 * size2 + j2] = attr[this.getFuncs[j2]](i2);
        }
      }
      return arr;
    } else {
      return attr.array;
    }
  }
  subArray(arr, st, ct) {
    if (Array.isArray(arr)) {
      return arr.slice(st, st + ct);
    } else {
      const TypedArrayConstructor = arr.constructor;
      return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);
    }
  }
  getAttribute(attr, name, params, type2) {
    const array = this.attrBufferToArray(attr);
    const res = Array.isArray(array) ? `${`<source id="${name}"><float_array id="${name}-array" count="${array.length}">` + array.join(" ")}</float_array><technique_common>${`<accessor source="#${name}-array" count="${Math.floor(array.length / attr.itemSize)}" stride="${attr.itemSize}">`}${params.map((n) => `<param name="${n}" type="${type2}" />`).join("")}</accessor></technique_common></source>` : "";
    return res;
  }
  getTransform(o) {
    o.updateMatrix();
    this.transMat = this.transMat || new Matrix4();
    this.transMat.copy(o.matrix);
    this.transMat.transpose();
    return `<matrix>${this.transMat.toArray().join(" ")}</matrix>`;
  }
  processGeometry(g2) {
    let info = this.geometryInfo.get(g2);
    if (!info) {
      const bufferGeometry = g2;
      if (!bufferGeometry.isBufferGeometry) {
        throw new Error("THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.");
      }
      const meshid = `Mesh${this.libraryGeometries.length + 1}`;
      const indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;
      const groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{
        start: 0,
        count: indexCount,
        materialIndex: 0
      }];
      const gname = g2.name ? ` name="${g2.name}"` : "";
      let gnode = `<geometry id="${meshid}"${gname}><mesh>`;
      const posName = `${meshid}-position`;
      const vertName = `${meshid}-vertices`;
      gnode += this.getAttribute(bufferGeometry.attributes.position, posName, ["X", "Y", "Z"], "float");
      gnode += `<vertices id="${vertName}"><input semantic="POSITION" source="#${posName}" /></vertices>`;
      let triangleInputs = `<input semantic="VERTEX" source="#${vertName}" offset="0" />`;
      if ("normal" in bufferGeometry.attributes) {
        const normName = `${meshid}-normal`;
        gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, ["X", "Y", "Z"], "float");
        triangleInputs += `<input semantic="NORMAL" source="#${normName}" offset="0" />`;
      }
      if ("uv" in bufferGeometry.attributes) {
        const uvName = `${meshid}-texcoord`;
        gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, ["S", "T"], "float");
        triangleInputs += `<input semantic="TEXCOORD" source="#${uvName}" offset="0" set="0" />`;
      }
      if ("uv2" in bufferGeometry.attributes) {
        const uvName = `${meshid}-texcoord2`;
        gnode += this.getAttribute(bufferGeometry.attributes.uv2, uvName, ["S", "T"], "float");
        triangleInputs += `<input semantic="TEXCOORD" source="#${uvName}" offset="0" set="1" />`;
      }
      if ("color" in bufferGeometry.attributes) {
        const colName = `${meshid}-color`;
        gnode += this.getAttribute(bufferGeometry.attributes.color, colName, ["X", "Y", "Z"], "uint8");
        triangleInputs += `<input semantic="COLOR" source="#${colName}" offset="0" />`;
      }
      let indexArray = null;
      if (bufferGeometry.index) {
        indexArray = this.attrBufferToArray(bufferGeometry.index);
      } else {
        indexArray = new Array(indexCount);
        for (let i2 = 0, l = indexArray.length; i2 < l && Array.isArray(indexArray); i2++)
          indexArray[i2] = i2;
      }
      for (let i2 = 0, l = groups.length; i2 < l; i2++) {
        const group = groups[i2];
        const subarr = this.subArray(indexArray, group.start, group.count);
        const polycount = subarr.length / 3;
        gnode += `<triangles material="MESH_MATERIAL_${group.materialIndex}" count="${polycount}">`;
        gnode += triangleInputs;
        gnode += `<p>${subarr.join(" ")}</p>`;
        gnode += "</triangles>";
      }
      gnode += "</mesh></geometry>";
      this.libraryGeometries.push(gnode);
      info = {
        meshid,
        bufferGeometry
      };
      this.geometryInfo.set(g2, info);
    }
    return info;
  }
  processTexture(tex) {
    let texid = this.imageMap.get(tex);
    if (texid == null) {
      texid = `image-${this.libraryImages.length + 1}`;
      const ext = "png";
      const name = tex.name || texid;
      let imageNode = `<image id="${texid}" name="${name}">`;
      if (this.options.version === "1.5.0") {
        imageNode += `<init_from><ref>${this.options.textureDirectory}${name}.${ext}</ref></init_from>`;
      } else {
        imageNode += `<init_from>${this.options.textureDirectory}${name}.${ext}</init_from>`;
      }
      imageNode += "</image>";
      this.libraryImages.push(imageNode);
      this.imageMap.set(tex, texid);
      this.textures.push({
        directory: this.options.textureDirectory,
        name,
        ext,
        data: this.imageToData(tex.image, ext),
        original: tex
      });
    }
    return texid;
  }
  processMaterial(m) {
    let matid = this.materialMap.get(m);
    if (matid == null) {
      matid = `Mat${this.libraryEffects.length + 1}`;
      let type2 = "phong";
      if (m instanceof MeshLambertMaterial) {
        type2 = "lambert";
      } else if (m instanceof MeshBasicMaterial) {
        type2 = "constant";
        if (m.map !== null) {
          console.warn("ColladaExporter: Texture maps not supported with MeshBasicMaterial.");
        }
      }
      if (m instanceof MeshPhongMaterial) {
        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0);
        const diffuse = m.color ? m.color : new Color(0, 0, 0);
        const specular = m.specular ? m.specular : new Color(1, 1, 1);
        const shininess = m.shininess || 0;
        const reflectivity = m.reflectivity || 0;
        let transparencyNode = "";
        if (m.transparent) {
          transparencyNode += `<transparent>${m.map ? '<texture texture="diffuse-sampler"></texture>' : "<float>1</float>"}</transparent>`;
          if (m.opacity < 1) {
            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`;
          }
        }
        const techniqueNode = `${`<technique sid="common"><${type2}>`}<emission>${m.emissiveMap ? '<texture texture="emissive-sampler" texcoord="TEXCOORD" />' : `<color sid="emission">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`}</emission>${type2 !== "constant" ? `<diffuse>${m.map ? '<texture texture="diffuse-sampler" texcoord="TEXCOORD" />' : `<color sid="diffuse">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`}</diffuse>` : ""}${type2 !== "constant" ? `<bump>${m.normalMap ? '<texture texture="bump-sampler" texcoord="TEXCOORD" />' : ""}</bump>` : ""}${type2 === "phong" ? `${`<specular><color sid="specular">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${m.specularMap ? '<texture texture="specular-sampler" texcoord="TEXCOORD" />' : `<float sid="shininess">${shininess}</float>`}</shininess>` : ""}${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type2}></technique>`}`;
        const effectnode = `${`<effect id="${matid}-effect">`}<profile_COMMON>${m.map ? `<newparam sid="diffuse-surface"><surface type="2D">${`<init_from>${this.processTexture(m.map)}</init_from>`}</surface></newparam><newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>` : ""}${m.specularMap ? `<newparam sid="specular-surface"><surface type="2D">${`<init_from>${this.processTexture(m.specularMap)}</init_from>`}</surface></newparam><newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>` : ""}${m.emissiveMap ? `<newparam sid="emissive-surface"><surface type="2D">${`<init_from>${this.processTexture(m.emissiveMap)}</init_from>`}</surface></newparam><newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>` : ""}${m.normalMap ? `<newparam sid="bump-surface"><surface type="2D">${`<init_from>${this.processTexture(m.normalMap)}</init_from>`}</surface></newparam><newparam sid="bump-sampler"><sampler2D><source>bump-surface</source></sampler2D></newparam>` : ""}${techniqueNode}${m.side === DoubleSide ? '<extra><technique profile="THREEJS"><double_sided sid="double_sided" type="int">1</double_sided></technique></extra>' : ""}</profile_COMMON></effect>`;
        const materialName = m.name ? ` name="${m.name}"` : "";
        const materialNode = `<material id="${matid}"${materialName}><instance_effect url="#${matid}-effect" /></material>`;
        this.libraryMaterials.push(materialNode);
        this.libraryEffects.push(effectnode);
        this.materialMap.set(m, matid);
      }
    }
    return matid;
  }
  processObject(o) {
    let node = `<node name="${o.name}">`;
    node += this.getTransform(o);
    new Mesh();
    if (o instanceof Mesh && o.isMesh && o.geometry !== null) {
      const geomInfo = this.processGeometry(o.geometry);
      const meshid = geomInfo.meshid;
      const geometry = geomInfo.bufferGeometry;
      let matids = null;
      let matidsArray;
      const mat = o.material || new MeshBasicMaterial();
      const materials = Array.isArray(mat) ? mat : [mat];
      if (geometry.groups.length > materials.length) {
        matidsArray = new Array(geometry.groups.length);
      } else {
        matidsArray = new Array(materials.length);
      }
      matids = matidsArray.fill(null).map((_, i2) => this.processMaterial(materials[i2 % materials.length]));
      node += `${`<instance_geometry url="#${meshid}">` + (matids != null ? `<bind_material><technique_common>${matids.map((id, i2) => `${`<instance_material symbol="MESH_MATERIAL_${i2}" target="#${id}" >`}<bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" /></instance_material>`).join("")}</technique_common></bind_material>` : "")}</instance_geometry>`;
    }
    o.children.forEach((c) => node += this.processObject(c));
    node += "</node>";
    return node;
  }
};

// node_modules/mmd-parser/build/mmdparser.module.js
function CharsetEncoder() {
}
CharsetEncoder.prototype.s2u = function(uint8Array) {
  var t2 = this.s2uTable;
  var str = "";
  var p = 0;
  while (p < uint8Array.length) {
    var key = uint8Array[p++];
    if (!(key >= 0 && key <= 126 || key >= 161 && key <= 223) && p < uint8Array.length) {
      key = key << 8 | uint8Array[p++];
    }
    if (t2[key] === void 0) {
      console.error("unknown char code " + key + ".");
      return str;
    }
    str += String.fromCharCode(t2[key]);
  }
  return str;
};
CharsetEncoder.prototype.s2uTable = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  10: 10,
  11: 11,
  12: 12,
  13: 13,
  14: 14,
  15: 15,
  16: 16,
  17: 17,
  18: 18,
  19: 19,
  20: 20,
  21: 21,
  22: 22,
  23: 23,
  24: 24,
  25: 25,
  26: 26,
  27: 27,
  28: 28,
  29: 29,
  30: 30,
  31: 31,
  32: 32,
  33: 33,
  34: 34,
  35: 35,
  36: 36,
  37: 37,
  38: 38,
  39: 39,
  40: 40,
  41: 41,
  42: 42,
  43: 43,
  44: 44,
  45: 45,
  46: 46,
  47: 47,
  48: 48,
  49: 49,
  50: 50,
  51: 51,
  52: 52,
  53: 53,
  54: 54,
  55: 55,
  56: 56,
  57: 57,
  58: 58,
  59: 59,
  60: 60,
  61: 61,
  62: 62,
  63: 63,
  64: 64,
  65: 65,
  66: 66,
  67: 67,
  68: 68,
  69: 69,
  70: 70,
  71: 71,
  72: 72,
  73: 73,
  74: 74,
  75: 75,
  76: 76,
  77: 77,
  78: 78,
  79: 79,
  80: 80,
  81: 81,
  82: 82,
  83: 83,
  84: 84,
  85: 85,
  86: 86,
  87: 87,
  88: 88,
  89: 89,
  90: 90,
  91: 91,
  92: 92,
  93: 93,
  94: 94,
  95: 95,
  96: 96,
  97: 97,
  98: 98,
  99: 99,
  100: 100,
  101: 101,
  102: 102,
  103: 103,
  104: 104,
  105: 105,
  106: 106,
  107: 107,
  108: 108,
  109: 109,
  110: 110,
  111: 111,
  112: 112,
  113: 113,
  114: 114,
  115: 115,
  116: 116,
  117: 117,
  118: 118,
  119: 119,
  120: 120,
  121: 121,
  122: 122,
  123: 123,
  124: 124,
  125: 125,
  126: 126,
  161: 65377,
  162: 65378,
  163: 65379,
  164: 65380,
  165: 65381,
  166: 65382,
  167: 65383,
  168: 65384,
  169: 65385,
  170: 65386,
  171: 65387,
  172: 65388,
  173: 65389,
  174: 65390,
  175: 65391,
  176: 65392,
  177: 65393,
  178: 65394,
  179: 65395,
  180: 65396,
  181: 65397,
  182: 65398,
  183: 65399,
  184: 65400,
  185: 65401,
  186: 65402,
  187: 65403,
  188: 65404,
  189: 65405,
  190: 65406,
  191: 65407,
  192: 65408,
  193: 65409,
  194: 65410,
  195: 65411,
  196: 65412,
  197: 65413,
  198: 65414,
  199: 65415,
  200: 65416,
  201: 65417,
  202: 65418,
  203: 65419,
  204: 65420,
  205: 65421,
  206: 65422,
  207: 65423,
  208: 65424,
  209: 65425,
  210: 65426,
  211: 65427,
  212: 65428,
  213: 65429,
  214: 65430,
  215: 65431,
  216: 65432,
  217: 65433,
  218: 65434,
  219: 65435,
  220: 65436,
  221: 65437,
  222: 65438,
  223: 65439,
  33088: 12288,
  33089: 12289,
  33090: 12290,
  33091: 65292,
  33092: 65294,
  33093: 12539,
  33094: 65306,
  33095: 65307,
  33096: 65311,
  33097: 65281,
  33098: 12443,
  33099: 12444,
  33100: 180,
  33101: 65344,
  33102: 168,
  33103: 65342,
  33104: 65507,
  33105: 65343,
  33106: 12541,
  33107: 12542,
  33108: 12445,
  33109: 12446,
  33110: 12291,
  33111: 20189,
  33112: 12293,
  33113: 12294,
  33114: 12295,
  33115: 12540,
  33116: 8213,
  33117: 8208,
  33118: 65295,
  33119: 65340,
  33120: 65374,
  33121: 8741,
  33122: 65372,
  33123: 8230,
  33124: 8229,
  33125: 8216,
  33126: 8217,
  33127: 8220,
  33128: 8221,
  33129: 65288,
  33130: 65289,
  33131: 12308,
  33132: 12309,
  33133: 65339,
  33134: 65341,
  33135: 65371,
  33136: 65373,
  33137: 12296,
  33138: 12297,
  33139: 12298,
  33140: 12299,
  33141: 12300,
  33142: 12301,
  33143: 12302,
  33144: 12303,
  33145: 12304,
  33146: 12305,
  33147: 65291,
  33148: 65293,
  33149: 177,
  33150: 215,
  33152: 247,
  33153: 65309,
  33154: 8800,
  33155: 65308,
  33156: 65310,
  33157: 8806,
  33158: 8807,
  33159: 8734,
  33160: 8756,
  33161: 9794,
  33162: 9792,
  33163: 176,
  33164: 8242,
  33165: 8243,
  33166: 8451,
  33167: 65509,
  33168: 65284,
  33169: 65504,
  33170: 65505,
  33171: 65285,
  33172: 65283,
  33173: 65286,
  33174: 65290,
  33175: 65312,
  33176: 167,
  33177: 9734,
  33178: 9733,
  33179: 9675,
  33180: 9679,
  33181: 9678,
  33182: 9671,
  33183: 9670,
  33184: 9633,
  33185: 9632,
  33186: 9651,
  33187: 9650,
  33188: 9661,
  33189: 9660,
  33190: 8251,
  33191: 12306,
  33192: 8594,
  33193: 8592,
  33194: 8593,
  33195: 8595,
  33196: 12307,
  33208: 8712,
  33209: 8715,
  33210: 8838,
  33211: 8839,
  33212: 8834,
  33213: 8835,
  33214: 8746,
  33215: 8745,
  33224: 8743,
  33225: 8744,
  33226: 65506,
  33227: 8658,
  33228: 8660,
  33229: 8704,
  33230: 8707,
  33242: 8736,
  33243: 8869,
  33244: 8978,
  33245: 8706,
  33246: 8711,
  33247: 8801,
  33248: 8786,
  33249: 8810,
  33250: 8811,
  33251: 8730,
  33252: 8765,
  33253: 8733,
  33254: 8757,
  33255: 8747,
  33256: 8748,
  33264: 8491,
  33265: 8240,
  33266: 9839,
  33267: 9837,
  33268: 9834,
  33269: 8224,
  33270: 8225,
  33271: 182,
  33276: 9711,
  33359: 65296,
  33360: 65297,
  33361: 65298,
  33362: 65299,
  33363: 65300,
  33364: 65301,
  33365: 65302,
  33366: 65303,
  33367: 65304,
  33368: 65305,
  33376: 65313,
  33377: 65314,
  33378: 65315,
  33379: 65316,
  33380: 65317,
  33381: 65318,
  33382: 65319,
  33383: 65320,
  33384: 65321,
  33385: 65322,
  33386: 65323,
  33387: 65324,
  33388: 65325,
  33389: 65326,
  33390: 65327,
  33391: 65328,
  33392: 65329,
  33393: 65330,
  33394: 65331,
  33395: 65332,
  33396: 65333,
  33397: 65334,
  33398: 65335,
  33399: 65336,
  33400: 65337,
  33401: 65338,
  33409: 65345,
  33410: 65346,
  33411: 65347,
  33412: 65348,
  33413: 65349,
  33414: 65350,
  33415: 65351,
  33416: 65352,
  33417: 65353,
  33418: 65354,
  33419: 65355,
  33420: 65356,
  33421: 65357,
  33422: 65358,
  33423: 65359,
  33424: 65360,
  33425: 65361,
  33426: 65362,
  33427: 65363,
  33428: 65364,
  33429: 65365,
  33430: 65366,
  33431: 65367,
  33432: 65368,
  33433: 65369,
  33434: 65370,
  33439: 12353,
  33440: 12354,
  33441: 12355,
  33442: 12356,
  33443: 12357,
  33444: 12358,
  33445: 12359,
  33446: 12360,
  33447: 12361,
  33448: 12362,
  33449: 12363,
  33450: 12364,
  33451: 12365,
  33452: 12366,
  33453: 12367,
  33454: 12368,
  33455: 12369,
  33456: 12370,
  33457: 12371,
  33458: 12372,
  33459: 12373,
  33460: 12374,
  33461: 12375,
  33462: 12376,
  33463: 12377,
  33464: 12378,
  33465: 12379,
  33466: 12380,
  33467: 12381,
  33468: 12382,
  33469: 12383,
  33470: 12384,
  33471: 12385,
  33472: 12386,
  33473: 12387,
  33474: 12388,
  33475: 12389,
  33476: 12390,
  33477: 12391,
  33478: 12392,
  33479: 12393,
  33480: 12394,
  33481: 12395,
  33482: 12396,
  33483: 12397,
  33484: 12398,
  33485: 12399,
  33486: 12400,
  33487: 12401,
  33488: 12402,
  33489: 12403,
  33490: 12404,
  33491: 12405,
  33492: 12406,
  33493: 12407,
  33494: 12408,
  33495: 12409,
  33496: 12410,
  33497: 12411,
  33498: 12412,
  33499: 12413,
  33500: 12414,
  33501: 12415,
  33502: 12416,
  33503: 12417,
  33504: 12418,
  33505: 12419,
  33506: 12420,
  33507: 12421,
  33508: 12422,
  33509: 12423,
  33510: 12424,
  33511: 12425,
  33512: 12426,
  33513: 12427,
  33514: 12428,
  33515: 12429,
  33516: 12430,
  33517: 12431,
  33518: 12432,
  33519: 12433,
  33520: 12434,
  33521: 12435,
  33600: 12449,
  33601: 12450,
  33602: 12451,
  33603: 12452,
  33604: 12453,
  33605: 12454,
  33606: 12455,
  33607: 12456,
  33608: 12457,
  33609: 12458,
  33610: 12459,
  33611: 12460,
  33612: 12461,
  33613: 12462,
  33614: 12463,
  33615: 12464,
  33616: 12465,
  33617: 12466,
  33618: 12467,
  33619: 12468,
  33620: 12469,
  33621: 12470,
  33622: 12471,
  33623: 12472,
  33624: 12473,
  33625: 12474,
  33626: 12475,
  33627: 12476,
  33628: 12477,
  33629: 12478,
  33630: 12479,
  33631: 12480,
  33632: 12481,
  33633: 12482,
  33634: 12483,
  33635: 12484,
  33636: 12485,
  33637: 12486,
  33638: 12487,
  33639: 12488,
  33640: 12489,
  33641: 12490,
  33642: 12491,
  33643: 12492,
  33644: 12493,
  33645: 12494,
  33646: 12495,
  33647: 12496,
  33648: 12497,
  33649: 12498,
  33650: 12499,
  33651: 12500,
  33652: 12501,
  33653: 12502,
  33654: 12503,
  33655: 12504,
  33656: 12505,
  33657: 12506,
  33658: 12507,
  33659: 12508,
  33660: 12509,
  33661: 12510,
  33662: 12511,
  33664: 12512,
  33665: 12513,
  33666: 12514,
  33667: 12515,
  33668: 12516,
  33669: 12517,
  33670: 12518,
  33671: 12519,
  33672: 12520,
  33673: 12521,
  33674: 12522,
  33675: 12523,
  33676: 12524,
  33677: 12525,
  33678: 12526,
  33679: 12527,
  33680: 12528,
  33681: 12529,
  33682: 12530,
  33683: 12531,
  33684: 12532,
  33685: 12533,
  33686: 12534,
  33695: 913,
  33696: 914,
  33697: 915,
  33698: 916,
  33699: 917,
  33700: 918,
  33701: 919,
  33702: 920,
  33703: 921,
  33704: 922,
  33705: 923,
  33706: 924,
  33707: 925,
  33708: 926,
  33709: 927,
  33710: 928,
  33711: 929,
  33712: 931,
  33713: 932,
  33714: 933,
  33715: 934,
  33716: 935,
  33717: 936,
  33718: 937,
  33727: 945,
  33728: 946,
  33729: 947,
  33730: 948,
  33731: 949,
  33732: 950,
  33733: 951,
  33734: 952,
  33735: 953,
  33736: 954,
  33737: 955,
  33738: 956,
  33739: 957,
  33740: 958,
  33741: 959,
  33742: 960,
  33743: 961,
  33744: 963,
  33745: 964,
  33746: 965,
  33747: 966,
  33748: 967,
  33749: 968,
  33750: 969,
  33856: 1040,
  33857: 1041,
  33858: 1042,
  33859: 1043,
  33860: 1044,
  33861: 1045,
  33862: 1025,
  33863: 1046,
  33864: 1047,
  33865: 1048,
  33866: 1049,
  33867: 1050,
  33868: 1051,
  33869: 1052,
  33870: 1053,
  33871: 1054,
  33872: 1055,
  33873: 1056,
  33874: 1057,
  33875: 1058,
  33876: 1059,
  33877: 1060,
  33878: 1061,
  33879: 1062,
  33880: 1063,
  33881: 1064,
  33882: 1065,
  33883: 1066,
  33884: 1067,
  33885: 1068,
  33886: 1069,
  33887: 1070,
  33888: 1071,
  33904: 1072,
  33905: 1073,
  33906: 1074,
  33907: 1075,
  33908: 1076,
  33909: 1077,
  33910: 1105,
  33911: 1078,
  33912: 1079,
  33913: 1080,
  33914: 1081,
  33915: 1082,
  33916: 1083,
  33917: 1084,
  33918: 1085,
  33920: 1086,
  33921: 1087,
  33922: 1088,
  33923: 1089,
  33924: 1090,
  33925: 1091,
  33926: 1092,
  33927: 1093,
  33928: 1094,
  33929: 1095,
  33930: 1096,
  33931: 1097,
  33932: 1098,
  33933: 1099,
  33934: 1100,
  33935: 1101,
  33936: 1102,
  33937: 1103,
  33951: 9472,
  33952: 9474,
  33953: 9484,
  33954: 9488,
  33955: 9496,
  33956: 9492,
  33957: 9500,
  33958: 9516,
  33959: 9508,
  33960: 9524,
  33961: 9532,
  33962: 9473,
  33963: 9475,
  33964: 9487,
  33965: 9491,
  33966: 9499,
  33967: 9495,
  33968: 9507,
  33969: 9523,
  33970: 9515,
  33971: 9531,
  33972: 9547,
  33973: 9504,
  33974: 9519,
  33975: 9512,
  33976: 9527,
  33977: 9535,
  33978: 9501,
  33979: 9520,
  33980: 9509,
  33981: 9528,
  33982: 9538,
  34624: 9312,
  34625: 9313,
  34626: 9314,
  34627: 9315,
  34628: 9316,
  34629: 9317,
  34630: 9318,
  34631: 9319,
  34632: 9320,
  34633: 9321,
  34634: 9322,
  34635: 9323,
  34636: 9324,
  34637: 9325,
  34638: 9326,
  34639: 9327,
  34640: 9328,
  34641: 9329,
  34642: 9330,
  34643: 9331,
  34644: 8544,
  34645: 8545,
  34646: 8546,
  34647: 8547,
  34648: 8548,
  34649: 8549,
  34650: 8550,
  34651: 8551,
  34652: 8552,
  34653: 8553,
  34655: 13129,
  34656: 13076,
  34657: 13090,
  34658: 13133,
  34659: 13080,
  34660: 13095,
  34661: 13059,
  34662: 13110,
  34663: 13137,
  34664: 13143,
  34665: 13069,
  34666: 13094,
  34667: 13091,
  34668: 13099,
  34669: 13130,
  34670: 13115,
  34671: 13212,
  34672: 13213,
  34673: 13214,
  34674: 13198,
  34675: 13199,
  34676: 13252,
  34677: 13217,
  34686: 13179,
  34688: 12317,
  34689: 12319,
  34690: 8470,
  34691: 13261,
  34692: 8481,
  34693: 12964,
  34694: 12965,
  34695: 12966,
  34696: 12967,
  34697: 12968,
  34698: 12849,
  34699: 12850,
  34700: 12857,
  34701: 13182,
  34702: 13181,
  34703: 13180,
  34704: 8786,
  34705: 8801,
  34706: 8747,
  34707: 8750,
  34708: 8721,
  34709: 8730,
  34710: 8869,
  34711: 8736,
  34712: 8735,
  34713: 8895,
  34714: 8757,
  34715: 8745,
  34716: 8746,
  34975: 20124,
  34976: 21782,
  34977: 23043,
  34978: 38463,
  34979: 21696,
  34980: 24859,
  34981: 25384,
  34982: 23030,
  34983: 36898,
  34984: 33909,
  34985: 33564,
  34986: 31312,
  34987: 24746,
  34988: 25569,
  34989: 28197,
  34990: 26093,
  34991: 33894,
  34992: 33446,
  34993: 39925,
  34994: 26771,
  34995: 22311,
  34996: 26017,
  34997: 25201,
  34998: 23451,
  34999: 22992,
  35e3: 34427,
  35001: 39156,
  35002: 32098,
  35003: 32190,
  35004: 39822,
  35005: 25110,
  35006: 31903,
  35007: 34999,
  35008: 23433,
  35009: 24245,
  35010: 25353,
  35011: 26263,
  35012: 26696,
  35013: 38343,
  35014: 38797,
  35015: 26447,
  35016: 20197,
  35017: 20234,
  35018: 20301,
  35019: 20381,
  35020: 20553,
  35021: 22258,
  35022: 22839,
  35023: 22996,
  35024: 23041,
  35025: 23561,
  35026: 24799,
  35027: 24847,
  35028: 24944,
  35029: 26131,
  35030: 26885,
  35031: 28858,
  35032: 30031,
  35033: 30064,
  35034: 31227,
  35035: 32173,
  35036: 32239,
  35037: 32963,
  35038: 33806,
  35039: 34915,
  35040: 35586,
  35041: 36949,
  35042: 36986,
  35043: 21307,
  35044: 20117,
  35045: 20133,
  35046: 22495,
  35047: 32946,
  35048: 37057,
  35049: 30959,
  35050: 19968,
  35051: 22769,
  35052: 28322,
  35053: 36920,
  35054: 31282,
  35055: 33576,
  35056: 33419,
  35057: 39983,
  35058: 20801,
  35059: 21360,
  35060: 21693,
  35061: 21729,
  35062: 22240,
  35063: 23035,
  35064: 24341,
  35065: 39154,
  35066: 28139,
  35067: 32996,
  35068: 34093,
  35136: 38498,
  35137: 38512,
  35138: 38560,
  35139: 38907,
  35140: 21515,
  35141: 21491,
  35142: 23431,
  35143: 28879,
  35144: 32701,
  35145: 36802,
  35146: 38632,
  35147: 21359,
  35148: 40284,
  35149: 31418,
  35150: 19985,
  35151: 30867,
  35152: 33276,
  35153: 28198,
  35154: 22040,
  35155: 21764,
  35156: 27421,
  35157: 34074,
  35158: 39995,
  35159: 23013,
  35160: 21417,
  35161: 28006,
  35162: 29916,
  35163: 38287,
  35164: 22082,
  35165: 20113,
  35166: 36939,
  35167: 38642,
  35168: 33615,
  35169: 39180,
  35170: 21473,
  35171: 21942,
  35172: 23344,
  35173: 24433,
  35174: 26144,
  35175: 26355,
  35176: 26628,
  35177: 27704,
  35178: 27891,
  35179: 27945,
  35180: 29787,
  35181: 30408,
  35182: 31310,
  35183: 38964,
  35184: 33521,
  35185: 34907,
  35186: 35424,
  35187: 37613,
  35188: 28082,
  35189: 30123,
  35190: 30410,
  35191: 39365,
  35192: 24742,
  35193: 35585,
  35194: 36234,
  35195: 38322,
  35196: 27022,
  35197: 21421,
  35198: 20870,
  35200: 22290,
  35201: 22576,
  35202: 22852,
  35203: 23476,
  35204: 24310,
  35205: 24616,
  35206: 25513,
  35207: 25588,
  35208: 27839,
  35209: 28436,
  35210: 28814,
  35211: 28948,
  35212: 29017,
  35213: 29141,
  35214: 29503,
  35215: 32257,
  35216: 33398,
  35217: 33489,
  35218: 34199,
  35219: 36960,
  35220: 37467,
  35221: 40219,
  35222: 22633,
  35223: 26044,
  35224: 27738,
  35225: 29989,
  35226: 20985,
  35227: 22830,
  35228: 22885,
  35229: 24448,
  35230: 24540,
  35231: 25276,
  35232: 26106,
  35233: 27178,
  35234: 27431,
  35235: 27572,
  35236: 29579,
  35237: 32705,
  35238: 35158,
  35239: 40236,
  35240: 40206,
  35241: 40644,
  35242: 23713,
  35243: 27798,
  35244: 33659,
  35245: 20740,
  35246: 23627,
  35247: 25014,
  35248: 33222,
  35249: 26742,
  35250: 29281,
  35251: 20057,
  35252: 20474,
  35253: 21368,
  35254: 24681,
  35255: 28201,
  35256: 31311,
  35257: 38899,
  35258: 19979,
  35259: 21270,
  35260: 20206,
  35261: 20309,
  35262: 20285,
  35263: 20385,
  35264: 20339,
  35265: 21152,
  35266: 21487,
  35267: 22025,
  35268: 22799,
  35269: 23233,
  35270: 23478,
  35271: 23521,
  35272: 31185,
  35273: 26247,
  35274: 26524,
  35275: 26550,
  35276: 27468,
  35277: 27827,
  35278: 28779,
  35279: 29634,
  35280: 31117,
  35281: 31166,
  35282: 31292,
  35283: 31623,
  35284: 33457,
  35285: 33499,
  35286: 33540,
  35287: 33655,
  35288: 33775,
  35289: 33747,
  35290: 34662,
  35291: 35506,
  35292: 22057,
  35293: 36008,
  35294: 36838,
  35295: 36942,
  35296: 38686,
  35297: 34442,
  35298: 20420,
  35299: 23784,
  35300: 25105,
  35301: 29273,
  35302: 30011,
  35303: 33253,
  35304: 33469,
  35305: 34558,
  35306: 36032,
  35307: 38597,
  35308: 39187,
  35309: 39381,
  35310: 20171,
  35311: 20250,
  35312: 35299,
  35313: 22238,
  35314: 22602,
  35315: 22730,
  35316: 24315,
  35317: 24555,
  35318: 24618,
  35319: 24724,
  35320: 24674,
  35321: 25040,
  35322: 25106,
  35323: 25296,
  35324: 25913,
  35392: 39745,
  35393: 26214,
  35394: 26800,
  35395: 28023,
  35396: 28784,
  35397: 30028,
  35398: 30342,
  35399: 32117,
  35400: 33445,
  35401: 34809,
  35402: 38283,
  35403: 38542,
  35404: 35997,
  35405: 20977,
  35406: 21182,
  35407: 22806,
  35408: 21683,
  35409: 23475,
  35410: 23830,
  35411: 24936,
  35412: 27010,
  35413: 28079,
  35414: 30861,
  35415: 33995,
  35416: 34903,
  35417: 35442,
  35418: 37799,
  35419: 39608,
  35420: 28012,
  35421: 39336,
  35422: 34521,
  35423: 22435,
  35424: 26623,
  35425: 34510,
  35426: 37390,
  35427: 21123,
  35428: 22151,
  35429: 21508,
  35430: 24275,
  35431: 25313,
  35432: 25785,
  35433: 26684,
  35434: 26680,
  35435: 27579,
  35436: 29554,
  35437: 30906,
  35438: 31339,
  35439: 35226,
  35440: 35282,
  35441: 36203,
  35442: 36611,
  35443: 37101,
  35444: 38307,
  35445: 38548,
  35446: 38761,
  35447: 23398,
  35448: 23731,
  35449: 27005,
  35450: 38989,
  35451: 38990,
  35452: 25499,
  35453: 31520,
  35454: 27179,
  35456: 27263,
  35457: 26806,
  35458: 39949,
  35459: 28511,
  35460: 21106,
  35461: 21917,
  35462: 24688,
  35463: 25324,
  35464: 27963,
  35465: 28167,
  35466: 28369,
  35467: 33883,
  35468: 35088,
  35469: 36676,
  35470: 19988,
  35471: 39993,
  35472: 21494,
  35473: 26907,
  35474: 27194,
  35475: 38788,
  35476: 26666,
  35477: 20828,
  35478: 31427,
  35479: 33970,
  35480: 37340,
  35481: 37772,
  35482: 22107,
  35483: 40232,
  35484: 26658,
  35485: 33541,
  35486: 33841,
  35487: 31909,
  35488: 21e3,
  35489: 33477,
  35490: 29926,
  35491: 20094,
  35492: 20355,
  35493: 20896,
  35494: 23506,
  35495: 21002,
  35496: 21208,
  35497: 21223,
  35498: 24059,
  35499: 21914,
  35500: 22570,
  35501: 23014,
  35502: 23436,
  35503: 23448,
  35504: 23515,
  35505: 24178,
  35506: 24185,
  35507: 24739,
  35508: 24863,
  35509: 24931,
  35510: 25022,
  35511: 25563,
  35512: 25954,
  35513: 26577,
  35514: 26707,
  35515: 26874,
  35516: 27454,
  35517: 27475,
  35518: 27735,
  35519: 28450,
  35520: 28567,
  35521: 28485,
  35522: 29872,
  35523: 29976,
  35524: 30435,
  35525: 30475,
  35526: 31487,
  35527: 31649,
  35528: 31777,
  35529: 32233,
  35530: 32566,
  35531: 32752,
  35532: 32925,
  35533: 33382,
  35534: 33694,
  35535: 35251,
  35536: 35532,
  35537: 36011,
  35538: 36996,
  35539: 37969,
  35540: 38291,
  35541: 38289,
  35542: 38306,
  35543: 38501,
  35544: 38867,
  35545: 39208,
  35546: 33304,
  35547: 20024,
  35548: 21547,
  35549: 23736,
  35550: 24012,
  35551: 29609,
  35552: 30284,
  35553: 30524,
  35554: 23721,
  35555: 32747,
  35556: 36107,
  35557: 38593,
  35558: 38929,
  35559: 38996,
  35560: 39e3,
  35561: 20225,
  35562: 20238,
  35563: 21361,
  35564: 21916,
  35565: 22120,
  35566: 22522,
  35567: 22855,
  35568: 23305,
  35569: 23492,
  35570: 23696,
  35571: 24076,
  35572: 24190,
  35573: 24524,
  35574: 25582,
  35575: 26426,
  35576: 26071,
  35577: 26082,
  35578: 26399,
  35579: 26827,
  35580: 26820,
  35648: 27231,
  35649: 24112,
  35650: 27589,
  35651: 27671,
  35652: 27773,
  35653: 30079,
  35654: 31048,
  35655: 23395,
  35656: 31232,
  35657: 32e3,
  35658: 24509,
  35659: 35215,
  35660: 35352,
  35661: 36020,
  35662: 36215,
  35663: 36556,
  35664: 36637,
  35665: 39138,
  35666: 39438,
  35667: 39740,
  35668: 20096,
  35669: 20605,
  35670: 20736,
  35671: 22931,
  35672: 23452,
  35673: 25135,
  35674: 25216,
  35675: 25836,
  35676: 27450,
  35677: 29344,
  35678: 30097,
  35679: 31047,
  35680: 32681,
  35681: 34811,
  35682: 35516,
  35683: 35696,
  35684: 25516,
  35685: 33738,
  35686: 38816,
  35687: 21513,
  35688: 21507,
  35689: 21931,
  35690: 26708,
  35691: 27224,
  35692: 35440,
  35693: 30759,
  35694: 26485,
  35695: 40653,
  35696: 21364,
  35697: 23458,
  35698: 33050,
  35699: 34384,
  35700: 36870,
  35701: 19992,
  35702: 20037,
  35703: 20167,
  35704: 20241,
  35705: 21450,
  35706: 21560,
  35707: 23470,
  35708: 24339,
  35709: 24613,
  35710: 25937,
  35712: 26429,
  35713: 27714,
  35714: 27762,
  35715: 27875,
  35716: 28792,
  35717: 29699,
  35718: 31350,
  35719: 31406,
  35720: 31496,
  35721: 32026,
  35722: 31998,
  35723: 32102,
  35724: 26087,
  35725: 29275,
  35726: 21435,
  35727: 23621,
  35728: 24040,
  35729: 25298,
  35730: 25312,
  35731: 25369,
  35732: 28192,
  35733: 34394,
  35734: 35377,
  35735: 36317,
  35736: 37624,
  35737: 28417,
  35738: 31142,
  35739: 39770,
  35740: 20136,
  35741: 20139,
  35742: 20140,
  35743: 20379,
  35744: 20384,
  35745: 20689,
  35746: 20807,
  35747: 31478,
  35748: 20849,
  35749: 20982,
  35750: 21332,
  35751: 21281,
  35752: 21375,
  35753: 21483,
  35754: 21932,
  35755: 22659,
  35756: 23777,
  35757: 24375,
  35758: 24394,
  35759: 24623,
  35760: 24656,
  35761: 24685,
  35762: 25375,
  35763: 25945,
  35764: 27211,
  35765: 27841,
  35766: 29378,
  35767: 29421,
  35768: 30703,
  35769: 33016,
  35770: 33029,
  35771: 33288,
  35772: 34126,
  35773: 37111,
  35774: 37857,
  35775: 38911,
  35776: 39255,
  35777: 39514,
  35778: 20208,
  35779: 20957,
  35780: 23597,
  35781: 26241,
  35782: 26989,
  35783: 23616,
  35784: 26354,
  35785: 26997,
  35786: 29577,
  35787: 26704,
  35788: 31873,
  35789: 20677,
  35790: 21220,
  35791: 22343,
  35792: 24062,
  35793: 37670,
  35794: 26020,
  35795: 27427,
  35796: 27453,
  35797: 29748,
  35798: 31105,
  35799: 31165,
  35800: 31563,
  35801: 32202,
  35802: 33465,
  35803: 33740,
  35804: 34943,
  35805: 35167,
  35806: 35641,
  35807: 36817,
  35808: 37329,
  35809: 21535,
  35810: 37504,
  35811: 20061,
  35812: 20534,
  35813: 21477,
  35814: 21306,
  35815: 29399,
  35816: 29590,
  35817: 30697,
  35818: 33510,
  35819: 36527,
  35820: 39366,
  35821: 39368,
  35822: 39378,
  35823: 20855,
  35824: 24858,
  35825: 34398,
  35826: 21936,
  35827: 31354,
  35828: 20598,
  35829: 23507,
  35830: 36935,
  35831: 38533,
  35832: 20018,
  35833: 27355,
  35834: 37351,
  35835: 23633,
  35836: 23624,
  35904: 25496,
  35905: 31391,
  35906: 27795,
  35907: 38772,
  35908: 36705,
  35909: 31402,
  35910: 29066,
  35911: 38536,
  35912: 31874,
  35913: 26647,
  35914: 32368,
  35915: 26705,
  35916: 37740,
  35917: 21234,
  35918: 21531,
  35919: 34219,
  35920: 35347,
  35921: 32676,
  35922: 36557,
  35923: 37089,
  35924: 21350,
  35925: 34952,
  35926: 31041,
  35927: 20418,
  35928: 20670,
  35929: 21009,
  35930: 20804,
  35931: 21843,
  35932: 22317,
  35933: 29674,
  35934: 22411,
  35935: 22865,
  35936: 24418,
  35937: 24452,
  35938: 24693,
  35939: 24950,
  35940: 24935,
  35941: 25001,
  35942: 25522,
  35943: 25658,
  35944: 25964,
  35945: 26223,
  35946: 26690,
  35947: 28179,
  35948: 30054,
  35949: 31293,
  35950: 31995,
  35951: 32076,
  35952: 32153,
  35953: 32331,
  35954: 32619,
  35955: 33550,
  35956: 33610,
  35957: 34509,
  35958: 35336,
  35959: 35427,
  35960: 35686,
  35961: 36605,
  35962: 38938,
  35963: 40335,
  35964: 33464,
  35965: 36814,
  35966: 39912,
  35968: 21127,
  35969: 25119,
  35970: 25731,
  35971: 28608,
  35972: 38553,
  35973: 26689,
  35974: 20625,
  35975: 27424,
  35976: 27770,
  35977: 28500,
  35978: 31348,
  35979: 32080,
  35980: 34880,
  35981: 35363,
  35982: 26376,
  35983: 20214,
  35984: 20537,
  35985: 20518,
  35986: 20581,
  35987: 20860,
  35988: 21048,
  35989: 21091,
  35990: 21927,
  35991: 22287,
  35992: 22533,
  35993: 23244,
  35994: 24314,
  35995: 25010,
  35996: 25080,
  35997: 25331,
  35998: 25458,
  35999: 26908,
  36e3: 27177,
  36001: 29309,
  36002: 29356,
  36003: 29486,
  36004: 30740,
  36005: 30831,
  36006: 32121,
  36007: 30476,
  36008: 32937,
  36009: 35211,
  36010: 35609,
  36011: 36066,
  36012: 36562,
  36013: 36963,
  36014: 37749,
  36015: 38522,
  36016: 38997,
  36017: 39443,
  36018: 40568,
  36019: 20803,
  36020: 21407,
  36021: 21427,
  36022: 24187,
  36023: 24358,
  36024: 28187,
  36025: 28304,
  36026: 29572,
  36027: 29694,
  36028: 32067,
  36029: 33335,
  36030: 35328,
  36031: 35578,
  36032: 38480,
  36033: 20046,
  36034: 20491,
  36035: 21476,
  36036: 21628,
  36037: 22266,
  36038: 22993,
  36039: 23396,
  36040: 24049,
  36041: 24235,
  36042: 24359,
  36043: 25144,
  36044: 25925,
  36045: 26543,
  36046: 28246,
  36047: 29392,
  36048: 31946,
  36049: 34996,
  36050: 32929,
  36051: 32993,
  36052: 33776,
  36053: 34382,
  36054: 35463,
  36055: 36328,
  36056: 37431,
  36057: 38599,
  36058: 39015,
  36059: 40723,
  36060: 20116,
  36061: 20114,
  36062: 20237,
  36063: 21320,
  36064: 21577,
  36065: 21566,
  36066: 23087,
  36067: 24460,
  36068: 24481,
  36069: 24735,
  36070: 26791,
  36071: 27278,
  36072: 29786,
  36073: 30849,
  36074: 35486,
  36075: 35492,
  36076: 35703,
  36077: 37264,
  36078: 20062,
  36079: 39881,
  36080: 20132,
  36081: 20348,
  36082: 20399,
  36083: 20505,
  36084: 20502,
  36085: 20809,
  36086: 20844,
  36087: 21151,
  36088: 21177,
  36089: 21246,
  36090: 21402,
  36091: 21475,
  36092: 21521,
  36160: 21518,
  36161: 21897,
  36162: 22353,
  36163: 22434,
  36164: 22909,
  36165: 23380,
  36166: 23389,
  36167: 23439,
  36168: 24037,
  36169: 24039,
  36170: 24055,
  36171: 24184,
  36172: 24195,
  36173: 24218,
  36174: 24247,
  36175: 24344,
  36176: 24658,
  36177: 24908,
  36178: 25239,
  36179: 25304,
  36180: 25511,
  36181: 25915,
  36182: 26114,
  36183: 26179,
  36184: 26356,
  36185: 26477,
  36186: 26657,
  36187: 26775,
  36188: 27083,
  36189: 27743,
  36190: 27946,
  36191: 28009,
  36192: 28207,
  36193: 28317,
  36194: 30002,
  36195: 30343,
  36196: 30828,
  36197: 31295,
  36198: 31968,
  36199: 32005,
  36200: 32024,
  36201: 32094,
  36202: 32177,
  36203: 32789,
  36204: 32771,
  36205: 32943,
  36206: 32945,
  36207: 33108,
  36208: 33167,
  36209: 33322,
  36210: 33618,
  36211: 34892,
  36212: 34913,
  36213: 35611,
  36214: 36002,
  36215: 36092,
  36216: 37066,
  36217: 37237,
  36218: 37489,
  36219: 30783,
  36220: 37628,
  36221: 38308,
  36222: 38477,
  36224: 38917,
  36225: 39321,
  36226: 39640,
  36227: 40251,
  36228: 21083,
  36229: 21163,
  36230: 21495,
  36231: 21512,
  36232: 22741,
  36233: 25335,
  36234: 28640,
  36235: 35946,
  36236: 36703,
  36237: 40633,
  36238: 20811,
  36239: 21051,
  36240: 21578,
  36241: 22269,
  36242: 31296,
  36243: 37239,
  36244: 40288,
  36245: 40658,
  36246: 29508,
  36247: 28425,
  36248: 33136,
  36249: 29969,
  36250: 24573,
  36251: 24794,
  36252: 39592,
  36253: 29403,
  36254: 36796,
  36255: 27492,
  36256: 38915,
  36257: 20170,
  36258: 22256,
  36259: 22372,
  36260: 22718,
  36261: 23130,
  36262: 24680,
  36263: 25031,
  36264: 26127,
  36265: 26118,
  36266: 26681,
  36267: 26801,
  36268: 28151,
  36269: 30165,
  36270: 32058,
  36271: 33390,
  36272: 39746,
  36273: 20123,
  36274: 20304,
  36275: 21449,
  36276: 21766,
  36277: 23919,
  36278: 24038,
  36279: 24046,
  36280: 26619,
  36281: 27801,
  36282: 29811,
  36283: 30722,
  36284: 35408,
  36285: 37782,
  36286: 35039,
  36287: 22352,
  36288: 24231,
  36289: 25387,
  36290: 20661,
  36291: 20652,
  36292: 20877,
  36293: 26368,
  36294: 21705,
  36295: 22622,
  36296: 22971,
  36297: 23472,
  36298: 24425,
  36299: 25165,
  36300: 25505,
  36301: 26685,
  36302: 27507,
  36303: 28168,
  36304: 28797,
  36305: 37319,
  36306: 29312,
  36307: 30741,
  36308: 30758,
  36309: 31085,
  36310: 25998,
  36311: 32048,
  36312: 33756,
  36313: 35009,
  36314: 36617,
  36315: 38555,
  36316: 21092,
  36317: 22312,
  36318: 26448,
  36319: 32618,
  36320: 36001,
  36321: 20916,
  36322: 22338,
  36323: 38442,
  36324: 22586,
  36325: 27018,
  36326: 32948,
  36327: 21682,
  36328: 23822,
  36329: 22524,
  36330: 30869,
  36331: 40442,
  36332: 20316,
  36333: 21066,
  36334: 21643,
  36335: 25662,
  36336: 26152,
  36337: 26388,
  36338: 26613,
  36339: 31364,
  36340: 31574,
  36341: 32034,
  36342: 37679,
  36343: 26716,
  36344: 39853,
  36345: 31545,
  36346: 21273,
  36347: 20874,
  36348: 21047,
  36416: 23519,
  36417: 25334,
  36418: 25774,
  36419: 25830,
  36420: 26413,
  36421: 27578,
  36422: 34217,
  36423: 38609,
  36424: 30352,
  36425: 39894,
  36426: 25420,
  36427: 37638,
  36428: 39851,
  36429: 30399,
  36430: 26194,
  36431: 19977,
  36432: 20632,
  36433: 21442,
  36434: 23665,
  36435: 24808,
  36436: 25746,
  36437: 25955,
  36438: 26719,
  36439: 29158,
  36440: 29642,
  36441: 29987,
  36442: 31639,
  36443: 32386,
  36444: 34453,
  36445: 35715,
  36446: 36059,
  36447: 37240,
  36448: 39184,
  36449: 26028,
  36450: 26283,
  36451: 27531,
  36452: 20181,
  36453: 20180,
  36454: 20282,
  36455: 20351,
  36456: 21050,
  36457: 21496,
  36458: 21490,
  36459: 21987,
  36460: 22235,
  36461: 22763,
  36462: 22987,
  36463: 22985,
  36464: 23039,
  36465: 23376,
  36466: 23629,
  36467: 24066,
  36468: 24107,
  36469: 24535,
  36470: 24605,
  36471: 25351,
  36472: 25903,
  36473: 23388,
  36474: 26031,
  36475: 26045,
  36476: 26088,
  36477: 26525,
  36478: 27490,
  36480: 27515,
  36481: 27663,
  36482: 29509,
  36483: 31049,
  36484: 31169,
  36485: 31992,
  36486: 32025,
  36487: 32043,
  36488: 32930,
  36489: 33026,
  36490: 33267,
  36491: 35222,
  36492: 35422,
  36493: 35433,
  36494: 35430,
  36495: 35468,
  36496: 35566,
  36497: 36039,
  36498: 36060,
  36499: 38604,
  36500: 39164,
  36501: 27503,
  36502: 20107,
  36503: 20284,
  36504: 20365,
  36505: 20816,
  36506: 23383,
  36507: 23546,
  36508: 24904,
  36509: 25345,
  36510: 26178,
  36511: 27425,
  36512: 28363,
  36513: 27835,
  36514: 29246,
  36515: 29885,
  36516: 30164,
  36517: 30913,
  36518: 31034,
  36519: 32780,
  36520: 32819,
  36521: 33258,
  36522: 33940,
  36523: 36766,
  36524: 27728,
  36525: 40575,
  36526: 24335,
  36527: 35672,
  36528: 40235,
  36529: 31482,
  36530: 36600,
  36531: 23437,
  36532: 38635,
  36533: 19971,
  36534: 21489,
  36535: 22519,
  36536: 22833,
  36537: 23241,
  36538: 23460,
  36539: 24713,
  36540: 28287,
  36541: 28422,
  36542: 30142,
  36543: 36074,
  36544: 23455,
  36545: 34048,
  36546: 31712,
  36547: 20594,
  36548: 26612,
  36549: 33437,
  36550: 23649,
  36551: 34122,
  36552: 32286,
  36553: 33294,
  36554: 20889,
  36555: 23556,
  36556: 25448,
  36557: 36198,
  36558: 26012,
  36559: 29038,
  36560: 31038,
  36561: 32023,
  36562: 32773,
  36563: 35613,
  36564: 36554,
  36565: 36974,
  36566: 34503,
  36567: 37034,
  36568: 20511,
  36569: 21242,
  36570: 23610,
  36571: 26451,
  36572: 28796,
  36573: 29237,
  36574: 37196,
  36575: 37320,
  36576: 37675,
  36577: 33509,
  36578: 23490,
  36579: 24369,
  36580: 24825,
  36581: 20027,
  36582: 21462,
  36583: 23432,
  36584: 25163,
  36585: 26417,
  36586: 27530,
  36587: 29417,
  36588: 29664,
  36589: 31278,
  36590: 33131,
  36591: 36259,
  36592: 37202,
  36593: 39318,
  36594: 20754,
  36595: 21463,
  36596: 21610,
  36597: 23551,
  36598: 25480,
  36599: 27193,
  36600: 32172,
  36601: 38656,
  36602: 22234,
  36603: 21454,
  36604: 21608,
  36672: 23447,
  36673: 23601,
  36674: 24030,
  36675: 20462,
  36676: 24833,
  36677: 25342,
  36678: 27954,
  36679: 31168,
  36680: 31179,
  36681: 32066,
  36682: 32333,
  36683: 32722,
  36684: 33261,
  36685: 33311,
  36686: 33936,
  36687: 34886,
  36688: 35186,
  36689: 35728,
  36690: 36468,
  36691: 36655,
  36692: 36913,
  36693: 37195,
  36694: 37228,
  36695: 38598,
  36696: 37276,
  36697: 20160,
  36698: 20303,
  36699: 20805,
  36700: 21313,
  36701: 24467,
  36702: 25102,
  36703: 26580,
  36704: 27713,
  36705: 28171,
  36706: 29539,
  36707: 32294,
  36708: 37325,
  36709: 37507,
  36710: 21460,
  36711: 22809,
  36712: 23487,
  36713: 28113,
  36714: 31069,
  36715: 32302,
  36716: 31899,
  36717: 22654,
  36718: 29087,
  36719: 20986,
  36720: 34899,
  36721: 36848,
  36722: 20426,
  36723: 23803,
  36724: 26149,
  36725: 30636,
  36726: 31459,
  36727: 33308,
  36728: 39423,
  36729: 20934,
  36730: 24490,
  36731: 26092,
  36732: 26991,
  36733: 27529,
  36734: 28147,
  36736: 28310,
  36737: 28516,
  36738: 30462,
  36739: 32020,
  36740: 24033,
  36741: 36981,
  36742: 37255,
  36743: 38918,
  36744: 20966,
  36745: 21021,
  36746: 25152,
  36747: 26257,
  36748: 26329,
  36749: 28186,
  36750: 24246,
  36751: 32210,
  36752: 32626,
  36753: 26360,
  36754: 34223,
  36755: 34295,
  36756: 35576,
  36757: 21161,
  36758: 21465,
  36759: 22899,
  36760: 24207,
  36761: 24464,
  36762: 24661,
  36763: 37604,
  36764: 38500,
  36765: 20663,
  36766: 20767,
  36767: 21213,
  36768: 21280,
  36769: 21319,
  36770: 21484,
  36771: 21736,
  36772: 21830,
  36773: 21809,
  36774: 22039,
  36775: 22888,
  36776: 22974,
  36777: 23100,
  36778: 23477,
  36779: 23558,
  36780: 23567,
  36781: 23569,
  36782: 23578,
  36783: 24196,
  36784: 24202,
  36785: 24288,
  36786: 24432,
  36787: 25215,
  36788: 25220,
  36789: 25307,
  36790: 25484,
  36791: 25463,
  36792: 26119,
  36793: 26124,
  36794: 26157,
  36795: 26230,
  36796: 26494,
  36797: 26786,
  36798: 27167,
  36799: 27189,
  36800: 27836,
  36801: 28040,
  36802: 28169,
  36803: 28248,
  36804: 28988,
  36805: 28966,
  36806: 29031,
  36807: 30151,
  36808: 30465,
  36809: 30813,
  36810: 30977,
  36811: 31077,
  36812: 31216,
  36813: 31456,
  36814: 31505,
  36815: 31911,
  36816: 32057,
  36817: 32918,
  36818: 33750,
  36819: 33931,
  36820: 34121,
  36821: 34909,
  36822: 35059,
  36823: 35359,
  36824: 35388,
  36825: 35412,
  36826: 35443,
  36827: 35937,
  36828: 36062,
  36829: 37284,
  36830: 37478,
  36831: 37758,
  36832: 37912,
  36833: 38556,
  36834: 38808,
  36835: 19978,
  36836: 19976,
  36837: 19998,
  36838: 20055,
  36839: 20887,
  36840: 21104,
  36841: 22478,
  36842: 22580,
  36843: 22732,
  36844: 23330,
  36845: 24120,
  36846: 24773,
  36847: 25854,
  36848: 26465,
  36849: 26454,
  36850: 27972,
  36851: 29366,
  36852: 30067,
  36853: 31331,
  36854: 33976,
  36855: 35698,
  36856: 37304,
  36857: 37664,
  36858: 22065,
  36859: 22516,
  36860: 39166,
  36928: 25325,
  36929: 26893,
  36930: 27542,
  36931: 29165,
  36932: 32340,
  36933: 32887,
  36934: 33394,
  36935: 35302,
  36936: 39135,
  36937: 34645,
  36938: 36785,
  36939: 23611,
  36940: 20280,
  36941: 20449,
  36942: 20405,
  36943: 21767,
  36944: 23072,
  36945: 23517,
  36946: 23529,
  36947: 24515,
  36948: 24910,
  36949: 25391,
  36950: 26032,
  36951: 26187,
  36952: 26862,
  36953: 27035,
  36954: 28024,
  36955: 28145,
  36956: 30003,
  36957: 30137,
  36958: 30495,
  36959: 31070,
  36960: 31206,
  36961: 32051,
  36962: 33251,
  36963: 33455,
  36964: 34218,
  36965: 35242,
  36966: 35386,
  36967: 36523,
  36968: 36763,
  36969: 36914,
  36970: 37341,
  36971: 38663,
  36972: 20154,
  36973: 20161,
  36974: 20995,
  36975: 22645,
  36976: 22764,
  36977: 23563,
  36978: 29978,
  36979: 23613,
  36980: 33102,
  36981: 35338,
  36982: 36805,
  36983: 38499,
  36984: 38765,
  36985: 31525,
  36986: 35535,
  36987: 38920,
  36988: 37218,
  36989: 22259,
  36990: 21416,
  36992: 36887,
  36993: 21561,
  36994: 22402,
  36995: 24101,
  36996: 25512,
  36997: 27700,
  36998: 28810,
  36999: 30561,
  37e3: 31883,
  37001: 32736,
  37002: 34928,
  37003: 36930,
  37004: 37204,
  37005: 37648,
  37006: 37656,
  37007: 38543,
  37008: 29790,
  37009: 39620,
  37010: 23815,
  37011: 23913,
  37012: 25968,
  37013: 26530,
  37014: 36264,
  37015: 38619,
  37016: 25454,
  37017: 26441,
  37018: 26905,
  37019: 33733,
  37020: 38935,
  37021: 38592,
  37022: 35070,
  37023: 28548,
  37024: 25722,
  37025: 23544,
  37026: 19990,
  37027: 28716,
  37028: 30045,
  37029: 26159,
  37030: 20932,
  37031: 21046,
  37032: 21218,
  37033: 22995,
  37034: 24449,
  37035: 24615,
  37036: 25104,
  37037: 25919,
  37038: 25972,
  37039: 26143,
  37040: 26228,
  37041: 26866,
  37042: 26646,
  37043: 27491,
  37044: 28165,
  37045: 29298,
  37046: 29983,
  37047: 30427,
  37048: 31934,
  37049: 32854,
  37050: 22768,
  37051: 35069,
  37052: 35199,
  37053: 35488,
  37054: 35475,
  37055: 35531,
  37056: 36893,
  37057: 37266,
  37058: 38738,
  37059: 38745,
  37060: 25993,
  37061: 31246,
  37062: 33030,
  37063: 38587,
  37064: 24109,
  37065: 24796,
  37066: 25114,
  37067: 26021,
  37068: 26132,
  37069: 26512,
  37070: 30707,
  37071: 31309,
  37072: 31821,
  37073: 32318,
  37074: 33034,
  37075: 36012,
  37076: 36196,
  37077: 36321,
  37078: 36447,
  37079: 30889,
  37080: 20999,
  37081: 25305,
  37082: 25509,
  37083: 25666,
  37084: 25240,
  37085: 35373,
  37086: 31363,
  37087: 31680,
  37088: 35500,
  37089: 38634,
  37090: 32118,
  37091: 33292,
  37092: 34633,
  37093: 20185,
  37094: 20808,
  37095: 21315,
  37096: 21344,
  37097: 23459,
  37098: 23554,
  37099: 23574,
  37100: 24029,
  37101: 25126,
  37102: 25159,
  37103: 25776,
  37104: 26643,
  37105: 26676,
  37106: 27849,
  37107: 27973,
  37108: 27927,
  37109: 26579,
  37110: 28508,
  37111: 29006,
  37112: 29053,
  37113: 26059,
  37114: 31359,
  37115: 31661,
  37116: 32218,
  37184: 32330,
  37185: 32680,
  37186: 33146,
  37187: 33307,
  37188: 33337,
  37189: 34214,
  37190: 35438,
  37191: 36046,
  37192: 36341,
  37193: 36984,
  37194: 36983,
  37195: 37549,
  37196: 37521,
  37197: 38275,
  37198: 39854,
  37199: 21069,
  37200: 21892,
  37201: 28472,
  37202: 28982,
  37203: 20840,
  37204: 31109,
  37205: 32341,
  37206: 33203,
  37207: 31950,
  37208: 22092,
  37209: 22609,
  37210: 23720,
  37211: 25514,
  37212: 26366,
  37213: 26365,
  37214: 26970,
  37215: 29401,
  37216: 30095,
  37217: 30094,
  37218: 30990,
  37219: 31062,
  37220: 31199,
  37221: 31895,
  37222: 32032,
  37223: 32068,
  37224: 34311,
  37225: 35380,
  37226: 38459,
  37227: 36961,
  37228: 40736,
  37229: 20711,
  37230: 21109,
  37231: 21452,
  37232: 21474,
  37233: 20489,
  37234: 21930,
  37235: 22766,
  37236: 22863,
  37237: 29245,
  37238: 23435,
  37239: 23652,
  37240: 21277,
  37241: 24803,
  37242: 24819,
  37243: 25436,
  37244: 25475,
  37245: 25407,
  37246: 25531,
  37248: 25805,
  37249: 26089,
  37250: 26361,
  37251: 24035,
  37252: 27085,
  37253: 27133,
  37254: 28437,
  37255: 29157,
  37256: 20105,
  37257: 30185,
  37258: 30456,
  37259: 31379,
  37260: 31967,
  37261: 32207,
  37262: 32156,
  37263: 32865,
  37264: 33609,
  37265: 33624,
  37266: 33900,
  37267: 33980,
  37268: 34299,
  37269: 35013,
  37270: 36208,
  37271: 36865,
  37272: 36973,
  37273: 37783,
  37274: 38684,
  37275: 39442,
  37276: 20687,
  37277: 22679,
  37278: 24974,
  37279: 33235,
  37280: 34101,
  37281: 36104,
  37282: 36896,
  37283: 20419,
  37284: 20596,
  37285: 21063,
  37286: 21363,
  37287: 24687,
  37288: 25417,
  37289: 26463,
  37290: 28204,
  37291: 36275,
  37292: 36895,
  37293: 20439,
  37294: 23646,
  37295: 36042,
  37296: 26063,
  37297: 32154,
  37298: 21330,
  37299: 34966,
  37300: 20854,
  37301: 25539,
  37302: 23384,
  37303: 23403,
  37304: 23562,
  37305: 25613,
  37306: 26449,
  37307: 36956,
  37308: 20182,
  37309: 22810,
  37310: 22826,
  37311: 27760,
  37312: 35409,
  37313: 21822,
  37314: 22549,
  37315: 22949,
  37316: 24816,
  37317: 25171,
  37318: 26561,
  37319: 33333,
  37320: 26965,
  37321: 38464,
  37322: 39364,
  37323: 39464,
  37324: 20307,
  37325: 22534,
  37326: 23550,
  37327: 32784,
  37328: 23729,
  37329: 24111,
  37330: 24453,
  37331: 24608,
  37332: 24907,
  37333: 25140,
  37334: 26367,
  37335: 27888,
  37336: 28382,
  37337: 32974,
  37338: 33151,
  37339: 33492,
  37340: 34955,
  37341: 36024,
  37342: 36864,
  37343: 36910,
  37344: 38538,
  37345: 40667,
  37346: 39899,
  37347: 20195,
  37348: 21488,
  37349: 22823,
  37350: 31532,
  37351: 37261,
  37352: 38988,
  37353: 40441,
  37354: 28381,
  37355: 28711,
  37356: 21331,
  37357: 21828,
  37358: 23429,
  37359: 25176,
  37360: 25246,
  37361: 25299,
  37362: 27810,
  37363: 28655,
  37364: 29730,
  37365: 35351,
  37366: 37944,
  37367: 28609,
  37368: 35582,
  37369: 33592,
  37370: 20967,
  37371: 34552,
  37372: 21482,
  37440: 21481,
  37441: 20294,
  37442: 36948,
  37443: 36784,
  37444: 22890,
  37445: 33073,
  37446: 24061,
  37447: 31466,
  37448: 36799,
  37449: 26842,
  37450: 35895,
  37451: 29432,
  37452: 40008,
  37453: 27197,
  37454: 35504,
  37455: 20025,
  37456: 21336,
  37457: 22022,
  37458: 22374,
  37459: 25285,
  37460: 25506,
  37461: 26086,
  37462: 27470,
  37463: 28129,
  37464: 28251,
  37465: 28845,
  37466: 30701,
  37467: 31471,
  37468: 31658,
  37469: 32187,
  37470: 32829,
  37471: 32966,
  37472: 34507,
  37473: 35477,
  37474: 37723,
  37475: 22243,
  37476: 22727,
  37477: 24382,
  37478: 26029,
  37479: 26262,
  37480: 27264,
  37481: 27573,
  37482: 30007,
  37483: 35527,
  37484: 20516,
  37485: 30693,
  37486: 22320,
  37487: 24347,
  37488: 24677,
  37489: 26234,
  37490: 27744,
  37491: 30196,
  37492: 31258,
  37493: 32622,
  37494: 33268,
  37495: 34584,
  37496: 36933,
  37497: 39347,
  37498: 31689,
  37499: 30044,
  37500: 31481,
  37501: 31569,
  37502: 33988,
  37504: 36880,
  37505: 31209,
  37506: 31378,
  37507: 33590,
  37508: 23265,
  37509: 30528,
  37510: 20013,
  37511: 20210,
  37512: 23449,
  37513: 24544,
  37514: 25277,
  37515: 26172,
  37516: 26609,
  37517: 27880,
  37518: 34411,
  37519: 34935,
  37520: 35387,
  37521: 37198,
  37522: 37619,
  37523: 39376,
  37524: 27159,
  37525: 28710,
  37526: 29482,
  37527: 33511,
  37528: 33879,
  37529: 36015,
  37530: 19969,
  37531: 20806,
  37532: 20939,
  37533: 21899,
  37534: 23541,
  37535: 24086,
  37536: 24115,
  37537: 24193,
  37538: 24340,
  37539: 24373,
  37540: 24427,
  37541: 24500,
  37542: 25074,
  37543: 25361,
  37544: 26274,
  37545: 26397,
  37546: 28526,
  37547: 29266,
  37548: 30010,
  37549: 30522,
  37550: 32884,
  37551: 33081,
  37552: 33144,
  37553: 34678,
  37554: 35519,
  37555: 35548,
  37556: 36229,
  37557: 36339,
  37558: 37530,
  37559: 38263,
  37560: 38914,
  37561: 40165,
  37562: 21189,
  37563: 25431,
  37564: 30452,
  37565: 26389,
  37566: 27784,
  37567: 29645,
  37568: 36035,
  37569: 37806,
  37570: 38515,
  37571: 27941,
  37572: 22684,
  37573: 26894,
  37574: 27084,
  37575: 36861,
  37576: 37786,
  37577: 30171,
  37578: 36890,
  37579: 22618,
  37580: 26626,
  37581: 25524,
  37582: 27131,
  37583: 20291,
  37584: 28460,
  37585: 26584,
  37586: 36795,
  37587: 34086,
  37588: 32180,
  37589: 37716,
  37590: 26943,
  37591: 28528,
  37592: 22378,
  37593: 22775,
  37594: 23340,
  37595: 32044,
  37596: 29226,
  37597: 21514,
  37598: 37347,
  37599: 40372,
  37600: 20141,
  37601: 20302,
  37602: 20572,
  37603: 20597,
  37604: 21059,
  37605: 35998,
  37606: 21576,
  37607: 22564,
  37608: 23450,
  37609: 24093,
  37610: 24213,
  37611: 24237,
  37612: 24311,
  37613: 24351,
  37614: 24716,
  37615: 25269,
  37616: 25402,
  37617: 25552,
  37618: 26799,
  37619: 27712,
  37620: 30855,
  37621: 31118,
  37622: 31243,
  37623: 32224,
  37624: 33351,
  37625: 35330,
  37626: 35558,
  37627: 36420,
  37628: 36883,
  37696: 37048,
  37697: 37165,
  37698: 37336,
  37699: 40718,
  37700: 27877,
  37701: 25688,
  37702: 25826,
  37703: 25973,
  37704: 28404,
  37705: 30340,
  37706: 31515,
  37707: 36969,
  37708: 37841,
  37709: 28346,
  37710: 21746,
  37711: 24505,
  37712: 25764,
  37713: 36685,
  37714: 36845,
  37715: 37444,
  37716: 20856,
  37717: 22635,
  37718: 22825,
  37719: 23637,
  37720: 24215,
  37721: 28155,
  37722: 32399,
  37723: 29980,
  37724: 36028,
  37725: 36578,
  37726: 39003,
  37727: 28857,
  37728: 20253,
  37729: 27583,
  37730: 28593,
  37731: 3e4,
  37732: 38651,
  37733: 20814,
  37734: 21520,
  37735: 22581,
  37736: 22615,
  37737: 22956,
  37738: 23648,
  37739: 24466,
  37740: 26007,
  37741: 26460,
  37742: 28193,
  37743: 30331,
  37744: 33759,
  37745: 36077,
  37746: 36884,
  37747: 37117,
  37748: 37709,
  37749: 30757,
  37750: 30778,
  37751: 21162,
  37752: 24230,
  37753: 22303,
  37754: 22900,
  37755: 24594,
  37756: 20498,
  37757: 20826,
  37758: 20908,
  37760: 20941,
  37761: 20992,
  37762: 21776,
  37763: 22612,
  37764: 22616,
  37765: 22871,
  37766: 23445,
  37767: 23798,
  37768: 23947,
  37769: 24764,
  37770: 25237,
  37771: 25645,
  37772: 26481,
  37773: 26691,
  37774: 26812,
  37775: 26847,
  37776: 30423,
  37777: 28120,
  37778: 28271,
  37779: 28059,
  37780: 28783,
  37781: 29128,
  37782: 24403,
  37783: 30168,
  37784: 31095,
  37785: 31561,
  37786: 31572,
  37787: 31570,
  37788: 31958,
  37789: 32113,
  37790: 21040,
  37791: 33891,
  37792: 34153,
  37793: 34276,
  37794: 35342,
  37795: 35588,
  37796: 35910,
  37797: 36367,
  37798: 36867,
  37799: 36879,
  37800: 37913,
  37801: 38518,
  37802: 38957,
  37803: 39472,
  37804: 38360,
  37805: 20685,
  37806: 21205,
  37807: 21516,
  37808: 22530,
  37809: 23566,
  37810: 24999,
  37811: 25758,
  37812: 27934,
  37813: 30643,
  37814: 31461,
  37815: 33012,
  37816: 33796,
  37817: 36947,
  37818: 37509,
  37819: 23776,
  37820: 40199,
  37821: 21311,
  37822: 24471,
  37823: 24499,
  37824: 28060,
  37825: 29305,
  37826: 30563,
  37827: 31167,
  37828: 31716,
  37829: 27602,
  37830: 29420,
  37831: 35501,
  37832: 26627,
  37833: 27233,
  37834: 20984,
  37835: 31361,
  37836: 26932,
  37837: 23626,
  37838: 40182,
  37839: 33515,
  37840: 23493,
  37841: 37193,
  37842: 28702,
  37843: 22136,
  37844: 23663,
  37845: 24775,
  37846: 25958,
  37847: 27788,
  37848: 35930,
  37849: 36929,
  37850: 38931,
  37851: 21585,
  37852: 26311,
  37853: 37389,
  37854: 22856,
  37855: 37027,
  37856: 20869,
  37857: 20045,
  37858: 20970,
  37859: 34201,
  37860: 35598,
  37861: 28760,
  37862: 25466,
  37863: 37707,
  37864: 26978,
  37865: 39348,
  37866: 32260,
  37867: 30071,
  37868: 21335,
  37869: 26976,
  37870: 36575,
  37871: 38627,
  37872: 27741,
  37873: 20108,
  37874: 23612,
  37875: 24336,
  37876: 36841,
  37877: 21250,
  37878: 36049,
  37879: 32905,
  37880: 34425,
  37881: 24319,
  37882: 26085,
  37883: 20083,
  37884: 20837,
  37952: 22914,
  37953: 23615,
  37954: 38894,
  37955: 20219,
  37956: 22922,
  37957: 24525,
  37958: 35469,
  37959: 28641,
  37960: 31152,
  37961: 31074,
  37962: 23527,
  37963: 33905,
  37964: 29483,
  37965: 29105,
  37966: 24180,
  37967: 24565,
  37968: 25467,
  37969: 25754,
  37970: 29123,
  37971: 31896,
  37972: 20035,
  37973: 24316,
  37974: 20043,
  37975: 22492,
  37976: 22178,
  37977: 24745,
  37978: 28611,
  37979: 32013,
  37980: 33021,
  37981: 33075,
  37982: 33215,
  37983: 36786,
  37984: 35223,
  37985: 34468,
  37986: 24052,
  37987: 25226,
  37988: 25773,
  37989: 35207,
  37990: 26487,
  37991: 27874,
  37992: 27966,
  37993: 29750,
  37994: 30772,
  37995: 23110,
  37996: 32629,
  37997: 33453,
  37998: 39340,
  37999: 20467,
  38e3: 24259,
  38001: 25309,
  38002: 25490,
  38003: 25943,
  38004: 26479,
  38005: 30403,
  38006: 29260,
  38007: 32972,
  38008: 32954,
  38009: 36649,
  38010: 37197,
  38011: 20493,
  38012: 22521,
  38013: 23186,
  38014: 26757,
  38016: 26995,
  38017: 29028,
  38018: 29437,
  38019: 36023,
  38020: 22770,
  38021: 36064,
  38022: 38506,
  38023: 36889,
  38024: 34687,
  38025: 31204,
  38026: 30695,
  38027: 33833,
  38028: 20271,
  38029: 21093,
  38030: 21338,
  38031: 25293,
  38032: 26575,
  38033: 27850,
  38034: 30333,
  38035: 31636,
  38036: 31893,
  38037: 33334,
  38038: 34180,
  38039: 36843,
  38040: 26333,
  38041: 28448,
  38042: 29190,
  38043: 32283,
  38044: 33707,
  38045: 39361,
  38046: 40614,
  38047: 20989,
  38048: 31665,
  38049: 30834,
  38050: 31672,
  38051: 32903,
  38052: 31560,
  38053: 27368,
  38054: 24161,
  38055: 32908,
  38056: 30033,
  38057: 30048,
  38058: 20843,
  38059: 37474,
  38060: 28300,
  38061: 30330,
  38062: 37271,
  38063: 39658,
  38064: 20240,
  38065: 32624,
  38066: 25244,
  38067: 31567,
  38068: 38309,
  38069: 40169,
  38070: 22138,
  38071: 22617,
  38072: 34532,
  38073: 38588,
  38074: 20276,
  38075: 21028,
  38076: 21322,
  38077: 21453,
  38078: 21467,
  38079: 24070,
  38080: 25644,
  38081: 26001,
  38082: 26495,
  38083: 27710,
  38084: 27726,
  38085: 29256,
  38086: 29359,
  38087: 29677,
  38088: 30036,
  38089: 32321,
  38090: 33324,
  38091: 34281,
  38092: 36009,
  38093: 31684,
  38094: 37318,
  38095: 29033,
  38096: 38930,
  38097: 39151,
  38098: 25405,
  38099: 26217,
  38100: 30058,
  38101: 30436,
  38102: 30928,
  38103: 34115,
  38104: 34542,
  38105: 21290,
  38106: 21329,
  38107: 21542,
  38108: 22915,
  38109: 24199,
  38110: 24444,
  38111: 24754,
  38112: 25161,
  38113: 25209,
  38114: 25259,
  38115: 26e3,
  38116: 27604,
  38117: 27852,
  38118: 30130,
  38119: 30382,
  38120: 30865,
  38121: 31192,
  38122: 32203,
  38123: 32631,
  38124: 32933,
  38125: 34987,
  38126: 35513,
  38127: 36027,
  38128: 36991,
  38129: 38750,
  38130: 39131,
  38131: 27147,
  38132: 31800,
  38133: 20633,
  38134: 23614,
  38135: 24494,
  38136: 26503,
  38137: 27608,
  38138: 29749,
  38139: 30473,
  38140: 32654,
  38208: 40763,
  38209: 26570,
  38210: 31255,
  38211: 21305,
  38212: 30091,
  38213: 39661,
  38214: 24422,
  38215: 33181,
  38216: 33777,
  38217: 32920,
  38218: 24380,
  38219: 24517,
  38220: 30050,
  38221: 31558,
  38222: 36924,
  38223: 26727,
  38224: 23019,
  38225: 23195,
  38226: 32016,
  38227: 30334,
  38228: 35628,
  38229: 20469,
  38230: 24426,
  38231: 27161,
  38232: 27703,
  38233: 28418,
  38234: 29922,
  38235: 31080,
  38236: 34920,
  38237: 35413,
  38238: 35961,
  38239: 24287,
  38240: 25551,
  38241: 30149,
  38242: 31186,
  38243: 33495,
  38244: 37672,
  38245: 37618,
  38246: 33948,
  38247: 34541,
  38248: 39981,
  38249: 21697,
  38250: 24428,
  38251: 25996,
  38252: 27996,
  38253: 28693,
  38254: 36007,
  38255: 36051,
  38256: 38971,
  38257: 25935,
  38258: 29942,
  38259: 19981,
  38260: 20184,
  38261: 22496,
  38262: 22827,
  38263: 23142,
  38264: 23500,
  38265: 20904,
  38266: 24067,
  38267: 24220,
  38268: 24598,
  38269: 25206,
  38270: 25975,
  38272: 26023,
  38273: 26222,
  38274: 28014,
  38275: 29238,
  38276: 31526,
  38277: 33104,
  38278: 33178,
  38279: 33433,
  38280: 35676,
  38281: 36e3,
  38282: 36070,
  38283: 36212,
  38284: 38428,
  38285: 38468,
  38286: 20398,
  38287: 25771,
  38288: 27494,
  38289: 33310,
  38290: 33889,
  38291: 34154,
  38292: 37096,
  38293: 23553,
  38294: 26963,
  38295: 39080,
  38296: 33914,
  38297: 34135,
  38298: 20239,
  38299: 21103,
  38300: 24489,
  38301: 24133,
  38302: 26381,
  38303: 31119,
  38304: 33145,
  38305: 35079,
  38306: 35206,
  38307: 28149,
  38308: 24343,
  38309: 25173,
  38310: 27832,
  38311: 20175,
  38312: 29289,
  38313: 39826,
  38314: 20998,
  38315: 21563,
  38316: 22132,
  38317: 22707,
  38318: 24996,
  38319: 25198,
  38320: 28954,
  38321: 22894,
  38322: 31881,
  38323: 31966,
  38324: 32027,
  38325: 38640,
  38326: 25991,
  38327: 32862,
  38328: 19993,
  38329: 20341,
  38330: 20853,
  38331: 22592,
  38332: 24163,
  38333: 24179,
  38334: 24330,
  38335: 26564,
  38336: 20006,
  38337: 34109,
  38338: 38281,
  38339: 38491,
  38340: 31859,
  38341: 38913,
  38342: 20731,
  38343: 22721,
  38344: 30294,
  38345: 30887,
  38346: 21029,
  38347: 30629,
  38348: 34065,
  38349: 31622,
  38350: 20559,
  38351: 22793,
  38352: 29255,
  38353: 31687,
  38354: 32232,
  38355: 36794,
  38356: 36820,
  38357: 36941,
  38358: 20415,
  38359: 21193,
  38360: 23081,
  38361: 24321,
  38362: 38829,
  38363: 20445,
  38364: 33303,
  38365: 37610,
  38366: 22275,
  38367: 25429,
  38368: 27497,
  38369: 29995,
  38370: 35036,
  38371: 36628,
  38372: 31298,
  38373: 21215,
  38374: 22675,
  38375: 24917,
  38376: 25098,
  38377: 26286,
  38378: 27597,
  38379: 31807,
  38380: 33769,
  38381: 20515,
  38382: 20472,
  38383: 21253,
  38384: 21574,
  38385: 22577,
  38386: 22857,
  38387: 23453,
  38388: 23792,
  38389: 23791,
  38390: 23849,
  38391: 24214,
  38392: 25265,
  38393: 25447,
  38394: 25918,
  38395: 26041,
  38396: 26379,
  38464: 27861,
  38465: 27873,
  38466: 28921,
  38467: 30770,
  38468: 32299,
  38469: 32990,
  38470: 33459,
  38471: 33804,
  38472: 34028,
  38473: 34562,
  38474: 35090,
  38475: 35370,
  38476: 35914,
  38477: 37030,
  38478: 37586,
  38479: 39165,
  38480: 40179,
  38481: 40300,
  38482: 20047,
  38483: 20129,
  38484: 20621,
  38485: 21078,
  38486: 22346,
  38487: 22952,
  38488: 24125,
  38489: 24536,
  38490: 24537,
  38491: 25151,
  38492: 26292,
  38493: 26395,
  38494: 26576,
  38495: 26834,
  38496: 20882,
  38497: 32033,
  38498: 32938,
  38499: 33192,
  38500: 35584,
  38501: 35980,
  38502: 36031,
  38503: 37502,
  38504: 38450,
  38505: 21536,
  38506: 38956,
  38507: 21271,
  38508: 20693,
  38509: 21340,
  38510: 22696,
  38511: 25778,
  38512: 26420,
  38513: 29287,
  38514: 30566,
  38515: 31302,
  38516: 37350,
  38517: 21187,
  38518: 27809,
  38519: 27526,
  38520: 22528,
  38521: 24140,
  38522: 22868,
  38523: 26412,
  38524: 32763,
  38525: 20961,
  38526: 30406,
  38528: 25705,
  38529: 30952,
  38530: 39764,
  38531: 40635,
  38532: 22475,
  38533: 22969,
  38534: 26151,
  38535: 26522,
  38536: 27598,
  38537: 21737,
  38538: 27097,
  38539: 24149,
  38540: 33180,
  38541: 26517,
  38542: 39850,
  38543: 26622,
  38544: 40018,
  38545: 26717,
  38546: 20134,
  38547: 20451,
  38548: 21448,
  38549: 25273,
  38550: 26411,
  38551: 27819,
  38552: 36804,
  38553: 20397,
  38554: 32365,
  38555: 40639,
  38556: 19975,
  38557: 24930,
  38558: 28288,
  38559: 28459,
  38560: 34067,
  38561: 21619,
  38562: 26410,
  38563: 39749,
  38564: 24051,
  38565: 31637,
  38566: 23724,
  38567: 23494,
  38568: 34588,
  38569: 28234,
  38570: 34001,
  38571: 31252,
  38572: 33032,
  38573: 22937,
  38574: 31885,
  38575: 27665,
  38576: 30496,
  38577: 21209,
  38578: 22818,
  38579: 28961,
  38580: 29279,
  38581: 30683,
  38582: 38695,
  38583: 40289,
  38584: 26891,
  38585: 23167,
  38586: 23064,
  38587: 20901,
  38588: 21517,
  38589: 21629,
  38590: 26126,
  38591: 30431,
  38592: 36855,
  38593: 37528,
  38594: 40180,
  38595: 23018,
  38596: 29277,
  38597: 28357,
  38598: 20813,
  38599: 26825,
  38600: 32191,
  38601: 32236,
  38602: 38754,
  38603: 40634,
  38604: 25720,
  38605: 27169,
  38606: 33538,
  38607: 22916,
  38608: 23391,
  38609: 27611,
  38610: 29467,
  38611: 30450,
  38612: 32178,
  38613: 32791,
  38614: 33945,
  38615: 20786,
  38616: 26408,
  38617: 40665,
  38618: 30446,
  38619: 26466,
  38620: 21247,
  38621: 39173,
  38622: 23588,
  38623: 25147,
  38624: 31870,
  38625: 36016,
  38626: 21839,
  38627: 24758,
  38628: 32011,
  38629: 38272,
  38630: 21249,
  38631: 20063,
  38632: 20918,
  38633: 22812,
  38634: 29242,
  38635: 32822,
  38636: 37326,
  38637: 24357,
  38638: 30690,
  38639: 21380,
  38640: 24441,
  38641: 32004,
  38642: 34220,
  38643: 35379,
  38644: 36493,
  38645: 38742,
  38646: 26611,
  38647: 34222,
  38648: 37971,
  38649: 24841,
  38650: 24840,
  38651: 27833,
  38652: 30290,
  38720: 35565,
  38721: 36664,
  38722: 21807,
  38723: 20305,
  38724: 20778,
  38725: 21191,
  38726: 21451,
  38727: 23461,
  38728: 24189,
  38729: 24736,
  38730: 24962,
  38731: 25558,
  38732: 26377,
  38733: 26586,
  38734: 28263,
  38735: 28044,
  38736: 29494,
  38737: 29495,
  38738: 30001,
  38739: 31056,
  38740: 35029,
  38741: 35480,
  38742: 36938,
  38743: 37009,
  38744: 37109,
  38745: 38596,
  38746: 34701,
  38747: 22805,
  38748: 20104,
  38749: 20313,
  38750: 19982,
  38751: 35465,
  38752: 36671,
  38753: 38928,
  38754: 20653,
  38755: 24188,
  38756: 22934,
  38757: 23481,
  38758: 24248,
  38759: 25562,
  38760: 25594,
  38761: 25793,
  38762: 26332,
  38763: 26954,
  38764: 27096,
  38765: 27915,
  38766: 28342,
  38767: 29076,
  38768: 29992,
  38769: 31407,
  38770: 32650,
  38771: 32768,
  38772: 33865,
  38773: 33993,
  38774: 35201,
  38775: 35617,
  38776: 36362,
  38777: 36965,
  38778: 38525,
  38779: 39178,
  38780: 24958,
  38781: 25233,
  38782: 27442,
  38784: 27779,
  38785: 28020,
  38786: 32716,
  38787: 32764,
  38788: 28096,
  38789: 32645,
  38790: 34746,
  38791: 35064,
  38792: 26469,
  38793: 33713,
  38794: 38972,
  38795: 38647,
  38796: 27931,
  38797: 32097,
  38798: 33853,
  38799: 37226,
  38800: 20081,
  38801: 21365,
  38802: 23888,
  38803: 27396,
  38804: 28651,
  38805: 34253,
  38806: 34349,
  38807: 35239,
  38808: 21033,
  38809: 21519,
  38810: 23653,
  38811: 26446,
  38812: 26792,
  38813: 29702,
  38814: 29827,
  38815: 30178,
  38816: 35023,
  38817: 35041,
  38818: 37324,
  38819: 38626,
  38820: 38520,
  38821: 24459,
  38822: 29575,
  38823: 31435,
  38824: 33870,
  38825: 25504,
  38826: 30053,
  38827: 21129,
  38828: 27969,
  38829: 28316,
  38830: 29705,
  38831: 30041,
  38832: 30827,
  38833: 31890,
  38834: 38534,
  38835: 31452,
  38836: 40845,
  38837: 20406,
  38838: 24942,
  38839: 26053,
  38840: 34396,
  38841: 20102,
  38842: 20142,
  38843: 20698,
  38844: 20001,
  38845: 20940,
  38846: 23534,
  38847: 26009,
  38848: 26753,
  38849: 28092,
  38850: 29471,
  38851: 30274,
  38852: 30637,
  38853: 31260,
  38854: 31975,
  38855: 33391,
  38856: 35538,
  38857: 36988,
  38858: 37327,
  38859: 38517,
  38860: 38936,
  38861: 21147,
  38862: 32209,
  38863: 20523,
  38864: 21400,
  38865: 26519,
  38866: 28107,
  38867: 29136,
  38868: 29747,
  38869: 33256,
  38870: 36650,
  38871: 38563,
  38872: 40023,
  38873: 40607,
  38874: 29792,
  38875: 22593,
  38876: 28057,
  38877: 32047,
  38878: 39006,
  38879: 20196,
  38880: 20278,
  38881: 20363,
  38882: 20919,
  38883: 21169,
  38884: 23994,
  38885: 24604,
  38886: 29618,
  38887: 31036,
  38888: 33491,
  38889: 37428,
  38890: 38583,
  38891: 38646,
  38892: 38666,
  38893: 40599,
  38894: 40802,
  38895: 26278,
  38896: 27508,
  38897: 21015,
  38898: 21155,
  38899: 28872,
  38900: 35010,
  38901: 24265,
  38902: 24651,
  38903: 24976,
  38904: 28451,
  38905: 29001,
  38906: 31806,
  38907: 32244,
  38908: 32879,
  38976: 34030,
  38977: 36899,
  38978: 37676,
  38979: 21570,
  38980: 39791,
  38981: 27347,
  38982: 28809,
  38983: 36034,
  38984: 36335,
  38985: 38706,
  38986: 21172,
  38987: 23105,
  38988: 24266,
  38989: 24324,
  38990: 26391,
  38991: 27004,
  38992: 27028,
  38993: 28010,
  38994: 28431,
  38995: 29282,
  38996: 29436,
  38997: 31725,
  38998: 32769,
  38999: 32894,
  39e3: 34635,
  39001: 37070,
  39002: 20845,
  39003: 40595,
  39004: 31108,
  39005: 32907,
  39006: 37682,
  39007: 35542,
  39008: 20525,
  39009: 21644,
  39010: 35441,
  39011: 27498,
  39012: 36036,
  39013: 33031,
  39014: 24785,
  39015: 26528,
  39016: 40434,
  39017: 20121,
  39018: 20120,
  39019: 39952,
  39020: 35435,
  39021: 34241,
  39022: 34152,
  39023: 26880,
  39024: 28286,
  39025: 30871,
  39026: 33109,
  39071: 24332,
  39072: 19984,
  39073: 19989,
  39074: 20010,
  39075: 20017,
  39076: 20022,
  39077: 20028,
  39078: 20031,
  39079: 20034,
  39080: 20054,
  39081: 20056,
  39082: 20098,
  39083: 20101,
  39084: 35947,
  39085: 20106,
  39086: 33298,
  39087: 24333,
  39088: 20110,
  39089: 20126,
  39090: 20127,
  39091: 20128,
  39092: 20130,
  39093: 20144,
  39094: 20147,
  39095: 20150,
  39096: 20174,
  39097: 20173,
  39098: 20164,
  39099: 20166,
  39100: 20162,
  39101: 20183,
  39102: 20190,
  39103: 20205,
  39104: 20191,
  39105: 20215,
  39106: 20233,
  39107: 20314,
  39108: 20272,
  39109: 20315,
  39110: 20317,
  39111: 20311,
  39112: 20295,
  39113: 20342,
  39114: 20360,
  39115: 20367,
  39116: 20376,
  39117: 20347,
  39118: 20329,
  39119: 20336,
  39120: 20369,
  39121: 20335,
  39122: 20358,
  39123: 20374,
  39124: 20760,
  39125: 20436,
  39126: 20447,
  39127: 20430,
  39128: 20440,
  39129: 20443,
  39130: 20433,
  39131: 20442,
  39132: 20432,
  39133: 20452,
  39134: 20453,
  39135: 20506,
  39136: 20520,
  39137: 20500,
  39138: 20522,
  39139: 20517,
  39140: 20485,
  39141: 20252,
  39142: 20470,
  39143: 20513,
  39144: 20521,
  39145: 20524,
  39146: 20478,
  39147: 20463,
  39148: 20497,
  39149: 20486,
  39150: 20547,
  39151: 20551,
  39152: 26371,
  39153: 20565,
  39154: 20560,
  39155: 20552,
  39156: 20570,
  39157: 20566,
  39158: 20588,
  39159: 20600,
  39160: 20608,
  39161: 20634,
  39162: 20613,
  39163: 20660,
  39164: 20658,
  39232: 20681,
  39233: 20682,
  39234: 20659,
  39235: 20674,
  39236: 20694,
  39237: 20702,
  39238: 20709,
  39239: 20717,
  39240: 20707,
  39241: 20718,
  39242: 20729,
  39243: 20725,
  39244: 20745,
  39245: 20737,
  39246: 20738,
  39247: 20758,
  39248: 20757,
  39249: 20756,
  39250: 20762,
  39251: 20769,
  39252: 20794,
  39253: 20791,
  39254: 20796,
  39255: 20795,
  39256: 20799,
  39257: 20800,
  39258: 20818,
  39259: 20812,
  39260: 20820,
  39261: 20834,
  39262: 31480,
  39263: 20841,
  39264: 20842,
  39265: 20846,
  39266: 20864,
  39267: 20866,
  39268: 22232,
  39269: 20876,
  39270: 20873,
  39271: 20879,
  39272: 20881,
  39273: 20883,
  39274: 20885,
  39275: 20886,
  39276: 20900,
  39277: 20902,
  39278: 20898,
  39279: 20905,
  39280: 20906,
  39281: 20907,
  39282: 20915,
  39283: 20913,
  39284: 20914,
  39285: 20912,
  39286: 20917,
  39287: 20925,
  39288: 20933,
  39289: 20937,
  39290: 20955,
  39291: 20960,
  39292: 34389,
  39293: 20969,
  39294: 20973,
  39296: 20976,
  39297: 20981,
  39298: 20990,
  39299: 20996,
  39300: 21003,
  39301: 21012,
  39302: 21006,
  39303: 21031,
  39304: 21034,
  39305: 21038,
  39306: 21043,
  39307: 21049,
  39308: 21071,
  39309: 21060,
  39310: 21067,
  39311: 21068,
  39312: 21086,
  39313: 21076,
  39314: 21098,
  39315: 21108,
  39316: 21097,
  39317: 21107,
  39318: 21119,
  39319: 21117,
  39320: 21133,
  39321: 21140,
  39322: 21138,
  39323: 21105,
  39324: 21128,
  39325: 21137,
  39326: 36776,
  39327: 36775,
  39328: 21164,
  39329: 21165,
  39330: 21180,
  39331: 21173,
  39332: 21185,
  39333: 21197,
  39334: 21207,
  39335: 21214,
  39336: 21219,
  39337: 21222,
  39338: 39149,
  39339: 21216,
  39340: 21235,
  39341: 21237,
  39342: 21240,
  39343: 21241,
  39344: 21254,
  39345: 21256,
  39346: 30008,
  39347: 21261,
  39348: 21264,
  39349: 21263,
  39350: 21269,
  39351: 21274,
  39352: 21283,
  39353: 21295,
  39354: 21297,
  39355: 21299,
  39356: 21304,
  39357: 21312,
  39358: 21318,
  39359: 21317,
  39360: 19991,
  39361: 21321,
  39362: 21325,
  39363: 20950,
  39364: 21342,
  39365: 21353,
  39366: 21358,
  39367: 22808,
  39368: 21371,
  39369: 21367,
  39370: 21378,
  39371: 21398,
  39372: 21408,
  39373: 21414,
  39374: 21413,
  39375: 21422,
  39376: 21424,
  39377: 21430,
  39378: 21443,
  39379: 31762,
  39380: 38617,
  39381: 21471,
  39382: 26364,
  39383: 29166,
  39384: 21486,
  39385: 21480,
  39386: 21485,
  39387: 21498,
  39388: 21505,
  39389: 21565,
  39390: 21568,
  39391: 21548,
  39392: 21549,
  39393: 21564,
  39394: 21550,
  39395: 21558,
  39396: 21545,
  39397: 21533,
  39398: 21582,
  39399: 21647,
  39400: 21621,
  39401: 21646,
  39402: 21599,
  39403: 21617,
  39404: 21623,
  39405: 21616,
  39406: 21650,
  39407: 21627,
  39408: 21632,
  39409: 21622,
  39410: 21636,
  39411: 21648,
  39412: 21638,
  39413: 21703,
  39414: 21666,
  39415: 21688,
  39416: 21669,
  39417: 21676,
  39418: 21700,
  39419: 21704,
  39420: 21672,
  39488: 21675,
  39489: 21698,
  39490: 21668,
  39491: 21694,
  39492: 21692,
  39493: 21720,
  39494: 21733,
  39495: 21734,
  39496: 21775,
  39497: 21780,
  39498: 21757,
  39499: 21742,
  39500: 21741,
  39501: 21754,
  39502: 21730,
  39503: 21817,
  39504: 21824,
  39505: 21859,
  39506: 21836,
  39507: 21806,
  39508: 21852,
  39509: 21829,
  39510: 21846,
  39511: 21847,
  39512: 21816,
  39513: 21811,
  39514: 21853,
  39515: 21913,
  39516: 21888,
  39517: 21679,
  39518: 21898,
  39519: 21919,
  39520: 21883,
  39521: 21886,
  39522: 21912,
  39523: 21918,
  39524: 21934,
  39525: 21884,
  39526: 21891,
  39527: 21929,
  39528: 21895,
  39529: 21928,
  39530: 21978,
  39531: 21957,
  39532: 21983,
  39533: 21956,
  39534: 21980,
  39535: 21988,
  39536: 21972,
  39537: 22036,
  39538: 22007,
  39539: 22038,
  39540: 22014,
  39541: 22013,
  39542: 22043,
  39543: 22009,
  39544: 22094,
  39545: 22096,
  39546: 29151,
  39547: 22068,
  39548: 22070,
  39549: 22066,
  39550: 22072,
  39552: 22123,
  39553: 22116,
  39554: 22063,
  39555: 22124,
  39556: 22122,
  39557: 22150,
  39558: 22144,
  39559: 22154,
  39560: 22176,
  39561: 22164,
  39562: 22159,
  39563: 22181,
  39564: 22190,
  39565: 22198,
  39566: 22196,
  39567: 22210,
  39568: 22204,
  39569: 22209,
  39570: 22211,
  39571: 22208,
  39572: 22216,
  39573: 22222,
  39574: 22225,
  39575: 22227,
  39576: 22231,
  39577: 22254,
  39578: 22265,
  39579: 22272,
  39580: 22271,
  39581: 22276,
  39582: 22281,
  39583: 22280,
  39584: 22283,
  39585: 22285,
  39586: 22291,
  39587: 22296,
  39588: 22294,
  39589: 21959,
  39590: 22300,
  39591: 22310,
  39592: 22327,
  39593: 22328,
  39594: 22350,
  39595: 22331,
  39596: 22336,
  39597: 22351,
  39598: 22377,
  39599: 22464,
  39600: 22408,
  39601: 22369,
  39602: 22399,
  39603: 22409,
  39604: 22419,
  39605: 22432,
  39606: 22451,
  39607: 22436,
  39608: 22442,
  39609: 22448,
  39610: 22467,
  39611: 22470,
  39612: 22484,
  39613: 22482,
  39614: 22483,
  39615: 22538,
  39616: 22486,
  39617: 22499,
  39618: 22539,
  39619: 22553,
  39620: 22557,
  39621: 22642,
  39622: 22561,
  39623: 22626,
  39624: 22603,
  39625: 22640,
  39626: 27584,
  39627: 22610,
  39628: 22589,
  39629: 22649,
  39630: 22661,
  39631: 22713,
  39632: 22687,
  39633: 22699,
  39634: 22714,
  39635: 22750,
  39636: 22715,
  39637: 22712,
  39638: 22702,
  39639: 22725,
  39640: 22739,
  39641: 22737,
  39642: 22743,
  39643: 22745,
  39644: 22744,
  39645: 22757,
  39646: 22748,
  39647: 22756,
  39648: 22751,
  39649: 22767,
  39650: 22778,
  39651: 22777,
  39652: 22779,
  39653: 22780,
  39654: 22781,
  39655: 22786,
  39656: 22794,
  39657: 22800,
  39658: 22811,
  39659: 26790,
  39660: 22821,
  39661: 22828,
  39662: 22829,
  39663: 22834,
  39664: 22840,
  39665: 22846,
  39666: 31442,
  39667: 22869,
  39668: 22864,
  39669: 22862,
  39670: 22874,
  39671: 22872,
  39672: 22882,
  39673: 22880,
  39674: 22887,
  39675: 22892,
  39676: 22889,
  39744: 22904,
  39745: 22913,
  39746: 22941,
  39747: 20318,
  39748: 20395,
  39749: 22947,
  39750: 22962,
  39751: 22982,
  39752: 23016,
  39753: 23004,
  39754: 22925,
  39755: 23001,
  39756: 23002,
  39757: 23077,
  39758: 23071,
  39759: 23057,
  39760: 23068,
  39761: 23049,
  39762: 23066,
  39763: 23104,
  39764: 23148,
  39765: 23113,
  39766: 23093,
  39767: 23094,
  39768: 23138,
  39769: 23146,
  39770: 23194,
  39771: 23228,
  39772: 23230,
  39773: 23243,
  39774: 23234,
  39775: 23229,
  39776: 23267,
  39777: 23255,
  39778: 23270,
  39779: 23273,
  39780: 23254,
  39781: 23290,
  39782: 23291,
  39783: 23308,
  39784: 23307,
  39785: 23318,
  39786: 23346,
  39787: 23248,
  39788: 23338,
  39789: 23350,
  39790: 23358,
  39791: 23363,
  39792: 23365,
  39793: 23360,
  39794: 23377,
  39795: 23381,
  39796: 23386,
  39797: 23387,
  39798: 23397,
  39799: 23401,
  39800: 23408,
  39801: 23411,
  39802: 23413,
  39803: 23416,
  39804: 25992,
  39805: 23418,
  39806: 23424,
  39808: 23427,
  39809: 23462,
  39810: 23480,
  39811: 23491,
  39812: 23495,
  39813: 23497,
  39814: 23508,
  39815: 23504,
  39816: 23524,
  39817: 23526,
  39818: 23522,
  39819: 23518,
  39820: 23525,
  39821: 23531,
  39822: 23536,
  39823: 23542,
  39824: 23539,
  39825: 23557,
  39826: 23559,
  39827: 23560,
  39828: 23565,
  39829: 23571,
  39830: 23584,
  39831: 23586,
  39832: 23592,
  39833: 23608,
  39834: 23609,
  39835: 23617,
  39836: 23622,
  39837: 23630,
  39838: 23635,
  39839: 23632,
  39840: 23631,
  39841: 23409,
  39842: 23660,
  39843: 23662,
  39844: 20066,
  39845: 23670,
  39846: 23673,
  39847: 23692,
  39848: 23697,
  39849: 23700,
  39850: 22939,
  39851: 23723,
  39852: 23739,
  39853: 23734,
  39854: 23740,
  39855: 23735,
  39856: 23749,
  39857: 23742,
  39858: 23751,
  39859: 23769,
  39860: 23785,
  39861: 23805,
  39862: 23802,
  39863: 23789,
  39864: 23948,
  39865: 23786,
  39866: 23819,
  39867: 23829,
  39868: 23831,
  39869: 23900,
  39870: 23839,
  39871: 23835,
  39872: 23825,
  39873: 23828,
  39874: 23842,
  39875: 23834,
  39876: 23833,
  39877: 23832,
  39878: 23884,
  39879: 23890,
  39880: 23886,
  39881: 23883,
  39882: 23916,
  39883: 23923,
  39884: 23926,
  39885: 23943,
  39886: 23940,
  39887: 23938,
  39888: 23970,
  39889: 23965,
  39890: 23980,
  39891: 23982,
  39892: 23997,
  39893: 23952,
  39894: 23991,
  39895: 23996,
  39896: 24009,
  39897: 24013,
  39898: 24019,
  39899: 24018,
  39900: 24022,
  39901: 24027,
  39902: 24043,
  39903: 24050,
  39904: 24053,
  39905: 24075,
  39906: 24090,
  39907: 24089,
  39908: 24081,
  39909: 24091,
  39910: 24118,
  39911: 24119,
  39912: 24132,
  39913: 24131,
  39914: 24128,
  39915: 24142,
  39916: 24151,
  39917: 24148,
  39918: 24159,
  39919: 24162,
  39920: 24164,
  39921: 24135,
  39922: 24181,
  39923: 24182,
  39924: 24186,
  39925: 40636,
  39926: 24191,
  39927: 24224,
  39928: 24257,
  39929: 24258,
  39930: 24264,
  39931: 24272,
  39932: 24271,
  4e4: 24278,
  40001: 24291,
  40002: 24285,
  40003: 24282,
  40004: 24283,
  40005: 24290,
  40006: 24289,
  40007: 24296,
  40008: 24297,
  40009: 24300,
  40010: 24305,
  40011: 24307,
  40012: 24304,
  40013: 24308,
  40014: 24312,
  40015: 24318,
  40016: 24323,
  40017: 24329,
  40018: 24413,
  40019: 24412,
  40020: 24331,
  40021: 24337,
  40022: 24342,
  40023: 24361,
  40024: 24365,
  40025: 24376,
  40026: 24385,
  40027: 24392,
  40028: 24396,
  40029: 24398,
  40030: 24367,
  40031: 24401,
  40032: 24406,
  40033: 24407,
  40034: 24409,
  40035: 24417,
  40036: 24429,
  40037: 24435,
  40038: 24439,
  40039: 24451,
  40040: 24450,
  40041: 24447,
  40042: 24458,
  40043: 24456,
  40044: 24465,
  40045: 24455,
  40046: 24478,
  40047: 24473,
  40048: 24472,
  40049: 24480,
  40050: 24488,
  40051: 24493,
  40052: 24508,
  40053: 24534,
  40054: 24571,
  40055: 24548,
  40056: 24568,
  40057: 24561,
  40058: 24541,
  40059: 24755,
  40060: 24575,
  40061: 24609,
  40062: 24672,
  40064: 24601,
  40065: 24592,
  40066: 24617,
  40067: 24590,
  40068: 24625,
  40069: 24603,
  40070: 24597,
  40071: 24619,
  40072: 24614,
  40073: 24591,
  40074: 24634,
  40075: 24666,
  40076: 24641,
  40077: 24682,
  40078: 24695,
  40079: 24671,
  40080: 24650,
  40081: 24646,
  40082: 24653,
  40083: 24675,
  40084: 24643,
  40085: 24676,
  40086: 24642,
  40087: 24684,
  40088: 24683,
  40089: 24665,
  40090: 24705,
  40091: 24717,
  40092: 24807,
  40093: 24707,
  40094: 24730,
  40095: 24708,
  40096: 24731,
  40097: 24726,
  40098: 24727,
  40099: 24722,
  40100: 24743,
  40101: 24715,
  40102: 24801,
  40103: 24760,
  40104: 24800,
  40105: 24787,
  40106: 24756,
  40107: 24560,
  40108: 24765,
  40109: 24774,
  40110: 24757,
  40111: 24792,
  40112: 24909,
  40113: 24853,
  40114: 24838,
  40115: 24822,
  40116: 24823,
  40117: 24832,
  40118: 24820,
  40119: 24826,
  40120: 24835,
  40121: 24865,
  40122: 24827,
  40123: 24817,
  40124: 24845,
  40125: 24846,
  40126: 24903,
  40127: 24894,
  40128: 24872,
  40129: 24871,
  40130: 24906,
  40131: 24895,
  40132: 24892,
  40133: 24876,
  40134: 24884,
  40135: 24893,
  40136: 24898,
  40137: 24900,
  40138: 24947,
  40139: 24951,
  40140: 24920,
  40141: 24921,
  40142: 24922,
  40143: 24939,
  40144: 24948,
  40145: 24943,
  40146: 24933,
  40147: 24945,
  40148: 24927,
  40149: 24925,
  40150: 24915,
  40151: 24949,
  40152: 24985,
  40153: 24982,
  40154: 24967,
  40155: 25004,
  40156: 24980,
  40157: 24986,
  40158: 24970,
  40159: 24977,
  40160: 25003,
  40161: 25006,
  40162: 25036,
  40163: 25034,
  40164: 25033,
  40165: 25079,
  40166: 25032,
  40167: 25027,
  40168: 25030,
  40169: 25018,
  40170: 25035,
  40171: 32633,
  40172: 25037,
  40173: 25062,
  40174: 25059,
  40175: 25078,
  40176: 25082,
  40177: 25076,
  40178: 25087,
  40179: 25085,
  40180: 25084,
  40181: 25086,
  40182: 25088,
  40183: 25096,
  40184: 25097,
  40185: 25101,
  40186: 25100,
  40187: 25108,
  40188: 25115,
  40256: 25118,
  40257: 25121,
  40258: 25130,
  40259: 25134,
  40260: 25136,
  40261: 25138,
  40262: 25139,
  40263: 25153,
  40264: 25166,
  40265: 25182,
  40266: 25187,
  40267: 25179,
  40268: 25184,
  40269: 25192,
  40270: 25212,
  40271: 25218,
  40272: 25225,
  40273: 25214,
  40274: 25234,
  40275: 25235,
  40276: 25238,
  40277: 25300,
  40278: 25219,
  40279: 25236,
  40280: 25303,
  40281: 25297,
  40282: 25275,
  40283: 25295,
  40284: 25343,
  40285: 25286,
  40286: 25812,
  40287: 25288,
  40288: 25308,
  40289: 25292,
  40290: 25290,
  40291: 25282,
  40292: 25287,
  40293: 25243,
  40294: 25289,
  40295: 25356,
  40296: 25326,
  40297: 25329,
  40298: 25383,
  40299: 25346,
  40300: 25352,
  40301: 25327,
  40302: 25333,
  40303: 25424,
  40304: 25406,
  40305: 25421,
  40306: 25628,
  40307: 25423,
  40308: 25494,
  40309: 25486,
  40310: 25472,
  40311: 25515,
  40312: 25462,
  40313: 25507,
  40314: 25487,
  40315: 25481,
  40316: 25503,
  40317: 25525,
  40318: 25451,
  40320: 25449,
  40321: 25534,
  40322: 25577,
  40323: 25536,
  40324: 25542,
  40325: 25571,
  40326: 25545,
  40327: 25554,
  40328: 25590,
  40329: 25540,
  40330: 25622,
  40331: 25652,
  40332: 25606,
  40333: 25619,
  40334: 25638,
  40335: 25654,
  40336: 25885,
  40337: 25623,
  40338: 25640,
  40339: 25615,
  40340: 25703,
  40341: 25711,
  40342: 25718,
  40343: 25678,
  40344: 25898,
  40345: 25749,
  40346: 25747,
  40347: 25765,
  40348: 25769,
  40349: 25736,
  40350: 25788,
  40351: 25818,
  40352: 25810,
  40353: 25797,
  40354: 25799,
  40355: 25787,
  40356: 25816,
  40357: 25794,
  40358: 25841,
  40359: 25831,
  40360: 33289,
  40361: 25824,
  40362: 25825,
  40363: 25260,
  40364: 25827,
  40365: 25839,
  40366: 25900,
  40367: 25846,
  40368: 25844,
  40369: 25842,
  40370: 25850,
  40371: 25856,
  40372: 25853,
  40373: 25880,
  40374: 25884,
  40375: 25861,
  40376: 25892,
  40377: 25891,
  40378: 25899,
  40379: 25908,
  40380: 25909,
  40381: 25911,
  40382: 25910,
  40383: 25912,
  40384: 30027,
  40385: 25928,
  40386: 25942,
  40387: 25941,
  40388: 25933,
  40389: 25944,
  40390: 25950,
  40391: 25949,
  40392: 25970,
  40393: 25976,
  40394: 25986,
  40395: 25987,
  40396: 35722,
  40397: 26011,
  40398: 26015,
  40399: 26027,
  40400: 26039,
  40401: 26051,
  40402: 26054,
  40403: 26049,
  40404: 26052,
  40405: 26060,
  40406: 26066,
  40407: 26075,
  40408: 26073,
  40409: 26080,
  40410: 26081,
  40411: 26097,
  40412: 26482,
  40413: 26122,
  40414: 26115,
  40415: 26107,
  40416: 26483,
  40417: 26165,
  40418: 26166,
  40419: 26164,
  40420: 26140,
  40421: 26191,
  40422: 26180,
  40423: 26185,
  40424: 26177,
  40425: 26206,
  40426: 26205,
  40427: 26212,
  40428: 26215,
  40429: 26216,
  40430: 26207,
  40431: 26210,
  40432: 26224,
  40433: 26243,
  40434: 26248,
  40435: 26254,
  40436: 26249,
  40437: 26244,
  40438: 26264,
  40439: 26269,
  40440: 26305,
  40441: 26297,
  40442: 26313,
  40443: 26302,
  40444: 26300,
  40512: 26308,
  40513: 26296,
  40514: 26326,
  40515: 26330,
  40516: 26336,
  40517: 26175,
  40518: 26342,
  40519: 26345,
  40520: 26352,
  40521: 26357,
  40522: 26359,
  40523: 26383,
  40524: 26390,
  40525: 26398,
  40526: 26406,
  40527: 26407,
  40528: 38712,
  40529: 26414,
  40530: 26431,
  40531: 26422,
  40532: 26433,
  40533: 26424,
  40534: 26423,
  40535: 26438,
  40536: 26462,
  40537: 26464,
  40538: 26457,
  40539: 26467,
  40540: 26468,
  40541: 26505,
  40542: 26480,
  40543: 26537,
  40544: 26492,
  40545: 26474,
  40546: 26508,
  40547: 26507,
  40548: 26534,
  40549: 26529,
  40550: 26501,
  40551: 26551,
  40552: 26607,
  40553: 26548,
  40554: 26604,
  40555: 26547,
  40556: 26601,
  40557: 26552,
  40558: 26596,
  40559: 26590,
  40560: 26589,
  40561: 26594,
  40562: 26606,
  40563: 26553,
  40564: 26574,
  40565: 26566,
  40566: 26599,
  40567: 27292,
  40568: 26654,
  40569: 26694,
  40570: 26665,
  40571: 26688,
  40572: 26701,
  40573: 26674,
  40574: 26702,
  40576: 26803,
  40577: 26667,
  40578: 26713,
  40579: 26723,
  40580: 26743,
  40581: 26751,
  40582: 26783,
  40583: 26767,
  40584: 26797,
  40585: 26772,
  40586: 26781,
  40587: 26779,
  40588: 26755,
  40589: 27310,
  40590: 26809,
  40591: 26740,
  40592: 26805,
  40593: 26784,
  40594: 26810,
  40595: 26895,
  40596: 26765,
  40597: 26750,
  40598: 26881,
  40599: 26826,
  40600: 26888,
  40601: 26840,
  40602: 26914,
  40603: 26918,
  40604: 26849,
  40605: 26892,
  40606: 26829,
  40607: 26836,
  40608: 26855,
  40609: 26837,
  40610: 26934,
  40611: 26898,
  40612: 26884,
  40613: 26839,
  40614: 26851,
  40615: 26917,
  40616: 26873,
  40617: 26848,
  40618: 26863,
  40619: 26920,
  40620: 26922,
  40621: 26906,
  40622: 26915,
  40623: 26913,
  40624: 26822,
  40625: 27001,
  40626: 26999,
  40627: 26972,
  40628: 27e3,
  40629: 26987,
  40630: 26964,
  40631: 27006,
  40632: 26990,
  40633: 26937,
  40634: 26996,
  40635: 26941,
  40636: 26969,
  40637: 26928,
  40638: 26977,
  40639: 26974,
  40640: 26973,
  40641: 27009,
  40642: 26986,
  40643: 27058,
  40644: 27054,
  40645: 27088,
  40646: 27071,
  40647: 27073,
  40648: 27091,
  40649: 27070,
  40650: 27086,
  40651: 23528,
  40652: 27082,
  40653: 27101,
  40654: 27067,
  40655: 27075,
  40656: 27047,
  40657: 27182,
  40658: 27025,
  40659: 27040,
  40660: 27036,
  40661: 27029,
  40662: 27060,
  40663: 27102,
  40664: 27112,
  40665: 27138,
  40666: 27163,
  40667: 27135,
  40668: 27402,
  40669: 27129,
  40670: 27122,
  40671: 27111,
  40672: 27141,
  40673: 27057,
  40674: 27166,
  40675: 27117,
  40676: 27156,
  40677: 27115,
  40678: 27146,
  40679: 27154,
  40680: 27329,
  40681: 27171,
  40682: 27155,
  40683: 27204,
  40684: 27148,
  40685: 27250,
  40686: 27190,
  40687: 27256,
  40688: 27207,
  40689: 27234,
  40690: 27225,
  40691: 27238,
  40692: 27208,
  40693: 27192,
  40694: 27170,
  40695: 27280,
  40696: 27277,
  40697: 27296,
  40698: 27268,
  40699: 27298,
  40700: 27299,
  40768: 27287,
  40769: 34327,
  40770: 27323,
  40771: 27331,
  40772: 27330,
  40773: 27320,
  40774: 27315,
  40775: 27308,
  40776: 27358,
  40777: 27345,
  40778: 27359,
  40779: 27306,
  40780: 27354,
  40781: 27370,
  40782: 27387,
  40783: 27397,
  40784: 34326,
  40785: 27386,
  40786: 27410,
  40787: 27414,
  40788: 39729,
  40789: 27423,
  40790: 27448,
  40791: 27447,
  40792: 30428,
  40793: 27449,
  40794: 39150,
  40795: 27463,
  40796: 27459,
  40797: 27465,
  40798: 27472,
  40799: 27481,
  40800: 27476,
  40801: 27483,
  40802: 27487,
  40803: 27489,
  40804: 27512,
  40805: 27513,
  40806: 27519,
  40807: 27520,
  40808: 27524,
  40809: 27523,
  40810: 27533,
  40811: 27544,
  40812: 27541,
  40813: 27550,
  40814: 27556,
  40815: 27562,
  40816: 27563,
  40817: 27567,
  40818: 27570,
  40819: 27569,
  40820: 27571,
  40821: 27575,
  40822: 27580,
  40823: 27590,
  40824: 27595,
  40825: 27603,
  40826: 27615,
  40827: 27628,
  40828: 27627,
  40829: 27635,
  40830: 27631,
  40832: 40638,
  40833: 27656,
  40834: 27667,
  40835: 27668,
  40836: 27675,
  40837: 27684,
  40838: 27683,
  40839: 27742,
  40840: 27733,
  40841: 27746,
  40842: 27754,
  40843: 27778,
  40844: 27789,
  40845: 27802,
  40846: 27777,
  40847: 27803,
  40848: 27774,
  40849: 27752,
  40850: 27763,
  40851: 27794,
  40852: 27792,
  40853: 27844,
  40854: 27889,
  40855: 27859,
  40856: 27837,
  40857: 27863,
  40858: 27845,
  40859: 27869,
  40860: 27822,
  40861: 27825,
  40862: 27838,
  40863: 27834,
  40864: 27867,
  40865: 27887,
  40866: 27865,
  40867: 27882,
  40868: 27935,
  40869: 34893,
  40870: 27958,
  40871: 27947,
  40872: 27965,
  40873: 27960,
  40874: 27929,
  40875: 27957,
  40876: 27955,
  40877: 27922,
  40878: 27916,
  40879: 28003,
  40880: 28051,
  40881: 28004,
  40882: 27994,
  40883: 28025,
  40884: 27993,
  40885: 28046,
  40886: 28053,
  40887: 28644,
  40888: 28037,
  40889: 28153,
  40890: 28181,
  40891: 28170,
  40892: 28085,
  40893: 28103,
  40894: 28134,
  40895: 28088,
  40896: 28102,
  40897: 28140,
  40898: 28126,
  40899: 28108,
  40900: 28136,
  40901: 28114,
  40902: 28101,
  40903: 28154,
  40904: 28121,
  40905: 28132,
  40906: 28117,
  40907: 28138,
  40908: 28142,
  40909: 28205,
  40910: 28270,
  40911: 28206,
  40912: 28185,
  40913: 28274,
  40914: 28255,
  40915: 28222,
  40916: 28195,
  40917: 28267,
  40918: 28203,
  40919: 28278,
  40920: 28237,
  40921: 28191,
  40922: 28227,
  40923: 28218,
  40924: 28238,
  40925: 28196,
  40926: 28415,
  40927: 28189,
  40928: 28216,
  40929: 28290,
  40930: 28330,
  40931: 28312,
  40932: 28361,
  40933: 28343,
  40934: 28371,
  40935: 28349,
  40936: 28335,
  40937: 28356,
  40938: 28338,
  40939: 28372,
  40940: 28373,
  40941: 28303,
  40942: 28325,
  40943: 28354,
  40944: 28319,
  40945: 28481,
  40946: 28433,
  40947: 28748,
  40948: 28396,
  40949: 28408,
  40950: 28414,
  40951: 28479,
  40952: 28402,
  40953: 28465,
  40954: 28399,
  40955: 28466,
  40956: 28364,
  57408: 28478,
  57409: 28435,
  57410: 28407,
  57411: 28550,
  57412: 28538,
  57413: 28536,
  57414: 28545,
  57415: 28544,
  57416: 28527,
  57417: 28507,
  57418: 28659,
  57419: 28525,
  57420: 28546,
  57421: 28540,
  57422: 28504,
  57423: 28558,
  57424: 28561,
  57425: 28610,
  57426: 28518,
  57427: 28595,
  57428: 28579,
  57429: 28577,
  57430: 28580,
  57431: 28601,
  57432: 28614,
  57433: 28586,
  57434: 28639,
  57435: 28629,
  57436: 28652,
  57437: 28628,
  57438: 28632,
  57439: 28657,
  57440: 28654,
  57441: 28635,
  57442: 28681,
  57443: 28683,
  57444: 28666,
  57445: 28689,
  57446: 28673,
  57447: 28687,
  57448: 28670,
  57449: 28699,
  57450: 28698,
  57451: 28532,
  57452: 28701,
  57453: 28696,
  57454: 28703,
  57455: 28720,
  57456: 28734,
  57457: 28722,
  57458: 28753,
  57459: 28771,
  57460: 28825,
  57461: 28818,
  57462: 28847,
  57463: 28913,
  57464: 28844,
  57465: 28856,
  57466: 28851,
  57467: 28846,
  57468: 28895,
  57469: 28875,
  57470: 28893,
  57472: 28889,
  57473: 28937,
  57474: 28925,
  57475: 28956,
  57476: 28953,
  57477: 29029,
  57478: 29013,
  57479: 29064,
  57480: 29030,
  57481: 29026,
  57482: 29004,
  57483: 29014,
  57484: 29036,
  57485: 29071,
  57486: 29179,
  57487: 29060,
  57488: 29077,
  57489: 29096,
  57490: 29100,
  57491: 29143,
  57492: 29113,
  57493: 29118,
  57494: 29138,
  57495: 29129,
  57496: 29140,
  57497: 29134,
  57498: 29152,
  57499: 29164,
  57500: 29159,
  57501: 29173,
  57502: 29180,
  57503: 29177,
  57504: 29183,
  57505: 29197,
  57506: 29200,
  57507: 29211,
  57508: 29224,
  57509: 29229,
  57510: 29228,
  57511: 29232,
  57512: 29234,
  57513: 29243,
  57514: 29244,
  57515: 29247,
  57516: 29248,
  57517: 29254,
  57518: 29259,
  57519: 29272,
  57520: 29300,
  57521: 29310,
  57522: 29314,
  57523: 29313,
  57524: 29319,
  57525: 29330,
  57526: 29334,
  57527: 29346,
  57528: 29351,
  57529: 29369,
  57530: 29362,
  57531: 29379,
  57532: 29382,
  57533: 29380,
  57534: 29390,
  57535: 29394,
  57536: 29410,
  57537: 29408,
  57538: 29409,
  57539: 29433,
  57540: 29431,
  57541: 20495,
  57542: 29463,
  57543: 29450,
  57544: 29468,
  57545: 29462,
  57546: 29469,
  57547: 29492,
  57548: 29487,
  57549: 29481,
  57550: 29477,
  57551: 29502,
  57552: 29518,
  57553: 29519,
  57554: 40664,
  57555: 29527,
  57556: 29546,
  57557: 29544,
  57558: 29552,
  57559: 29560,
  57560: 29557,
  57561: 29563,
  57562: 29562,
  57563: 29640,
  57564: 29619,
  57565: 29646,
  57566: 29627,
  57567: 29632,
  57568: 29669,
  57569: 29678,
  57570: 29662,
  57571: 29858,
  57572: 29701,
  57573: 29807,
  57574: 29733,
  57575: 29688,
  57576: 29746,
  57577: 29754,
  57578: 29781,
  57579: 29759,
  57580: 29791,
  57581: 29785,
  57582: 29761,
  57583: 29788,
  57584: 29801,
  57585: 29808,
  57586: 29795,
  57587: 29802,
  57588: 29814,
  57589: 29822,
  57590: 29835,
  57591: 29854,
  57592: 29863,
  57593: 29898,
  57594: 29903,
  57595: 29908,
  57596: 29681,
  57664: 29920,
  57665: 29923,
  57666: 29927,
  57667: 29929,
  57668: 29934,
  57669: 29938,
  57670: 29936,
  57671: 29937,
  57672: 29944,
  57673: 29943,
  57674: 29956,
  57675: 29955,
  57676: 29957,
  57677: 29964,
  57678: 29966,
  57679: 29965,
  57680: 29973,
  57681: 29971,
  57682: 29982,
  57683: 29990,
  57684: 29996,
  57685: 30012,
  57686: 30020,
  57687: 30029,
  57688: 30026,
  57689: 30025,
  57690: 30043,
  57691: 30022,
  57692: 30042,
  57693: 30057,
  57694: 30052,
  57695: 30055,
  57696: 30059,
  57697: 30061,
  57698: 30072,
  57699: 30070,
  57700: 30086,
  57701: 30087,
  57702: 30068,
  57703: 30090,
  57704: 30089,
  57705: 30082,
  57706: 30100,
  57707: 30106,
  57708: 30109,
  57709: 30117,
  57710: 30115,
  57711: 30146,
  57712: 30131,
  57713: 30147,
  57714: 30133,
  57715: 30141,
  57716: 30136,
  57717: 30140,
  57718: 30129,
  57719: 30157,
  57720: 30154,
  57721: 30162,
  57722: 30169,
  57723: 30179,
  57724: 30174,
  57725: 30206,
  57726: 30207,
  57728: 30204,
  57729: 30209,
  57730: 30192,
  57731: 30202,
  57732: 30194,
  57733: 30195,
  57734: 30219,
  57735: 30221,
  57736: 30217,
  57737: 30239,
  57738: 30247,
  57739: 30240,
  57740: 30241,
  57741: 30242,
  57742: 30244,
  57743: 30260,
  57744: 30256,
  57745: 30267,
  57746: 30279,
  57747: 30280,
  57748: 30278,
  57749: 30300,
  57750: 30296,
  57751: 30305,
  57752: 30306,
  57753: 30312,
  57754: 30313,
  57755: 30314,
  57756: 30311,
  57757: 30316,
  57758: 30320,
  57759: 30322,
  57760: 30326,
  57761: 30328,
  57762: 30332,
  57763: 30336,
  57764: 30339,
  57765: 30344,
  57766: 30347,
  57767: 30350,
  57768: 30358,
  57769: 30355,
  57770: 30361,
  57771: 30362,
  57772: 30384,
  57773: 30388,
  57774: 30392,
  57775: 30393,
  57776: 30394,
  57777: 30402,
  57778: 30413,
  57779: 30422,
  57780: 30418,
  57781: 30430,
  57782: 30433,
  57783: 30437,
  57784: 30439,
  57785: 30442,
  57786: 34351,
  57787: 30459,
  57788: 30472,
  57789: 30471,
  57790: 30468,
  57791: 30505,
  57792: 30500,
  57793: 30494,
  57794: 30501,
  57795: 30502,
  57796: 30491,
  57797: 30519,
  57798: 30520,
  57799: 30535,
  57800: 30554,
  57801: 30568,
  57802: 30571,
  57803: 30555,
  57804: 30565,
  57805: 30591,
  57806: 30590,
  57807: 30585,
  57808: 30606,
  57809: 30603,
  57810: 30609,
  57811: 30624,
  57812: 30622,
  57813: 30640,
  57814: 30646,
  57815: 30649,
  57816: 30655,
  57817: 30652,
  57818: 30653,
  57819: 30651,
  57820: 30663,
  57821: 30669,
  57822: 30679,
  57823: 30682,
  57824: 30684,
  57825: 30691,
  57826: 30702,
  57827: 30716,
  57828: 30732,
  57829: 30738,
  57830: 31014,
  57831: 30752,
  57832: 31018,
  57833: 30789,
  57834: 30862,
  57835: 30836,
  57836: 30854,
  57837: 30844,
  57838: 30874,
  57839: 30860,
  57840: 30883,
  57841: 30901,
  57842: 30890,
  57843: 30895,
  57844: 30929,
  57845: 30918,
  57846: 30923,
  57847: 30932,
  57848: 30910,
  57849: 30908,
  57850: 30917,
  57851: 30922,
  57852: 30956,
  57920: 30951,
  57921: 30938,
  57922: 30973,
  57923: 30964,
  57924: 30983,
  57925: 30994,
  57926: 30993,
  57927: 31001,
  57928: 31020,
  57929: 31019,
  57930: 31040,
  57931: 31072,
  57932: 31063,
  57933: 31071,
  57934: 31066,
  57935: 31061,
  57936: 31059,
  57937: 31098,
  57938: 31103,
  57939: 31114,
  57940: 31133,
  57941: 31143,
  57942: 40779,
  57943: 31146,
  57944: 31150,
  57945: 31155,
  57946: 31161,
  57947: 31162,
  57948: 31177,
  57949: 31189,
  57950: 31207,
  57951: 31212,
  57952: 31201,
  57953: 31203,
  57954: 31240,
  57955: 31245,
  57956: 31256,
  57957: 31257,
  57958: 31264,
  57959: 31263,
  57960: 31104,
  57961: 31281,
  57962: 31291,
  57963: 31294,
  57964: 31287,
  57965: 31299,
  57966: 31319,
  57967: 31305,
  57968: 31329,
  57969: 31330,
  57970: 31337,
  57971: 40861,
  57972: 31344,
  57973: 31353,
  57974: 31357,
  57975: 31368,
  57976: 31383,
  57977: 31381,
  57978: 31384,
  57979: 31382,
  57980: 31401,
  57981: 31432,
  57982: 31408,
  57984: 31414,
  57985: 31429,
  57986: 31428,
  57987: 31423,
  57988: 36995,
  57989: 31431,
  57990: 31434,
  57991: 31437,
  57992: 31439,
  57993: 31445,
  57994: 31443,
  57995: 31449,
  57996: 31450,
  57997: 31453,
  57998: 31457,
  57999: 31458,
  58e3: 31462,
  58001: 31469,
  58002: 31472,
  58003: 31490,
  58004: 31503,
  58005: 31498,
  58006: 31494,
  58007: 31539,
  58008: 31512,
  58009: 31513,
  58010: 31518,
  58011: 31541,
  58012: 31528,
  58013: 31542,
  58014: 31568,
  58015: 31610,
  58016: 31492,
  58017: 31565,
  58018: 31499,
  58019: 31564,
  58020: 31557,
  58021: 31605,
  58022: 31589,
  58023: 31604,
  58024: 31591,
  58025: 31600,
  58026: 31601,
  58027: 31596,
  58028: 31598,
  58029: 31645,
  58030: 31640,
  58031: 31647,
  58032: 31629,
  58033: 31644,
  58034: 31642,
  58035: 31627,
  58036: 31634,
  58037: 31631,
  58038: 31581,
  58039: 31641,
  58040: 31691,
  58041: 31681,
  58042: 31692,
  58043: 31695,
  58044: 31668,
  58045: 31686,
  58046: 31709,
  58047: 31721,
  58048: 31761,
  58049: 31764,
  58050: 31718,
  58051: 31717,
  58052: 31840,
  58053: 31744,
  58054: 31751,
  58055: 31763,
  58056: 31731,
  58057: 31735,
  58058: 31767,
  58059: 31757,
  58060: 31734,
  58061: 31779,
  58062: 31783,
  58063: 31786,
  58064: 31775,
  58065: 31799,
  58066: 31787,
  58067: 31805,
  58068: 31820,
  58069: 31811,
  58070: 31828,
  58071: 31823,
  58072: 31808,
  58073: 31824,
  58074: 31832,
  58075: 31839,
  58076: 31844,
  58077: 31830,
  58078: 31845,
  58079: 31852,
  58080: 31861,
  58081: 31875,
  58082: 31888,
  58083: 31908,
  58084: 31917,
  58085: 31906,
  58086: 31915,
  58087: 31905,
  58088: 31912,
  58089: 31923,
  58090: 31922,
  58091: 31921,
  58092: 31918,
  58093: 31929,
  58094: 31933,
  58095: 31936,
  58096: 31941,
  58097: 31938,
  58098: 31960,
  58099: 31954,
  58100: 31964,
  58101: 31970,
  58102: 39739,
  58103: 31983,
  58104: 31986,
  58105: 31988,
  58106: 31990,
  58107: 31994,
  58108: 32006,
  58176: 32002,
  58177: 32028,
  58178: 32021,
  58179: 32010,
  58180: 32069,
  58181: 32075,
  58182: 32046,
  58183: 32050,
  58184: 32063,
  58185: 32053,
  58186: 32070,
  58187: 32115,
  58188: 32086,
  58189: 32078,
  58190: 32114,
  58191: 32104,
  58192: 32110,
  58193: 32079,
  58194: 32099,
  58195: 32147,
  58196: 32137,
  58197: 32091,
  58198: 32143,
  58199: 32125,
  58200: 32155,
  58201: 32186,
  58202: 32174,
  58203: 32163,
  58204: 32181,
  58205: 32199,
  58206: 32189,
  58207: 32171,
  58208: 32317,
  58209: 32162,
  58210: 32175,
  58211: 32220,
  58212: 32184,
  58213: 32159,
  58214: 32176,
  58215: 32216,
  58216: 32221,
  58217: 32228,
  58218: 32222,
  58219: 32251,
  58220: 32242,
  58221: 32225,
  58222: 32261,
  58223: 32266,
  58224: 32291,
  58225: 32289,
  58226: 32274,
  58227: 32305,
  58228: 32287,
  58229: 32265,
  58230: 32267,
  58231: 32290,
  58232: 32326,
  58233: 32358,
  58234: 32315,
  58235: 32309,
  58236: 32313,
  58237: 32323,
  58238: 32311,
  58240: 32306,
  58241: 32314,
  58242: 32359,
  58243: 32349,
  58244: 32342,
  58245: 32350,
  58246: 32345,
  58247: 32346,
  58248: 32377,
  58249: 32362,
  58250: 32361,
  58251: 32380,
  58252: 32379,
  58253: 32387,
  58254: 32213,
  58255: 32381,
  58256: 36782,
  58257: 32383,
  58258: 32392,
  58259: 32393,
  58260: 32396,
  58261: 32402,
  58262: 32400,
  58263: 32403,
  58264: 32404,
  58265: 32406,
  58266: 32398,
  58267: 32411,
  58268: 32412,
  58269: 32568,
  58270: 32570,
  58271: 32581,
  58272: 32588,
  58273: 32589,
  58274: 32590,
  58275: 32592,
  58276: 32593,
  58277: 32597,
  58278: 32596,
  58279: 32600,
  58280: 32607,
  58281: 32608,
  58282: 32616,
  58283: 32617,
  58284: 32615,
  58285: 32632,
  58286: 32642,
  58287: 32646,
  58288: 32643,
  58289: 32648,
  58290: 32647,
  58291: 32652,
  58292: 32660,
  58293: 32670,
  58294: 32669,
  58295: 32666,
  58296: 32675,
  58297: 32687,
  58298: 32690,
  58299: 32697,
  58300: 32686,
  58301: 32694,
  58302: 32696,
  58303: 35697,
  58304: 32709,
  58305: 32710,
  58306: 32714,
  58307: 32725,
  58308: 32724,
  58309: 32737,
  58310: 32742,
  58311: 32745,
  58312: 32755,
  58313: 32761,
  58314: 39132,
  58315: 32774,
  58316: 32772,
  58317: 32779,
  58318: 32786,
  58319: 32792,
  58320: 32793,
  58321: 32796,
  58322: 32801,
  58323: 32808,
  58324: 32831,
  58325: 32827,
  58326: 32842,
  58327: 32838,
  58328: 32850,
  58329: 32856,
  58330: 32858,
  58331: 32863,
  58332: 32866,
  58333: 32872,
  58334: 32883,
  58335: 32882,
  58336: 32880,
  58337: 32886,
  58338: 32889,
  58339: 32893,
  58340: 32895,
  58341: 32900,
  58342: 32902,
  58343: 32901,
  58344: 32923,
  58345: 32915,
  58346: 32922,
  58347: 32941,
  58348: 20880,
  58349: 32940,
  58350: 32987,
  58351: 32997,
  58352: 32985,
  58353: 32989,
  58354: 32964,
  58355: 32986,
  58356: 32982,
  58357: 33033,
  58358: 33007,
  58359: 33009,
  58360: 33051,
  58361: 33065,
  58362: 33059,
  58363: 33071,
  58364: 33099,
  58432: 38539,
  58433: 33094,
  58434: 33086,
  58435: 33107,
  58436: 33105,
  58437: 33020,
  58438: 33137,
  58439: 33134,
  58440: 33125,
  58441: 33126,
  58442: 33140,
  58443: 33155,
  58444: 33160,
  58445: 33162,
  58446: 33152,
  58447: 33154,
  58448: 33184,
  58449: 33173,
  58450: 33188,
  58451: 33187,
  58452: 33119,
  58453: 33171,
  58454: 33193,
  58455: 33200,
  58456: 33205,
  58457: 33214,
  58458: 33208,
  58459: 33213,
  58460: 33216,
  58461: 33218,
  58462: 33210,
  58463: 33225,
  58464: 33229,
  58465: 33233,
  58466: 33241,
  58467: 33240,
  58468: 33224,
  58469: 33242,
  58470: 33247,
  58471: 33248,
  58472: 33255,
  58473: 33274,
  58474: 33275,
  58475: 33278,
  58476: 33281,
  58477: 33282,
  58478: 33285,
  58479: 33287,
  58480: 33290,
  58481: 33293,
  58482: 33296,
  58483: 33302,
  58484: 33321,
  58485: 33323,
  58486: 33336,
  58487: 33331,
  58488: 33344,
  58489: 33369,
  58490: 33368,
  58491: 33373,
  58492: 33370,
  58493: 33375,
  58494: 33380,
  58496: 33378,
  58497: 33384,
  58498: 33386,
  58499: 33387,
  58500: 33326,
  58501: 33393,
  58502: 33399,
  58503: 33400,
  58504: 33406,
  58505: 33421,
  58506: 33426,
  58507: 33451,
  58508: 33439,
  58509: 33467,
  58510: 33452,
  58511: 33505,
  58512: 33507,
  58513: 33503,
  58514: 33490,
  58515: 33524,
  58516: 33523,
  58517: 33530,
  58518: 33683,
  58519: 33539,
  58520: 33531,
  58521: 33529,
  58522: 33502,
  58523: 33542,
  58524: 33500,
  58525: 33545,
  58526: 33497,
  58527: 33589,
  58528: 33588,
  58529: 33558,
  58530: 33586,
  58531: 33585,
  58532: 33600,
  58533: 33593,
  58534: 33616,
  58535: 33605,
  58536: 33583,
  58537: 33579,
  58538: 33559,
  58539: 33560,
  58540: 33669,
  58541: 33690,
  58542: 33706,
  58543: 33695,
  58544: 33698,
  58545: 33686,
  58546: 33571,
  58547: 33678,
  58548: 33671,
  58549: 33674,
  58550: 33660,
  58551: 33717,
  58552: 33651,
  58553: 33653,
  58554: 33696,
  58555: 33673,
  58556: 33704,
  58557: 33780,
  58558: 33811,
  58559: 33771,
  58560: 33742,
  58561: 33789,
  58562: 33795,
  58563: 33752,
  58564: 33803,
  58565: 33729,
  58566: 33783,
  58567: 33799,
  58568: 33760,
  58569: 33778,
  58570: 33805,
  58571: 33826,
  58572: 33824,
  58573: 33725,
  58574: 33848,
  58575: 34054,
  58576: 33787,
  58577: 33901,
  58578: 33834,
  58579: 33852,
  58580: 34138,
  58581: 33924,
  58582: 33911,
  58583: 33899,
  58584: 33965,
  58585: 33902,
  58586: 33922,
  58587: 33897,
  58588: 33862,
  58589: 33836,
  58590: 33903,
  58591: 33913,
  58592: 33845,
  58593: 33994,
  58594: 33890,
  58595: 33977,
  58596: 33983,
  58597: 33951,
  58598: 34009,
  58599: 33997,
  58600: 33979,
  58601: 34010,
  58602: 34e3,
  58603: 33985,
  58604: 33990,
  58605: 34006,
  58606: 33953,
  58607: 34081,
  58608: 34047,
  58609: 34036,
  58610: 34071,
  58611: 34072,
  58612: 34092,
  58613: 34079,
  58614: 34069,
  58615: 34068,
  58616: 34044,
  58617: 34112,
  58618: 34147,
  58619: 34136,
  58620: 34120,
  58688: 34113,
  58689: 34306,
  58690: 34123,
  58691: 34133,
  58692: 34176,
  58693: 34212,
  58694: 34184,
  58695: 34193,
  58696: 34186,
  58697: 34216,
  58698: 34157,
  58699: 34196,
  58700: 34203,
  58701: 34282,
  58702: 34183,
  58703: 34204,
  58704: 34167,
  58705: 34174,
  58706: 34192,
  58707: 34249,
  58708: 34234,
  58709: 34255,
  58710: 34233,
  58711: 34256,
  58712: 34261,
  58713: 34269,
  58714: 34277,
  58715: 34268,
  58716: 34297,
  58717: 34314,
  58718: 34323,
  58719: 34315,
  58720: 34302,
  58721: 34298,
  58722: 34310,
  58723: 34338,
  58724: 34330,
  58725: 34352,
  58726: 34367,
  58727: 34381,
  58728: 20053,
  58729: 34388,
  58730: 34399,
  58731: 34407,
  58732: 34417,
  58733: 34451,
  58734: 34467,
  58735: 34473,
  58736: 34474,
  58737: 34443,
  58738: 34444,
  58739: 34486,
  58740: 34479,
  58741: 34500,
  58742: 34502,
  58743: 34480,
  58744: 34505,
  58745: 34851,
  58746: 34475,
  58747: 34516,
  58748: 34526,
  58749: 34537,
  58750: 34540,
  58752: 34527,
  58753: 34523,
  58754: 34543,
  58755: 34578,
  58756: 34566,
  58757: 34568,
  58758: 34560,
  58759: 34563,
  58760: 34555,
  58761: 34577,
  58762: 34569,
  58763: 34573,
  58764: 34553,
  58765: 34570,
  58766: 34612,
  58767: 34623,
  58768: 34615,
  58769: 34619,
  58770: 34597,
  58771: 34601,
  58772: 34586,
  58773: 34656,
  58774: 34655,
  58775: 34680,
  58776: 34636,
  58777: 34638,
  58778: 34676,
  58779: 34647,
  58780: 34664,
  58781: 34670,
  58782: 34649,
  58783: 34643,
  58784: 34659,
  58785: 34666,
  58786: 34821,
  58787: 34722,
  58788: 34719,
  58789: 34690,
  58790: 34735,
  58791: 34763,
  58792: 34749,
  58793: 34752,
  58794: 34768,
  58795: 38614,
  58796: 34731,
  58797: 34756,
  58798: 34739,
  58799: 34759,
  58800: 34758,
  58801: 34747,
  58802: 34799,
  58803: 34802,
  58804: 34784,
  58805: 34831,
  58806: 34829,
  58807: 34814,
  58808: 34806,
  58809: 34807,
  58810: 34830,
  58811: 34770,
  58812: 34833,
  58813: 34838,
  58814: 34837,
  58815: 34850,
  58816: 34849,
  58817: 34865,
  58818: 34870,
  58819: 34873,
  58820: 34855,
  58821: 34875,
  58822: 34884,
  58823: 34882,
  58824: 34898,
  58825: 34905,
  58826: 34910,
  58827: 34914,
  58828: 34923,
  58829: 34945,
  58830: 34942,
  58831: 34974,
  58832: 34933,
  58833: 34941,
  58834: 34997,
  58835: 34930,
  58836: 34946,
  58837: 34967,
  58838: 34962,
  58839: 34990,
  58840: 34969,
  58841: 34978,
  58842: 34957,
  58843: 34980,
  58844: 34992,
  58845: 35007,
  58846: 34993,
  58847: 35011,
  58848: 35012,
  58849: 35028,
  58850: 35032,
  58851: 35033,
  58852: 35037,
  58853: 35065,
  58854: 35074,
  58855: 35068,
  58856: 35060,
  58857: 35048,
  58858: 35058,
  58859: 35076,
  58860: 35084,
  58861: 35082,
  58862: 35091,
  58863: 35139,
  58864: 35102,
  58865: 35109,
  58866: 35114,
  58867: 35115,
  58868: 35137,
  58869: 35140,
  58870: 35131,
  58871: 35126,
  58872: 35128,
  58873: 35148,
  58874: 35101,
  58875: 35168,
  58876: 35166,
  58944: 35174,
  58945: 35172,
  58946: 35181,
  58947: 35178,
  58948: 35183,
  58949: 35188,
  58950: 35191,
  58951: 35198,
  58952: 35203,
  58953: 35208,
  58954: 35210,
  58955: 35219,
  58956: 35224,
  58957: 35233,
  58958: 35241,
  58959: 35238,
  58960: 35244,
  58961: 35247,
  58962: 35250,
  58963: 35258,
  58964: 35261,
  58965: 35263,
  58966: 35264,
  58967: 35290,
  58968: 35292,
  58969: 35293,
  58970: 35303,
  58971: 35316,
  58972: 35320,
  58973: 35331,
  58974: 35350,
  58975: 35344,
  58976: 35340,
  58977: 35355,
  58978: 35357,
  58979: 35365,
  58980: 35382,
  58981: 35393,
  58982: 35419,
  58983: 35410,
  58984: 35398,
  58985: 35400,
  58986: 35452,
  58987: 35437,
  58988: 35436,
  58989: 35426,
  58990: 35461,
  58991: 35458,
  58992: 35460,
  58993: 35496,
  58994: 35489,
  58995: 35473,
  58996: 35493,
  58997: 35494,
  58998: 35482,
  58999: 35491,
  59e3: 35524,
  59001: 35533,
  59002: 35522,
  59003: 35546,
  59004: 35563,
  59005: 35571,
  59006: 35559,
  59008: 35556,
  59009: 35569,
  59010: 35604,
  59011: 35552,
  59012: 35554,
  59013: 35575,
  59014: 35550,
  59015: 35547,
  59016: 35596,
  59017: 35591,
  59018: 35610,
  59019: 35553,
  59020: 35606,
  59021: 35600,
  59022: 35607,
  59023: 35616,
  59024: 35635,
  59025: 38827,
  59026: 35622,
  59027: 35627,
  59028: 35646,
  59029: 35624,
  59030: 35649,
  59031: 35660,
  59032: 35663,
  59033: 35662,
  59034: 35657,
  59035: 35670,
  59036: 35675,
  59037: 35674,
  59038: 35691,
  59039: 35679,
  59040: 35692,
  59041: 35695,
  59042: 35700,
  59043: 35709,
  59044: 35712,
  59045: 35724,
  59046: 35726,
  59047: 35730,
  59048: 35731,
  59049: 35734,
  59050: 35737,
  59051: 35738,
  59052: 35898,
  59053: 35905,
  59054: 35903,
  59055: 35912,
  59056: 35916,
  59057: 35918,
  59058: 35920,
  59059: 35925,
  59060: 35938,
  59061: 35948,
  59062: 35960,
  59063: 35962,
  59064: 35970,
  59065: 35977,
  59066: 35973,
  59067: 35978,
  59068: 35981,
  59069: 35982,
  59070: 35988,
  59071: 35964,
  59072: 35992,
  59073: 25117,
  59074: 36013,
  59075: 36010,
  59076: 36029,
  59077: 36018,
  59078: 36019,
  59079: 36014,
  59080: 36022,
  59081: 36040,
  59082: 36033,
  59083: 36068,
  59084: 36067,
  59085: 36058,
  59086: 36093,
  59087: 36090,
  59088: 36091,
  59089: 36100,
  59090: 36101,
  59091: 36106,
  59092: 36103,
  59093: 36111,
  59094: 36109,
  59095: 36112,
  59096: 40782,
  59097: 36115,
  59098: 36045,
  59099: 36116,
  59100: 36118,
  59101: 36199,
  59102: 36205,
  59103: 36209,
  59104: 36211,
  59105: 36225,
  59106: 36249,
  59107: 36290,
  59108: 36286,
  59109: 36282,
  59110: 36303,
  59111: 36314,
  59112: 36310,
  59113: 36300,
  59114: 36315,
  59115: 36299,
  59116: 36330,
  59117: 36331,
  59118: 36319,
  59119: 36323,
  59120: 36348,
  59121: 36360,
  59122: 36361,
  59123: 36351,
  59124: 36381,
  59125: 36382,
  59126: 36368,
  59127: 36383,
  59128: 36418,
  59129: 36405,
  59130: 36400,
  59131: 36404,
  59132: 36426,
  59200: 36423,
  59201: 36425,
  59202: 36428,
  59203: 36432,
  59204: 36424,
  59205: 36441,
  59206: 36452,
  59207: 36448,
  59208: 36394,
  59209: 36451,
  59210: 36437,
  59211: 36470,
  59212: 36466,
  59213: 36476,
  59214: 36481,
  59215: 36487,
  59216: 36485,
  59217: 36484,
  59218: 36491,
  59219: 36490,
  59220: 36499,
  59221: 36497,
  59222: 36500,
  59223: 36505,
  59224: 36522,
  59225: 36513,
  59226: 36524,
  59227: 36528,
  59228: 36550,
  59229: 36529,
  59230: 36542,
  59231: 36549,
  59232: 36552,
  59233: 36555,
  59234: 36571,
  59235: 36579,
  59236: 36604,
  59237: 36603,
  59238: 36587,
  59239: 36606,
  59240: 36618,
  59241: 36613,
  59242: 36629,
  59243: 36626,
  59244: 36633,
  59245: 36627,
  59246: 36636,
  59247: 36639,
  59248: 36635,
  59249: 36620,
  59250: 36646,
  59251: 36659,
  59252: 36667,
  59253: 36665,
  59254: 36677,
  59255: 36674,
  59256: 36670,
  59257: 36684,
  59258: 36681,
  59259: 36678,
  59260: 36686,
  59261: 36695,
  59262: 36700,
  59264: 36706,
  59265: 36707,
  59266: 36708,
  59267: 36764,
  59268: 36767,
  59269: 36771,
  59270: 36781,
  59271: 36783,
  59272: 36791,
  59273: 36826,
  59274: 36837,
  59275: 36834,
  59276: 36842,
  59277: 36847,
  59278: 36999,
  59279: 36852,
  59280: 36869,
  59281: 36857,
  59282: 36858,
  59283: 36881,
  59284: 36885,
  59285: 36897,
  59286: 36877,
  59287: 36894,
  59288: 36886,
  59289: 36875,
  59290: 36903,
  59291: 36918,
  59292: 36917,
  59293: 36921,
  59294: 36856,
  59295: 36943,
  59296: 36944,
  59297: 36945,
  59298: 36946,
  59299: 36878,
  59300: 36937,
  59301: 36926,
  59302: 36950,
  59303: 36952,
  59304: 36958,
  59305: 36968,
  59306: 36975,
  59307: 36982,
  59308: 38568,
  59309: 36978,
  59310: 36994,
  59311: 36989,
  59312: 36993,
  59313: 36992,
  59314: 37002,
  59315: 37001,
  59316: 37007,
  59317: 37032,
  59318: 37039,
  59319: 37041,
  59320: 37045,
  59321: 37090,
  59322: 37092,
  59323: 25160,
  59324: 37083,
  59325: 37122,
  59326: 37138,
  59327: 37145,
  59328: 37170,
  59329: 37168,
  59330: 37194,
  59331: 37206,
  59332: 37208,
  59333: 37219,
  59334: 37221,
  59335: 37225,
  59336: 37235,
  59337: 37234,
  59338: 37259,
  59339: 37257,
  59340: 37250,
  59341: 37282,
  59342: 37291,
  59343: 37295,
  59344: 37290,
  59345: 37301,
  59346: 37300,
  59347: 37306,
  59348: 37312,
  59349: 37313,
  59350: 37321,
  59351: 37323,
  59352: 37328,
  59353: 37334,
  59354: 37343,
  59355: 37345,
  59356: 37339,
  59357: 37372,
  59358: 37365,
  59359: 37366,
  59360: 37406,
  59361: 37375,
  59362: 37396,
  59363: 37420,
  59364: 37397,
  59365: 37393,
  59366: 37470,
  59367: 37463,
  59368: 37445,
  59369: 37449,
  59370: 37476,
  59371: 37448,
  59372: 37525,
  59373: 37439,
  59374: 37451,
  59375: 37456,
  59376: 37532,
  59377: 37526,
  59378: 37523,
  59379: 37531,
  59380: 37466,
  59381: 37583,
  59382: 37561,
  59383: 37559,
  59384: 37609,
  59385: 37647,
  59386: 37626,
  59387: 37700,
  59388: 37678,
  59456: 37657,
  59457: 37666,
  59458: 37658,
  59459: 37667,
  59460: 37690,
  59461: 37685,
  59462: 37691,
  59463: 37724,
  59464: 37728,
  59465: 37756,
  59466: 37742,
  59467: 37718,
  59468: 37808,
  59469: 37804,
  59470: 37805,
  59471: 37780,
  59472: 37817,
  59473: 37846,
  59474: 37847,
  59475: 37864,
  59476: 37861,
  59477: 37848,
  59478: 37827,
  59479: 37853,
  59480: 37840,
  59481: 37832,
  59482: 37860,
  59483: 37914,
  59484: 37908,
  59485: 37907,
  59486: 37891,
  59487: 37895,
  59488: 37904,
  59489: 37942,
  59490: 37931,
  59491: 37941,
  59492: 37921,
  59493: 37946,
  59494: 37953,
  59495: 37970,
  59496: 37956,
  59497: 37979,
  59498: 37984,
  59499: 37986,
  59500: 37982,
  59501: 37994,
  59502: 37417,
  59503: 38e3,
  59504: 38005,
  59505: 38007,
  59506: 38013,
  59507: 37978,
  59508: 38012,
  59509: 38014,
  59510: 38017,
  59511: 38015,
  59512: 38274,
  59513: 38279,
  59514: 38282,
  59515: 38292,
  59516: 38294,
  59517: 38296,
  59518: 38297,
  59520: 38304,
  59521: 38312,
  59522: 38311,
  59523: 38317,
  59524: 38332,
  59525: 38331,
  59526: 38329,
  59527: 38334,
  59528: 38346,
  59529: 28662,
  59530: 38339,
  59531: 38349,
  59532: 38348,
  59533: 38357,
  59534: 38356,
  59535: 38358,
  59536: 38364,
  59537: 38369,
  59538: 38373,
  59539: 38370,
  59540: 38433,
  59541: 38440,
  59542: 38446,
  59543: 38447,
  59544: 38466,
  59545: 38476,
  59546: 38479,
  59547: 38475,
  59548: 38519,
  59549: 38492,
  59550: 38494,
  59551: 38493,
  59552: 38495,
  59553: 38502,
  59554: 38514,
  59555: 38508,
  59556: 38541,
  59557: 38552,
  59558: 38549,
  59559: 38551,
  59560: 38570,
  59561: 38567,
  59562: 38577,
  59563: 38578,
  59564: 38576,
  59565: 38580,
  59566: 38582,
  59567: 38584,
  59568: 38585,
  59569: 38606,
  59570: 38603,
  59571: 38601,
  59572: 38605,
  59573: 35149,
  59574: 38620,
  59575: 38669,
  59576: 38613,
  59577: 38649,
  59578: 38660,
  59579: 38662,
  59580: 38664,
  59581: 38675,
  59582: 38670,
  59583: 38673,
  59584: 38671,
  59585: 38678,
  59586: 38681,
  59587: 38692,
  59588: 38698,
  59589: 38704,
  59590: 38713,
  59591: 38717,
  59592: 38718,
  59593: 38724,
  59594: 38726,
  59595: 38728,
  59596: 38722,
  59597: 38729,
  59598: 38748,
  59599: 38752,
  59600: 38756,
  59601: 38758,
  59602: 38760,
  59603: 21202,
  59604: 38763,
  59605: 38769,
  59606: 38777,
  59607: 38789,
  59608: 38780,
  59609: 38785,
  59610: 38778,
  59611: 38790,
  59612: 38795,
  59613: 38799,
  59614: 38800,
  59615: 38812,
  59616: 38824,
  59617: 38822,
  59618: 38819,
  59619: 38835,
  59620: 38836,
  59621: 38851,
  59622: 38854,
  59623: 38856,
  59624: 38859,
  59625: 38876,
  59626: 38893,
  59627: 40783,
  59628: 38898,
  59629: 31455,
  59630: 38902,
  59631: 38901,
  59632: 38927,
  59633: 38924,
  59634: 38968,
  59635: 38948,
  59636: 38945,
  59637: 38967,
  59638: 38973,
  59639: 38982,
  59640: 38991,
  59641: 38987,
  59642: 39019,
  59643: 39023,
  59644: 39024,
  59712: 39025,
  59713: 39028,
  59714: 39027,
  59715: 39082,
  59716: 39087,
  59717: 39089,
  59718: 39094,
  59719: 39108,
  59720: 39107,
  59721: 39110,
  59722: 39145,
  59723: 39147,
  59724: 39171,
  59725: 39177,
  59726: 39186,
  59727: 39188,
  59728: 39192,
  59729: 39201,
  59730: 39197,
  59731: 39198,
  59732: 39204,
  59733: 39200,
  59734: 39212,
  59735: 39214,
  59736: 39229,
  59737: 39230,
  59738: 39234,
  59739: 39241,
  59740: 39237,
  59741: 39248,
  59742: 39243,
  59743: 39249,
  59744: 39250,
  59745: 39244,
  59746: 39253,
  59747: 39319,
  59748: 39320,
  59749: 39333,
  59750: 39341,
  59751: 39342,
  59752: 39356,
  59753: 39391,
  59754: 39387,
  59755: 39389,
  59756: 39384,
  59757: 39377,
  59758: 39405,
  59759: 39406,
  59760: 39409,
  59761: 39410,
  59762: 39419,
  59763: 39416,
  59764: 39425,
  59765: 39439,
  59766: 39429,
  59767: 39394,
  59768: 39449,
  59769: 39467,
  59770: 39479,
  59771: 39493,
  59772: 39490,
  59773: 39488,
  59774: 39491,
  59776: 39486,
  59777: 39509,
  59778: 39501,
  59779: 39515,
  59780: 39511,
  59781: 39519,
  59782: 39522,
  59783: 39525,
  59784: 39524,
  59785: 39529,
  59786: 39531,
  59787: 39530,
  59788: 39597,
  59789: 39600,
  59790: 39612,
  59791: 39616,
  59792: 39631,
  59793: 39633,
  59794: 39635,
  59795: 39636,
  59796: 39646,
  59797: 39647,
  59798: 39650,
  59799: 39651,
  59800: 39654,
  59801: 39663,
  59802: 39659,
  59803: 39662,
  59804: 39668,
  59805: 39665,
  59806: 39671,
  59807: 39675,
  59808: 39686,
  59809: 39704,
  59810: 39706,
  59811: 39711,
  59812: 39714,
  59813: 39715,
  59814: 39717,
  59815: 39719,
  59816: 39720,
  59817: 39721,
  59818: 39722,
  59819: 39726,
  59820: 39727,
  59821: 39730,
  59822: 39748,
  59823: 39747,
  59824: 39759,
  59825: 39757,
  59826: 39758,
  59827: 39761,
  59828: 39768,
  59829: 39796,
  59830: 39827,
  59831: 39811,
  59832: 39825,
  59833: 39830,
  59834: 39831,
  59835: 39839,
  59836: 39840,
  59837: 39848,
  59838: 39860,
  59839: 39872,
  59840: 39882,
  59841: 39865,
  59842: 39878,
  59843: 39887,
  59844: 39889,
  59845: 39890,
  59846: 39907,
  59847: 39906,
  59848: 39908,
  59849: 39892,
  59850: 39905,
  59851: 39994,
  59852: 39922,
  59853: 39921,
  59854: 39920,
  59855: 39957,
  59856: 39956,
  59857: 39945,
  59858: 39955,
  59859: 39948,
  59860: 39942,
  59861: 39944,
  59862: 39954,
  59863: 39946,
  59864: 39940,
  59865: 39982,
  59866: 39963,
  59867: 39973,
  59868: 39972,
  59869: 39969,
  59870: 39984,
  59871: 40007,
  59872: 39986,
  59873: 40006,
  59874: 39998,
  59875: 40026,
  59876: 40032,
  59877: 40039,
  59878: 40054,
  59879: 40056,
  59880: 40167,
  59881: 40172,
  59882: 40176,
  59883: 40201,
  59884: 40200,
  59885: 40171,
  59886: 40195,
  59887: 40198,
  59888: 40234,
  59889: 40230,
  59890: 40367,
  59891: 40227,
  59892: 40223,
  59893: 40260,
  59894: 40213,
  59895: 40210,
  59896: 40257,
  59897: 40255,
  59898: 40254,
  59899: 40262,
  59900: 40264,
  59968: 40285,
  59969: 40286,
  59970: 40292,
  59971: 40273,
  59972: 40272,
  59973: 40281,
  59974: 40306,
  59975: 40329,
  59976: 40327,
  59977: 40363,
  59978: 40303,
  59979: 40314,
  59980: 40346,
  59981: 40356,
  59982: 40361,
  59983: 40370,
  59984: 40388,
  59985: 40385,
  59986: 40379,
  59987: 40376,
  59988: 40378,
  59989: 40390,
  59990: 40399,
  59991: 40386,
  59992: 40409,
  59993: 40403,
  59994: 40440,
  59995: 40422,
  59996: 40429,
  59997: 40431,
  59998: 40445,
  59999: 40474,
  6e4: 40475,
  60001: 40478,
  60002: 40565,
  60003: 40569,
  60004: 40573,
  60005: 40577,
  60006: 40584,
  60007: 40587,
  60008: 40588,
  60009: 40594,
  60010: 40597,
  60011: 40593,
  60012: 40605,
  60013: 40613,
  60014: 40617,
  60015: 40632,
  60016: 40618,
  60017: 40621,
  60018: 38753,
  60019: 40652,
  60020: 40654,
  60021: 40655,
  60022: 40656,
  60023: 40660,
  60024: 40668,
  60025: 40670,
  60026: 40669,
  60027: 40672,
  60028: 40677,
  60029: 40680,
  60030: 40687,
  60032: 40692,
  60033: 40694,
  60034: 40695,
  60035: 40697,
  60036: 40699,
  60037: 40700,
  60038: 40701,
  60039: 40711,
  60040: 40712,
  60041: 30391,
  60042: 40725,
  60043: 40737,
  60044: 40748,
  60045: 40766,
  60046: 40778,
  60047: 40786,
  60048: 40788,
  60049: 40803,
  60050: 40799,
  60051: 40800,
  60052: 40801,
  60053: 40806,
  60054: 40807,
  60055: 40812,
  60056: 40810,
  60057: 40823,
  60058: 40818,
  60059: 40822,
  60060: 40853,
  60061: 40860,
  60062: 40864,
  60063: 22575,
  60064: 27079,
  60065: 36953,
  60066: 29796,
  60067: 20956,
  60068: 29081,
  60736: 32394,
  60737: 35100,
  60738: 37704,
  60739: 37512,
  60740: 34012,
  60741: 20425,
  60742: 28859,
  60743: 26161,
  60744: 26824,
  60745: 37625,
  60746: 26363,
  60747: 24389,
  60748: 20008,
  60749: 20193,
  60750: 20220,
  60751: 20224,
  60752: 20227,
  60753: 20281,
  60754: 20310,
  60755: 20370,
  60756: 20362,
  60757: 20378,
  60758: 20372,
  60759: 20429,
  60760: 20544,
  60761: 20514,
  60762: 20479,
  60763: 20510,
  60764: 20550,
  60765: 20592,
  60766: 20546,
  60767: 20628,
  60768: 20724,
  60769: 20696,
  60770: 20810,
  60771: 20836,
  60772: 20893,
  60773: 20926,
  60774: 20972,
  60775: 21013,
  60776: 21148,
  60777: 21158,
  60778: 21184,
  60779: 21211,
  60780: 21248,
  60781: 21255,
  60782: 21284,
  60783: 21362,
  60784: 21395,
  60785: 21426,
  60786: 21469,
  60787: 64014,
  60788: 21660,
  60789: 21642,
  60790: 21673,
  60791: 21759,
  60792: 21894,
  60793: 22361,
  60794: 22373,
  60795: 22444,
  60796: 22472,
  60797: 22471,
  60798: 64015,
  60800: 64016,
  60801: 22686,
  60802: 22706,
  60803: 22795,
  60804: 22867,
  60805: 22875,
  60806: 22877,
  60807: 22883,
  60808: 22948,
  60809: 22970,
  60810: 23382,
  60811: 23488,
  60812: 29999,
  60813: 23512,
  60814: 23532,
  60815: 23582,
  60816: 23718,
  60817: 23738,
  60818: 23797,
  60819: 23847,
  60820: 23891,
  60821: 64017,
  60822: 23874,
  60823: 23917,
  60824: 23992,
  60825: 23993,
  60826: 24016,
  60827: 24353,
  60828: 24372,
  60829: 24423,
  60830: 24503,
  60831: 24542,
  60832: 24669,
  60833: 24709,
  60834: 24714,
  60835: 24798,
  60836: 24789,
  60837: 24864,
  60838: 24818,
  60839: 24849,
  60840: 24887,
  60841: 24880,
  60842: 24984,
  60843: 25107,
  60844: 25254,
  60845: 25589,
  60846: 25696,
  60847: 25757,
  60848: 25806,
  60849: 25934,
  60850: 26112,
  60851: 26133,
  60852: 26171,
  60853: 26121,
  60854: 26158,
  60855: 26142,
  60856: 26148,
  60857: 26213,
  60858: 26199,
  60859: 26201,
  60860: 64018,
  60861: 26227,
  60862: 26265,
  60863: 26272,
  60864: 26290,
  60865: 26303,
  60866: 26362,
  60867: 26382,
  60868: 63785,
  60869: 26470,
  60870: 26555,
  60871: 26706,
  60872: 26560,
  60873: 26625,
  60874: 26692,
  60875: 26831,
  60876: 64019,
  60877: 26984,
  60878: 64020,
  60879: 27032,
  60880: 27106,
  60881: 27184,
  60882: 27243,
  60883: 27206,
  60884: 27251,
  60885: 27262,
  60886: 27362,
  60887: 27364,
  60888: 27606,
  60889: 27711,
  60890: 27740,
  60891: 27782,
  60892: 27759,
  60893: 27866,
  60894: 27908,
  60895: 28039,
  60896: 28015,
  60897: 28054,
  60898: 28076,
  60899: 28111,
  60900: 28152,
  60901: 28146,
  60902: 28156,
  60903: 28217,
  60904: 28252,
  60905: 28199,
  60906: 28220,
  60907: 28351,
  60908: 28552,
  60909: 28597,
  60910: 28661,
  60911: 28677,
  60912: 28679,
  60913: 28712,
  60914: 28805,
  60915: 28843,
  60916: 28943,
  60917: 28932,
  60918: 29020,
  60919: 28998,
  60920: 28999,
  60921: 64021,
  60922: 29121,
  60923: 29182,
  60924: 29361,
  60992: 29374,
  60993: 29476,
  60994: 64022,
  60995: 29559,
  60996: 29629,
  60997: 29641,
  60998: 29654,
  60999: 29667,
  61e3: 29650,
  61001: 29703,
  61002: 29685,
  61003: 29734,
  61004: 29738,
  61005: 29737,
  61006: 29742,
  61007: 29794,
  61008: 29833,
  61009: 29855,
  61010: 29953,
  61011: 30063,
  61012: 30338,
  61013: 30364,
  61014: 30366,
  61015: 30363,
  61016: 30374,
  61017: 64023,
  61018: 30534,
  61019: 21167,
  61020: 30753,
  61021: 30798,
  61022: 30820,
  61023: 30842,
  61024: 31024,
  61025: 64024,
  61026: 64025,
  61027: 64026,
  61028: 31124,
  61029: 64027,
  61030: 31131,
  61031: 31441,
  61032: 31463,
  61033: 64028,
  61034: 31467,
  61035: 31646,
  61036: 64029,
  61037: 32072,
  61038: 32092,
  61039: 32183,
  61040: 32160,
  61041: 32214,
  61042: 32338,
  61043: 32583,
  61044: 32673,
  61045: 64030,
  61046: 33537,
  61047: 33634,
  61048: 33663,
  61049: 33735,
  61050: 33782,
  61051: 33864,
  61052: 33972,
  61053: 34131,
  61054: 34137,
  61056: 34155,
  61057: 64031,
  61058: 34224,
  61059: 64032,
  61060: 64033,
  61061: 34823,
  61062: 35061,
  61063: 35346,
  61064: 35383,
  61065: 35449,
  61066: 35495,
  61067: 35518,
  61068: 35551,
  61069: 64034,
  61070: 35574,
  61071: 35667,
  61072: 35711,
  61073: 36080,
  61074: 36084,
  61075: 36114,
  61076: 36214,
  61077: 64035,
  61078: 36559,
  61079: 64036,
  61080: 64037,
  61081: 36967,
  61082: 37086,
  61083: 64038,
  61084: 37141,
  61085: 37159,
  61086: 37338,
  61087: 37335,
  61088: 37342,
  61089: 37357,
  61090: 37358,
  61091: 37348,
  61092: 37349,
  61093: 37382,
  61094: 37392,
  61095: 37386,
  61096: 37434,
  61097: 37440,
  61098: 37436,
  61099: 37454,
  61100: 37465,
  61101: 37457,
  61102: 37433,
  61103: 37479,
  61104: 37543,
  61105: 37495,
  61106: 37496,
  61107: 37607,
  61108: 37591,
  61109: 37593,
  61110: 37584,
  61111: 64039,
  61112: 37589,
  61113: 37600,
  61114: 37587,
  61115: 37669,
  61116: 37665,
  61117: 37627,
  61118: 64040,
  61119: 37662,
  61120: 37631,
  61121: 37661,
  61122: 37634,
  61123: 37744,
  61124: 37719,
  61125: 37796,
  61126: 37830,
  61127: 37854,
  61128: 37880,
  61129: 37937,
  61130: 37957,
  61131: 37960,
  61132: 38290,
  61133: 63964,
  61134: 64041,
  61135: 38557,
  61136: 38575,
  61137: 38707,
  61138: 38715,
  61139: 38723,
  61140: 38733,
  61141: 38735,
  61142: 38737,
  61143: 38741,
  61144: 38999,
  61145: 39013,
  61146: 64042,
  61147: 64043,
  61148: 39207,
  61149: 64044,
  61150: 39326,
  61151: 39502,
  61152: 39641,
  61153: 39644,
  61154: 39797,
  61155: 39794,
  61156: 39823,
  61157: 39857,
  61158: 39867,
  61159: 39936,
  61160: 40304,
  61161: 40299,
  61162: 64045,
  61163: 40473,
  61164: 40657,
  61167: 8560,
  61168: 8561,
  61169: 8562,
  61170: 8563,
  61171: 8564,
  61172: 8565,
  61173: 8566,
  61174: 8567,
  61175: 8568,
  61176: 8569,
  61177: 65506,
  61178: 65508,
  61179: 65287,
  61180: 65282,
  61504: 57344,
  61505: 57345,
  61506: 57346,
  61507: 57347,
  61508: 57348,
  61509: 57349,
  61510: 57350,
  61511: 57351,
  61512: 57352,
  61513: 57353,
  61514: 57354,
  61515: 57355,
  61516: 57356,
  61517: 57357,
  61518: 57358,
  61519: 57359,
  61520: 57360,
  61521: 57361,
  61522: 57362,
  61523: 57363,
  61524: 57364,
  61525: 57365,
  61526: 57366,
  61527: 57367,
  61528: 57368,
  61529: 57369,
  61530: 57370,
  61531: 57371,
  61532: 57372,
  61533: 57373,
  61534: 57374,
  61535: 57375,
  61536: 57376,
  61537: 57377,
  61538: 57378,
  61539: 57379,
  61540: 57380,
  61541: 57381,
  61542: 57382,
  61543: 57383,
  61544: 57384,
  61545: 57385,
  61546: 57386,
  61547: 57387,
  61548: 57388,
  61549: 57389,
  61550: 57390,
  61551: 57391,
  61552: 57392,
  61553: 57393,
  61554: 57394,
  61555: 57395,
  61556: 57396,
  61557: 57397,
  61558: 57398,
  61559: 57399,
  61560: 57400,
  61561: 57401,
  61562: 57402,
  61563: 57403,
  61564: 57404,
  61565: 57405,
  61566: 57406,
  61568: 57407,
  61569: 57408,
  61570: 57409,
  61571: 57410,
  61572: 57411,
  61573: 57412,
  61574: 57413,
  61575: 57414,
  61576: 57415,
  61577: 57416,
  61578: 57417,
  61579: 57418,
  61580: 57419,
  61581: 57420,
  61582: 57421,
  61583: 57422,
  61584: 57423,
  61585: 57424,
  61586: 57425,
  61587: 57426,
  61588: 57427,
  61589: 57428,
  61590: 57429,
  61591: 57430,
  61592: 57431,
  61593: 57432,
  61594: 57433,
  61595: 57434,
  61596: 57435,
  61597: 57436,
  61598: 57437,
  61599: 57438,
  61600: 57439,
  61601: 57440,
  61602: 57441,
  61603: 57442,
  61604: 57443,
  61605: 57444,
  61606: 57445,
  61607: 57446,
  61608: 57447,
  61609: 57448,
  61610: 57449,
  61611: 57450,
  61612: 57451,
  61613: 57452,
  61614: 57453,
  61615: 57454,
  61616: 57455,
  61617: 57456,
  61618: 57457,
  61619: 57458,
  61620: 57459,
  61621: 57460,
  61622: 57461,
  61623: 57462,
  61624: 57463,
  61625: 57464,
  61626: 57465,
  61627: 57466,
  61628: 57467,
  61629: 57468,
  61630: 57469,
  61631: 57470,
  61632: 57471,
  61633: 57472,
  61634: 57473,
  61635: 57474,
  61636: 57475,
  61637: 57476,
  61638: 57477,
  61639: 57478,
  61640: 57479,
  61641: 57480,
  61642: 57481,
  61643: 57482,
  61644: 57483,
  61645: 57484,
  61646: 57485,
  61647: 57486,
  61648: 57487,
  61649: 57488,
  61650: 57489,
  61651: 57490,
  61652: 57491,
  61653: 57492,
  61654: 57493,
  61655: 57494,
  61656: 57495,
  61657: 57496,
  61658: 57497,
  61659: 57498,
  61660: 57499,
  61661: 57500,
  61662: 57501,
  61663: 57502,
  61664: 57503,
  61665: 57504,
  61666: 57505,
  61667: 57506,
  61668: 57507,
  61669: 57508,
  61670: 57509,
  61671: 57510,
  61672: 57511,
  61673: 57512,
  61674: 57513,
  61675: 57514,
  61676: 57515,
  61677: 57516,
  61678: 57517,
  61679: 57518,
  61680: 57519,
  61681: 57520,
  61682: 57521,
  61683: 57522,
  61684: 57523,
  61685: 57524,
  61686: 57525,
  61687: 57526,
  61688: 57527,
  61689: 57528,
  61690: 57529,
  61691: 57530,
  61692: 57531,
  61760: 57532,
  61761: 57533,
  61762: 57534,
  61763: 57535,
  61764: 57536,
  61765: 57537,
  61766: 57538,
  61767: 57539,
  61768: 57540,
  61769: 57541,
  61770: 57542,
  61771: 57543,
  61772: 57544,
  61773: 57545,
  61774: 57546,
  61775: 57547,
  61776: 57548,
  61777: 57549,
  61778: 57550,
  61779: 57551,
  61780: 57552,
  61781: 57553,
  61782: 57554,
  61783: 57555,
  61784: 57556,
  61785: 57557,
  61786: 57558,
  61787: 57559,
  61788: 57560,
  61789: 57561,
  61790: 57562,
  61791: 57563,
  61792: 57564,
  61793: 57565,
  61794: 57566,
  61795: 57567,
  61796: 57568,
  61797: 57569,
  61798: 57570,
  61799: 57571,
  61800: 57572,
  61801: 57573,
  61802: 57574,
  61803: 57575,
  61804: 57576,
  61805: 57577,
  61806: 57578,
  61807: 57579,
  61808: 57580,
  61809: 57581,
  61810: 57582,
  61811: 57583,
  61812: 57584,
  61813: 57585,
  61814: 57586,
  61815: 57587,
  61816: 57588,
  61817: 57589,
  61818: 57590,
  61819: 57591,
  61820: 57592,
  61821: 57593,
  61822: 57594,
  61824: 57595,
  61825: 57596,
  61826: 57597,
  61827: 57598,
  61828: 57599,
  61829: 57600,
  61830: 57601,
  61831: 57602,
  61832: 57603,
  61833: 57604,
  61834: 57605,
  61835: 57606,
  61836: 57607,
  61837: 57608,
  61838: 57609,
  61839: 57610,
  61840: 57611,
  61841: 57612,
  61842: 57613,
  61843: 57614,
  61844: 57615,
  61845: 57616,
  61846: 57617,
  61847: 57618,
  61848: 57619,
  61849: 57620,
  61850: 57621,
  61851: 57622,
  61852: 57623,
  61853: 57624,
  61854: 57625,
  61855: 57626,
  61856: 57627,
  61857: 57628,
  61858: 57629,
  61859: 57630,
  61860: 57631,
  61861: 57632,
  61862: 57633,
  61863: 57634,
  61864: 57635,
  61865: 57636,
  61866: 57637,
  61867: 57638,
  61868: 57639,
  61869: 57640,
  61870: 57641,
  61871: 57642,
  61872: 57643,
  61873: 57644,
  61874: 57645,
  61875: 57646,
  61876: 57647,
  61877: 57648,
  61878: 57649,
  61879: 57650,
  61880: 57651,
  61881: 57652,
  61882: 57653,
  61883: 57654,
  61884: 57655,
  61885: 57656,
  61886: 57657,
  61887: 57658,
  61888: 57659,
  61889: 57660,
  61890: 57661,
  61891: 57662,
  61892: 57663,
  61893: 57664,
  61894: 57665,
  61895: 57666,
  61896: 57667,
  61897: 57668,
  61898: 57669,
  61899: 57670,
  61900: 57671,
  61901: 57672,
  61902: 57673,
  61903: 57674,
  61904: 57675,
  61905: 57676,
  61906: 57677,
  61907: 57678,
  61908: 57679,
  61909: 57680,
  61910: 57681,
  61911: 57682,
  61912: 57683,
  61913: 57684,
  61914: 57685,
  61915: 57686,
  61916: 57687,
  61917: 57688,
  61918: 57689,
  61919: 57690,
  61920: 57691,
  61921: 57692,
  61922: 57693,
  61923: 57694,
  61924: 57695,
  61925: 57696,
  61926: 57697,
  61927: 57698,
  61928: 57699,
  61929: 57700,
  61930: 57701,
  61931: 57702,
  61932: 57703,
  61933: 57704,
  61934: 57705,
  61935: 57706,
  61936: 57707,
  61937: 57708,
  61938: 57709,
  61939: 57710,
  61940: 57711,
  61941: 57712,
  61942: 57713,
  61943: 57714,
  61944: 57715,
  61945: 57716,
  61946: 57717,
  61947: 57718,
  61948: 57719,
  62016: 57720,
  62017: 57721,
  62018: 57722,
  62019: 57723,
  62020: 57724,
  62021: 57725,
  62022: 57726,
  62023: 57727,
  62024: 57728,
  62025: 57729,
  62026: 57730,
  62027: 57731,
  62028: 57732,
  62029: 57733,
  62030: 57734,
  62031: 57735,
  62032: 57736,
  62033: 57737,
  62034: 57738,
  62035: 57739,
  62036: 57740,
  62037: 57741,
  62038: 57742,
  62039: 57743,
  62040: 57744,
  62041: 57745,
  62042: 57746,
  62043: 57747,
  62044: 57748,
  62045: 57749,
  62046: 57750,
  62047: 57751,
  62048: 57752,
  62049: 57753,
  62050: 57754,
  62051: 57755,
  62052: 57756,
  62053: 57757,
  62054: 57758,
  62055: 57759,
  62056: 57760,
  62057: 57761,
  62058: 57762,
  62059: 57763,
  62060: 57764,
  62061: 57765,
  62062: 57766,
  62063: 57767,
  62064: 57768,
  62065: 57769,
  62066: 57770,
  62067: 57771,
  62068: 57772,
  62069: 57773,
  62070: 57774,
  62071: 57775,
  62072: 57776,
  62073: 57777,
  62074: 57778,
  62075: 57779,
  62076: 57780,
  62077: 57781,
  62078: 57782,
  62080: 57783,
  62081: 57784,
  62082: 57785,
  62083: 57786,
  62084: 57787,
  62085: 57788,
  62086: 57789,
  62087: 57790,
  62088: 57791,
  62089: 57792,
  62090: 57793,
  62091: 57794,
  62092: 57795,
  62093: 57796,
  62094: 57797,
  62095: 57798,
  62096: 57799,
  62097: 57800,
  62098: 57801,
  62099: 57802,
  62100: 57803,
  62101: 57804,
  62102: 57805,
  62103: 57806,
  62104: 57807,
  62105: 57808,
  62106: 57809,
  62107: 57810,
  62108: 57811,
  62109: 57812,
  62110: 57813,
  62111: 57814,
  62112: 57815,
  62113: 57816,
  62114: 57817,
  62115: 57818,
  62116: 57819,
  62117: 57820,
  62118: 57821,
  62119: 57822,
  62120: 57823,
  62121: 57824,
  62122: 57825,
  62123: 57826,
  62124: 57827,
  62125: 57828,
  62126: 57829,
  62127: 57830,
  62128: 57831,
  62129: 57832,
  62130: 57833,
  62131: 57834,
  62132: 57835,
  62133: 57836,
  62134: 57837,
  62135: 57838,
  62136: 57839,
  62137: 57840,
  62138: 57841,
  62139: 57842,
  62140: 57843,
  62141: 57844,
  62142: 57845,
  62143: 57846,
  62144: 57847,
  62145: 57848,
  62146: 57849,
  62147: 57850,
  62148: 57851,
  62149: 57852,
  62150: 57853,
  62151: 57854,
  62152: 57855,
  62153: 57856,
  62154: 57857,
  62155: 57858,
  62156: 57859,
  62157: 57860,
  62158: 57861,
  62159: 57862,
  62160: 57863,
  62161: 57864,
  62162: 57865,
  62163: 57866,
  62164: 57867,
  62165: 57868,
  62166: 57869,
  62167: 57870,
  62168: 57871,
  62169: 57872,
  62170: 57873,
  62171: 57874,
  62172: 57875,
  62173: 57876,
  62174: 57877,
  62175: 57878,
  62176: 57879,
  62177: 57880,
  62178: 57881,
  62179: 57882,
  62180: 57883,
  62181: 57884,
  62182: 57885,
  62183: 57886,
  62184: 57887,
  62185: 57888,
  62186: 57889,
  62187: 57890,
  62188: 57891,
  62189: 57892,
  62190: 57893,
  62191: 57894,
  62192: 57895,
  62193: 57896,
  62194: 57897,
  62195: 57898,
  62196: 57899,
  62197: 57900,
  62198: 57901,
  62199: 57902,
  62200: 57903,
  62201: 57904,
  62202: 57905,
  62203: 57906,
  62204: 57907,
  62272: 57908,
  62273: 57909,
  62274: 57910,
  62275: 57911,
  62276: 57912,
  62277: 57913,
  62278: 57914,
  62279: 57915,
  62280: 57916,
  62281: 57917,
  62282: 57918,
  62283: 57919,
  62284: 57920,
  62285: 57921,
  62286: 57922,
  62287: 57923,
  62288: 57924,
  62289: 57925,
  62290: 57926,
  62291: 57927,
  62292: 57928,
  62293: 57929,
  62294: 57930,
  62295: 57931,
  62296: 57932,
  62297: 57933,
  62298: 57934,
  62299: 57935,
  62300: 57936,
  62301: 57937,
  62302: 57938,
  62303: 57939,
  62304: 57940,
  62305: 57941,
  62306: 57942,
  62307: 57943,
  62308: 57944,
  62309: 57945,
  62310: 57946,
  62311: 57947,
  62312: 57948,
  62313: 57949,
  62314: 57950,
  62315: 57951,
  62316: 57952,
  62317: 57953,
  62318: 57954,
  62319: 57955,
  62320: 57956,
  62321: 57957,
  62322: 57958,
  62323: 57959,
  62324: 57960,
  62325: 57961,
  62326: 57962,
  62327: 57963,
  62328: 57964,
  62329: 57965,
  62330: 57966,
  62331: 57967,
  62332: 57968,
  62333: 57969,
  62334: 57970,
  62336: 57971,
  62337: 57972,
  62338: 57973,
  62339: 57974,
  62340: 57975,
  62341: 57976,
  62342: 57977,
  62343: 57978,
  62344: 57979,
  62345: 57980,
  62346: 57981,
  62347: 57982,
  62348: 57983,
  62349: 57984,
  62350: 57985,
  62351: 57986,
  62352: 57987,
  62353: 57988,
  62354: 57989,
  62355: 57990,
  62356: 57991,
  62357: 57992,
  62358: 57993,
  62359: 57994,
  62360: 57995,
  62361: 57996,
  62362: 57997,
  62363: 57998,
  62364: 57999,
  62365: 58e3,
  62366: 58001,
  62367: 58002,
  62368: 58003,
  62369: 58004,
  62370: 58005,
  62371: 58006,
  62372: 58007,
  62373: 58008,
  62374: 58009,
  62375: 58010,
  62376: 58011,
  62377: 58012,
  62378: 58013,
  62379: 58014,
  62380: 58015,
  62381: 58016,
  62382: 58017,
  62383: 58018,
  62384: 58019,
  62385: 58020,
  62386: 58021,
  62387: 58022,
  62388: 58023,
  62389: 58024,
  62390: 58025,
  62391: 58026,
  62392: 58027,
  62393: 58028,
  62394: 58029,
  62395: 58030,
  62396: 58031,
  62397: 58032,
  62398: 58033,
  62399: 58034,
  62400: 58035,
  62401: 58036,
  62402: 58037,
  62403: 58038,
  62404: 58039,
  62405: 58040,
  62406: 58041,
  62407: 58042,
  62408: 58043,
  62409: 58044,
  62410: 58045,
  62411: 58046,
  62412: 58047,
  62413: 58048,
  62414: 58049,
  62415: 58050,
  62416: 58051,
  62417: 58052,
  62418: 58053,
  62419: 58054,
  62420: 58055,
  62421: 58056,
  62422: 58057,
  62423: 58058,
  62424: 58059,
  62425: 58060,
  62426: 58061,
  62427: 58062,
  62428: 58063,
  62429: 58064,
  62430: 58065,
  62431: 58066,
  62432: 58067,
  62433: 58068,
  62434: 58069,
  62435: 58070,
  62436: 58071,
  62437: 58072,
  62438: 58073,
  62439: 58074,
  62440: 58075,
  62441: 58076,
  62442: 58077,
  62443: 58078,
  62444: 58079,
  62445: 58080,
  62446: 58081,
  62447: 58082,
  62448: 58083,
  62449: 58084,
  62450: 58085,
  62451: 58086,
  62452: 58087,
  62453: 58088,
  62454: 58089,
  62455: 58090,
  62456: 58091,
  62457: 58092,
  62458: 58093,
  62459: 58094,
  62460: 58095,
  62528: 58096,
  62529: 58097,
  62530: 58098,
  62531: 58099,
  62532: 58100,
  62533: 58101,
  62534: 58102,
  62535: 58103,
  62536: 58104,
  62537: 58105,
  62538: 58106,
  62539: 58107,
  62540: 58108,
  62541: 58109,
  62542: 58110,
  62543: 58111,
  62544: 58112,
  62545: 58113,
  62546: 58114,
  62547: 58115,
  62548: 58116,
  62549: 58117,
  62550: 58118,
  62551: 58119,
  62552: 58120,
  62553: 58121,
  62554: 58122,
  62555: 58123,
  62556: 58124,
  62557: 58125,
  62558: 58126,
  62559: 58127,
  62560: 58128,
  62561: 58129,
  62562: 58130,
  62563: 58131,
  62564: 58132,
  62565: 58133,
  62566: 58134,
  62567: 58135,
  62568: 58136,
  62569: 58137,
  62570: 58138,
  62571: 58139,
  62572: 58140,
  62573: 58141,
  62574: 58142,
  62575: 58143,
  62576: 58144,
  62577: 58145,
  62578: 58146,
  62579: 58147,
  62580: 58148,
  62581: 58149,
  62582: 58150,
  62583: 58151,
  62584: 58152,
  62585: 58153,
  62586: 58154,
  62587: 58155,
  62588: 58156,
  62589: 58157,
  62590: 58158,
  62592: 58159,
  62593: 58160,
  62594: 58161,
  62595: 58162,
  62596: 58163,
  62597: 58164,
  62598: 58165,
  62599: 58166,
  62600: 58167,
  62601: 58168,
  62602: 58169,
  62603: 58170,
  62604: 58171,
  62605: 58172,
  62606: 58173,
  62607: 58174,
  62608: 58175,
  62609: 58176,
  62610: 58177,
  62611: 58178,
  62612: 58179,
  62613: 58180,
  62614: 58181,
  62615: 58182,
  62616: 58183,
  62617: 58184,
  62618: 58185,
  62619: 58186,
  62620: 58187,
  62621: 58188,
  62622: 58189,
  62623: 58190,
  62624: 58191,
  62625: 58192,
  62626: 58193,
  62627: 58194,
  62628: 58195,
  62629: 58196,
  62630: 58197,
  62631: 58198,
  62632: 58199,
  62633: 58200,
  62634: 58201,
  62635: 58202,
  62636: 58203,
  62637: 58204,
  62638: 58205,
  62639: 58206,
  62640: 58207,
  62641: 58208,
  62642: 58209,
  62643: 58210,
  62644: 58211,
  62645: 58212,
  62646: 58213,
  62647: 58214,
  62648: 58215,
  62649: 58216,
  62650: 58217,
  62651: 58218,
  62652: 58219,
  62653: 58220,
  62654: 58221,
  62655: 58222,
  62656: 58223,
  62657: 58224,
  62658: 58225,
  62659: 58226,
  62660: 58227,
  62661: 58228,
  62662: 58229,
  62663: 58230,
  62664: 58231,
  62665: 58232,
  62666: 58233,
  62667: 58234,
  62668: 58235,
  62669: 58236,
  62670: 58237,
  62671: 58238,
  62672: 58239,
  62673: 58240,
  62674: 58241,
  62675: 58242,
  62676: 58243,
  62677: 58244,
  62678: 58245,
  62679: 58246,
  62680: 58247,
  62681: 58248,
  62682: 58249,
  62683: 58250,
  62684: 58251,
  62685: 58252,
  62686: 58253,
  62687: 58254,
  62688: 58255,
  62689: 58256,
  62690: 58257,
  62691: 58258,
  62692: 58259,
  62693: 58260,
  62694: 58261,
  62695: 58262,
  62696: 58263,
  62697: 58264,
  62698: 58265,
  62699: 58266,
  62700: 58267,
  62701: 58268,
  62702: 58269,
  62703: 58270,
  62704: 58271,
  62705: 58272,
  62706: 58273,
  62707: 58274,
  62708: 58275,
  62709: 58276,
  62710: 58277,
  62711: 58278,
  62712: 58279,
  62713: 58280,
  62714: 58281,
  62715: 58282,
  62716: 58283,
  62784: 58284,
  62785: 58285,
  62786: 58286,
  62787: 58287,
  62788: 58288,
  62789: 58289,
  62790: 58290,
  62791: 58291,
  62792: 58292,
  62793: 58293,
  62794: 58294,
  62795: 58295,
  62796: 58296,
  62797: 58297,
  62798: 58298,
  62799: 58299,
  62800: 58300,
  62801: 58301,
  62802: 58302,
  62803: 58303,
  62804: 58304,
  62805: 58305,
  62806: 58306,
  62807: 58307,
  62808: 58308,
  62809: 58309,
  62810: 58310,
  62811: 58311,
  62812: 58312,
  62813: 58313,
  62814: 58314,
  62815: 58315,
  62816: 58316,
  62817: 58317,
  62818: 58318,
  62819: 58319,
  62820: 58320,
  62821: 58321,
  62822: 58322,
  62823: 58323,
  62824: 58324,
  62825: 58325,
  62826: 58326,
  62827: 58327,
  62828: 58328,
  62829: 58329,
  62830: 58330,
  62831: 58331,
  62832: 58332,
  62833: 58333,
  62834: 58334,
  62835: 58335,
  62836: 58336,
  62837: 58337,
  62838: 58338,
  62839: 58339,
  62840: 58340,
  62841: 58341,
  62842: 58342,
  62843: 58343,
  62844: 58344,
  62845: 58345,
  62846: 58346,
  62848: 58347,
  62849: 58348,
  62850: 58349,
  62851: 58350,
  62852: 58351,
  62853: 58352,
  62854: 58353,
  62855: 58354,
  62856: 58355,
  62857: 58356,
  62858: 58357,
  62859: 58358,
  62860: 58359,
  62861: 58360,
  62862: 58361,
  62863: 58362,
  62864: 58363,
  62865: 58364,
  62866: 58365,
  62867: 58366,
  62868: 58367,
  62869: 58368,
  62870: 58369,
  62871: 58370,
  62872: 58371,
  62873: 58372,
  62874: 58373,
  62875: 58374,
  62876: 58375,
  62877: 58376,
  62878: 58377,
  62879: 58378,
  62880: 58379,
  62881: 58380,
  62882: 58381,
  62883: 58382,
  62884: 58383,
  62885: 58384,
  62886: 58385,
  62887: 58386,
  62888: 58387,
  62889: 58388,
  62890: 58389,
  62891: 58390,
  62892: 58391,
  62893: 58392,
  62894: 58393,
  62895: 58394,
  62896: 58395,
  62897: 58396,
  62898: 58397,
  62899: 58398,
  62900: 58399,
  62901: 58400,
  62902: 58401,
  62903: 58402,
  62904: 58403,
  62905: 58404,
  62906: 58405,
  62907: 58406,
  62908: 58407,
  62909: 58408,
  62910: 58409,
  62911: 58410,
  62912: 58411,
  62913: 58412,
  62914: 58413,
  62915: 58414,
  62916: 58415,
  62917: 58416,
  62918: 58417,
  62919: 58418,
  62920: 58419,
  62921: 58420,
  62922: 58421,
  62923: 58422,
  62924: 58423,
  62925: 58424,
  62926: 58425,
  62927: 58426,
  62928: 58427,
  62929: 58428,
  62930: 58429,
  62931: 58430,
  62932: 58431,
  62933: 58432,
  62934: 58433,
  62935: 58434,
  62936: 58435,
  62937: 58436,
  62938: 58437,
  62939: 58438,
  62940: 58439,
  62941: 58440,
  62942: 58441,
  62943: 58442,
  62944: 58443,
  62945: 58444,
  62946: 58445,
  62947: 58446,
  62948: 58447,
  62949: 58448,
  62950: 58449,
  62951: 58450,
  62952: 58451,
  62953: 58452,
  62954: 58453,
  62955: 58454,
  62956: 58455,
  62957: 58456,
  62958: 58457,
  62959: 58458,
  62960: 58459,
  62961: 58460,
  62962: 58461,
  62963: 58462,
  62964: 58463,
  62965: 58464,
  62966: 58465,
  62967: 58466,
  62968: 58467,
  62969: 58468,
  62970: 58469,
  62971: 58470,
  62972: 58471,
  63040: 58472,
  63041: 58473,
  63042: 58474,
  63043: 58475,
  63044: 58476,
  63045: 58477,
  63046: 58478,
  63047: 58479,
  63048: 58480,
  63049: 58481,
  63050: 58482,
  63051: 58483,
  63052: 58484,
  63053: 58485,
  63054: 58486,
  63055: 58487,
  63056: 58488,
  63057: 58489,
  63058: 58490,
  63059: 58491,
  63060: 58492,
  63061: 58493,
  63062: 58494,
  63063: 58495,
  63064: 58496,
  63065: 58497,
  63066: 58498,
  63067: 58499,
  63068: 58500,
  63069: 58501,
  63070: 58502,
  63071: 58503,
  63072: 58504,
  63073: 58505,
  63074: 58506,
  63075: 58507,
  63076: 58508,
  63077: 58509,
  63078: 58510,
  63079: 58511,
  63080: 58512,
  63081: 58513,
  63082: 58514,
  63083: 58515,
  63084: 58516,
  63085: 58517,
  63086: 58518,
  63087: 58519,
  63088: 58520,
  63089: 58521,
  63090: 58522,
  63091: 58523,
  63092: 58524,
  63093: 58525,
  63094: 58526,
  63095: 58527,
  63096: 58528,
  63097: 58529,
  63098: 58530,
  63099: 58531,
  63100: 58532,
  63101: 58533,
  63102: 58534,
  63104: 58535,
  63105: 58536,
  63106: 58537,
  63107: 58538,
  63108: 58539,
  63109: 58540,
  63110: 58541,
  63111: 58542,
  63112: 58543,
  63113: 58544,
  63114: 58545,
  63115: 58546,
  63116: 58547,
  63117: 58548,
  63118: 58549,
  63119: 58550,
  63120: 58551,
  63121: 58552,
  63122: 58553,
  63123: 58554,
  63124: 58555,
  63125: 58556,
  63126: 58557,
  63127: 58558,
  63128: 58559,
  63129: 58560,
  63130: 58561,
  63131: 58562,
  63132: 58563,
  63133: 58564,
  63134: 58565,
  63135: 58566,
  63136: 58567,
  63137: 58568,
  63138: 58569,
  63139: 58570,
  63140: 58571,
  63141: 58572,
  63142: 58573,
  63143: 58574,
  63144: 58575,
  63145: 58576,
  63146: 58577,
  63147: 58578,
  63148: 58579,
  63149: 58580,
  63150: 58581,
  63151: 58582,
  63152: 58583,
  63153: 58584,
  63154: 58585,
  63155: 58586,
  63156: 58587,
  63157: 58588,
  63158: 58589,
  63159: 58590,
  63160: 58591,
  63161: 58592,
  63162: 58593,
  63163: 58594,
  63164: 58595,
  63165: 58596,
  63166: 58597,
  63167: 58598,
  63168: 58599,
  63169: 58600,
  63170: 58601,
  63171: 58602,
  63172: 58603,
  63173: 58604,
  63174: 58605,
  63175: 58606,
  63176: 58607,
  63177: 58608,
  63178: 58609,
  63179: 58610,
  63180: 58611,
  63181: 58612,
  63182: 58613,
  63183: 58614,
  63184: 58615,
  63185: 58616,
  63186: 58617,
  63187: 58618,
  63188: 58619,
  63189: 58620,
  63190: 58621,
  63191: 58622,
  63192: 58623,
  63193: 58624,
  63194: 58625,
  63195: 58626,
  63196: 58627,
  63197: 58628,
  63198: 58629,
  63199: 58630,
  63200: 58631,
  63201: 58632,
  63202: 58633,
  63203: 58634,
  63204: 58635,
  63205: 58636,
  63206: 58637,
  63207: 58638,
  63208: 58639,
  63209: 58640,
  63210: 58641,
  63211: 58642,
  63212: 58643,
  63213: 58644,
  63214: 58645,
  63215: 58646,
  63216: 58647,
  63217: 58648,
  63218: 58649,
  63219: 58650,
  63220: 58651,
  63221: 58652,
  63222: 58653,
  63223: 58654,
  63224: 58655,
  63225: 58656,
  63226: 58657,
  63227: 58658,
  63228: 58659,
  63296: 58660,
  63297: 58661,
  63298: 58662,
  63299: 58663,
  63300: 58664,
  63301: 58665,
  63302: 58666,
  63303: 58667,
  63304: 58668,
  63305: 58669,
  63306: 58670,
  63307: 58671,
  63308: 58672,
  63309: 58673,
  63310: 58674,
  63311: 58675,
  63312: 58676,
  63313: 58677,
  63314: 58678,
  63315: 58679,
  63316: 58680,
  63317: 58681,
  63318: 58682,
  63319: 58683,
  63320: 58684,
  63321: 58685,
  63322: 58686,
  63323: 58687,
  63324: 58688,
  63325: 58689,
  63326: 58690,
  63327: 58691,
  63328: 58692,
  63329: 58693,
  63330: 58694,
  63331: 58695,
  63332: 58696,
  63333: 58697,
  63334: 58698,
  63335: 58699,
  63336: 58700,
  63337: 58701,
  63338: 58702,
  63339: 58703,
  63340: 58704,
  63341: 58705,
  63342: 58706,
  63343: 58707,
  63344: 58708,
  63345: 58709,
  63346: 58710,
  63347: 58711,
  63348: 58712,
  63349: 58713,
  63350: 58714,
  63351: 58715,
  63352: 58716,
  63353: 58717,
  63354: 58718,
  63355: 58719,
  63356: 58720,
  63357: 58721,
  63358: 58722,
  63360: 58723,
  63361: 58724,
  63362: 58725,
  63363: 58726,
  63364: 58727,
  63365: 58728,
  63366: 58729,
  63367: 58730,
  63368: 58731,
  63369: 58732,
  63370: 58733,
  63371: 58734,
  63372: 58735,
  63373: 58736,
  63374: 58737,
  63375: 58738,
  63376: 58739,
  63377: 58740,
  63378: 58741,
  63379: 58742,
  63380: 58743,
  63381: 58744,
  63382: 58745,
  63383: 58746,
  63384: 58747,
  63385: 58748,
  63386: 58749,
  63387: 58750,
  63388: 58751,
  63389: 58752,
  63390: 58753,
  63391: 58754,
  63392: 58755,
  63393: 58756,
  63394: 58757,
  63395: 58758,
  63396: 58759,
  63397: 58760,
  63398: 58761,
  63399: 58762,
  63400: 58763,
  63401: 58764,
  63402: 58765,
  63403: 58766,
  63404: 58767,
  63405: 58768,
  63406: 58769,
  63407: 58770,
  63408: 58771,
  63409: 58772,
  63410: 58773,
  63411: 58774,
  63412: 58775,
  63413: 58776,
  63414: 58777,
  63415: 58778,
  63416: 58779,
  63417: 58780,
  63418: 58781,
  63419: 58782,
  63420: 58783,
  63421: 58784,
  63422: 58785,
  63423: 58786,
  63424: 58787,
  63425: 58788,
  63426: 58789,
  63427: 58790,
  63428: 58791,
  63429: 58792,
  63430: 58793,
  63431: 58794,
  63432: 58795,
  63433: 58796,
  63434: 58797,
  63435: 58798,
  63436: 58799,
  63437: 58800,
  63438: 58801,
  63439: 58802,
  63440: 58803,
  63441: 58804,
  63442: 58805,
  63443: 58806,
  63444: 58807,
  63445: 58808,
  63446: 58809,
  63447: 58810,
  63448: 58811,
  63449: 58812,
  63450: 58813,
  63451: 58814,
  63452: 58815,
  63453: 58816,
  63454: 58817,
  63455: 58818,
  63456: 58819,
  63457: 58820,
  63458: 58821,
  63459: 58822,
  63460: 58823,
  63461: 58824,
  63462: 58825,
  63463: 58826,
  63464: 58827,
  63465: 58828,
  63466: 58829,
  63467: 58830,
  63468: 58831,
  63469: 58832,
  63470: 58833,
  63471: 58834,
  63472: 58835,
  63473: 58836,
  63474: 58837,
  63475: 58838,
  63476: 58839,
  63477: 58840,
  63478: 58841,
  63479: 58842,
  63480: 58843,
  63481: 58844,
  63482: 58845,
  63483: 58846,
  63484: 58847,
  63552: 58848,
  63553: 58849,
  63554: 58850,
  63555: 58851,
  63556: 58852,
  63557: 58853,
  63558: 58854,
  63559: 58855,
  63560: 58856,
  63561: 58857,
  63562: 58858,
  63563: 58859,
  63564: 58860,
  63565: 58861,
  63566: 58862,
  63567: 58863,
  63568: 58864,
  63569: 58865,
  63570: 58866,
  63571: 58867,
  63572: 58868,
  63573: 58869,
  63574: 58870,
  63575: 58871,
  63576: 58872,
  63577: 58873,
  63578: 58874,
  63579: 58875,
  63580: 58876,
  63581: 58877,
  63582: 58878,
  63583: 58879,
  63584: 58880,
  63585: 58881,
  63586: 58882,
  63587: 58883,
  63588: 58884,
  63589: 58885,
  63590: 58886,
  63591: 58887,
  63592: 58888,
  63593: 58889,
  63594: 58890,
  63595: 58891,
  63596: 58892,
  63597: 58893,
  63598: 58894,
  63599: 58895,
  63600: 58896,
  63601: 58897,
  63602: 58898,
  63603: 58899,
  63604: 58900,
  63605: 58901,
  63606: 58902,
  63607: 58903,
  63608: 58904,
  63609: 58905,
  63610: 58906,
  63611: 58907,
  63612: 58908,
  63613: 58909,
  63614: 58910,
  63616: 58911,
  63617: 58912,
  63618: 58913,
  63619: 58914,
  63620: 58915,
  63621: 58916,
  63622: 58917,
  63623: 58918,
  63624: 58919,
  63625: 58920,
  63626: 58921,
  63627: 58922,
  63628: 58923,
  63629: 58924,
  63630: 58925,
  63631: 58926,
  63632: 58927,
  63633: 58928,
  63634: 58929,
  63635: 58930,
  63636: 58931,
  63637: 58932,
  63638: 58933,
  63639: 58934,
  63640: 58935,
  63641: 58936,
  63642: 58937,
  63643: 58938,
  63644: 58939,
  63645: 58940,
  63646: 58941,
  63647: 58942,
  63648: 58943,
  63649: 58944,
  63650: 58945,
  63651: 58946,
  63652: 58947,
  63653: 58948,
  63654: 58949,
  63655: 58950,
  63656: 58951,
  63657: 58952,
  63658: 58953,
  63659: 58954,
  63660: 58955,
  63661: 58956,
  63662: 58957,
  63663: 58958,
  63664: 58959,
  63665: 58960,
  63666: 58961,
  63667: 58962,
  63668: 58963,
  63669: 58964,
  63670: 58965,
  63671: 58966,
  63672: 58967,
  63673: 58968,
  63674: 58969,
  63675: 58970,
  63676: 58971,
  63677: 58972,
  63678: 58973,
  63679: 58974,
  63680: 58975,
  63681: 58976,
  63682: 58977,
  63683: 58978,
  63684: 58979,
  63685: 58980,
  63686: 58981,
  63687: 58982,
  63688: 58983,
  63689: 58984,
  63690: 58985,
  63691: 58986,
  63692: 58987,
  63693: 58988,
  63694: 58989,
  63695: 58990,
  63696: 58991,
  63697: 58992,
  63698: 58993,
  63699: 58994,
  63700: 58995,
  63701: 58996,
  63702: 58997,
  63703: 58998,
  63704: 58999,
  63705: 59e3,
  63706: 59001,
  63707: 59002,
  63708: 59003,
  63709: 59004,
  63710: 59005,
  63711: 59006,
  63712: 59007,
  63713: 59008,
  63714: 59009,
  63715: 59010,
  63716: 59011,
  63717: 59012,
  63718: 59013,
  63719: 59014,
  63720: 59015,
  63721: 59016,
  63722: 59017,
  63723: 59018,
  63724: 59019,
  63725: 59020,
  63726: 59021,
  63727: 59022,
  63728: 59023,
  63729: 59024,
  63730: 59025,
  63731: 59026,
  63732: 59027,
  63733: 59028,
  63734: 59029,
  63735: 59030,
  63736: 59031,
  63737: 59032,
  63738: 59033,
  63739: 59034,
  63740: 59035,
  64064: 8560,
  64065: 8561,
  64066: 8562,
  64067: 8563,
  64068: 8564,
  64069: 8565,
  64070: 8566,
  64071: 8567,
  64072: 8568,
  64073: 8569,
  64074: 8544,
  64075: 8545,
  64076: 8546,
  64077: 8547,
  64078: 8548,
  64079: 8549,
  64080: 8550,
  64081: 8551,
  64082: 8552,
  64083: 8553,
  64084: 65506,
  64085: 65508,
  64086: 65287,
  64087: 65282,
  64088: 12849,
  64089: 8470,
  64090: 8481,
  64091: 8757,
  64092: 32394,
  64093: 35100,
  64094: 37704,
  64095: 37512,
  64096: 34012,
  64097: 20425,
  64098: 28859,
  64099: 26161,
  64100: 26824,
  64101: 37625,
  64102: 26363,
  64103: 24389,
  64104: 20008,
  64105: 20193,
  64106: 20220,
  64107: 20224,
  64108: 20227,
  64109: 20281,
  64110: 20310,
  64111: 20370,
  64112: 20362,
  64113: 20378,
  64114: 20372,
  64115: 20429,
  64116: 20544,
  64117: 20514,
  64118: 20479,
  64119: 20510,
  64120: 20550,
  64121: 20592,
  64122: 20546,
  64123: 20628,
  64124: 20724,
  64125: 20696,
  64126: 20810,
  64128: 20836,
  64129: 20893,
  64130: 20926,
  64131: 20972,
  64132: 21013,
  64133: 21148,
  64134: 21158,
  64135: 21184,
  64136: 21211,
  64137: 21248,
  64138: 21255,
  64139: 21284,
  64140: 21362,
  64141: 21395,
  64142: 21426,
  64143: 21469,
  64144: 64014,
  64145: 21660,
  64146: 21642,
  64147: 21673,
  64148: 21759,
  64149: 21894,
  64150: 22361,
  64151: 22373,
  64152: 22444,
  64153: 22472,
  64154: 22471,
  64155: 64015,
  64156: 64016,
  64157: 22686,
  64158: 22706,
  64159: 22795,
  64160: 22867,
  64161: 22875,
  64162: 22877,
  64163: 22883,
  64164: 22948,
  64165: 22970,
  64166: 23382,
  64167: 23488,
  64168: 29999,
  64169: 23512,
  64170: 23532,
  64171: 23582,
  64172: 23718,
  64173: 23738,
  64174: 23797,
  64175: 23847,
  64176: 23891,
  64177: 64017,
  64178: 23874,
  64179: 23917,
  64180: 23992,
  64181: 23993,
  64182: 24016,
  64183: 24353,
  64184: 24372,
  64185: 24423,
  64186: 24503,
  64187: 24542,
  64188: 24669,
  64189: 24709,
  64190: 24714,
  64191: 24798,
  64192: 24789,
  64193: 24864,
  64194: 24818,
  64195: 24849,
  64196: 24887,
  64197: 24880,
  64198: 24984,
  64199: 25107,
  64200: 25254,
  64201: 25589,
  64202: 25696,
  64203: 25757,
  64204: 25806,
  64205: 25934,
  64206: 26112,
  64207: 26133,
  64208: 26171,
  64209: 26121,
  64210: 26158,
  64211: 26142,
  64212: 26148,
  64213: 26213,
  64214: 26199,
  64215: 26201,
  64216: 64018,
  64217: 26227,
  64218: 26265,
  64219: 26272,
  64220: 26290,
  64221: 26303,
  64222: 26362,
  64223: 26382,
  64224: 63785,
  64225: 26470,
  64226: 26555,
  64227: 26706,
  64228: 26560,
  64229: 26625,
  64230: 26692,
  64231: 26831,
  64232: 64019,
  64233: 26984,
  64234: 64020,
  64235: 27032,
  64236: 27106,
  64237: 27184,
  64238: 27243,
  64239: 27206,
  64240: 27251,
  64241: 27262,
  64242: 27362,
  64243: 27364,
  64244: 27606,
  64245: 27711,
  64246: 27740,
  64247: 27782,
  64248: 27759,
  64249: 27866,
  64250: 27908,
  64251: 28039,
  64252: 28015,
  64320: 28054,
  64321: 28076,
  64322: 28111,
  64323: 28152,
  64324: 28146,
  64325: 28156,
  64326: 28217,
  64327: 28252,
  64328: 28199,
  64329: 28220,
  64330: 28351,
  64331: 28552,
  64332: 28597,
  64333: 28661,
  64334: 28677,
  64335: 28679,
  64336: 28712,
  64337: 28805,
  64338: 28843,
  64339: 28943,
  64340: 28932,
  64341: 29020,
  64342: 28998,
  64343: 28999,
  64344: 64021,
  64345: 29121,
  64346: 29182,
  64347: 29361,
  64348: 29374,
  64349: 29476,
  64350: 64022,
  64351: 29559,
  64352: 29629,
  64353: 29641,
  64354: 29654,
  64355: 29667,
  64356: 29650,
  64357: 29703,
  64358: 29685,
  64359: 29734,
  64360: 29738,
  64361: 29737,
  64362: 29742,
  64363: 29794,
  64364: 29833,
  64365: 29855,
  64366: 29953,
  64367: 30063,
  64368: 30338,
  64369: 30364,
  64370: 30366,
  64371: 30363,
  64372: 30374,
  64373: 64023,
  64374: 30534,
  64375: 21167,
  64376: 30753,
  64377: 30798,
  64378: 30820,
  64379: 30842,
  64380: 31024,
  64381: 64024,
  64382: 64025,
  64384: 64026,
  64385: 31124,
  64386: 64027,
  64387: 31131,
  64388: 31441,
  64389: 31463,
  64390: 64028,
  64391: 31467,
  64392: 31646,
  64393: 64029,
  64394: 32072,
  64395: 32092,
  64396: 32183,
  64397: 32160,
  64398: 32214,
  64399: 32338,
  64400: 32583,
  64401: 32673,
  64402: 64030,
  64403: 33537,
  64404: 33634,
  64405: 33663,
  64406: 33735,
  64407: 33782,
  64408: 33864,
  64409: 33972,
  64410: 34131,
  64411: 34137,
  64412: 34155,
  64413: 64031,
  64414: 34224,
  64415: 64032,
  64416: 64033,
  64417: 34823,
  64418: 35061,
  64419: 35346,
  64420: 35383,
  64421: 35449,
  64422: 35495,
  64423: 35518,
  64424: 35551,
  64425: 64034,
  64426: 35574,
  64427: 35667,
  64428: 35711,
  64429: 36080,
  64430: 36084,
  64431: 36114,
  64432: 36214,
  64433: 64035,
  64434: 36559,
  64435: 64036,
  64436: 64037,
  64437: 36967,
  64438: 37086,
  64439: 64038,
  64440: 37141,
  64441: 37159,
  64442: 37338,
  64443: 37335,
  64444: 37342,
  64445: 37357,
  64446: 37358,
  64447: 37348,
  64448: 37349,
  64449: 37382,
  64450: 37392,
  64451: 37386,
  64452: 37434,
  64453: 37440,
  64454: 37436,
  64455: 37454,
  64456: 37465,
  64457: 37457,
  64458: 37433,
  64459: 37479,
  64460: 37543,
  64461: 37495,
  64462: 37496,
  64463: 37607,
  64464: 37591,
  64465: 37593,
  64466: 37584,
  64467: 64039,
  64468: 37589,
  64469: 37600,
  64470: 37587,
  64471: 37669,
  64472: 37665,
  64473: 37627,
  64474: 64040,
  64475: 37662,
  64476: 37631,
  64477: 37661,
  64478: 37634,
  64479: 37744,
  64480: 37719,
  64481: 37796,
  64482: 37830,
  64483: 37854,
  64484: 37880,
  64485: 37937,
  64486: 37957,
  64487: 37960,
  64488: 38290,
  64489: 63964,
  64490: 64041,
  64491: 38557,
  64492: 38575,
  64493: 38707,
  64494: 38715,
  64495: 38723,
  64496: 38733,
  64497: 38735,
  64498: 38737,
  64499: 38741,
  64500: 38999,
  64501: 39013,
  64502: 64042,
  64503: 64043,
  64504: 39207,
  64505: 64044,
  64506: 39326,
  64507: 39502,
  64508: 39641,
  64576: 39644,
  64577: 39797,
  64578: 39794,
  64579: 39823,
  64580: 39857,
  64581: 39867,
  64582: 39936,
  64583: 40304,
  64584: 40299,
  64585: 64045,
  64586: 40473,
  64587: 40657
};
function DataViewEx(buffer2, littleEndian) {
  this.dv = new DataView(buffer2);
  this.offset = 0;
  this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
  this.encoder = new CharsetEncoder();
}
DataViewEx.prototype = {
  constructor: DataViewEx,
  getInt8: function() {
    var value = this.dv.getInt8(this.offset);
    this.offset += 1;
    return value;
  },
  getInt8Array: function(size2) {
    var a2 = [];
    for (var i2 = 0; i2 < size2; i2++) {
      a2.push(this.getInt8());
    }
    return a2;
  },
  getUint8: function() {
    var value = this.dv.getUint8(this.offset);
    this.offset += 1;
    return value;
  },
  getUint8Array: function(size2) {
    var a2 = [];
    for (var i2 = 0; i2 < size2; i2++) {
      a2.push(this.getUint8());
    }
    return a2;
  },
  getInt16: function() {
    var value = this.dv.getInt16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  },
  getInt16Array: function(size2) {
    var a2 = [];
    for (var i2 = 0; i2 < size2; i2++) {
      a2.push(this.getInt16());
    }
    return a2;
  },
  getUint16: function() {
    var value = this.dv.getUint16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  },
  getUint16Array: function(size2) {
    var a2 = [];
    for (var i2 = 0; i2 < size2; i2++) {
      a2.push(this.getUint16());
    }
    return a2;
  },
  getInt32: function() {
    var value = this.dv.getInt32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  },
  getInt32Array: function(size2) {
    var a2 = [];
    for (var i2 = 0; i2 < size2; i2++) {
      a2.push(this.getInt32());
    }
    return a2;
  },
  getUint32: function() {
    var value = this.dv.getUint32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  },
  getUint32Array: function(size2) {
    var a2 = [];
    for (var i2 = 0; i2 < size2; i2++) {
      a2.push(this.getUint32());
    }
    return a2;
  },
  getFloat32: function() {
    var value = this.dv.getFloat32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  },
  getFloat32Array: function(size2) {
    var a2 = [];
    for (var i2 = 0; i2 < size2; i2++) {
      a2.push(this.getFloat32());
    }
    return a2;
  },
  getFloat64: function() {
    var value = this.dv.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  },
  getFloat64Array: function(size2) {
    var a2 = [];
    for (var i2 = 0; i2 < size2; i2++) {
      a2.push(this.getFloat64());
    }
    return a2;
  },
  getIndex: function(type2, isUnsigned) {
    switch (type2) {
      case 1:
        return isUnsigned === true ? this.getUint8() : this.getInt8();
      case 2:
        return isUnsigned === true ? this.getUint16() : this.getInt16();
      case 4:
        return this.getInt32();
      default:
        throw "unknown number type " + type2 + " exception.";
    }
  },
  getIndexArray: function(type2, size2, isUnsigned) {
    var a2 = [];
    for (var i2 = 0; i2 < size2; i2++) {
      a2.push(this.getIndex(type2, isUnsigned));
    }
    return a2;
  },
  getChars: function(size2) {
    var str = "";
    while (size2 > 0) {
      var value = this.getUint8();
      size2--;
      if (value === 0) {
        break;
      }
      str += String.fromCharCode(value);
    }
    while (size2 > 0) {
      this.getUint8();
      size2--;
    }
    return str;
  },
  getSjisStringsAsUnicode: function(size2) {
    var a2 = [];
    while (size2 > 0) {
      var value = this.getUint8();
      size2--;
      if (value === 0) {
        break;
      }
      a2.push(value);
    }
    while (size2 > 0) {
      this.getUint8();
      size2--;
    }
    return this.encoder.s2u(new Uint8Array(a2));
  },
  getUnicodeStrings: function(size2) {
    var str = "";
    while (size2 > 0) {
      var value = this.getUint16();
      size2 -= 2;
      if (value === 0) {
        break;
      }
      str += String.fromCharCode(value);
    }
    while (size2 > 0) {
      this.getUint8();
      size2--;
    }
    return str;
  },
  getTextBuffer: function() {
    var size2 = this.getUint32();
    return this.getUnicodeStrings(size2);
  }
};
function DataCreationHelper() {
}
DataCreationHelper.prototype = {
  constructor: DataCreationHelper,
  leftToRightVector3: function(v) {
    v[2] = -v[2];
  },
  leftToRightQuaternion: function(q) {
    q[0] = -q[0];
    q[1] = -q[1];
  },
  leftToRightEuler: function(r) {
    r[0] = -r[0];
    r[1] = -r[1];
  },
  leftToRightIndexOrder: function(p) {
    var tmp = p[2];
    p[2] = p[0];
    p[0] = tmp;
  },
  leftToRightVector3Range: function(v12, v2) {
    var tmp = -v2[2];
    v2[2] = -v12[2];
    v12[2] = tmp;
  },
  leftToRightEulerRange: function(r1, r2) {
    var tmp1 = -r2[0];
    var tmp2 = -r2[1];
    r2[0] = -r1[0];
    r2[1] = -r1[1];
    r1[0] = tmp1;
    r1[1] = tmp2;
  }
};
function Parser() {
}
Parser.prototype.parsePmd = function(buffer2, leftToRight) {
  var pmd = {};
  var dv = new DataViewEx(buffer2);
  pmd.metadata = {};
  pmd.metadata.format = "pmd";
  pmd.metadata.coordinateSystem = "left";
  var parseHeader = function() {
    var metadata = pmd.metadata;
    metadata.magic = dv.getChars(3);
    if (metadata.magic !== "Pmd") {
      throw "PMD file magic is not Pmd, but " + metadata.magic;
    }
    metadata.version = dv.getFloat32();
    metadata.modelName = dv.getSjisStringsAsUnicode(20);
    metadata.comment = dv.getSjisStringsAsUnicode(256);
  };
  var parseVertices = function() {
    var parseVertex = function() {
      var p = {};
      p.position = dv.getFloat32Array(3);
      p.normal = dv.getFloat32Array(3);
      p.uv = dv.getFloat32Array(2);
      p.skinIndices = dv.getUint16Array(2);
      p.skinWeights = [dv.getUint8() / 100];
      p.skinWeights.push(1 - p.skinWeights[0]);
      p.edgeFlag = dv.getUint8();
      return p;
    };
    var metadata = pmd.metadata;
    metadata.vertexCount = dv.getUint32();
    pmd.vertices = [];
    for (var i2 = 0; i2 < metadata.vertexCount; i2++) {
      pmd.vertices.push(parseVertex());
    }
  };
  var parseFaces = function() {
    var parseFace = function() {
      var p = {};
      p.indices = dv.getUint16Array(3);
      return p;
    };
    var metadata = pmd.metadata;
    metadata.faceCount = dv.getUint32() / 3;
    pmd.faces = [];
    for (var i2 = 0; i2 < metadata.faceCount; i2++) {
      pmd.faces.push(parseFace());
    }
  };
  var parseMaterials = function() {
    var parseMaterial = function() {
      var p = {};
      p.diffuse = dv.getFloat32Array(4);
      p.shininess = dv.getFloat32();
      p.specular = dv.getFloat32Array(3);
      p.ambient = dv.getFloat32Array(3);
      p.toonIndex = dv.getInt8();
      p.edgeFlag = dv.getUint8();
      p.faceCount = dv.getUint32() / 3;
      p.fileName = dv.getSjisStringsAsUnicode(20);
      return p;
    };
    var metadata = pmd.metadata;
    metadata.materialCount = dv.getUint32();
    pmd.materials = [];
    for (var i2 = 0; i2 < metadata.materialCount; i2++) {
      pmd.materials.push(parseMaterial());
    }
  };
  var parseBones = function() {
    var parseBone = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(20);
      p.parentIndex = dv.getInt16();
      p.tailIndex = dv.getInt16();
      p.type = dv.getUint8();
      p.ikIndex = dv.getInt16();
      p.position = dv.getFloat32Array(3);
      return p;
    };
    var metadata = pmd.metadata;
    metadata.boneCount = dv.getUint16();
    pmd.bones = [];
    for (var i2 = 0; i2 < metadata.boneCount; i2++) {
      pmd.bones.push(parseBone());
    }
  };
  var parseIks = function() {
    var parseIk = function() {
      var p = {};
      p.target = dv.getUint16();
      p.effector = dv.getUint16();
      p.linkCount = dv.getUint8();
      p.iteration = dv.getUint16();
      p.maxAngle = dv.getFloat32();
      p.links = [];
      for (var i3 = 0; i3 < p.linkCount; i3++) {
        var link = {};
        link.index = dv.getUint16();
        p.links.push(link);
      }
      return p;
    };
    var metadata = pmd.metadata;
    metadata.ikCount = dv.getUint16();
    pmd.iks = [];
    for (var i2 = 0; i2 < metadata.ikCount; i2++) {
      pmd.iks.push(parseIk());
    }
  };
  var parseMorphs = function() {
    var parseMorph = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(20);
      p.elementCount = dv.getUint32();
      p.type = dv.getUint8();
      p.elements = [];
      for (var i3 = 0; i3 < p.elementCount; i3++) {
        p.elements.push({
          index: dv.getUint32(),
          position: dv.getFloat32Array(3)
        });
      }
      return p;
    };
    var metadata = pmd.metadata;
    metadata.morphCount = dv.getUint16();
    pmd.morphs = [];
    for (var i2 = 0; i2 < metadata.morphCount; i2++) {
      pmd.morphs.push(parseMorph());
    }
  };
  var parseMorphFrames = function() {
    var parseMorphFrame = function() {
      var p = {};
      p.index = dv.getUint16();
      return p;
    };
    var metadata = pmd.metadata;
    metadata.morphFrameCount = dv.getUint8();
    pmd.morphFrames = [];
    for (var i2 = 0; i2 < metadata.morphFrameCount; i2++) {
      pmd.morphFrames.push(parseMorphFrame());
    }
  };
  var parseBoneFrameNames = function() {
    var parseBoneFrameName = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(50);
      return p;
    };
    var metadata = pmd.metadata;
    metadata.boneFrameNameCount = dv.getUint8();
    pmd.boneFrameNames = [];
    for (var i2 = 0; i2 < metadata.boneFrameNameCount; i2++) {
      pmd.boneFrameNames.push(parseBoneFrameName());
    }
  };
  var parseBoneFrames = function() {
    var parseBoneFrame = function() {
      var p = {};
      p.boneIndex = dv.getInt16();
      p.frameIndex = dv.getUint8();
      return p;
    };
    var metadata = pmd.metadata;
    metadata.boneFrameCount = dv.getUint32();
    pmd.boneFrames = [];
    for (var i2 = 0; i2 < metadata.boneFrameCount; i2++) {
      pmd.boneFrames.push(parseBoneFrame());
    }
  };
  var parseEnglishHeader = function() {
    var metadata = pmd.metadata;
    metadata.englishCompatibility = dv.getUint8();
    if (metadata.englishCompatibility > 0) {
      metadata.englishModelName = dv.getSjisStringsAsUnicode(20);
      metadata.englishComment = dv.getSjisStringsAsUnicode(256);
    }
  };
  var parseEnglishBoneNames = function() {
    var parseEnglishBoneName = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(20);
      return p;
    };
    var metadata = pmd.metadata;
    if (metadata.englishCompatibility === 0) {
      return;
    }
    pmd.englishBoneNames = [];
    for (var i2 = 0; i2 < metadata.boneCount; i2++) {
      pmd.englishBoneNames.push(parseEnglishBoneName());
    }
  };
  var parseEnglishMorphNames = function() {
    var parseEnglishMorphName = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(20);
      return p;
    };
    var metadata = pmd.metadata;
    if (metadata.englishCompatibility === 0) {
      return;
    }
    pmd.englishMorphNames = [];
    for (var i2 = 0; i2 < metadata.morphCount - 1; i2++) {
      pmd.englishMorphNames.push(parseEnglishMorphName());
    }
  };
  var parseEnglishBoneFrameNames = function() {
    var parseEnglishBoneFrameName = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(50);
      return p;
    };
    var metadata = pmd.metadata;
    if (metadata.englishCompatibility === 0) {
      return;
    }
    pmd.englishBoneFrameNames = [];
    for (var i2 = 0; i2 < metadata.boneFrameNameCount; i2++) {
      pmd.englishBoneFrameNames.push(parseEnglishBoneFrameName());
    }
  };
  var parseToonTextures = function() {
    var parseToonTexture = function() {
      var p = {};
      p.fileName = dv.getSjisStringsAsUnicode(100);
      return p;
    };
    pmd.toonTextures = [];
    for (var i2 = 0; i2 < 10; i2++) {
      pmd.toonTextures.push(parseToonTexture());
    }
  };
  var parseRigidBodies = function() {
    var parseRigidBody = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(20);
      p.boneIndex = dv.getInt16();
      p.groupIndex = dv.getUint8();
      p.groupTarget = dv.getUint16();
      p.shapeType = dv.getUint8();
      p.width = dv.getFloat32();
      p.height = dv.getFloat32();
      p.depth = dv.getFloat32();
      p.position = dv.getFloat32Array(3);
      p.rotation = dv.getFloat32Array(3);
      p.weight = dv.getFloat32();
      p.positionDamping = dv.getFloat32();
      p.rotationDamping = dv.getFloat32();
      p.restitution = dv.getFloat32();
      p.friction = dv.getFloat32();
      p.type = dv.getUint8();
      return p;
    };
    var metadata = pmd.metadata;
    metadata.rigidBodyCount = dv.getUint32();
    pmd.rigidBodies = [];
    for (var i2 = 0; i2 < metadata.rigidBodyCount; i2++) {
      pmd.rigidBodies.push(parseRigidBody());
    }
  };
  var parseConstraints = function() {
    var parseConstraint = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(20);
      p.rigidBodyIndex1 = dv.getUint32();
      p.rigidBodyIndex2 = dv.getUint32();
      p.position = dv.getFloat32Array(3);
      p.rotation = dv.getFloat32Array(3);
      p.translationLimitation1 = dv.getFloat32Array(3);
      p.translationLimitation2 = dv.getFloat32Array(3);
      p.rotationLimitation1 = dv.getFloat32Array(3);
      p.rotationLimitation2 = dv.getFloat32Array(3);
      p.springPosition = dv.getFloat32Array(3);
      p.springRotation = dv.getFloat32Array(3);
      return p;
    };
    var metadata = pmd.metadata;
    metadata.constraintCount = dv.getUint32();
    pmd.constraints = [];
    for (var i2 = 0; i2 < metadata.constraintCount; i2++) {
      pmd.constraints.push(parseConstraint());
    }
  };
  parseHeader();
  parseVertices();
  parseFaces();
  parseMaterials();
  parseBones();
  parseIks();
  parseMorphs();
  parseMorphFrames();
  parseBoneFrameNames();
  parseBoneFrames();
  parseEnglishHeader();
  parseEnglishBoneNames();
  parseEnglishMorphNames();
  parseEnglishBoneFrameNames();
  parseToonTextures();
  parseRigidBodies();
  parseConstraints();
  if (leftToRight === true)
    this.leftToRightModel(pmd);
  return pmd;
};
Parser.prototype.parsePmx = function(buffer2, leftToRight) {
  var pmx = {};
  var dv = new DataViewEx(buffer2);
  pmx.metadata = {};
  pmx.metadata.format = "pmx";
  pmx.metadata.coordinateSystem = "left";
  var parseHeader = function() {
    var metadata = pmx.metadata;
    metadata.magic = dv.getChars(4);
    if (metadata.magic !== "PMX ") {
      throw "PMX file magic is not PMX , but " + metadata.magic;
    }
    metadata.version = dv.getFloat32();
    if (metadata.version !== 2 && metadata.version !== 2.1) {
      throw "PMX version " + metadata.version + " is not supported.";
    }
    metadata.headerSize = dv.getUint8();
    metadata.encoding = dv.getUint8();
    metadata.additionalUvNum = dv.getUint8();
    metadata.vertexIndexSize = dv.getUint8();
    metadata.textureIndexSize = dv.getUint8();
    metadata.materialIndexSize = dv.getUint8();
    metadata.boneIndexSize = dv.getUint8();
    metadata.morphIndexSize = dv.getUint8();
    metadata.rigidBodyIndexSize = dv.getUint8();
    metadata.modelName = dv.getTextBuffer();
    metadata.englishModelName = dv.getTextBuffer();
    metadata.comment = dv.getTextBuffer();
    metadata.englishComment = dv.getTextBuffer();
  };
  var parseVertices = function() {
    var parseVertex = function() {
      var p = {};
      p.position = dv.getFloat32Array(3);
      p.normal = dv.getFloat32Array(3);
      p.uv = dv.getFloat32Array(2);
      p.auvs = [];
      for (var i3 = 0; i3 < pmx.metadata.additionalUvNum; i3++) {
        p.auvs.push(dv.getFloat32Array(4));
      }
      p.type = dv.getUint8();
      var indexSize = metadata.boneIndexSize;
      if (p.type === 0) {
        p.skinIndices = dv.getIndexArray(indexSize, 1);
        p.skinWeights = [1];
      } else if (p.type === 1) {
        p.skinIndices = dv.getIndexArray(indexSize, 2);
        p.skinWeights = dv.getFloat32Array(1);
        p.skinWeights.push(1 - p.skinWeights[0]);
      } else if (p.type === 2) {
        p.skinIndices = dv.getIndexArray(indexSize, 4);
        p.skinWeights = dv.getFloat32Array(4);
      } else if (p.type === 3) {
        p.skinIndices = dv.getIndexArray(indexSize, 2);
        p.skinWeights = dv.getFloat32Array(1);
        p.skinWeights.push(1 - p.skinWeights[0]);
        p.skinC = dv.getFloat32Array(3);
        p.skinR0 = dv.getFloat32Array(3);
        p.skinR1 = dv.getFloat32Array(3);
        p.type = 1;
      } else {
        throw "unsupport bone type " + p.type + " exception.";
      }
      p.edgeRatio = dv.getFloat32();
      return p;
    };
    var metadata = pmx.metadata;
    metadata.vertexCount = dv.getUint32();
    pmx.vertices = [];
    for (var i2 = 0; i2 < metadata.vertexCount; i2++) {
      pmx.vertices.push(parseVertex());
    }
  };
  var parseFaces = function() {
    var parseFace = function() {
      var p = {};
      p.indices = dv.getIndexArray(metadata.vertexIndexSize, 3, true);
      return p;
    };
    var metadata = pmx.metadata;
    metadata.faceCount = dv.getUint32() / 3;
    pmx.faces = [];
    for (var i2 = 0; i2 < metadata.faceCount; i2++) {
      pmx.faces.push(parseFace());
    }
  };
  var parseTextures = function() {
    var parseTexture = function() {
      return dv.getTextBuffer();
    };
    var metadata = pmx.metadata;
    metadata.textureCount = dv.getUint32();
    pmx.textures = [];
    for (var i2 = 0; i2 < metadata.textureCount; i2++) {
      pmx.textures.push(parseTexture());
    }
  };
  var parseMaterials = function() {
    var parseMaterial = function() {
      var p = {};
      p.name = dv.getTextBuffer();
      p.englishName = dv.getTextBuffer();
      p.diffuse = dv.getFloat32Array(4);
      p.specular = dv.getFloat32Array(3);
      p.shininess = dv.getFloat32();
      p.ambient = dv.getFloat32Array(3);
      p.flag = dv.getUint8();
      p.edgeColor = dv.getFloat32Array(4);
      p.edgeSize = dv.getFloat32();
      p.textureIndex = dv.getIndex(pmx.metadata.textureIndexSize);
      p.envTextureIndex = dv.getIndex(pmx.metadata.textureIndexSize);
      p.envFlag = dv.getUint8();
      p.toonFlag = dv.getUint8();
      if (p.toonFlag === 0) {
        p.toonIndex = dv.getIndex(pmx.metadata.textureIndexSize);
      } else if (p.toonFlag === 1) {
        p.toonIndex = dv.getInt8();
      } else {
        throw "unknown toon flag " + p.toonFlag + " exception.";
      }
      p.comment = dv.getTextBuffer();
      p.faceCount = dv.getUint32() / 3;
      return p;
    };
    var metadata = pmx.metadata;
    metadata.materialCount = dv.getUint32();
    pmx.materials = [];
    for (var i2 = 0; i2 < metadata.materialCount; i2++) {
      pmx.materials.push(parseMaterial());
    }
  };
  var parseBones = function() {
    var parseBone = function() {
      var p = {};
      p.name = dv.getTextBuffer();
      p.englishName = dv.getTextBuffer();
      p.position = dv.getFloat32Array(3);
      p.parentIndex = dv.getIndex(pmx.metadata.boneIndexSize);
      p.transformationClass = dv.getUint32();
      p.flag = dv.getUint16();
      if (p.flag & 1) {
        p.connectIndex = dv.getIndex(pmx.metadata.boneIndexSize);
      } else {
        p.offsetPosition = dv.getFloat32Array(3);
      }
      if (p.flag & 256 || p.flag & 512) {
        var grant = {};
        grant.isLocal = (p.flag & 128) !== 0 ? true : false;
        grant.affectRotation = (p.flag & 256) !== 0 ? true : false;
        grant.affectPosition = (p.flag & 512) !== 0 ? true : false;
        grant.parentIndex = dv.getIndex(pmx.metadata.boneIndexSize);
        grant.ratio = dv.getFloat32();
        p.grant = grant;
      }
      if (p.flag & 1024) {
        p.fixAxis = dv.getFloat32Array(3);
      }
      if (p.flag & 2048) {
        p.localXVector = dv.getFloat32Array(3);
        p.localZVector = dv.getFloat32Array(3);
      }
      if (p.flag & 8192) {
        p.key = dv.getUint32();
      }
      if (p.flag & 32) {
        var ik = {};
        ik.effector = dv.getIndex(pmx.metadata.boneIndexSize);
        ik.target = null;
        ik.iteration = dv.getUint32();
        ik.maxAngle = dv.getFloat32();
        ik.linkCount = dv.getUint32();
        ik.links = [];
        for (var i3 = 0; i3 < ik.linkCount; i3++) {
          var link = {};
          link.index = dv.getIndex(pmx.metadata.boneIndexSize);
          link.angleLimitation = dv.getUint8();
          if (link.angleLimitation === 1) {
            link.lowerLimitationAngle = dv.getFloat32Array(3);
            link.upperLimitationAngle = dv.getFloat32Array(3);
          }
          ik.links.push(link);
        }
        p.ik = ik;
      }
      return p;
    };
    var metadata = pmx.metadata;
    metadata.boneCount = dv.getUint32();
    pmx.bones = [];
    for (var i2 = 0; i2 < metadata.boneCount; i2++) {
      pmx.bones.push(parseBone());
    }
  };
  var parseMorphs = function() {
    var parseMorph = function() {
      var p = {};
      p.name = dv.getTextBuffer();
      p.englishName = dv.getTextBuffer();
      p.panel = dv.getUint8();
      p.type = dv.getUint8();
      p.elementCount = dv.getUint32();
      p.elements = [];
      for (var i3 = 0; i3 < p.elementCount; i3++) {
        if (p.type === 0) {
          var m = {};
          m.index = dv.getIndex(pmx.metadata.morphIndexSize);
          m.ratio = dv.getFloat32();
          p.elements.push(m);
        } else if (p.type === 1) {
          var m = {};
          m.index = dv.getIndex(pmx.metadata.vertexIndexSize, true);
          m.position = dv.getFloat32Array(3);
          p.elements.push(m);
        } else if (p.type === 2) {
          var m = {};
          m.index = dv.getIndex(pmx.metadata.boneIndexSize);
          m.position = dv.getFloat32Array(3);
          m.rotation = dv.getFloat32Array(4);
          p.elements.push(m);
        } else if (p.type === 3) {
          var m = {};
          m.index = dv.getIndex(pmx.metadata.vertexIndexSize, true);
          m.uv = dv.getFloat32Array(4);
          p.elements.push(m);
        } else if (p.type === 4) {
        } else if (p.type === 5) {
        } else if (p.type === 6) {
        } else if (p.type === 7) {
        } else if (p.type === 8) {
          var m = {};
          m.index = dv.getIndex(pmx.metadata.materialIndexSize);
          m.type = dv.getUint8();
          m.diffuse = dv.getFloat32Array(4);
          m.specular = dv.getFloat32Array(3);
          m.shininess = dv.getFloat32();
          m.ambient = dv.getFloat32Array(3);
          m.edgeColor = dv.getFloat32Array(4);
          m.edgeSize = dv.getFloat32();
          m.textureColor = dv.getFloat32Array(4);
          m.sphereTextureColor = dv.getFloat32Array(4);
          m.toonColor = dv.getFloat32Array(4);
          p.elements.push(m);
        }
      }
      return p;
    };
    var metadata = pmx.metadata;
    metadata.morphCount = dv.getUint32();
    pmx.morphs = [];
    for (var i2 = 0; i2 < metadata.morphCount; i2++) {
      pmx.morphs.push(parseMorph());
    }
  };
  var parseFrames = function() {
    var parseFrame = function() {
      var p = {};
      p.name = dv.getTextBuffer();
      p.englishName = dv.getTextBuffer();
      p.type = dv.getUint8();
      p.elementCount = dv.getUint32();
      p.elements = [];
      for (var i3 = 0; i3 < p.elementCount; i3++) {
        var e = {};
        e.target = dv.getUint8();
        e.index = e.target === 0 ? dv.getIndex(pmx.metadata.boneIndexSize) : dv.getIndex(pmx.metadata.morphIndexSize);
        p.elements.push(e);
      }
      return p;
    };
    var metadata = pmx.metadata;
    metadata.frameCount = dv.getUint32();
    pmx.frames = [];
    for (var i2 = 0; i2 < metadata.frameCount; i2++) {
      pmx.frames.push(parseFrame());
    }
  };
  var parseRigidBodies = function() {
    var parseRigidBody = function() {
      var p = {};
      p.name = dv.getTextBuffer();
      p.englishName = dv.getTextBuffer();
      p.boneIndex = dv.getIndex(pmx.metadata.boneIndexSize);
      p.groupIndex = dv.getUint8();
      p.groupTarget = dv.getUint16();
      p.shapeType = dv.getUint8();
      p.width = dv.getFloat32();
      p.height = dv.getFloat32();
      p.depth = dv.getFloat32();
      p.position = dv.getFloat32Array(3);
      p.rotation = dv.getFloat32Array(3);
      p.weight = dv.getFloat32();
      p.positionDamping = dv.getFloat32();
      p.rotationDamping = dv.getFloat32();
      p.restitution = dv.getFloat32();
      p.friction = dv.getFloat32();
      p.type = dv.getUint8();
      return p;
    };
    var metadata = pmx.metadata;
    metadata.rigidBodyCount = dv.getUint32();
    pmx.rigidBodies = [];
    for (var i2 = 0; i2 < metadata.rigidBodyCount; i2++) {
      pmx.rigidBodies.push(parseRigidBody());
    }
  };
  var parseConstraints = function() {
    var parseConstraint = function() {
      var p = {};
      p.name = dv.getTextBuffer();
      p.englishName = dv.getTextBuffer();
      p.type = dv.getUint8();
      p.rigidBodyIndex1 = dv.getIndex(pmx.metadata.rigidBodyIndexSize);
      p.rigidBodyIndex2 = dv.getIndex(pmx.metadata.rigidBodyIndexSize);
      p.position = dv.getFloat32Array(3);
      p.rotation = dv.getFloat32Array(3);
      p.translationLimitation1 = dv.getFloat32Array(3);
      p.translationLimitation2 = dv.getFloat32Array(3);
      p.rotationLimitation1 = dv.getFloat32Array(3);
      p.rotationLimitation2 = dv.getFloat32Array(3);
      p.springPosition = dv.getFloat32Array(3);
      p.springRotation = dv.getFloat32Array(3);
      return p;
    };
    var metadata = pmx.metadata;
    metadata.constraintCount = dv.getUint32();
    pmx.constraints = [];
    for (var i2 = 0; i2 < metadata.constraintCount; i2++) {
      pmx.constraints.push(parseConstraint());
    }
  };
  parseHeader();
  parseVertices();
  parseFaces();
  parseTextures();
  parseMaterials();
  parseBones();
  parseMorphs();
  parseFrames();
  parseRigidBodies();
  parseConstraints();
  if (leftToRight === true)
    this.leftToRightModel(pmx);
  return pmx;
};
Parser.prototype.parseVmd = function(buffer2, leftToRight) {
  var vmd = {};
  var dv = new DataViewEx(buffer2);
  vmd.metadata = {};
  vmd.metadata.coordinateSystem = "left";
  var parseHeader = function() {
    var metadata = vmd.metadata;
    metadata.magic = dv.getChars(30);
    if (metadata.magic !== "Vocaloid Motion Data 0002") {
      throw "VMD file magic is not Vocaloid Motion Data 0002, but " + metadata.magic;
    }
    metadata.name = dv.getSjisStringsAsUnicode(20);
  };
  var parseMotions = function() {
    var parseMotion = function() {
      var p = {};
      p.boneName = dv.getSjisStringsAsUnicode(15);
      p.frameNum = dv.getUint32();
      p.position = dv.getFloat32Array(3);
      p.rotation = dv.getFloat32Array(4);
      p.interpolation = dv.getUint8Array(64);
      return p;
    };
    var metadata = vmd.metadata;
    metadata.motionCount = dv.getUint32();
    vmd.motions = [];
    for (var i2 = 0; i2 < metadata.motionCount; i2++) {
      vmd.motions.push(parseMotion());
    }
  };
  var parseMorphs = function() {
    var parseMorph = function() {
      var p = {};
      p.morphName = dv.getSjisStringsAsUnicode(15);
      p.frameNum = dv.getUint32();
      p.weight = dv.getFloat32();
      return p;
    };
    var metadata = vmd.metadata;
    metadata.morphCount = dv.getUint32();
    vmd.morphs = [];
    for (var i2 = 0; i2 < metadata.morphCount; i2++) {
      vmd.morphs.push(parseMorph());
    }
  };
  var parseCameras = function() {
    var parseCamera = function() {
      var p = {};
      p.frameNum = dv.getUint32();
      p.distance = dv.getFloat32();
      p.position = dv.getFloat32Array(3);
      p.rotation = dv.getFloat32Array(3);
      p.interpolation = dv.getUint8Array(24);
      p.fov = dv.getUint32();
      p.perspective = dv.getUint8();
      return p;
    };
    var metadata = vmd.metadata;
    metadata.cameraCount = dv.getUint32();
    vmd.cameras = [];
    for (var i2 = 0; i2 < metadata.cameraCount; i2++) {
      vmd.cameras.push(parseCamera());
    }
  };
  parseHeader();
  parseMotions();
  parseMorphs();
  parseCameras();
  if (leftToRight === true)
    this.leftToRightVmd(vmd);
  return vmd;
};
Parser.prototype.parseVpd = function(text, leftToRight) {
  var vpd = {};
  vpd.metadata = {};
  vpd.metadata.coordinateSystem = "left";
  vpd.bones = [];
  var commentPatternG = /\/\/\w*(\r|\n|\r\n)/g;
  var newlinePattern = /\r|\n|\r\n/;
  var lines = text.replace(commentPatternG, "").split(newlinePattern);
  function throwError() {
    throw "the file seems not vpd file.";
  }
  function checkMagic() {
    if (lines[0] !== "Vocaloid Pose Data file") {
      throwError();
    }
  }
  function parseHeader() {
    if (lines.length < 4) {
      throwError();
    }
    vpd.metadata.parentFile = lines[2];
    vpd.metadata.boneCount = parseInt(lines[3]);
  }
  function parseBones() {
    var boneHeaderPattern = /^\s*(Bone[0-9]+)\s*\{\s*(.*)$/;
    var boneVectorPattern = /^\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*;/;
    var boneQuaternionPattern = /^\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*;/;
    var boneFooterPattern = /^\s*}/;
    var bones = vpd.bones;
    var n = null;
    var v = null;
    var q = null;
    for (var i2 = 4; i2 < lines.length; i2++) {
      var line2 = lines[i2];
      var result;
      result = line2.match(boneHeaderPattern);
      if (result !== null) {
        if (n !== null) {
          throwError();
        }
        n = result[2];
      }
      result = line2.match(boneVectorPattern);
      if (result !== null) {
        if (v !== null) {
          throwError();
        }
        v = [
          parseFloat(result[1]),
          parseFloat(result[2]),
          parseFloat(result[3])
        ];
      }
      result = line2.match(boneQuaternionPattern);
      if (result !== null) {
        if (q !== null) {
          throwError();
        }
        q = [
          parseFloat(result[1]),
          parseFloat(result[2]),
          parseFloat(result[3]),
          parseFloat(result[4])
        ];
      }
      result = line2.match(boneFooterPattern);
      if (result !== null) {
        if (n === null || v === null || q === null) {
          throwError();
        }
        bones.push({
          name: n,
          translation: v,
          quaternion: q
        });
        n = null;
        v = null;
        q = null;
      }
    }
    if (n !== null || v !== null || q !== null) {
      throwError();
    }
  }
  checkMagic();
  parseHeader();
  parseBones();
  if (leftToRight === true)
    this.leftToRightVpd(vpd);
  return vpd;
};
Parser.prototype.mergeVmds = function(vmds) {
  var v = {};
  v.metadata = {};
  v.metadata.name = vmds[0].metadata.name;
  v.metadata.coordinateSystem = vmds[0].metadata.coordinateSystem;
  v.metadata.motionCount = 0;
  v.metadata.morphCount = 0;
  v.metadata.cameraCount = 0;
  v.motions = [];
  v.morphs = [];
  v.cameras = [];
  for (var i2 = 0; i2 < vmds.length; i2++) {
    var v2 = vmds[i2];
    v.metadata.motionCount += v2.metadata.motionCount;
    v.metadata.morphCount += v2.metadata.morphCount;
    v.metadata.cameraCount += v2.metadata.cameraCount;
    for (var j2 = 0; j2 < v2.metadata.motionCount; j2++) {
      v.motions.push(v2.motions[j2]);
    }
    for (var j2 = 0; j2 < v2.metadata.morphCount; j2++) {
      v.morphs.push(v2.morphs[j2]);
    }
    for (var j2 = 0; j2 < v2.metadata.cameraCount; j2++) {
      v.cameras.push(v2.cameras[j2]);
    }
  }
  return v;
};
Parser.prototype.leftToRightModel = function(model) {
  if (model.metadata.coordinateSystem === "right") {
    return;
  }
  model.metadata.coordinateSystem = "right";
  var helper = new DataCreationHelper();
  for (var i2 = 0; i2 < model.metadata.vertexCount; i2++) {
    helper.leftToRightVector3(model.vertices[i2].position);
    helper.leftToRightVector3(model.vertices[i2].normal);
  }
  for (var i2 = 0; i2 < model.metadata.faceCount; i2++) {
    helper.leftToRightIndexOrder(model.faces[i2].indices);
  }
  for (var i2 = 0; i2 < model.metadata.boneCount; i2++) {
    helper.leftToRightVector3(model.bones[i2].position);
  }
  for (var i2 = 0; i2 < model.metadata.morphCount; i2++) {
    var m = model.morphs[i2];
    if (model.metadata.format === "pmx" && m.type !== 1) {
      continue;
    }
    for (var j2 = 0; j2 < m.elements.length; j2++) {
      helper.leftToRightVector3(m.elements[j2].position);
    }
  }
  for (var i2 = 0; i2 < model.metadata.rigidBodyCount; i2++) {
    helper.leftToRightVector3(model.rigidBodies[i2].position);
    helper.leftToRightEuler(model.rigidBodies[i2].rotation);
  }
  for (var i2 = 0; i2 < model.metadata.constraintCount; i2++) {
    helper.leftToRightVector3(model.constraints[i2].position);
    helper.leftToRightEuler(model.constraints[i2].rotation);
    helper.leftToRightVector3Range(model.constraints[i2].translationLimitation1, model.constraints[i2].translationLimitation2);
    helper.leftToRightEulerRange(model.constraints[i2].rotationLimitation1, model.constraints[i2].rotationLimitation2);
  }
};
Parser.prototype.leftToRightVmd = function(vmd) {
  if (vmd.metadata.coordinateSystem === "right") {
    return;
  }
  vmd.metadata.coordinateSystem = "right";
  var helper = new DataCreationHelper();
  for (var i2 = 0; i2 < vmd.metadata.motionCount; i2++) {
    helper.leftToRightVector3(vmd.motions[i2].position);
    helper.leftToRightQuaternion(vmd.motions[i2].rotation);
  }
  for (var i2 = 0; i2 < vmd.metadata.cameraCount; i2++) {
    helper.leftToRightVector3(vmd.cameras[i2].position);
    helper.leftToRightEuler(vmd.cameras[i2].rotation);
  }
};
Parser.prototype.leftToRightVpd = function(vpd) {
  if (vpd.metadata.coordinateSystem === "right") {
    return;
  }
  vpd.metadata.coordinateSystem = "right";
  var helper = new DataCreationHelper();
  for (var i2 = 0; i2 < vpd.bones.length; i2++) {
    helper.leftToRightVector3(vpd.bones[i2].translation);
    helper.leftToRightQuaternion(vpd.bones[i2].quaternion);
  }
};

// node_modules/three-stdlib/exporters/MMDExporter.js
var MMDExporter = class {
  constructor() {
    _defineProperty(this, "u2sTable", void 0);
  }
  parseVpd(skin, outputShiftJis, useOriginalBones) {
    if (skin.isSkinnedMesh !== true) {
      console.warn("THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.");
      return null;
    }
    function toStringsFromNumber(num) {
      if (Math.abs(num) < 1e-6)
        num = 0;
      let a2 = num.toString();
      if (a2.indexOf(".") === -1) {
        a2 += ".";
      }
      a2 += "000000";
      const index = a2.indexOf(".");
      const d = a2.slice(0, index);
      const p = a2.slice(index + 1, index + 7);
      return d + "." + p;
    }
    function toStringsFromArray(array2) {
      const a2 = [];
      for (let i2 = 0, il = array2.length; i2 < il; i2++) {
        a2.push(toStringsFromNumber(array2[i2]));
      }
      return a2.join(",");
    }
    skin.updateMatrixWorld(true);
    const bones = skin.skeleton.bones;
    const bones2 = this.getBindBones(skin);
    const position = new Vector3();
    const quaternion = new Quaternion();
    const quaternion2 = new Quaternion();
    const matrix3 = new Matrix4();
    const array = [];
    array.push("Vocaloid Pose Data file");
    array.push("");
    array.push((skin.name !== "" ? skin.name.replace(/\s/g, "_") : "skin") + ".osm;");
    array.push(bones.length + ";");
    array.push("");
    for (let i2 = 0, il = bones.length; i2 < il; i2++) {
      const bone = bones[i2];
      const bone2 = bones2[i2];
      if (useOriginalBones === true && bone.userData.ik !== void 0 && bone.userData.ik.originalMatrix !== void 0) {
        matrix3.fromArray(bone.userData.ik.originalMatrix);
      } else {
        matrix3.copy(bone.matrix);
      }
      position.setFromMatrixPosition(matrix3);
      quaternion.setFromRotationMatrix(matrix3);
      const pArray = position.sub(bone2.position).toArray();
      const qArray = quaternion2.copy(bone2.quaternion).conjugate().multiply(quaternion).toArray();
      pArray[2] = -pArray[2];
      qArray[0] = -qArray[0];
      qArray[1] = -qArray[1];
      array.push("Bone" + i2 + "{" + bone.name);
      array.push("  " + toStringsFromArray(pArray) + ";");
      array.push("  " + toStringsFromArray(qArray) + ";");
      array.push("}");
      array.push("");
    }
    array.push("");
    const lines = array.join("\n");
    return outputShiftJis === true ? this.unicodeToShiftjis(lines) : lines;
  }
  unicodeToShiftjis(str) {
    if (this.u2sTable === void 0) {
      const encoder = new CharsetEncoder();
      const table2 = encoder.s2uTable;
      this.u2sTable = {};
      const keys = Object.keys(table2);
      for (let i2 = 0, il = keys.length; i2 < il; i2++) {
        let key = keys[i2];
        const value = table2[key];
        this.u2sTable[value] = parseInt(key);
      }
    }
    const array = [];
    for (let i2 = 0, il = str.length; i2 < il; i2++) {
      const code = str.charCodeAt(i2);
      const value = this.u2sTable[code];
      if (value === void 0) {
        throw "cannot convert charcode 0x" + code.toString(16);
      } else if (value > 255) {
        array.push(value >> 8 & 255);
        array.push(value & 255);
      } else {
        array.push(value & 255);
      }
    }
    return new Uint8Array(array);
  }
  getBindBones(skin) {
    const poseSkin = skin.clone();
    poseSkin.pose();
    return poseSkin.skeleton.bones;
  }
};

// node_modules/three-stdlib/exporters/STLExporter.js
var STLExporter = class {
  constructor() {
    _defineProperty(this, "binary", void 0);
    _defineProperty(this, "output", void 0);
    _defineProperty(this, "offset", void 0);
    _defineProperty(this, "objects", void 0);
    _defineProperty(this, "triangles", void 0);
    _defineProperty(this, "vA", void 0);
    _defineProperty(this, "vB", void 0);
    _defineProperty(this, "vC", void 0);
    _defineProperty(this, "cb", void 0);
    _defineProperty(this, "ab", void 0);
    _defineProperty(this, "normal", void 0);
    this.binary = false;
    this.output = "";
    this.offset = 80;
    this.objects = [];
    this.triangles = 0;
    this.vA = new Vector3();
    this.vB = new Vector3();
    this.vC = new Vector3();
    this.cb = new Vector3();
    this.ab = new Vector3();
    this.normal = new Vector3();
  }
  parse(scene, options) {
    this.binary = options.binary !== void 0 ? options.binary : false;
    scene.traverse((object) => {
      if (object instanceof Mesh && object.isMesh) {
        const geometry = object.geometry;
        if (!geometry.isBufferGeometry) {
          throw new Error("THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.");
        }
        const index = geometry.index;
        const positionAttribute = geometry.getAttribute("position");
        this.triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;
        this.objects.push({
          object3d: object,
          geometry
        });
      }
    });
    if (this.binary) {
      const bufferLength = this.triangles * 2 + this.triangles * 3 * 4 * 4 + 80 + 4;
      const arrayBuffer = new ArrayBuffer(bufferLength);
      this.output = new DataView(arrayBuffer);
      this.output.setUint32(this.offset, this.triangles, true);
      this.offset += 4;
    } else {
      this.output = "";
      this.output += "solid exported\n";
    }
    for (let i2 = 0, il = this.objects.length; i2 < il; i2++) {
      const object = this.objects[i2].object3d;
      const geometry = this.objects[i2].geometry;
      const index = geometry.index;
      const positionAttribute = geometry.getAttribute("position");
      if (object instanceof SkinnedMesh) {
        if (index !== null) {
          for (let j2 = 0; j2 < index.count; j2 += 3) {
            const a2 = index.getX(j2 + 0);
            const b3 = index.getX(j2 + 1);
            const c = index.getX(j2 + 2);
            this.writeFace(a2, b3, c, positionAttribute, object);
          }
        } else {
          for (let j2 = 0; j2 < positionAttribute.count; j2 += 3) {
            const a2 = j2 + 0;
            const b3 = j2 + 1;
            const c = j2 + 2;
            this.writeFace(a2, b3, c, positionAttribute, object);
          }
        }
      }
    }
    if (!this.binary) {
      this.output += "endsolid exported\n";
    }
    return this.output;
  }
  writeFace(a2, b3, c, positionAttribute, object) {
    this.vA.fromBufferAttribute(positionAttribute, a2);
    this.vB.fromBufferAttribute(positionAttribute, b3);
    this.vC.fromBufferAttribute(positionAttribute, c);
    if (object.isSkinnedMesh) {
      object.boneTransform(a2, this.vA);
      object.boneTransform(b3, this.vB);
      object.boneTransform(c, this.vC);
    }
    this.vA.applyMatrix4(object.matrixWorld);
    this.vB.applyMatrix4(object.matrixWorld);
    this.vC.applyMatrix4(object.matrixWorld);
    this.writeNormal(this.vA, this.vB, this.vC);
    this.writeVertex(this.vA);
    this.writeVertex(this.vB);
    this.writeVertex(this.vC);
    if (this.binary && this.output instanceof DataView) {
      this.output.setUint16(this.offset, 0, true);
      this.offset += 2;
    } else {
      this.output += "		endloop\n";
      this.output += "	endfacet\n";
    }
  }
  writeNormal(vA, vB, vC) {
    this.cb.subVectors(vC, vB);
    this.ab.subVectors(vA, vB);
    this.cb.cross(this.ab).normalize();
    this.normal.copy(this.cb).normalize();
    if (this.binary && this.output instanceof DataView) {
      this.output.setFloat32(this.offset, this.normal.x, true);
      this.offset += 4;
      this.output.setFloat32(this.offset, this.normal.y, true);
      this.offset += 4;
      this.output.setFloat32(this.offset, this.normal.z, true);
      this.offset += 4;
    } else {
      this.output += `	facet normal ${this.normal.x} ${this.normal.y} ${this.normal.z}
`;
      this.output += "		outer loop\n";
    }
  }
  writeVertex(vertex) {
    if (this.binary && this.output instanceof DataView) {
      this.output.setFloat32(this.offset, vertex.x, true);
      this.offset += 4;
      this.output.setFloat32(this.offset, vertex.y, true);
      this.offset += 4;
      this.output.setFloat32(this.offset, vertex.z, true);
      this.offset += 4;
    } else {
      this.output += `			vertex vertex.x vertex.y vertex.z
`;
    }
  }
};

// node_modules/three-stdlib/exporters/OBJExporter.js
var OBJExporter = class {
  constructor() {
    _defineProperty(this, "output", void 0);
    _defineProperty(this, "indexVertex", void 0);
    _defineProperty(this, "indexVertexUvs", void 0);
    _defineProperty(this, "indexNormals", void 0);
    _defineProperty(this, "vertex", void 0);
    _defineProperty(this, "color", void 0);
    _defineProperty(this, "normal", void 0);
    _defineProperty(this, "uv", void 0);
    _defineProperty(this, "face", void 0);
    this.output = "";
    this.indexVertex = 0;
    this.indexVertexUvs = 0;
    this.indexNormals = 0;
    this.vertex = new Vector3();
    this.color = new Color();
    this.normal = new Vector3();
    this.uv = new Vector2();
    this.face = [];
  }
  parse(object) {
    object.traverse((child) => {
      if (child instanceof Mesh && child.isMesh) {
        this.parseMesh(child);
      }
      if (child instanceof Line && child.isLine) {
        this.parseLine(child);
      }
      if (child instanceof Points && child.isPoints) {
        this.parsePoints(child);
      }
    });
    return this.output;
  }
  parseMesh(mesh) {
    let nbVertex = 0;
    let nbNormals = 0;
    let nbVertexUvs = 0;
    const geometry = mesh.geometry;
    const normalMatrixWorld = new Matrix3();
    if (!geometry.isBufferGeometry) {
      throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");
    }
    const vertices = geometry.getAttribute("position");
    const normals = geometry.getAttribute("normal");
    const uvs = geometry.getAttribute("uv");
    const indices = geometry.getIndex();
    this.output += `o ${mesh.name}
`;
    if (mesh.material && !Array.isArray(mesh.material) && mesh.material.name) {
      this.output += `usemtl ${mesh.material.name}
`;
    }
    if (vertices !== void 0) {
      for (let i2 = 0, l = vertices.count; i2 < l; i2++, nbVertex++) {
        this.vertex.x = vertices.getX(i2);
        this.vertex.y = vertices.getY(i2);
        this.vertex.z = vertices.getZ(i2);
        this.vertex.applyMatrix4(mesh.matrixWorld);
        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}
`;
      }
    }
    if (uvs !== void 0) {
      for (let i2 = 0, l = uvs.count; i2 < l; i2++, nbVertexUvs++) {
        this.uv.x = uvs.getX(i2);
        this.uv.y = uvs.getY(i2);
        this.output += `vt ${this.uv.x} ${this.uv.y}
`;
      }
    }
    if (normals !== void 0) {
      normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);
      for (let i2 = 0, l = normals.count; i2 < l; i2++, nbNormals++) {
        this.normal.x = normals.getX(i2);
        this.normal.y = normals.getY(i2);
        this.normal.z = normals.getZ(i2);
        this.normal.applyMatrix3(normalMatrixWorld).normalize();
        this.output += `vn ${this.normal.x} ${this.normal.y} ${this.normal.z}
`;
      }
    }
    if (indices !== null) {
      for (let i2 = 0, l = indices.count; i2 < l; i2 += 3) {
        for (let m = 0; m < 3; m++) {
          const j2 = indices.getX(i2 + m) + 1;
          this.face[m] = this.indexVertex + j2 + (normals || uvs ? `/${uvs ? this.indexVertexUvs + j2 : ""}${normals ? `/${this.indexNormals + j2}` : ""}` : "");
        }
        this.output += `f ${this.face.join(" ")}
`;
      }
    } else {
      for (let i2 = 0, l = vertices.count; i2 < l; i2 += 3) {
        for (let m = 0; m < 3; m++) {
          const j2 = i2 + m + 1;
          this.face[m] = this.indexVertex + j2 + (normals || uvs ? `/${uvs ? this.indexVertexUvs + j2 : ""}${normals ? `/${this.indexNormals + j2}` : ""}` : "");
        }
        this.output += `f ${this.face.join(" ")}
`;
      }
    }
    this.indexVertex += nbVertex;
    this.indexVertexUvs += nbVertexUvs;
    this.indexNormals += nbNormals;
  }
  parseLine(line2) {
    let nbVertex = 0;
    const geometry = line2.geometry;
    const type2 = line2.type;
    if (geometry.isBufferGeometry) {
      throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");
    }
    const vertices = geometry.getAttribute("position");
    this.output += `o ${line2.name}
`;
    if (vertices !== void 0) {
      for (let i2 = 0, l = vertices.count; i2 < l; i2++, nbVertex++) {
        this.vertex.x = vertices.getX(i2);
        this.vertex.y = vertices.getY(i2);
        this.vertex.z = vertices.getZ(i2);
        this.vertex.applyMatrix4(line2.matrixWorld);
        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}
`;
      }
    }
    if (type2 === "Line") {
      this.output += "l ";
      for (let j2 = 1, l = vertices.count; j2 <= l; j2++) {
        this.output += `${this.indexVertex + j2} `;
      }
      this.output += "\n";
    }
    if (type2 === "LineSegments") {
      for (let j2 = 1, k = j2 + 1, l = vertices.count; j2 < l; j2 += 2, k = j2 + 1) {
        this.output += `l ${this.indexVertex + j2} ${this.indexVertex + k}
`;
      }
    }
    this.indexVertex += nbVertex;
  }
  parsePoints(points) {
    let nbVertex = 0;
    const geometry = points.geometry;
    if (!geometry.isBufferGeometry) {
      throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");
    }
    const vertices = geometry.getAttribute("position");
    const colors = geometry.getAttribute("color");
    this.output += `o ${points.name}
`;
    if (vertices !== void 0) {
      for (let i2 = 0, l = vertices.count; i2 < l; i2++, nbVertex++) {
        this.vertex.fromBufferAttribute(vertices, i2);
        this.vertex.applyMatrix4(points.matrixWorld);
        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}`;
        if (colors !== void 0 && colors instanceof BufferAttribute) {
          this.color.fromBufferAttribute(colors, i2);
          this.output += ` ${this.color.r} ${this.color.g} ${this.color.b}`;
        }
        this.output += "\n";
      }
    }
    this.output += "p ";
    for (let j2 = 1, l = vertices.count; j2 <= l; j2++) {
      this.output += `${this.indexVertex + j2} `;
    }
    this.output += "\n";
    this.indexVertex += nbVertex;
  }
};

// node_modules/three-stdlib/environments/RoomEnvironment.js
function RoomEnvironment() {
  const scene = new Scene();
  const geometry = new BoxGeometry();
  geometry.deleteAttribute("uv");
  const roomMaterial = new MeshStandardMaterial({
    side: BackSide
  });
  const boxMaterial = new MeshStandardMaterial();
  const mainLight = new PointLight(16777215, 5, 28, 2);
  mainLight.position.set(0.418, 16.199, 0.3);
  scene.add(mainLight);
  const room = new Mesh(geometry, roomMaterial);
  room.position.set(-0.757, 13.219, 0.717);
  room.scale.set(31.713, 28.305, 28.591);
  scene.add(room);
  const box1 = new Mesh(geometry, boxMaterial);
  box1.position.set(-10.906, 2.009, 1.846);
  box1.rotation.set(0, -0.195, 0);
  box1.scale.set(2.328, 7.905, 4.651);
  scene.add(box1);
  const box2 = new Mesh(geometry, boxMaterial);
  box2.position.set(-5.607, -0.754, -0.758);
  box2.rotation.set(0, 0.994, 0);
  box2.scale.set(1.97, 1.534, 3.955);
  scene.add(box2);
  const box3 = new Mesh(geometry, boxMaterial);
  box3.position.set(6.167, 0.857, 7.803);
  box3.rotation.set(0, 0.561, 0);
  box3.scale.set(3.927, 6.285, 3.687);
  scene.add(box3);
  const box4 = new Mesh(geometry, boxMaterial);
  box4.position.set(-2.017, 0.018, 6.124);
  box4.rotation.set(0, 0.333, 0);
  box4.scale.set(2.002, 4.566, 2.064);
  scene.add(box4);
  const box5 = new Mesh(geometry, boxMaterial);
  box5.position.set(2.291, -0.756, -2.621);
  box5.rotation.set(0, -0.286, 0);
  box5.scale.set(1.546, 1.552, 1.496);
  scene.add(box5);
  const box6 = new Mesh(geometry, boxMaterial);
  box6.position.set(-2.193, -0.369, -5.547);
  box6.rotation.set(0, 0.516, 0);
  box6.scale.set(3.875, 3.487, 2.986);
  scene.add(box6);
  const light1 = new Mesh(geometry, createAreaLightMaterial(50));
  light1.position.set(-16.116, 14.37, 8.208);
  light1.scale.set(0.1, 2.428, 2.739);
  scene.add(light1);
  const light2 = new Mesh(geometry, createAreaLightMaterial(50));
  light2.position.set(-16.109, 18.021, -8.207);
  light2.scale.set(0.1, 2.425, 2.751);
  scene.add(light2);
  const light3 = new Mesh(geometry, createAreaLightMaterial(17));
  light3.position.set(14.904, 12.198, -1.832);
  light3.scale.set(0.15, 4.265, 6.331);
  scene.add(light3);
  const light4 = new Mesh(geometry, createAreaLightMaterial(43));
  light4.position.set(-0.462, 8.89, 14.52);
  light4.scale.set(4.38, 5.441, 0.088);
  scene.add(light4);
  const light5 = new Mesh(geometry, createAreaLightMaterial(20));
  light5.position.set(3.235, 11.486, -12.541);
  light5.scale.set(2.5, 2, 0.1);
  scene.add(light5);
  const light6 = new Mesh(geometry, createAreaLightMaterial(100));
  light6.position.set(0, 20, 0);
  light6.scale.set(1, 0.1, 1);
  scene.add(light6);
  function createAreaLightMaterial(intensity) {
    const material = new MeshBasicMaterial();
    material.color.setScalar(intensity);
    return material;
  }
  return scene;
}

// node_modules/three-stdlib/animation/AnimationClipCreator.js
var AnimationClipCreator = () => {
};
AnimationClipCreator.CreateRotationAnimation = (period, axis) => {
  const times = [0, period], values = [0, 360];
  axis = axis || "x";
  const trackName = `.rotation[${axis}]`;
  const track = new NumberKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, period, [track]);
};
AnimationClipCreator.CreateScaleAxisAnimation = (period, axis) => {
  const times = [0, period], values = [0, 1];
  axis = axis || "x";
  const trackName = `.scale[${axis}]`;
  const track = new NumberKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, period, [track]);
};
AnimationClipCreator.CreateShakeAnimation = (duration, shakeScale) => {
  const times = [], values = [], tmp = new Vector3();
  for (let i2 = 0; i2 < duration * 10; i2++) {
    times.push(i2 / 10);
    tmp.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).multiply(shakeScale).toArray(values, values.length);
  }
  const trackName = ".position";
  const track = new VectorKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, duration, [track]);
};
AnimationClipCreator.CreatePulsationAnimation = (duration, pulseScale) => {
  const times = [], values = [], tmp = new Vector3();
  for (let i2 = 0; i2 < duration * 10; i2++) {
    times.push(i2 / 10);
    const scaleFactor = Math.random() * pulseScale;
    tmp.set(scaleFactor, scaleFactor, scaleFactor).toArray(values, values.length);
  }
  const trackName = ".scale";
  const track = new VectorKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, duration, [track]);
};
AnimationClipCreator.CreateVisibilityAnimation = (duration) => {
  const times = [0, duration / 2, duration], values = [true, false, true];
  const trackName = ".visible";
  const track = new BooleanKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, duration, [track]);
};
AnimationClipCreator.CreateMaterialColorAnimation = (duration, colors) => {
  const times = [], values = [], timeStep = duration / colors.length;
  for (let i2 = 0; i2 <= colors.length; i2++) {
    times.push(i2 * timeStep);
    values.push(colors[i2 % colors.length]);
  }
  const trackName = ".material[0].color";
  const track = new ColorKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, duration, [track]);
};

// node_modules/three-stdlib/animation/CCDIKSolver.js
var CCDIKHelper = class extends Object3D {
  constructor(mesh, iks = []) {
    super();
    _defineProperty(this, "_m", new Matrix4());
    _defineProperty(this, "_v", new Vector3());
    this.root = mesh;
    this.iks = iks;
    this.matrix.copy(mesh.matrixWorld);
    this.matrixAutoUpdate = false;
    this.sphereGeometry = new SphereGeometry(0.25, 16, 8);
    this.targetSphereMaterial = new MeshBasicMaterial({
      color: new Color(16746632),
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this.effectorSphereMaterial = new MeshBasicMaterial({
      color: new Color(8978312),
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this.linkSphereMaterial = new MeshBasicMaterial({
      color: new Color(8947967),
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this.lineMaterial = new LineBasicMaterial({
      color: new Color(16711680),
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    function createLineGeometry(ik) {
      const geometry = new BufferGeometry();
      const vertices = new Float32Array((2 + ik.links.length) * 3);
      geometry.setAttribute("position", new BufferAttribute(vertices, 3));
      return geometry;
    }
    function createTargetMesh() {
      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);
    }
    function createEffectorMesh() {
      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);
    }
    function createLinkMesh() {
      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);
    }
    function createLine(ik) {
      return new Line(createLineGeometry(ik), scope.lineMaterial);
    }
    for (let i2 = 0, il = iks.length; i2 < il; i2++) {
      const ik = iks[i2];
      this.add(createTargetMesh());
      this.add(createEffectorMesh());
      for (let j2 = 0, jl2 = ik.links.length; j2 < jl2; j2++) {
        this.add(createLinkMesh());
      }
      this.add(createLine(ik));
    }
  }
  _getPosition(bone, matrixWorldInv) {
    return this._v.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);
  }
  _setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {
    const v = this._getPosition(bone, matrixWorldInv);
    array[index * 3 + 0] = v.x;
    array[index * 3 + 1] = v.y;
    array[index * 3 + 2] = v.z;
  }
  updateMatrixWorld(force) {
    const mesh = this.root;
    if (this.visible) {
      let offset = 0;
      const iks = this.iks;
      const bones = mesh.skeleton.bones;
      this._m.copy(mesh.matrixWorld).invert();
      for (let i2 = 0, il = iks.length; i2 < il; i2++) {
        const ik = iks[i2];
        const targetBone = bones[ik.target];
        const effectorBone = bones[ik.effector];
        const targetMesh = this.children[offset++];
        const effectorMesh = this.children[offset++];
        targetMesh.position.copy(this._getPosition(targetBone, this._m));
        effectorMesh.position.copy(this._getPosition(effectorBone, this._m));
        for (let j2 = 0, jl2 = ik.links.length; j2 < jl2; j2++) {
          const link = ik.links[j2];
          const linkBone = bones[link.index];
          const linkMesh = this.children[offset++];
          linkMesh.position.copy(this._getPosition(linkBone, this._m));
        }
        const line2 = this.children[offset++];
        const array = line2.geometry.attributes.position.array;
        this._setPositionOfBoneToAttributeArray(array, 0, targetBone, this._m);
        this._setPositionOfBoneToAttributeArray(array, 1, effectorBone, this._m);
        for (let j2 = 0, jl2 = ik.links.length; j2 < jl2; j2++) {
          const link = ik.links[j2];
          const linkBone = bones[link.index];
          this._setPositionOfBoneToAttributeArray(array, j2 + 2, linkBone, this._m);
        }
        line2.geometry.attributes.position.needsUpdate = true;
      }
    }
    this.matrix.copy(mesh.matrixWorld);
    super.updateMatrixWorld(force);
  }
};
var CCDIKSolver = class {
  constructor(mesh, iks) {
    _defineProperty(this, "q", new Quaternion());
    _defineProperty(this, "targetPos", new Vector3());
    _defineProperty(this, "targetVec", new Vector3());
    _defineProperty(this, "effectorPos", new Vector3());
    _defineProperty(this, "effectorVec", new Vector3());
    _defineProperty(this, "linkPos", new Vector3());
    _defineProperty(this, "invLinkQ", new Quaternion());
    _defineProperty(this, "linkScale", new Vector3());
    _defineProperty(this, "axis", new Vector3());
    _defineProperty(this, "vector", new Vector3());
    this.mesh = mesh;
    this.iks = iks;
    const bones = this.mesh.skeleton.bones;
    for (let i2 = 0, il = this.iks.length; i2 < il; i2++) {
      const ik = this.iks[i2];
      const effector = bones[ik.effector];
      const links = ik.links;
      let link0, link1;
      link0 = effector;
      for (let j2 = 0, jl2 = links.length; j2 < jl2; j2++) {
        link1 = bones[links[j2].index];
        if (link0.parent !== link1) {
          console.warn(`THREE.CCDIKSolver: bone ${link0.name} is not the child of bone ${link1.name}`);
        }
        link0 = link1;
      }
    }
  }
  update() {
    const bones = this.mesh.skeleton.bones;
    const iks = this.iks;
    const math = Math;
    for (let i2 = 0, il = iks.length; i2 < il; i2++) {
      const ik = iks[i2];
      const effector = bones[ik.effector];
      const target = bones[ik.target];
      this.targetPos.setFromMatrixPosition(target.matrixWorld);
      const links = ik.links;
      const iteration = ik.iteration !== void 0 ? ik.iteration : 1;
      for (let j2 = 0; j2 < iteration; j2++) {
        let rotated = false;
        for (let k = 0, kl = links.length; k < kl; k++) {
          const link = bones[links[k].index];
          if (links[k].enabled === false)
            break;
          const limitation = links[k].limitation;
          const rotationMin = links[k].rotationMin;
          const rotationMax = links[k].rotationMax;
          link.matrixWorld.decompose(this.linkPos, this.invLinkQ, this.linkScale);
          this.invLinkQ.invert();
          this.effectorPos.setFromMatrixPosition(effector.matrixWorld);
          this.effectorVec.subVectors(this.effectorPos, this.linkPos);
          this.effectorVec.applyQuaternion(this.invLinkQ);
          this.effectorVec.normalize();
          this.targetVec.subVectors(this.targetPos, this.linkPos);
          this.targetVec.applyQuaternion(this.invLinkQ);
          this.targetVec.normalize();
          let angle = this.targetVec.dot(this.effectorVec);
          if (angle > 1) {
            angle = 1;
          } else if (angle < -1) {
            angle = -1;
          }
          angle = math.acos(angle);
          if (angle < 1e-5)
            continue;
          if (ik.minAngle !== void 0 && angle < ik.minAngle) {
            angle = ik.minAngle;
          }
          if (ik.maxAngle !== void 0 && angle > ik.maxAngle) {
            angle = ik.maxAngle;
          }
          this.axis.crossVectors(this.effectorVec, this.targetVec);
          this.axis.normalize();
          this.q.setFromAxisAngle(this.axis, angle);
          link.quaternion.multiply(this.q);
          if (limitation !== void 0) {
            let c = link.quaternion.w;
            if (c > 1)
              c = 1;
            const c2 = math.sqrt(1 - c * c);
            link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);
          }
          if (rotationMin !== void 0) {
            link.rotation.setFromVector3(link.rotation.toVector3(this.vector).max(rotationMin));
          }
          if (rotationMax !== void 0) {
            link.rotation.setFromVector3(link.rotation.toVector3(this.vector).min(rotationMax));
          }
          link.updateMatrixWorld(true);
          rotated = true;
        }
        if (!rotated)
          break;
      }
    }
    return this;
  }
  createHelper() {
    return new CCDIKHelper(this.mesh, this.mesh.geometry.userData.MMD.iks);
  }
};

// node_modules/three-stdlib/animation/MMDPhysics.js
var MMDPhysics = (() => {
  function MMDPhysics2(mesh, rigidBodyParams, constraintParams, params) {
    if (typeof Ammo === "undefined") {
      throw new Error("THREE.MMDPhysics: Import ammo.js https://github.com/kripken/ammo.js");
    }
    constraintParams = constraintParams || [];
    params = params || {};
    this.manager = new ResourceManager();
    this.mesh = mesh;
    this.unitStep = params.unitStep !== void 0 ? params.unitStep : 1 / 65;
    this.maxStepNum = params.maxStepNum !== void 0 ? params.maxStepNum : 3;
    this.gravity = new Vector3(0, -9.8 * 10, 0);
    if (params.gravity !== void 0)
      this.gravity.copy(params.gravity);
    this.world = params.world !== void 0 ? params.world : null;
    this.bodies = [];
    this.constraints = [];
    this._init(mesh, rigidBodyParams, constraintParams);
  }
  MMDPhysics2.prototype = {
    constructor: MMDPhysics2,
    update: function(delta) {
      const manager = this.manager;
      const mesh = this.mesh;
      let isNonDefaultScale = false;
      const position = manager.allocThreeVector3();
      const quaternion = manager.allocThreeQuaternion();
      const scale = manager.allocThreeVector3();
      mesh.matrixWorld.decompose(position, quaternion, scale);
      if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {
        isNonDefaultScale = true;
      }
      let parent;
      if (isNonDefaultScale) {
        parent = mesh.parent;
        if (parent !== null)
          mesh.parent = null;
        scale.copy(this.mesh.scale);
        mesh.scale.set(1, 1, 1);
        mesh.updateMatrixWorld(true);
      }
      this._updateRigidBodies();
      this._stepSimulation(delta);
      this._updateBones();
      if (isNonDefaultScale) {
        if (parent !== null)
          mesh.parent = parent;
        mesh.scale.copy(scale);
      }
      manager.freeThreeVector3(scale);
      manager.freeThreeQuaternion(quaternion);
      manager.freeThreeVector3(position);
      return this;
    },
    reset: function() {
      for (let i2 = 0, il = this.bodies.length; i2 < il; i2++) {
        this.bodies[i2].reset();
      }
      return this;
    },
    warmup: function(cycles) {
      for (let i2 = 0; i2 < cycles; i2++) {
        this.update(1 / 60);
      }
      return this;
    },
    setGravity: function(gravity) {
      this.world.setGravity(new Ammo.btVector3(gravity.x, gravity.y, gravity.z));
      this.gravity.copy(gravity);
      return this;
    },
    createHelper: function() {
      return new MMDPhysicsHelper(this.mesh, this);
    },
    _init: function(mesh, rigidBodyParams, constraintParams) {
      const manager = this.manager;
      let parent = mesh.parent;
      if (parent !== null)
        parent = null;
      const currentPosition = manager.allocThreeVector3();
      const currentQuaternion = manager.allocThreeQuaternion();
      const currentScale = manager.allocThreeVector3();
      currentPosition.copy(mesh.position);
      currentQuaternion.copy(mesh.quaternion);
      currentScale.copy(mesh.scale);
      mesh.position.set(0, 0, 0);
      mesh.quaternion.set(0, 0, 0, 1);
      mesh.scale.set(1, 1, 1);
      mesh.updateMatrixWorld(true);
      if (this.world === null) {
        this.world = this._createWorld();
        this.setGravity(this.gravity);
      }
      this._initRigidBodies(rigidBodyParams);
      this._initConstraints(constraintParams);
      if (parent !== null)
        mesh.parent = parent;
      mesh.position.copy(currentPosition);
      mesh.quaternion.copy(currentQuaternion);
      mesh.scale.copy(currentScale);
      mesh.updateMatrixWorld(true);
      this.reset();
      manager.freeThreeVector3(currentPosition);
      manager.freeThreeQuaternion(currentQuaternion);
      manager.freeThreeVector3(currentScale);
    },
    _createWorld: function() {
      const config = new Ammo.btDefaultCollisionConfiguration();
      const dispatcher = new Ammo.btCollisionDispatcher(config);
      const cache = new Ammo.btDbvtBroadphase();
      const solver = new Ammo.btSequentialImpulseConstraintSolver();
      const world2 = new Ammo.btDiscreteDynamicsWorld(dispatcher, cache, solver, config);
      return world2;
    },
    _initRigidBodies: function(rigidBodies) {
      for (let i2 = 0, il = rigidBodies.length; i2 < il; i2++) {
        this.bodies.push(new RigidBody(this.mesh, this.world, rigidBodies[i2], this.manager));
      }
    },
    _initConstraints: function(constraints) {
      for (let i2 = 0, il = constraints.length; i2 < il; i2++) {
        const params = constraints[i2];
        const bodyA = this.bodies[params.rigidBodyIndex1];
        const bodyB = this.bodies[params.rigidBodyIndex2];
        this.constraints.push(new Constraint(this.mesh, this.world, bodyA, bodyB, params, this.manager));
      }
    },
    _stepSimulation: function(delta) {
      const unitStep = this.unitStep;
      let stepTime = delta;
      let maxStepNum = (delta / unitStep | 0) + 1;
      if (stepTime < unitStep) {
        stepTime = unitStep;
        maxStepNum = 1;
      }
      if (maxStepNum > this.maxStepNum) {
        maxStepNum = this.maxStepNum;
      }
      this.world.stepSimulation(stepTime, maxStepNum, unitStep);
    },
    _updateRigidBodies: function() {
      for (let i2 = 0, il = this.bodies.length; i2 < il; i2++) {
        this.bodies[i2].updateFromBone();
      }
    },
    _updateBones: function() {
      for (let i2 = 0, il = this.bodies.length; i2 < il; i2++) {
        this.bodies[i2].updateBone();
      }
    }
  };
  function ResourceManager() {
    this.threeVector3s = [];
    this.threeMatrix4s = [];
    this.threeQuaternions = [];
    this.threeEulers = [];
    this.transforms = [];
    this.quaternions = [];
    this.vector3s = [];
  }
  ResourceManager.prototype = {
    constructor: ResourceManager,
    allocThreeVector3: function() {
      return this.threeVector3s.length > 0 ? this.threeVector3s.pop() : new Vector3();
    },
    freeThreeVector3: function(v) {
      this.threeVector3s.push(v);
    },
    allocThreeMatrix4: function() {
      return this.threeMatrix4s.length > 0 ? this.threeMatrix4s.pop() : new Matrix4();
    },
    freeThreeMatrix4: function(m) {
      this.threeMatrix4s.push(m);
    },
    allocThreeQuaternion: function() {
      return this.threeQuaternions.length > 0 ? this.threeQuaternions.pop() : new Quaternion();
    },
    freeThreeQuaternion: function(q) {
      this.threeQuaternions.push(q);
    },
    allocThreeEuler: function() {
      return this.threeEulers.length > 0 ? this.threeEulers.pop() : new Euler();
    },
    freeThreeEuler: function(e) {
      this.threeEulers.push(e);
    },
    allocTransform: function() {
      return this.transforms.length > 0 ? this.transforms.pop() : new Ammo.btTransform();
    },
    freeTransform: function(t2) {
      this.transforms.push(t2);
    },
    allocQuaternion: function() {
      return this.quaternions.length > 0 ? this.quaternions.pop() : new Ammo.btQuaternion();
    },
    freeQuaternion: function(q) {
      this.quaternions.push(q);
    },
    allocVector3: function() {
      return this.vector3s.length > 0 ? this.vector3s.pop() : new Ammo.btVector3();
    },
    freeVector3: function(v) {
      this.vector3s.push(v);
    },
    setIdentity: function(t2) {
      t2.setIdentity();
    },
    getBasis: function(t2) {
      const q = this.allocQuaternion();
      t2.getBasis().getRotation(q);
      return q;
    },
    getBasisAsMatrix3: function(t2) {
      const q = this.getBasis(t2);
      const m = this.quaternionToMatrix3(q);
      this.freeQuaternion(q);
      return m;
    },
    getOrigin: function(t2) {
      return t2.getOrigin();
    },
    setOrigin: function(t2, v) {
      t2.getOrigin().setValue(v.x(), v.y(), v.z());
    },
    copyOrigin: function(t1, t2) {
      const o = t2.getOrigin();
      this.setOrigin(t1, o);
    },
    setBasis: function(t2, q) {
      t2.setRotation(q);
    },
    setBasisFromMatrix3: function(t2, m) {
      const q = this.matrix3ToQuaternion(m);
      this.setBasis(t2, q);
      this.freeQuaternion(q);
    },
    setOriginFromArray3: function(t2, a2) {
      t2.getOrigin().setValue(a2[0], a2[1], a2[2]);
    },
    setOriginFromThreeVector3: function(t2, v) {
      t2.getOrigin().setValue(v.x, v.y, v.z);
    },
    setBasisFromArray3: function(t2, a2) {
      const thQ = this.allocThreeQuaternion();
      const thE = this.allocThreeEuler();
      thE.set(a2[0], a2[1], a2[2]);
      this.setBasisFromThreeQuaternion(t2, thQ.setFromEuler(thE));
      this.freeThreeEuler(thE);
      this.freeThreeQuaternion(thQ);
    },
    setBasisFromThreeQuaternion: function(t2, a2) {
      const q = this.allocQuaternion();
      q.setX(a2.x);
      q.setY(a2.y);
      q.setZ(a2.z);
      q.setW(a2.w);
      this.setBasis(t2, q);
      this.freeQuaternion(q);
    },
    multiplyTransforms: function(t1, t2) {
      const t3 = this.allocTransform();
      this.setIdentity(t3);
      const m1 = this.getBasisAsMatrix3(t1);
      const m2 = this.getBasisAsMatrix3(t2);
      const o1 = this.getOrigin(t1);
      const o2 = this.getOrigin(t2);
      const v12 = this.multiplyMatrix3ByVector3(m1, o2);
      const v2 = this.addVector3(v12, o1);
      this.setOrigin(t3, v2);
      const m3 = this.multiplyMatrices3(m1, m2);
      this.setBasisFromMatrix3(t3, m3);
      this.freeVector3(v12);
      this.freeVector3(v2);
      return t3;
    },
    inverseTransform: function(t2) {
      const t22 = this.allocTransform();
      const m1 = this.getBasisAsMatrix3(t2);
      const o = this.getOrigin(t2);
      const m2 = this.transposeMatrix3(m1);
      const v12 = this.negativeVector3(o);
      const v2 = this.multiplyMatrix3ByVector3(m2, v12);
      this.setOrigin(t22, v2);
      this.setBasisFromMatrix3(t22, m2);
      this.freeVector3(v12);
      this.freeVector3(v2);
      return t22;
    },
    multiplyMatrices3: function(m1, m2) {
      const m3 = [];
      const v10 = this.rowOfMatrix3(m1, 0);
      const v11 = this.rowOfMatrix3(m1, 1);
      const v12 = this.rowOfMatrix3(m1, 2);
      const v20 = this.columnOfMatrix3(m2, 0);
      const v21 = this.columnOfMatrix3(m2, 1);
      const v22 = this.columnOfMatrix3(m2, 2);
      m3[0] = this.dotVectors3(v10, v20);
      m3[1] = this.dotVectors3(v10, v21);
      m3[2] = this.dotVectors3(v10, v22);
      m3[3] = this.dotVectors3(v11, v20);
      m3[4] = this.dotVectors3(v11, v21);
      m3[5] = this.dotVectors3(v11, v22);
      m3[6] = this.dotVectors3(v12, v20);
      m3[7] = this.dotVectors3(v12, v21);
      m3[8] = this.dotVectors3(v12, v22);
      this.freeVector3(v10);
      this.freeVector3(v11);
      this.freeVector3(v12);
      this.freeVector3(v20);
      this.freeVector3(v21);
      this.freeVector3(v22);
      return m3;
    },
    addVector3: function(v12, v2) {
      const v = this.allocVector3();
      v.setValue(v12.x() + v2.x(), v12.y() + v2.y(), v12.z() + v2.z());
      return v;
    },
    dotVectors3: function(v12, v2) {
      return v12.x() * v2.x() + v12.y() * v2.y() + v12.z() * v2.z();
    },
    rowOfMatrix3: function(m, i2) {
      const v = this.allocVector3();
      v.setValue(m[i2 * 3 + 0], m[i2 * 3 + 1], m[i2 * 3 + 2]);
      return v;
    },
    columnOfMatrix3: function(m, i2) {
      const v = this.allocVector3();
      v.setValue(m[i2 + 0], m[i2 + 3], m[i2 + 6]);
      return v;
    },
    negativeVector3: function(v) {
      const v2 = this.allocVector3();
      v2.setValue(-v.x(), -v.y(), -v.z());
      return v2;
    },
    multiplyMatrix3ByVector3: function(m, v) {
      const v4 = this.allocVector3();
      const v0 = this.rowOfMatrix3(m, 0);
      const v12 = this.rowOfMatrix3(m, 1);
      const v2 = this.rowOfMatrix3(m, 2);
      const x = this.dotVectors3(v0, v);
      const y = this.dotVectors3(v12, v);
      const z = this.dotVectors3(v2, v);
      v4.setValue(x, y, z);
      this.freeVector3(v0);
      this.freeVector3(v12);
      this.freeVector3(v2);
      return v4;
    },
    transposeMatrix3: function(m) {
      const m2 = [];
      m2[0] = m[0];
      m2[1] = m[3];
      m2[2] = m[6];
      m2[3] = m[1];
      m2[4] = m[4];
      m2[5] = m[7];
      m2[6] = m[2];
      m2[7] = m[5];
      m2[8] = m[8];
      return m2;
    },
    quaternionToMatrix3: function(q) {
      const m = [];
      const x = q.x();
      const y = q.y();
      const z = q.z();
      const w = q.w();
      const xx = x * x;
      const yy = y * y;
      const zz = z * z;
      const xy = x * y;
      const yz = y * z;
      const zx = z * x;
      const xw = x * w;
      const yw = y * w;
      const zw = z * w;
      m[0] = 1 - 2 * (yy + zz);
      m[1] = 2 * (xy - zw);
      m[2] = 2 * (zx + yw);
      m[3] = 2 * (xy + zw);
      m[4] = 1 - 2 * (zz + xx);
      m[5] = 2 * (yz - xw);
      m[6] = 2 * (zx - yw);
      m[7] = 2 * (yz + xw);
      m[8] = 1 - 2 * (xx + yy);
      return m;
    },
    matrix3ToQuaternion: function(m) {
      const t2 = m[0] + m[4] + m[8];
      let s, x, y, z, w;
      if (t2 > 0) {
        s = Math.sqrt(t2 + 1) * 2;
        w = 0.25 * s;
        x = (m[7] - m[5]) / s;
        y = (m[2] - m[6]) / s;
        z = (m[3] - m[1]) / s;
      } else if (m[0] > m[4] && m[0] > m[8]) {
        s = Math.sqrt(1 + m[0] - m[4] - m[8]) * 2;
        w = (m[7] - m[5]) / s;
        x = 0.25 * s;
        y = (m[1] + m[3]) / s;
        z = (m[2] + m[6]) / s;
      } else if (m[4] > m[8]) {
        s = Math.sqrt(1 + m[4] - m[0] - m[8]) * 2;
        w = (m[2] - m[6]) / s;
        x = (m[1] + m[3]) / s;
        y = 0.25 * s;
        z = (m[5] + m[7]) / s;
      } else {
        s = Math.sqrt(1 + m[8] - m[0] - m[4]) * 2;
        w = (m[3] - m[1]) / s;
        x = (m[2] + m[6]) / s;
        y = (m[5] + m[7]) / s;
        z = 0.25 * s;
      }
      const q = this.allocQuaternion();
      q.setX(x);
      q.setY(y);
      q.setZ(z);
      q.setW(w);
      return q;
    }
  };
  function RigidBody(mesh, world2, params, manager) {
    this.mesh = mesh;
    this.world = world2;
    this.params = params;
    this.manager = manager;
    this.body = null;
    this.bone = null;
    this.boneOffsetForm = null;
    this.boneOffsetFormInverse = null;
    this._init();
  }
  RigidBody.prototype = {
    constructor: MMDPhysics2.RigidBody,
    reset: function() {
      this._setTransformFromBone();
      return this;
    },
    updateFromBone: function() {
      if (this.params.boneIndex !== -1 && this.params.type === 0) {
        this._setTransformFromBone();
      }
      return this;
    },
    updateBone: function() {
      if (this.params.type === 0 || this.params.boneIndex === -1) {
        return this;
      }
      this._updateBoneRotation();
      if (this.params.type === 1) {
        this._updateBonePosition();
      }
      this.bone.updateMatrixWorld(true);
      if (this.params.type === 2) {
        this._setPositionFromBone();
      }
      return this;
    },
    _init: function() {
      function generateShape(p) {
        switch (p.shapeType) {
          case 0:
            return new Ammo.btSphereShape(p.width);
          case 1:
            return new Ammo.btBoxShape(new Ammo.btVector3(p.width, p.height, p.depth));
          case 2:
            return new Ammo.btCapsuleShape(p.width, p.height);
          default:
            throw `unknown shape type ${p.shapeType}`;
        }
      }
      const manager = this.manager;
      const params = this.params;
      const bones = this.mesh.skeleton.bones;
      const bone = params.boneIndex === -1 ? new Bone() : bones[params.boneIndex];
      const shape = generateShape(params);
      const weight = params.type === 0 ? 0 : params.weight;
      const localInertia = manager.allocVector3();
      localInertia.setValue(0, 0, 0);
      if (weight !== 0) {
        shape.calculateLocalInertia(weight, localInertia);
      }
      const boneOffsetForm = manager.allocTransform();
      manager.setIdentity(boneOffsetForm);
      manager.setOriginFromArray3(boneOffsetForm, params.position);
      manager.setBasisFromArray3(boneOffsetForm, params.rotation);
      const vector2 = manager.allocThreeVector3();
      const boneForm = manager.allocTransform();
      manager.setIdentity(boneForm);
      manager.setOriginFromThreeVector3(boneForm, bone.getWorldPosition(vector2));
      const form = manager.multiplyTransforms(boneForm, boneOffsetForm);
      const state = new Ammo.btDefaultMotionState(form);
      const info = new Ammo.btRigidBodyConstructionInfo(weight, state, shape, localInertia);
      info.set_m_friction(params.friction);
      info.set_m_restitution(params.restitution);
      const body = new Ammo.btRigidBody(info);
      if (params.type === 0) {
        body.setCollisionFlags(body.getCollisionFlags() | 2);
        body.setActivationState(4);
      }
      body.setDamping(params.positionDamping, params.rotationDamping);
      body.setSleepingThresholds(0, 0);
      this.world.addRigidBody(body, 1 << params.groupIndex, params.groupTarget);
      this.body = body;
      this.bone = bone;
      this.boneOffsetForm = boneOffsetForm;
      this.boneOffsetFormInverse = manager.inverseTransform(boneOffsetForm);
      manager.freeVector3(localInertia);
      manager.freeTransform(form);
      manager.freeTransform(boneForm);
      manager.freeThreeVector3(vector2);
    },
    _getBoneTransform: function() {
      const manager = this.manager;
      const p = manager.allocThreeVector3();
      const q = manager.allocThreeQuaternion();
      const s = manager.allocThreeVector3();
      this.bone.matrixWorld.decompose(p, q, s);
      const tr = manager.allocTransform();
      manager.setOriginFromThreeVector3(tr, p);
      manager.setBasisFromThreeQuaternion(tr, q);
      const form = manager.multiplyTransforms(tr, this.boneOffsetForm);
      manager.freeTransform(tr);
      manager.freeThreeVector3(s);
      manager.freeThreeQuaternion(q);
      manager.freeThreeVector3(p);
      return form;
    },
    _getWorldTransformForBone: function() {
      const manager = this.manager;
      const tr = this.body.getCenterOfMassTransform();
      return manager.multiplyTransforms(tr, this.boneOffsetFormInverse);
    },
    _setTransformFromBone: function() {
      const manager = this.manager;
      const form = this._getBoneTransform();
      this.body.setCenterOfMassTransform(form);
      this.body.getMotionState().setWorldTransform(form);
      manager.freeTransform(form);
    },
    _setPositionFromBone: function() {
      const manager = this.manager;
      const form = this._getBoneTransform();
      const tr = manager.allocTransform();
      this.body.getMotionState().getWorldTransform(tr);
      manager.copyOrigin(tr, form);
      this.body.setCenterOfMassTransform(tr);
      this.body.getMotionState().setWorldTransform(tr);
      manager.freeTransform(tr);
      manager.freeTransform(form);
    },
    _updateBoneRotation: function() {
      const manager = this.manager;
      const tr = this._getWorldTransformForBone();
      const q = manager.getBasis(tr);
      const thQ = manager.allocThreeQuaternion();
      const thQ2 = manager.allocThreeQuaternion();
      const thQ3 = manager.allocThreeQuaternion();
      thQ.set(q.x(), q.y(), q.z(), q.w());
      thQ2.setFromRotationMatrix(this.bone.matrixWorld);
      thQ2.conjugate();
      thQ2.multiply(thQ);
      thQ3.setFromRotationMatrix(this.bone.matrix);
      this.bone.quaternion.copy(thQ2.multiply(thQ3).normalize());
      manager.freeThreeQuaternion(thQ);
      manager.freeThreeQuaternion(thQ2);
      manager.freeThreeQuaternion(thQ3);
      manager.freeQuaternion(q);
      manager.freeTransform(tr);
    },
    _updateBonePosition: function() {
      const manager = this.manager;
      const tr = this._getWorldTransformForBone();
      const thV = manager.allocThreeVector3();
      const o = manager.getOrigin(tr);
      thV.set(o.x(), o.y(), o.z());
      if (this.bone.parent) {
        this.bone.parent.worldToLocal(thV);
      }
      this.bone.position.copy(thV);
      manager.freeThreeVector3(thV);
      manager.freeTransform(tr);
    }
  };
  function Constraint(mesh, world2, bodyA, bodyB, params, manager) {
    this.mesh = mesh;
    this.world = world2;
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.params = params;
    this.manager = manager;
    this.constraint = null;
    this._init();
  }
  Constraint.prototype = {
    constructor: Constraint,
    _init: function() {
      const manager = this.manager;
      const params = this.params;
      const bodyA = this.bodyA;
      const bodyB = this.bodyB;
      const form = manager.allocTransform();
      manager.setIdentity(form);
      manager.setOriginFromArray3(form, params.position);
      manager.setBasisFromArray3(form, params.rotation);
      const formA = manager.allocTransform();
      const formB = manager.allocTransform();
      bodyA.body.getMotionState().getWorldTransform(formA);
      bodyB.body.getMotionState().getWorldTransform(formB);
      const formInverseA = manager.inverseTransform(formA);
      const formInverseB = manager.inverseTransform(formB);
      const formA2 = manager.multiplyTransforms(formInverseA, form);
      const formB2 = manager.multiplyTransforms(formInverseB, form);
      const constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA.body, bodyB.body, formA2, formB2, true);
      const lll = manager.allocVector3();
      const lul = manager.allocVector3();
      const all = manager.allocVector3();
      const aul = manager.allocVector3();
      lll.setValue(params.translationLimitation1[0], params.translationLimitation1[1], params.translationLimitation1[2]);
      lul.setValue(params.translationLimitation2[0], params.translationLimitation2[1], params.translationLimitation2[2]);
      all.setValue(params.rotationLimitation1[0], params.rotationLimitation1[1], params.rotationLimitation1[2]);
      aul.setValue(params.rotationLimitation2[0], params.rotationLimitation2[1], params.rotationLimitation2[2]);
      constraint.setLinearLowerLimit(lll);
      constraint.setLinearUpperLimit(lul);
      constraint.setAngularLowerLimit(all);
      constraint.setAngularUpperLimit(aul);
      for (let i2 = 0; i2 < 3; i2++) {
        if (params.springPosition[i2] !== 0) {
          constraint.enableSpring(i2, true);
          constraint.setStiffness(i2, params.springPosition[i2]);
        }
      }
      for (let i2 = 0; i2 < 3; i2++) {
        if (params.springRotation[i2] !== 0) {
          constraint.enableSpring(i2 + 3, true);
          constraint.setStiffness(i2 + 3, params.springRotation[i2]);
        }
      }
      if (constraint.setParam !== void 0) {
        for (let i2 = 0; i2 < 6; i2++) {
          constraint.setParam(2, 0.475, i2);
        }
      }
      this.world.addConstraint(constraint, true);
      this.constraint = constraint;
      manager.freeTransform(form);
      manager.freeTransform(formA);
      manager.freeTransform(formB);
      manager.freeTransform(formInverseA);
      manager.freeTransform(formInverseB);
      manager.freeTransform(formA2);
      manager.freeTransform(formB2);
      manager.freeVector3(lll);
      manager.freeVector3(lul);
      manager.freeVector3(all);
      manager.freeVector3(aul);
    }
  };
  function MMDPhysicsHelper(mesh, physics) {
    Object3D.call(this);
    this.root = mesh;
    this.physics = physics;
    this.matrix.copy(mesh.matrixWorld);
    this.matrixAutoUpdate = false;
    this.materials = [];
    this.materials.push(new MeshBasicMaterial({
      color: new Color(16746632),
      wireframe: true,
      depthTest: false,
      depthWrite: false,
      opacity: 0.25,
      transparent: true
    }));
    this.materials.push(new MeshBasicMaterial({
      color: new Color(8978312),
      wireframe: true,
      depthTest: false,
      depthWrite: false,
      opacity: 0.25,
      transparent: true
    }));
    this.materials.push(new MeshBasicMaterial({
      color: new Color(8947967),
      wireframe: true,
      depthTest: false,
      depthWrite: false,
      opacity: 0.25,
      transparent: true
    }));
    this._init();
  }
  MMDPhysicsHelper.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: MMDPhysicsHelper,
    updateMatrixWorld: (() => {
      const position = new Vector3();
      const quaternion = new Quaternion();
      const scale = new Vector3();
      const matrixWorldInv = new Matrix4();
      return function updateMatrixWorld(force) {
        const mesh = this.root;
        if (this.visible) {
          const bodies = this.physics.bodies;
          matrixWorldInv.copy(mesh.matrixWorld).decompose(position, quaternion, scale).compose(position, quaternion, scale.set(1, 1, 1)).invert();
          for (let i2 = 0, il = bodies.length; i2 < il; i2++) {
            const body = bodies[i2].body;
            const child = this.children[i2];
            const tr = body.getCenterOfMassTransform();
            const origin = tr.getOrigin();
            const rotation = tr.getRotation();
            child.position.set(origin.x(), origin.y(), origin.z()).applyMatrix4(matrixWorldInv);
            child.quaternion.setFromRotationMatrix(matrixWorldInv).multiply(quaternion.set(rotation.x(), rotation.y(), rotation.z(), rotation.w()));
          }
        }
        this.matrix.copy(mesh.matrixWorld).decompose(position, quaternion, scale).compose(position, quaternion, scale.set(1, 1, 1));
        Object3D.prototype.updateMatrixWorld.call(this, force);
      };
    })(),
    _init: function() {
      const bodies = this.physics.bodies;
      function createGeometry(param) {
        switch (param.shapeType) {
          case 0:
            return new SphereGeometry(param.width, 16, 8);
          case 1:
            return new BoxGeometry(param.width * 2, param.height * 2, param.depth * 2, 8, 8, 8);
          case 2:
            return new createCapsuleGeometry(param.width, param.height, 16, 8);
          default:
            return null;
        }
      }
      function createCapsuleGeometry(radius, cylinderHeight, segmentsRadius, segmentsHeight) {
        const geometry = new CylinderGeometry(radius, radius, cylinderHeight, segmentsRadius, segmentsHeight, true);
        const upperSphere = new Mesh(new SphereGeometry(radius, segmentsRadius, segmentsHeight, 0, Math.PI * 2, 0, Math.PI / 2));
        const lowerSphere = new Mesh(new SphereGeometry(radius, segmentsRadius, segmentsHeight, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2));
        upperSphere.position.set(0, cylinderHeight / 2, 0);
        lowerSphere.position.set(0, -cylinderHeight / 2, 0);
        upperSphere.updateMatrix();
        lowerSphere.updateMatrix();
        geometry.merge(upperSphere.geometry, upperSphere.matrix);
        geometry.merge(lowerSphere.geometry, lowerSphere.matrix);
        return geometry;
      }
      for (let i2 = 0, il = bodies.length; i2 < il; i2++) {
        const param = bodies[i2].params;
        this.add(new Mesh(createGeometry(param), this.materials[param.type]));
      }
    }
  });
  return MMDPhysics2;
})();

// node_modules/three-stdlib/animation/MMDAnimationHelper.js
var MMDAnimationHelper = (() => {
  function MMDAnimationHelper2(params) {
    params = params || {};
    this.meshes = [];
    this.camera = null;
    this.cameraTarget = new Object3D();
    this.cameraTarget.name = "target";
    this.audio = null;
    this.audioManager = null;
    this.objects = /* @__PURE__ */ new WeakMap();
    this.configuration = {
      sync: params.sync !== void 0 ? params.sync : true,
      afterglow: params.afterglow !== void 0 ? params.afterglow : 0,
      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== void 0 ? params.resetPhysicsOnLoop : true
    };
    this.enabled = {
      animation: true,
      ik: true,
      grant: true,
      physics: true,
      cameraAnimation: true
    };
    this.onBeforePhysics = () => {
    };
    this.sharedPhysics = false;
    this.masterPhysics = null;
  }
  MMDAnimationHelper2.prototype = {
    constructor: MMDAnimationHelper2,
    add: function(object, params) {
      params = params || {};
      if (object.isSkinnedMesh) {
        this._addMesh(object, params);
      } else if (object.isCamera) {
        this._setupCamera(object, params);
      } else if (object.type === "Audio") {
        this._setupAudio(object, params);
      } else {
        throw new Error("THREE.MMDAnimationHelper.add: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.");
      }
      if (this.configuration.sync)
        this._syncDuration();
      return this;
    },
    remove: function(object) {
      if (object.isSkinnedMesh) {
        this._removeMesh(object);
      } else if (object.isCamera) {
        this._clearCamera(object);
      } else if (object.type === "Audio") {
        this._clearAudio(object);
      } else {
        throw new Error("THREE.MMDAnimationHelper.remove: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.");
      }
      if (this.configuration.sync)
        this._syncDuration();
      return this;
    },
    update: function(delta) {
      if (this.audioManager !== null)
        this.audioManager.control(delta);
      for (let i2 = 0; i2 < this.meshes.length; i2++) {
        this._animateMesh(this.meshes[i2], delta);
      }
      if (this.sharedPhysics)
        this._updateSharedPhysics(delta);
      if (this.camera !== null)
        this._animateCamera(this.camera, delta);
      return this;
    },
    pose: function(mesh, vpd, params) {
      params = params || {};
      if (params.resetPose !== false)
        mesh.pose();
      const bones = mesh.skeleton.bones;
      const boneParams = vpd.bones;
      const boneNameDictionary = {};
      for (let i2 = 0, il = bones.length; i2 < il; i2++) {
        boneNameDictionary[bones[i2].name] = i2;
      }
      const vector2 = new Vector3();
      const quaternion = new Quaternion();
      for (let i2 = 0, il = boneParams.length; i2 < il; i2++) {
        const boneParam = boneParams[i2];
        const boneIndex = boneNameDictionary[boneParam.name];
        if (boneIndex === void 0)
          continue;
        const bone = bones[boneIndex];
        bone.position.add(vector2.fromArray(boneParam.translation));
        bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));
      }
      mesh.updateMatrixWorld(true);
      if (params.ik !== false) {
        this._createCCDIKSolver(mesh).update(params.saveOriginalBonesBeforeIK);
      }
      if (params.grant !== false) {
        this.createGrantSolver(mesh).update();
      }
      return this;
    },
    enable: function(key, enabled) {
      if (this.enabled[key] === void 0) {
        throw new Error(`THREE.MMDAnimationHelper.enable: unknown key ${key}`);
      }
      this.enabled[key] = enabled;
      if (key === "physics") {
        for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
          this._optimizeIK(this.meshes[i2], enabled);
        }
      }
      return this;
    },
    createGrantSolver: function(mesh) {
      return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);
    },
    _addMesh: function(mesh, params) {
      if (this.meshes.indexOf(mesh) >= 0) {
        throw new Error(`THREE.MMDAnimationHelper._addMesh: SkinnedMesh '${mesh.name}' has already been added.`);
      }
      this.meshes.push(mesh);
      this.objects.set(mesh, {
        looped: false
      });
      this._setupMeshAnimation(mesh, params.animation);
      if (params.physics !== false) {
        this._setupMeshPhysics(mesh, params);
      }
      return this;
    },
    _setupCamera: function(camera, params) {
      if (this.camera === camera) {
        throw new Error(`THREE.MMDAnimationHelper._setupCamera: Camera '${camera.name}' has already been set.`);
      }
      if (this.camera)
        this.clearCamera(this.camera);
      this.camera = camera;
      camera.add(this.cameraTarget);
      this.objects.set(camera, {});
      if (params.animation !== void 0) {
        this._setupCameraAnimation(camera, params.animation);
      }
      return this;
    },
    _setupAudio: function(audio, params) {
      if (this.audio === audio) {
        throw new Error(`THREE.MMDAnimationHelper._setupAudio: Audio '${audio.name}' has already been set.`);
      }
      if (this.audio)
        this.clearAudio(this.audio);
      this.audio = audio;
      this.audioManager = new AudioManager(audio, params);
      this.objects.set(this.audioManager, {
        duration: this.audioManager.duration
      });
      return this;
    },
    _removeMesh: function(mesh) {
      let found = false;
      let writeIndex = 0;
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        if (this.meshes[i2] === mesh) {
          this.objects.delete(mesh);
          found = true;
          continue;
        }
        this.meshes[writeIndex++] = this.meshes[i2];
      }
      if (!found) {
        throw new Error(`THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '${mesh.name}' has not been added yet.`);
      }
      this.meshes.length = writeIndex;
      return this;
    },
    _clearCamera: function(camera) {
      if (camera !== this.camera) {
        throw new Error(`THREE.MMDAnimationHelper._clearCamera: Camera '${camera.name}' has not been set yet.`);
      }
      this.camera.remove(this.cameraTarget);
      this.objects.delete(this.camera);
      this.camera = null;
      return this;
    },
    _clearAudio: function(audio) {
      if (audio !== this.audio) {
        throw new Error(`THREE.MMDAnimationHelper._clearAudio: Audio '${audio.name}' has not been set yet.`);
      }
      this.objects.delete(this.audioManager);
      this.audio = null;
      this.audioManager = null;
      return this;
    },
    _setupMeshAnimation: function(mesh, animation) {
      const objects = this.objects.get(mesh);
      if (animation !== void 0) {
        const animations = Array.isArray(animation) ? animation : [animation];
        objects.mixer = new AnimationMixer(mesh);
        for (let i2 = 0, il = animations.length; i2 < il; i2++) {
          objects.mixer.clipAction(animations[i2]).play();
        }
        objects.mixer.addEventListener("loop", (event) => {
          const tracks = event.action._clip.tracks;
          if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== ".bones")
            return;
          objects.looped = true;
        });
      }
      objects.ikSolver = this._createCCDIKSolver(mesh);
      objects.grantSolver = this.createGrantSolver(mesh);
      return this;
    },
    _setupCameraAnimation: function(camera, animation) {
      const animations = Array.isArray(animation) ? animation : [animation];
      const objects = this.objects.get(camera);
      objects.mixer = new AnimationMixer(camera);
      for (let i2 = 0, il = animations.length; i2 < il; i2++) {
        objects.mixer.clipAction(animations[i2]).play();
      }
    },
    _setupMeshPhysics: function(mesh, params) {
      const objects = this.objects.get(mesh);
      if (params.world === void 0 && this.sharedPhysics) {
        const masterPhysics = this._getMasterPhysics();
        if (masterPhysics !== null)
          world = masterPhysics.world;
      }
      objects.physics = this._createMMDPhysics(mesh, params);
      if (objects.mixer && params.animationWarmup !== false) {
        this._animateMesh(mesh, 0);
        objects.physics.reset();
      }
      objects.physics.warmup(params.warmup !== void 0 ? params.warmup : 60);
      this._optimizeIK(mesh, true);
    },
    _animateMesh: function(mesh, delta) {
      const objects = this.objects.get(mesh);
      const mixer = objects.mixer;
      const ikSolver = objects.ikSolver;
      const grantSolver = objects.grantSolver;
      const physics = objects.physics;
      const looped = objects.looped;
      if (mixer && this.enabled.animation) {
        this._restoreBones(mesh);
        mixer.update(delta);
        this._saveBones(mesh);
        if (ikSolver && this.enabled.ik) {
          mesh.updateMatrixWorld(true);
          ikSolver.update();
        }
        if (grantSolver && this.enabled.grant) {
          grantSolver.update();
        }
      }
      if (looped === true && this.enabled.physics) {
        if (physics && this.configuration.resetPhysicsOnLoop)
          physics.reset();
        objects.looped = false;
      }
      if (physics && this.enabled.physics && !this.sharedPhysics) {
        this.onBeforePhysics(mesh);
        physics.update(delta);
      }
    },
    _animateCamera: function(camera, delta) {
      const mixer = this.objects.get(camera).mixer;
      if (mixer && this.enabled.cameraAnimation) {
        mixer.update(delta);
        camera.updateProjectionMatrix();
        camera.up.set(0, 1, 0);
        camera.up.applyQuaternion(camera.quaternion);
        camera.lookAt(this.cameraTarget.position);
      }
    },
    _optimizeIK: function(mesh, physicsEnabled) {
      const iks = mesh.geometry.userData.MMD.iks;
      const bones = mesh.geometry.userData.MMD.bones;
      for (let i2 = 0, il = iks.length; i2 < il; i2++) {
        const ik = iks[i2];
        const links = ik.links;
        for (let j2 = 0, jl2 = links.length; j2 < jl2; j2++) {
          const link = links[j2];
          if (physicsEnabled === true) {
            link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;
          } else {
            link.enabled = true;
          }
        }
      }
    },
    _createCCDIKSolver: function(mesh) {
      if (CCDIKSolver === void 0) {
        throw new Error("THREE.MMDAnimationHelper: Import CCDIKSolver.");
      }
      return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);
    },
    _createMMDPhysics: function(mesh, params) {
      if (MMDPhysics === void 0) {
        throw new Error("THREE.MMDPhysics: Import MMDPhysics.");
      }
      return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);
    },
    _syncDuration: function() {
      let max3 = 0;
      const objects = this.objects;
      const meshes = this.meshes;
      const camera = this.camera;
      const audioManager = this.audioManager;
      for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
        var mixer = this.objects.get(meshes[i2]).mixer;
        if (mixer === void 0)
          continue;
        for (let j2 = 0; j2 < mixer._actions.length; j2++) {
          var clip = mixer._actions[j2]._clip;
          if (!objects.has(clip)) {
            objects.set(clip, {
              duration: clip.duration
            });
          }
          max3 = Math.max(max3, objects.get(clip).duration);
        }
      }
      if (camera !== null) {
        var mixer = this.objects.get(camera).mixer;
        if (mixer !== void 0) {
          for (let i2 = 0, il = mixer._actions.length; i2 < il; i2++) {
            var clip = mixer._actions[i2]._clip;
            if (!objects.has(clip)) {
              objects.set(clip, {
                duration: clip.duration
              });
            }
            max3 = Math.max(max3, objects.get(clip).duration);
          }
        }
      }
      if (audioManager !== null) {
        max3 = Math.max(max3, objects.get(audioManager).duration);
      }
      max3 += this.configuration.afterglow;
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        var mixer = this.objects.get(this.meshes[i2]).mixer;
        if (mixer === void 0)
          continue;
        for (let j2 = 0, jl2 = mixer._actions.length; j2 < jl2; j2++) {
          mixer._actions[j2]._clip.duration = max3;
        }
      }
      if (camera !== null) {
        var mixer = this.objects.get(camera).mixer;
        if (mixer !== void 0) {
          for (let i2 = 0, il = mixer._actions.length; i2 < il; i2++) {
            mixer._actions[i2]._clip.duration = max3;
          }
        }
      }
      if (audioManager !== null) {
        audioManager.duration = max3;
      }
    },
    _updatePropertyMixersBuffer: function(mesh) {
      const mixer = this.objects.get(mesh).mixer;
      const propertyMixers = mixer._bindings;
      const accuIndex = mixer._accuIndex;
      for (let i2 = 0, il = propertyMixers.length; i2 < il; i2++) {
        const propertyMixer = propertyMixers[i2];
        const buffer2 = propertyMixer.buffer;
        const stride = propertyMixer.valueSize;
        const offset = (accuIndex + 1) * stride;
        propertyMixer.binding.getValue(buffer2, offset);
      }
    },
    _saveBones: function(mesh) {
      const objects = this.objects.get(mesh);
      const bones = mesh.skeleton.bones;
      let backupBones = objects.backupBones;
      if (backupBones === void 0) {
        backupBones = new Float32Array(bones.length * 7);
        objects.backupBones = backupBones;
      }
      for (let i2 = 0, il = bones.length; i2 < il; i2++) {
        const bone = bones[i2];
        bone.position.toArray(backupBones, i2 * 7);
        bone.quaternion.toArray(backupBones, i2 * 7 + 3);
      }
    },
    _restoreBones: function(mesh) {
      const objects = this.objects.get(mesh);
      const backupBones = objects.backupBones;
      if (backupBones === void 0)
        return;
      const bones = mesh.skeleton.bones;
      for (let i2 = 0, il = bones.length; i2 < il; i2++) {
        const bone = bones[i2];
        bone.position.fromArray(backupBones, i2 * 7);
        bone.quaternion.fromArray(backupBones, i2 * 7 + 3);
      }
    },
    _getMasterPhysics: function() {
      if (this.masterPhysics !== null)
        return this.masterPhysics;
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        const physics = this.meshes[i2].physics;
        if (physics !== void 0 && physics !== null) {
          this.masterPhysics = physics;
          return this.masterPhysics;
        }
      }
      return null;
    },
    _updateSharedPhysics: function(delta) {
      if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics)
        return;
      const physics = this._getMasterPhysics();
      if (physics === null)
        return;
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        var p = this.meshes[i2].physics;
        if (p !== null && p !== void 0) {
          p.updateRigidBodies();
        }
      }
      physics.stepSimulation(delta);
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        var p = this.meshes[i2].physics;
        if (p !== null && p !== void 0) {
          p.updateBones();
        }
      }
    }
  };
  function AudioManager(audio, params) {
    params = params || {};
    this.audio = audio;
    this.elapsedTime = 0;
    this.currentTime = 0;
    this.delayTime = params.delayTime !== void 0 ? params.delayTime : 0;
    this.audioDuration = this.audio.buffer.duration;
    this.duration = this.audioDuration + this.delayTime;
  }
  AudioManager.prototype = {
    constructor: AudioManager,
    control: function(delta) {
      this.elapsed += delta;
      this.currentTime += delta;
      if (this._shouldStopAudio())
        this.audio.stop();
      if (this._shouldStartAudio())
        this.audio.play();
      return this;
    },
    _shouldStartAudio: function() {
      if (this.audio.isPlaying)
        return false;
      while (this.currentTime >= this.duration) {
        this.currentTime -= this.duration;
      }
      if (this.currentTime < this.delayTime)
        return false;
      if (this.currentTime - this.delayTime > this.audioDuration)
        return false;
      return true;
    },
    _shouldStopAudio: function() {
      return this.audio.isPlaying && this.currentTime >= this.duration;
    }
  };
  function GrantSolver(mesh, grants) {
    this.mesh = mesh;
    this.grants = grants || [];
  }
  GrantSolver.prototype = {
    constructor: GrantSolver,
    update: (() => {
      const quaternion = new Quaternion();
      return function() {
        const bones = this.mesh.skeleton.bones;
        const grants = this.grants;
        for (let i2 = 0, il = grants.length; i2 < il; i2++) {
          const grant = grants[i2];
          const bone = bones[grant.index];
          const parentBone = bones[grant.parentIndex];
          if (grant.isLocal) {
            if (grant.affectPosition)
              ;
            if (grant.affectRotation)
              ;
          } else {
            if (grant.affectPosition)
              ;
            if (grant.affectRotation) {
              quaternion.set(0, 0, 0, 1);
              quaternion.slerp(parentBone.quaternion, grant.ratio);
              bone.quaternion.multiply(quaternion);
            }
          }
        }
        return this;
      };
    })()
  };
  return MMDAnimationHelper2;
})();

// node_modules/three-stdlib/objects/Reflector.js
var Reflector = class extends Mesh {
  constructor(geometry, options = {}) {
    super(geometry);
    this.type = "Reflector";
    const scope2 = this;
    const color2 = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const shader = options.shader || Reflector.ReflectorShader;
    const reflectorPlane = new Plane();
    const normal = new Vector3();
    const reflectorWorldPosition = new Vector3();
    const cameraWorldPosition = new Vector3();
    const rotationMatrix2 = new Matrix4();
    const lookAtPosition = new Vector3(0, 0, -1);
    const clipPlane = new Vector4();
    const view = new Vector3();
    const target = new Vector3();
    const q = new Vector4();
    const textureMatrix = new Matrix4();
    const virtualCamera = new PerspectiveCamera();
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);
    const material = new ShaderMaterial({
      uniforms: UniformsUtils.clone(shader.uniforms),
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader
    });
    material.uniforms["tDiffuse"].value = renderTarget.texture;
    material.uniforms["color"].value = color2;
    material.uniforms["textureMatrix"].value = textureMatrix;
    this.material = material;
    this.onBeforeRender = function(renderer, scene, camera) {
      reflectorWorldPosition.setFromMatrixPosition(scope2.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix2.extractRotation(scope2.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix2);
      view.subVectors(reflectorWorldPosition, cameraWorldPosition);
      if (view.dot(normal) > 0)
        return;
      view.reflect(normal).negate();
      view.add(reflectorWorldPosition);
      rotationMatrix2.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, -1);
      lookAtPosition.applyMatrix4(rotationMatrix2);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(reflectorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(reflectorWorldPosition);
      virtualCamera.position.copy(view);
      virtualCamera.up.set(0, 1, 0);
      virtualCamera.up.applyMatrix4(rotationMatrix2);
      virtualCamera.up.reflect(normal);
      virtualCamera.lookAt(target);
      virtualCamera.far = camera.far;
      virtualCamera.updateMatrixWorld();
      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(virtualCamera.projectionMatrix);
      textureMatrix.multiply(virtualCamera.matrixWorldInverse);
      textureMatrix.multiply(scope2.matrixWorld);
      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
      const projectionMatrix = virtualCamera.projectionMatrix;
      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
      q.z = -1;
      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
      clipPlane.multiplyScalar(2 / clipPlane.dot(q));
      projectionMatrix.elements[2] = clipPlane.x;
      projectionMatrix.elements[6] = clipPlane.y;
      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;
      projectionMatrix.elements[14] = clipPlane.w;
      renderTarget.texture.encoding = renderer.outputEncoding;
      scope2.visible = false;
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.setRenderTarget(renderTarget);
      renderer.state.buffers.depth.setMask(true);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
      scope2.visible = true;
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
    this.dispose = function() {
      renderTarget.dispose();
      scope2.material.dispose();
    };
  }
};
Reflector.prototype.isReflector = true;
Reflector.ReflectorShader = {
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`,
  fragmentShader: `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

		}`
};

// node_modules/three-stdlib/objects/Refractor.js
var Refractor = class extends Mesh {
  constructor(geometry, options = {}) {
    super(geometry);
    this.type = "Refractor";
    const scope2 = this;
    const color2 = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const shader = options.shader || Refractor.RefractorShader;
    const virtualCamera = new PerspectiveCamera();
    virtualCamera.matrixAutoUpdate = false;
    virtualCamera.userData.refractor = true;
    const refractorPlane = new Plane();
    const textureMatrix = new Matrix4();
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);
    this.material = new ShaderMaterial({
      uniforms: UniformsUtils.clone(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      transparent: true
    });
    this.material.uniforms["color"].value = color2;
    this.material.uniforms["tDiffuse"].value = renderTarget.texture;
    this.material.uniforms["textureMatrix"].value = textureMatrix;
    const visible = function() {
      const refractorWorldPosition = new Vector3();
      const cameraWorldPosition = new Vector3();
      const rotationMatrix2 = new Matrix4();
      const view = new Vector3();
      const normal = new Vector3();
      return function visible2(camera) {
        refractorWorldPosition.setFromMatrixPosition(scope2.matrixWorld);
        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
        view.subVectors(refractorWorldPosition, cameraWorldPosition);
        rotationMatrix2.extractRotation(scope2.matrixWorld);
        normal.set(0, 0, 1);
        normal.applyMatrix4(rotationMatrix2);
        return view.dot(normal) < 0;
      };
    }();
    const updateRefractorPlane = function() {
      const normal = new Vector3();
      const position = new Vector3();
      const quaternion = new Quaternion();
      const scale = new Vector3();
      return function updateRefractorPlane2() {
        scope2.matrixWorld.decompose(position, quaternion, scale);
        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();
        normal.negate();
        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);
      };
    }();
    const updateVirtualCamera = function() {
      const clipPlane = new Plane();
      const clipVector = new Vector4();
      const q = new Vector4();
      return function updateVirtualCamera2(camera) {
        virtualCamera.matrixWorld.copy(camera.matrixWorld);
        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();
        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
        virtualCamera.far = camera.far;
        clipPlane.copy(refractorPlane);
        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);
        const projectionMatrix = virtualCamera.projectionMatrix;
        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
        q.z = -1;
        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
        clipVector.multiplyScalar(2 / clipVector.dot(q));
        projectionMatrix.elements[2] = clipVector.x;
        projectionMatrix.elements[6] = clipVector.y;
        projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;
        projectionMatrix.elements[14] = clipVector.w;
      };
    }();
    function updateTextureMatrix(camera) {
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(camera.projectionMatrix);
      textureMatrix.multiply(camera.matrixWorldInverse);
      textureMatrix.multiply(scope2.matrixWorld);
    }
    function render(renderer, scene, camera) {
      scope2.visible = false;
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.setRenderTarget(renderTarget);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
      scope2.visible = true;
    }
    this.onBeforeRender = function(renderer, scene, camera) {
      renderTarget.texture.encoding = renderer.outputEncoding;
      if (camera.userData.refractor === true)
        return;
      if (!visible(camera) === true)
        return;
      updateRefractorPlane();
      updateTextureMatrix(camera);
      updateVirtualCamera(camera);
      render(renderer, scene, camera);
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
    this.dispose = function() {
      renderTarget.dispose();
      scope2.material.dispose();
    };
  }
};
Refractor.prototype.isRefractor = true;
Refractor.RefractorShader = {
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: `

		uniform mat4 textureMatrix;

		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec4 vUv;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

		}`
};

// node_modules/three-stdlib/objects/ShadowMesh.js
var _shadowMatrix = new Matrix4();
var ShadowMesh = class extends Mesh {
  constructor(mesh) {
    const shadowMaterial = new MeshBasicMaterial({
      color: 0,
      transparent: true,
      opacity: 0.6,
      depthWrite: false
    });
    super(mesh.geometry, shadowMaterial);
    this.meshMatrix = mesh.matrixWorld;
    this.frustumCulled = false;
    this.matrixAutoUpdate = false;
  }
  update(plane, lightPosition4D) {
    const dot2 = plane.normal.x * lightPosition4D.x + plane.normal.y * lightPosition4D.y + plane.normal.z * lightPosition4D.z + -plane.constant * lightPosition4D.w;
    const sme = _shadowMatrix.elements;
    sme[0] = dot2 - lightPosition4D.x * plane.normal.x;
    sme[4] = -lightPosition4D.x * plane.normal.y;
    sme[8] = -lightPosition4D.x * plane.normal.z;
    sme[12] = -lightPosition4D.x * -plane.constant;
    sme[1] = -lightPosition4D.y * plane.normal.x;
    sme[5] = dot2 - lightPosition4D.y * plane.normal.y;
    sme[9] = -lightPosition4D.y * plane.normal.z;
    sme[13] = -lightPosition4D.y * -plane.constant;
    sme[2] = -lightPosition4D.z * plane.normal.x;
    sme[6] = -lightPosition4D.z * plane.normal.y;
    sme[10] = dot2 - lightPosition4D.z * plane.normal.z;
    sme[14] = -lightPosition4D.z * -plane.constant;
    sme[3] = -lightPosition4D.w * plane.normal.x;
    sme[7] = -lightPosition4D.w * plane.normal.y;
    sme[11] = -lightPosition4D.w * plane.normal.z;
    sme[15] = dot2 - lightPosition4D.w * -plane.constant;
    this.matrix.multiplyMatrices(_shadowMatrix, this.meshMatrix);
  }
};
ShadowMesh.prototype.isShadowMesh = true;

// node_modules/three-stdlib/objects/Lensflare.js
var Lensflare = class extends Mesh {
  constructor() {
    super(Lensflare.Geometry, new MeshBasicMaterial({
      opacity: 0,
      transparent: true
    }));
    this.type = "Lensflare";
    this.frustumCulled = false;
    this.renderOrder = Infinity;
    const positionScreen = new Vector3();
    const positionView2 = new Vector3();
    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);
    tempMap.minFilter = NearestFilter;
    tempMap.magFilter = NearestFilter;
    tempMap.wrapS = ClampToEdgeWrapping;
    tempMap.wrapT = ClampToEdgeWrapping;
    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);
    occlusionMap.minFilter = NearestFilter;
    occlusionMap.magFilter = NearestFilter;
    occlusionMap.wrapS = ClampToEdgeWrapping;
    occlusionMap.wrapT = ClampToEdgeWrapping;
    const geometry = Lensflare.Geometry;
    const material1a = new RawShaderMaterial({
      uniforms: {
        scale: {
          value: null
        },
        screenPosition: {
          value: null
        }
      },
      vertexShader: `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;

				void main() {

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`,
      fragmentShader: `

				precision highp float;

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

				}`,
      depthTest: true,
      depthWrite: false,
      transparent: false
    });
    const material1b = new RawShaderMaterial({
      uniforms: {
        map: {
          value: tempMap
        },
        scale: {
          value: null
        },
        screenPosition: {
          value: null
        }
      },
      vertexShader: `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUV;

				void main() {

					vUV = uv;

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`,
      fragmentShader: `

				precision highp float;

				uniform sampler2D map;

				varying vec2 vUV;

				void main() {

					gl_FragColor = texture2D( map, vUV );

				}`,
      depthTest: false,
      depthWrite: false,
      transparent: false
    });
    const mesh1 = new Mesh(geometry, material1a);
    const elements = [];
    const shader = LensflareElement.Shader;
    const material2 = new RawShaderMaterial({
      uniforms: {
        map: {
          value: null
        },
        occlusionMap: {
          value: occlusionMap
        },
        color: {
          value: new Color(16777215)
        },
        scale: {
          value: new Vector2()
        },
        screenPosition: {
          value: new Vector3()
        }
      },
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      blending: AdditiveBlending,
      transparent: true,
      depthWrite: false
    });
    const mesh2 = new Mesh(geometry, material2);
    this.addElement = function(element2) {
      elements.push(element2);
    };
    const scale = new Vector2();
    const screenPositionPixels = new Vector2();
    const validArea = new Box2();
    const viewport = new Vector4();
    this.onBeforeRender = function(renderer, scene, camera) {
      renderer.getCurrentViewport(viewport);
      const invAspect = viewport.w / viewport.z;
      const halfViewportWidth = viewport.z / 2;
      const halfViewportHeight = viewport.w / 2;
      let size2 = 16 / viewport.w;
      scale.set(size2 * invAspect, size2);
      validArea.min.set(viewport.x, viewport.y);
      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));
      positionView2.setFromMatrixPosition(this.matrixWorld);
      positionView2.applyMatrix4(camera.matrixWorldInverse);
      if (positionView2.z > 0)
        return;
      positionScreen.copy(positionView2).applyMatrix4(camera.projectionMatrix);
      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;
      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8;
      if (validArea.containsPoint(screenPositionPixels)) {
        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap);
        let uniforms = material1a.uniforms;
        uniforms["scale"].value = scale;
        uniforms["screenPosition"].value = positionScreen;
        renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null);
        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap);
        uniforms = material1b.uniforms;
        uniforms["scale"].value = scale;
        uniforms["screenPosition"].value = positionScreen;
        renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null);
        const vecX = -positionScreen.x * 2;
        const vecY = -positionScreen.y * 2;
        for (let i2 = 0, l = elements.length; i2 < l; i2++) {
          const element2 = elements[i2];
          const uniforms2 = material2.uniforms;
          uniforms2["color"].value.copy(element2.color);
          uniforms2["map"].value = element2.texture;
          uniforms2["screenPosition"].value.x = positionScreen.x + vecX * element2.distance;
          uniforms2["screenPosition"].value.y = positionScreen.y + vecY * element2.distance;
          size2 = element2.size / viewport.w;
          const invAspect2 = viewport.w / viewport.z;
          uniforms2["scale"].value.set(size2 * invAspect2, size2);
          material2.uniformsNeedUpdate = true;
          renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);
        }
      }
    };
    this.dispose = function() {
      material1a.dispose();
      material1b.dispose();
      material2.dispose();
      tempMap.dispose();
      occlusionMap.dispose();
      for (let i2 = 0, l = elements.length; i2 < l; i2++) {
        elements[i2].texture.dispose();
      }
    };
  }
};
Lensflare.prototype.isLensflare = true;
var LensflareElement = class {
  constructor(texture2, size2 = 1, distance2 = 0, color2 = new Color(16777215)) {
    this.texture = texture2;
    this.size = size2;
    this.distance = distance2;
    this.color = color2;
  }
};
LensflareElement.Shader = {
  uniforms: {
    map: {
      value: null
    },
    occlusionMap: {
      value: null
    },
    color: {
      value: null
    },
    scale: {
      value: null
    },
    screenPosition: {
      value: null
    }
  },
  vertexShader: `

		precision highp float;

		uniform vec3 screenPosition;
		uniform vec2 scale;

		uniform sampler2D occlusionMap;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vUV = uv;

			vec2 pos = position.xy;

			vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

			vVisibility =        visibility.r / 9.0;
			vVisibility *= 1.0 - visibility.g / 9.0;
			vVisibility *=       visibility.b / 9.0;

			gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

		}`,
  fragmentShader: `

		precision highp float;

		uniform sampler2D map;
		uniform vec3 color;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vec4 texture = texture2D( map, vUV );
			texture.a *= vVisibility;
			gl_FragColor = texture;
			gl_FragColor.rgb *= color;

		}`
};
Lensflare.Geometry = function() {
  const geometry = new BufferGeometry();
  const float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);
  const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
  geometry.setIndex([0, 1, 2, 0, 2, 3]);
  geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
  geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
  return geometry;
}();

// node_modules/three-stdlib/objects/Water.js
var Water2 = class extends Mesh {
  constructor(geometry, options = {}) {
    super(geometry);
    const scope2 = this;
    const textureWidth = options.textureWidth !== void 0 ? options.textureWidth : 512;
    const textureHeight = options.textureHeight !== void 0 ? options.textureHeight : 512;
    const clipBias = options.clipBias !== void 0 ? options.clipBias : 0;
    const alpha = options.alpha !== void 0 ? options.alpha : 1;
    const time = options.time !== void 0 ? options.time : 0;
    const normalSampler = options.waterNormals !== void 0 ? options.waterNormals : null;
    const sunDirection = options.sunDirection !== void 0 ? options.sunDirection : new Vector3(0.70707, 0.70707, 0);
    const sunColor = new Color(options.sunColor !== void 0 ? options.sunColor : 16777215);
    const waterColor = new Color(options.waterColor !== void 0 ? options.waterColor : 8355711);
    const eye = options.eye !== void 0 ? options.eye : new Vector3(0, 0, 0);
    const distortionScale = options.distortionScale !== void 0 ? options.distortionScale : 20;
    const side = options.side !== void 0 ? options.side : FrontSide;
    const fog = options.fog !== void 0 ? options.fog : false;
    const mirrorPlane = new Plane();
    const normal = new Vector3();
    const mirrorWorldPosition = new Vector3();
    const cameraWorldPosition = new Vector3();
    const rotationMatrix2 = new Matrix4();
    const lookAtPosition = new Vector3(0, 0, -1);
    const clipPlane = new Vector4();
    const view = new Vector3();
    const target = new Vector3();
    const q = new Vector4();
    const textureMatrix = new Matrix4();
    const mirrorCamera = new PerspectiveCamera();
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);
    const mirrorShader = {
      uniforms: UniformsUtils.merge([UniformsLib["fog"], UniformsLib["lights"], {
        normalSampler: {
          value: null
        },
        mirrorSampler: {
          value: null
        },
        alpha: {
          value: 1
        },
        time: {
          value: 0
        },
        size: {
          value: 1
        },
        distortionScale: {
          value: 20
        },
        textureMatrix: {
          value: new Matrix4()
        },
        sunColor: {
          value: new Color(8355711)
        },
        sunDirection: {
          value: new Vector3(0.70707, 0.70707, 0)
        },
        eye: {
          value: new Vector3()
        },
        waterColor: {
          value: new Color(5592405)
        }
      }]),
      vertexShader: `
				uniform mat4 textureMatrix;
				uniform float time;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				#include <common>
				#include <fog_pars_vertex>
				#include <shadowmap_pars_vertex>
				#include <logdepthbuf_pars_vertex>

				void main() {
					mirrorCoord = modelMatrix * vec4( position, 1.0 );
					worldPosition = mirrorCoord.xyzw;
					mirrorCoord = textureMatrix * mirrorCoord;
					vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );
					gl_Position = projectionMatrix * mvPosition;

				#include <beginnormal_vertex>
				#include <defaultnormal_vertex>
				#include <logdepthbuf_vertex>
				#include <fog_vertex>
				#include <shadowmap_vertex>
			}`,
      fragmentShader: `
				uniform sampler2D mirrorSampler;
				uniform float alpha;
				uniform float time;
				uniform float size;
				uniform float distortionScale;
				uniform sampler2D normalSampler;
				uniform vec3 sunColor;
				uniform vec3 sunDirection;
				uniform vec3 eye;
				uniform vec3 waterColor;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				vec4 getNoise( vec2 uv ) {
					vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);
					vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );
					vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
					vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
					vec4 noise = texture2D( normalSampler, uv0 ) +
						texture2D( normalSampler, uv1 ) +
						texture2D( normalSampler, uv2 ) +
						texture2D( normalSampler, uv3 );
					return noise * 0.5 - 1.0;
				}

				void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {
					vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );
					float direction = max( 0.0, dot( eyeDirection, reflection ) );
					specularColor += pow( direction, shiny ) * sunColor * spec;
					diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;
				}

				#include <common>
				#include <packing>
				#include <bsdfs>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <lights_pars_begin>
				#include <shadowmap_pars_fragment>
				#include <shadowmask_pars_fragment>

				void main() {

					#include <logdepthbuf_fragment>
					vec4 noise = getNoise( worldPosition.xz * size );
					vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );

					vec3 diffuseLight = vec3(0.0);
					vec3 specularLight = vec3(0.0);

					vec3 worldToEye = eye-worldPosition.xyz;
					vec3 eyeDirection = normalize( worldToEye );
					sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );

					float distance = length(worldToEye);

					vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;
					vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );

					float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );
					float rf0 = 0.3;
					float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );
					vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;
					vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);
					vec3 outgoingLight = albedo;
					gl_FragColor = vec4( outgoingLight, alpha );

					#include <tonemapping_fragment>
					#include <fog_fragment>
				}`
    };
    const material = new ShaderMaterial({
      fragmentShader: mirrorShader.fragmentShader,
      vertexShader: mirrorShader.vertexShader,
      uniforms: UniformsUtils.clone(mirrorShader.uniforms),
      lights: true,
      side,
      fog
    });
    material.uniforms["mirrorSampler"].value = renderTarget.texture;
    material.uniforms["textureMatrix"].value = textureMatrix;
    material.uniforms["alpha"].value = alpha;
    material.uniforms["time"].value = time;
    material.uniforms["normalSampler"].value = normalSampler;
    material.uniforms["sunColor"].value = sunColor;
    material.uniforms["waterColor"].value = waterColor;
    material.uniforms["sunDirection"].value = sunDirection;
    material.uniforms["distortionScale"].value = distortionScale;
    material.uniforms["eye"].value = eye;
    scope2.material = material;
    scope2.onBeforeRender = function(renderer, scene, camera) {
      mirrorWorldPosition.setFromMatrixPosition(scope2.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix2.extractRotation(scope2.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix2);
      view.subVectors(mirrorWorldPosition, cameraWorldPosition);
      if (view.dot(normal) > 0)
        return;
      view.reflect(normal).negate();
      view.add(mirrorWorldPosition);
      rotationMatrix2.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, -1);
      lookAtPosition.applyMatrix4(rotationMatrix2);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(mirrorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(mirrorWorldPosition);
      mirrorCamera.position.copy(view);
      mirrorCamera.up.set(0, 1, 0);
      mirrorCamera.up.applyMatrix4(rotationMatrix2);
      mirrorCamera.up.reflect(normal);
      mirrorCamera.lookAt(target);
      mirrorCamera.far = camera.far;
      mirrorCamera.updateMatrixWorld();
      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix);
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(mirrorCamera.projectionMatrix);
      textureMatrix.multiply(mirrorCamera.matrixWorldInverse);
      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);
      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);
      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);
      const projectionMatrix = mirrorCamera.projectionMatrix;
      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
      q.z = -1;
      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
      clipPlane.multiplyScalar(2 / clipPlane.dot(q));
      projectionMatrix.elements[2] = clipPlane.x;
      projectionMatrix.elements[6] = clipPlane.y;
      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;
      projectionMatrix.elements[14] = clipPlane.w;
      eye.setFromMatrixPosition(camera.matrixWorld);
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      scope2.visible = false;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.setRenderTarget(renderTarget);
      renderer.state.buffers.depth.setMask(true);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, mirrorCamera);
      scope2.visible = true;
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
    };
  }
};
Water2.prototype.isWater = true;

// node_modules/three-stdlib/objects/MarchingCubes.js
var MarchingCubes = class extends Mesh {
  constructor(resolution, material, enableUvs = false, enableColors = false, maxPolyCount = 1e4) {
    const geometry = new BufferGeometry();
    super(geometry, material);
    const scope2 = this;
    const vlist = new Float32Array(12 * 3);
    const nlist = new Float32Array(12 * 3);
    const clist = new Float32Array(12 * 3);
    this.enableUvs = enableUvs;
    this.enableColors = enableColors;
    this.init = function(resolution2) {
      this.resolution = resolution2;
      this.isolation = 80;
      this.size = resolution2;
      this.size2 = this.size * this.size;
      this.size3 = this.size2 * this.size;
      this.halfsize = this.size / 2;
      this.delta = 2 / this.size;
      this.yd = this.size;
      this.zd = this.size2;
      this.field = new Float32Array(this.size3);
      this.normal_cache = new Float32Array(this.size3 * 3);
      this.palette = new Float32Array(this.size3 * 3);
      this.count = 0;
      const maxVertexCount = maxPolyCount * 3;
      this.positionArray = new Float32Array(maxVertexCount * 3);
      const positionAttribute = new BufferAttribute(this.positionArray, 3);
      positionAttribute.setUsage(DynamicDrawUsage);
      geometry.setAttribute("position", positionAttribute);
      this.normalArray = new Float32Array(maxVertexCount * 3);
      const normalAttribute = new BufferAttribute(this.normalArray, 3);
      normalAttribute.setUsage(DynamicDrawUsage);
      geometry.setAttribute("normal", normalAttribute);
      if (this.enableUvs) {
        this.uvArray = new Float32Array(maxVertexCount * 2);
        const uvAttribute = new BufferAttribute(this.uvArray, 2);
        uvAttribute.setUsage(DynamicDrawUsage);
        geometry.setAttribute("uv", uvAttribute);
      }
      if (this.enableColors) {
        this.colorArray = new Float32Array(maxVertexCount * 3);
        const colorAttribute = new BufferAttribute(this.colorArray, 3);
        colorAttribute.setUsage(DynamicDrawUsage);
        geometry.setAttribute("color", colorAttribute);
      }
    };
    function lerp(a2, b3, t2) {
      return a2 + (b3 - a2) * t2;
    }
    function VIntX(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {
      const mu = (isol - valp1) / (valp2 - valp1), nc = scope2.normal_cache;
      vlist[offset + 0] = x + mu * scope2.delta;
      vlist[offset + 1] = y;
      vlist[offset + 2] = z;
      nlist[offset + 0] = lerp(nc[q + 0], nc[q + 3], mu);
      nlist[offset + 1] = lerp(nc[q + 1], nc[q + 4], mu);
      nlist[offset + 2] = lerp(nc[q + 2], nc[q + 5], mu);
      clist[offset + 0] = lerp(scope2.palette[c_offset1 * 3 + 0], scope2.palette[c_offset2 * 3 + 0], mu);
      clist[offset + 1] = lerp(scope2.palette[c_offset1 * 3 + 1], scope2.palette[c_offset2 * 3 + 1], mu);
      clist[offset + 2] = lerp(scope2.palette[c_offset1 * 3 + 2], scope2.palette[c_offset2 * 3 + 2], mu);
    }
    function VIntY(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {
      const mu = (isol - valp1) / (valp2 - valp1), nc = scope2.normal_cache;
      vlist[offset + 0] = x;
      vlist[offset + 1] = y + mu * scope2.delta;
      vlist[offset + 2] = z;
      const q2 = q + scope2.yd * 3;
      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);
      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);
      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);
      clist[offset + 0] = lerp(scope2.palette[c_offset1 * 3 + 0], scope2.palette[c_offset2 * 3 + 0], mu);
      clist[offset + 1] = lerp(scope2.palette[c_offset1 * 3 + 1], scope2.palette[c_offset2 * 3 + 1], mu);
      clist[offset + 2] = lerp(scope2.palette[c_offset1 * 3 + 2], scope2.palette[c_offset2 * 3 + 2], mu);
    }
    function VIntZ(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {
      const mu = (isol - valp1) / (valp2 - valp1), nc = scope2.normal_cache;
      vlist[offset + 0] = x;
      vlist[offset + 1] = y;
      vlist[offset + 2] = z + mu * scope2.delta;
      const q2 = q + scope2.zd * 3;
      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);
      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);
      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);
      clist[offset + 0] = lerp(scope2.palette[c_offset1 * 3 + 0], scope2.palette[c_offset2 * 3 + 0], mu);
      clist[offset + 1] = lerp(scope2.palette[c_offset1 * 3 + 1], scope2.palette[c_offset2 * 3 + 1], mu);
      clist[offset + 2] = lerp(scope2.palette[c_offset1 * 3 + 2], scope2.palette[c_offset2 * 3 + 2], mu);
    }
    function compNorm(q) {
      const q3 = q * 3;
      if (scope2.normal_cache[q3] === 0) {
        scope2.normal_cache[q3 + 0] = scope2.field[q - 1] - scope2.field[q + 1];
        scope2.normal_cache[q3 + 1] = scope2.field[q - scope2.yd] - scope2.field[q + scope2.yd];
        scope2.normal_cache[q3 + 2] = scope2.field[q - scope2.zd] - scope2.field[q + scope2.zd];
      }
    }
    function polygonize(fx, fy, fz, q, isol) {
      const q1 = q + 1, qy = q + scope2.yd, qz = q + scope2.zd, q1y = q1 + scope2.yd, q1z = q1 + scope2.zd, qyz = q + scope2.yd + scope2.zd, q1yz = q1 + scope2.yd + scope2.zd;
      let cubeindex = 0;
      const field0 = scope2.field[q], field1 = scope2.field[q1], field2 = scope2.field[qy], field3 = scope2.field[q1y], field4 = scope2.field[qz], field5 = scope2.field[q1z], field6 = scope2.field[qyz], field7 = scope2.field[q1yz];
      if (field0 < isol)
        cubeindex |= 1;
      if (field1 < isol)
        cubeindex |= 2;
      if (field2 < isol)
        cubeindex |= 8;
      if (field3 < isol)
        cubeindex |= 4;
      if (field4 < isol)
        cubeindex |= 16;
      if (field5 < isol)
        cubeindex |= 32;
      if (field6 < isol)
        cubeindex |= 128;
      if (field7 < isol)
        cubeindex |= 64;
      const bits2 = edgeTable[cubeindex];
      if (bits2 === 0)
        return 0;
      const d = scope2.delta, fx2 = fx + d, fy2 = fy + d, fz2 = fz + d;
      if (bits2 & 1) {
        compNorm(q);
        compNorm(q1);
        VIntX(q * 3, 0, isol, fx, fy, fz, field0, field1, q, q1);
      }
      if (bits2 & 2) {
        compNorm(q1);
        compNorm(q1y);
        VIntY(q1 * 3, 3, isol, fx2, fy, fz, field1, field3, q1, q1y);
      }
      if (bits2 & 4) {
        compNorm(qy);
        compNorm(q1y);
        VIntX(qy * 3, 6, isol, fx, fy2, fz, field2, field3, qy, q1y);
      }
      if (bits2 & 8) {
        compNorm(q);
        compNorm(qy);
        VIntY(q * 3, 9, isol, fx, fy, fz, field0, field2, q, qy);
      }
      if (bits2 & 16) {
        compNorm(qz);
        compNorm(q1z);
        VIntX(qz * 3, 12, isol, fx, fy, fz2, field4, field5, qz, q1z);
      }
      if (bits2 & 32) {
        compNorm(q1z);
        compNorm(q1yz);
        VIntY(q1z * 3, 15, isol, fx2, fy, fz2, field5, field7, q1z, q1yz);
      }
      if (bits2 & 64) {
        compNorm(qyz);
        compNorm(q1yz);
        VIntX(qyz * 3, 18, isol, fx, fy2, fz2, field6, field7, qyz, q1yz);
      }
      if (bits2 & 128) {
        compNorm(qz);
        compNorm(qyz);
        VIntY(qz * 3, 21, isol, fx, fy, fz2, field4, field6, qz, qyz);
      }
      if (bits2 & 256) {
        compNorm(q);
        compNorm(qz);
        VIntZ(q * 3, 24, isol, fx, fy, fz, field0, field4, q, qz);
      }
      if (bits2 & 512) {
        compNorm(q1);
        compNorm(q1z);
        VIntZ(q1 * 3, 27, isol, fx2, fy, fz, field1, field5, q1, q1z);
      }
      if (bits2 & 1024) {
        compNorm(q1y);
        compNorm(q1yz);
        VIntZ(q1y * 3, 30, isol, fx2, fy2, fz, field3, field7, q1y, q1yz);
      }
      if (bits2 & 2048) {
        compNorm(qy);
        compNorm(qyz);
        VIntZ(qy * 3, 33, isol, fx, fy2, fz, field2, field6, qy, qyz);
      }
      cubeindex <<= 4;
      let o1, o2, o3, numtris = 0, i2 = 0;
      while (triTable[cubeindex + i2] != -1) {
        o1 = cubeindex + i2;
        o2 = o1 + 1;
        o3 = o1 + 2;
        posnormtriv(vlist, nlist, clist, 3 * triTable[o1], 3 * triTable[o2], 3 * triTable[o3]);
        i2 += 3;
        numtris++;
      }
      return numtris;
    }
    function posnormtriv(pos, norm, colors, o1, o2, o3) {
      const c = scope2.count * 3;
      scope2.positionArray[c + 0] = pos[o1];
      scope2.positionArray[c + 1] = pos[o1 + 1];
      scope2.positionArray[c + 2] = pos[o1 + 2];
      scope2.positionArray[c + 3] = pos[o2];
      scope2.positionArray[c + 4] = pos[o2 + 1];
      scope2.positionArray[c + 5] = pos[o2 + 2];
      scope2.positionArray[c + 6] = pos[o3];
      scope2.positionArray[c + 7] = pos[o3 + 1];
      scope2.positionArray[c + 8] = pos[o3 + 2];
      if (scope2.material.flatShading === true) {
        const nx = (norm[o1 + 0] + norm[o2 + 0] + norm[o3 + 0]) / 3;
        const ny = (norm[o1 + 1] + norm[o2 + 1] + norm[o3 + 1]) / 3;
        const nz = (norm[o1 + 2] + norm[o2 + 2] + norm[o3 + 2]) / 3;
        scope2.normalArray[c + 0] = nx;
        scope2.normalArray[c + 1] = ny;
        scope2.normalArray[c + 2] = nz;
        scope2.normalArray[c + 3] = nx;
        scope2.normalArray[c + 4] = ny;
        scope2.normalArray[c + 5] = nz;
        scope2.normalArray[c + 6] = nx;
        scope2.normalArray[c + 7] = ny;
        scope2.normalArray[c + 8] = nz;
      } else {
        scope2.normalArray[c + 0] = norm[o1 + 0];
        scope2.normalArray[c + 1] = norm[o1 + 1];
        scope2.normalArray[c + 2] = norm[o1 + 2];
        scope2.normalArray[c + 3] = norm[o2 + 0];
        scope2.normalArray[c + 4] = norm[o2 + 1];
        scope2.normalArray[c + 5] = norm[o2 + 2];
        scope2.normalArray[c + 6] = norm[o3 + 0];
        scope2.normalArray[c + 7] = norm[o3 + 1];
        scope2.normalArray[c + 8] = norm[o3 + 2];
      }
      if (scope2.enableUvs) {
        const d = scope2.count * 2;
        scope2.uvArray[d + 0] = pos[o1 + 0];
        scope2.uvArray[d + 1] = pos[o1 + 2];
        scope2.uvArray[d + 2] = pos[o2 + 0];
        scope2.uvArray[d + 3] = pos[o2 + 2];
        scope2.uvArray[d + 4] = pos[o3 + 0];
        scope2.uvArray[d + 5] = pos[o3 + 2];
      }
      if (scope2.enableColors) {
        scope2.colorArray[c + 0] = colors[o1 + 0];
        scope2.colorArray[c + 1] = colors[o1 + 1];
        scope2.colorArray[c + 2] = colors[o1 + 2];
        scope2.colorArray[c + 3] = colors[o2 + 0];
        scope2.colorArray[c + 4] = colors[o2 + 1];
        scope2.colorArray[c + 5] = colors[o2 + 2];
        scope2.colorArray[c + 6] = colors[o3 + 0];
        scope2.colorArray[c + 7] = colors[o3 + 1];
        scope2.colorArray[c + 8] = colors[o3 + 2];
      }
      scope2.count += 3;
    }
    this.addBall = function(ballx, bally, ballz, strength, subtract, colors) {
      const sign2 = Math.sign(strength);
      strength = Math.abs(strength);
      const userDefineColor = !(colors === void 0 || colors === null);
      let ballColor = new Color(ballx, bally, ballz);
      if (userDefineColor) {
        try {
          ballColor = colors instanceof Color ? colors : Array.isArray(colors) ? new Color(Math.min(Math.abs(colors[0]), 1), Math.min(Math.abs(colors[1]), 1), Math.min(Math.abs(colors[2]), 1)) : new Color(colors);
        } catch (err) {
          ballColor = new Color(ballx, bally, ballz);
        }
      }
      const radius = this.size * Math.sqrt(strength / subtract), zs = ballz * this.size, ys = bally * this.size, xs = ballx * this.size;
      let min_z = Math.floor(zs - radius);
      if (min_z < 1)
        min_z = 1;
      let max_z = Math.floor(zs + radius);
      if (max_z > this.size - 1)
        max_z = this.size - 1;
      let min_y = Math.floor(ys - radius);
      if (min_y < 1)
        min_y = 1;
      let max_y = Math.floor(ys + radius);
      if (max_y > this.size - 1)
        max_y = this.size - 1;
      let min_x = Math.floor(xs - radius);
      if (min_x < 1)
        min_x = 1;
      let max_x = Math.floor(xs + radius);
      if (max_x > this.size - 1)
        max_x = this.size - 1;
      let x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val;
      for (z = min_z; z < max_z; z++) {
        z_offset = this.size2 * z;
        fz = z / this.size - ballz;
        fz2 = fz * fz;
        for (y = min_y; y < max_y; y++) {
          y_offset = z_offset + this.size * y;
          fy = y / this.size - bally;
          fy2 = fy * fy;
          for (x = min_x; x < max_x; x++) {
            fx = x / this.size - ballx;
            val = strength / (1e-6 + fx * fx + fy2 + fz2) - subtract;
            if (val > 0) {
              this.field[y_offset + x] += val * sign2;
              const ratio = Math.sqrt((x - xs) * (x - xs) + (y - ys) * (y - ys) + (z - zs) * (z - zs)) / radius;
              const contrib = 1 - ratio * ratio * ratio * (ratio * (ratio * 6 - 15) + 10);
              this.palette[(y_offset + x) * 3 + 0] += ballColor.r * contrib;
              this.palette[(y_offset + x) * 3 + 1] += ballColor.g * contrib;
              this.palette[(y_offset + x) * 3 + 2] += ballColor.b * contrib;
            }
          }
        }
      }
    };
    this.addPlaneX = function(strength, subtract) {
      const size2 = this.size, yd = this.yd, zd = this.zd, field = this.field;
      let x, y, z, xx, val, xdiv, cxy, dist = size2 * Math.sqrt(strength / subtract);
      if (dist > size2)
        dist = size2;
      for (x = 0; x < dist; x++) {
        xdiv = x / size2;
        xx = xdiv * xdiv;
        val = strength / (1e-4 + xx) - subtract;
        if (val > 0) {
          for (y = 0; y < size2; y++) {
            cxy = x + y * yd;
            for (z = 0; z < size2; z++) {
              field[zd * z + cxy] += val;
            }
          }
        }
      }
    };
    this.addPlaneY = function(strength, subtract) {
      const size2 = this.size, yd = this.yd, zd = this.zd, field = this.field;
      let x, y, z, yy, val, ydiv, cy, cxy, dist = size2 * Math.sqrt(strength / subtract);
      if (dist > size2)
        dist = size2;
      for (y = 0; y < dist; y++) {
        ydiv = y / size2;
        yy = ydiv * ydiv;
        val = strength / (1e-4 + yy) - subtract;
        if (val > 0) {
          cy = y * yd;
          for (x = 0; x < size2; x++) {
            cxy = cy + x;
            for (z = 0; z < size2; z++)
              field[zd * z + cxy] += val;
          }
        }
      }
    };
    this.addPlaneZ = function(strength, subtract) {
      const size2 = this.size, yd = this.yd, zd = this.zd, field = this.field;
      let x, y, z, zz, val, zdiv, cz, cyz, dist = size2 * Math.sqrt(strength / subtract);
      if (dist > size2)
        dist = size2;
      for (z = 0; z < dist; z++) {
        zdiv = z / size2;
        zz = zdiv * zdiv;
        val = strength / (1e-4 + zz) - subtract;
        if (val > 0) {
          cz = zd * z;
          for (y = 0; y < size2; y++) {
            cyz = cz + y * yd;
            for (x = 0; x < size2; x++)
              field[cyz + x] += val;
          }
        }
      }
    };
    this.setCell = function(x, y, z, value) {
      const index = this.size2 * z + this.size * y + x;
      this.field[index] = value;
    };
    this.getCell = function(x, y, z) {
      const index = this.size2 * z + this.size * y + x;
      return this.field[index];
    };
    this.blur = function(intensity = 1) {
      const field = this.field;
      const fieldCopy = field.slice();
      const size2 = this.size;
      const size22 = this.size2;
      for (let x = 0; x < size2; x++) {
        for (let y = 0; y < size2; y++) {
          for (let z = 0; z < size2; z++) {
            const index = size22 * z + size2 * y + x;
            let val = fieldCopy[index];
            let count = 1;
            for (let x2 = -1; x2 <= 1; x2 += 2) {
              const x3 = x2 + x;
              if (x3 < 0 || x3 >= size2)
                continue;
              for (let y2 = -1; y2 <= 1; y2 += 2) {
                const y3 = y2 + y;
                if (y3 < 0 || y3 >= size2)
                  continue;
                for (let z2 = -1; z2 <= 1; z2 += 2) {
                  const z3 = z2 + z;
                  if (z3 < 0 || z3 >= size2)
                    continue;
                  const index2 = size22 * z3 + size2 * y3 + x3;
                  const val2 = fieldCopy[index2];
                  count++;
                  val += intensity * (val2 - val) / count;
                }
              }
            }
            field[index] = val;
          }
        }
      }
    };
    this.reset = function() {
      for (let i2 = 0; i2 < this.size3; i2++) {
        this.normal_cache[i2 * 3] = 0;
        this.field[i2] = 0;
        this.palette[i2 * 3] = this.palette[i2 * 3 + 1] = this.palette[i2 * 3 + 2] = 0;
      }
    };
    this.onBeforeRender = function() {
      this.count = 0;
      const smin2 = this.size - 2;
      for (let z = 1; z < smin2; z++) {
        const z_offset = this.size2 * z;
        const fz = (z - this.halfsize) / this.halfsize;
        for (let y = 1; y < smin2; y++) {
          const y_offset = z_offset + this.size * y;
          const fy = (y - this.halfsize) / this.halfsize;
          for (let x = 1; x < smin2; x++) {
            const fx = (x - this.halfsize) / this.halfsize;
            const q = y_offset + x;
            polygonize(fx, fy, fz, q, this.isolation);
          }
        }
      }
      for (let i2 = this.count * 3; i2 < this.positionArray.length; i2++) {
        this.positionArray[i2] = 0;
      }
      geometry.getAttribute("position").needsUpdate = true;
      geometry.getAttribute("normal").needsUpdate = true;
      if (this.enableUvs)
        geometry.getAttribute("uv").needsUpdate = true;
      if (this.enableColors)
        geometry.getAttribute("color").needsUpdate = true;
      if (this.count / 3 > maxPolyCount) {
        console.warn("MarchingCubes: Geometry buffers too small for rendering. Please create an instance with a higher poly count.");
      }
    };
    this.init(resolution);
  }
};
MarchingCubes.prototype.isMarchingCubes = true;
var edgeTable = new Int32Array([0, 265, 515, 778, 1030, 1295, 1541, 1804, 2060, 2309, 2575, 2822, 3082, 3331, 3593, 3840, 400, 153, 915, 666, 1430, 1183, 1941, 1692, 2460, 2197, 2975, 2710, 3482, 3219, 3993, 3728, 560, 825, 51, 314, 1590, 1855, 1077, 1340, 2620, 2869, 2111, 2358, 3642, 3891, 3129, 3376, 928, 681, 419, 170, 1958, 1711, 1445, 1196, 2988, 2725, 2479, 2214, 4010, 3747, 3497, 3232, 1120, 1385, 1635, 1898, 102, 367, 613, 876, 3180, 3429, 3695, 3942, 2154, 2403, 2665, 2912, 1520, 1273, 2035, 1786, 502, 255, 1013, 764, 3580, 3317, 4095, 3830, 2554, 2291, 3065, 2800, 1616, 1881, 1107, 1370, 598, 863, 85, 348, 3676, 3925, 3167, 3414, 2650, 2899, 2137, 2384, 1984, 1737, 1475, 1226, 966, 719, 453, 204, 4044, 3781, 3535, 3270, 3018, 2755, 2505, 2240, 2240, 2505, 2755, 3018, 3270, 3535, 3781, 4044, 204, 453, 719, 966, 1226, 1475, 1737, 1984, 2384, 2137, 2899, 2650, 3414, 3167, 3925, 3676, 348, 85, 863, 598, 1370, 1107, 1881, 1616, 2800, 3065, 2291, 2554, 3830, 4095, 3317, 3580, 764, 1013, 255, 502, 1786, 2035, 1273, 1520, 2912, 2665, 2403, 2154, 3942, 3695, 3429, 3180, 876, 613, 367, 102, 1898, 1635, 1385, 1120, 3232, 3497, 3747, 4010, 2214, 2479, 2725, 2988, 1196, 1445, 1711, 1958, 170, 419, 681, 928, 3376, 3129, 3891, 3642, 2358, 2111, 2869, 2620, 1340, 1077, 1855, 1590, 314, 51, 825, 560, 3728, 3993, 3219, 3482, 2710, 2975, 2197, 2460, 1692, 1941, 1183, 1430, 666, 915, 153, 400, 3840, 3593, 3331, 3082, 2822, 2575, 2309, 2060, 1804, 1541, 1295, 1030, 778, 515, 265, 0]);
var triTable = new Int32Array([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1, 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1, 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1, 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1, 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1, 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1, 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1, 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1, 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1, 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1, 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1, 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1, 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1, 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1, 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1, 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1, 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1, 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1, 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1, 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1, 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1, 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1, 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1, 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1, 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1, 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1, 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1, 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1, 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]);

// node_modules/three-stdlib/math/SimplexNoise.js
var SimplexNoise = class {
  constructor(r = Math) {
    _defineProperty(this, "grad3", [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]]);
    _defineProperty(this, "grad4", [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]]);
    _defineProperty(this, "p", []);
    _defineProperty(this, "perm", []);
    _defineProperty(this, "simplex", [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]]);
    _defineProperty(this, "dot", (g2, x, y) => {
      return g2[0] * x + g2[1] * y;
    });
    _defineProperty(this, "dot3", (g2, x, y, z) => {
      return g2[0] * x + g2[1] * y + g2[2] * z;
    });
    _defineProperty(this, "dot4", (g2, x, y, z, w) => {
      return g2[0] * x + g2[1] * y + g2[2] * z + g2[3] * w;
    });
    _defineProperty(this, "noise", (xin, yin) => {
      let n0;
      let n1;
      let n2;
      const F2 = 0.5 * (Math.sqrt(3) - 1);
      const s = (xin + yin) * F2;
      const i2 = Math.floor(xin + s);
      const j2 = Math.floor(yin + s);
      const G2 = (3 - Math.sqrt(3)) / 6;
      const t2 = (i2 + j2) * G2;
      const X0 = i2 - t2;
      const Y0 = j2 - t2;
      const x0 = xin - X0;
      const y0 = yin - Y0;
      let i1 = 0;
      let j1 = 1;
      if (x0 > y0) {
        i1 = 1;
        j1 = 0;
      }
      const x1 = x0 - i1 + G2;
      const y1 = y0 - j1 + G2;
      const x2 = x0 - 1 + 2 * G2;
      const y2 = y0 - 1 + 2 * G2;
      const ii = i2 & 255;
      const jj = j2 & 255;
      const gi0 = this.perm[ii + this.perm[jj]] % 12;
      const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
      const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
      let t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
      }
      let t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
      }
      let t22 = 0.5 - x2 * x2 - y2 * y2;
      if (t22 < 0) {
        n2 = 0;
      } else {
        t22 *= t22;
        n2 = t22 * t22 * this.dot(this.grad3[gi2], x2, y2);
      }
      return 70 * (n0 + n1 + n2);
    });
    _defineProperty(this, "noise3d", (xin, yin, zin) => {
      let n0;
      let n1;
      let n2;
      let n3;
      const F3 = 1 / 3;
      const s = (xin + yin + zin) * F3;
      const i2 = Math.floor(xin + s);
      const j2 = Math.floor(yin + s);
      const k = Math.floor(zin + s);
      const G3 = 1 / 6;
      const t2 = (i2 + j2 + k) * G3;
      const X0 = i2 - t2;
      const Y0 = j2 - t2;
      const Z0 = k - t2;
      const x0 = xin - X0;
      const y0 = yin - Y0;
      const z0 = zin - Z0;
      let i1;
      let j1;
      let k1;
      let i22;
      let j22;
      let k2;
      if (x0 >= y0) {
        if (y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i22 = 1;
          j22 = 1;
          k2 = 0;
        } else if (x0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i22 = 1;
          j22 = 0;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i22 = 1;
          j22 = 0;
          k2 = 1;
        }
      } else {
        if (y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i22 = 0;
          j22 = 1;
          k2 = 1;
        } else if (x0 < z0) {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i22 = 0;
          j22 = 1;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i22 = 1;
          j22 = 1;
          k2 = 0;
        }
      }
      const x1 = x0 - i1 + G3;
      const y1 = y0 - j1 + G3;
      const z1 = z0 - k1 + G3;
      const x2 = x0 - i22 + 2 * G3;
      const y2 = y0 - j22 + 2 * G3;
      const z2 = z0 - k2 + 2 * G3;
      const x3 = x0 - 1 + 3 * G3;
      const y3 = y0 - 1 + 3 * G3;
      const z3 = z0 - 1 + 3 * G3;
      const ii = i2 & 255;
      const jj = j2 & 255;
      const kk = k & 255;
      const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
      const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
      const gi2 = this.perm[ii + i22 + this.perm[jj + j22 + this.perm[kk + k2]]] % 12;
      const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);
      }
      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);
      }
      let t22 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if (t22 < 0) {
        n2 = 0;
      } else {
        t22 *= t22;
        n2 = t22 * t22 * this.dot3(this.grad3[gi2], x2, y2, z2);
      }
      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if (t3 < 0) {
        n3 = 0;
      } else {
        t3 *= t3;
        n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);
      }
      return 32 * (n0 + n1 + n2 + n3);
    });
    _defineProperty(this, "noise4d", (x, y, z, w) => {
      const grad4 = this.grad4;
      const simplex = this.simplex;
      const perm = this.perm;
      const F4 = (Math.sqrt(5) - 1) / 4;
      const G4 = (5 - Math.sqrt(5)) / 20;
      let n0;
      let n1;
      let n2;
      let n3;
      let n4;
      const s = (x + y + z + w) * F4;
      const i2 = Math.floor(x + s);
      const j2 = Math.floor(y + s);
      const k = Math.floor(z + s);
      const l = Math.floor(w + s);
      const t2 = (i2 + j2 + k + l) * G4;
      const X0 = i2 - t2;
      const Y0 = j2 - t2;
      const Z0 = k - t2;
      const W0 = l - t2;
      const x0 = x - X0;
      const y0 = y - Y0;
      const z0 = z - Z0;
      const w0 = w - W0;
      const c1 = x0 > y0 ? 32 : 0;
      const c2 = x0 > z0 ? 16 : 0;
      const c3 = y0 > z0 ? 8 : 0;
      const c4 = x0 > w0 ? 4 : 0;
      const c5 = y0 > w0 ? 2 : 0;
      const c6 = z0 > w0 ? 1 : 0;
      const c = c1 + c2 + c3 + c4 + c5 + c6;
      let i1;
      let j1;
      let k1;
      let l1;
      let i22;
      let j22;
      let k2;
      let l2;
      let i3;
      let j3;
      let k3;
      let l3;
      i1 = simplex[c][0] >= 3 ? 1 : 0;
      j1 = simplex[c][1] >= 3 ? 1 : 0;
      k1 = simplex[c][2] >= 3 ? 1 : 0;
      l1 = simplex[c][3] >= 3 ? 1 : 0;
      i22 = simplex[c][0] >= 2 ? 1 : 0;
      j22 = simplex[c][1] >= 2 ? 1 : 0;
      k2 = simplex[c][2] >= 2 ? 1 : 0;
      l2 = simplex[c][3] >= 2 ? 1 : 0;
      i3 = simplex[c][0] >= 1 ? 1 : 0;
      j3 = simplex[c][1] >= 1 ? 1 : 0;
      k3 = simplex[c][2] >= 1 ? 1 : 0;
      l3 = simplex[c][3] >= 1 ? 1 : 0;
      const x1 = x0 - i1 + G4;
      const y1 = y0 - j1 + G4;
      const z1 = z0 - k1 + G4;
      const w1 = w0 - l1 + G4;
      const x2 = x0 - i22 + 2 * G4;
      const y2 = y0 - j22 + 2 * G4;
      const z2 = z0 - k2 + 2 * G4;
      const w2 = w0 - l2 + 2 * G4;
      const x3 = x0 - i3 + 3 * G4;
      const y3 = y0 - j3 + 3 * G4;
      const z3 = z0 - k3 + 3 * G4;
      const w3 = w0 - l3 + 3 * G4;
      const x4 = x0 - 1 + 4 * G4;
      const y4 = y0 - 1 + 4 * G4;
      const z4 = z0 - 1 + 4 * G4;
      const w4 = w0 - 1 + 4 * G4;
      const ii = i2 & 255;
      const jj = j2 & 255;
      const kk = k & 255;
      const ll = l & 255;
      const gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
      const gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
      const gi2 = perm[ii + i22 + perm[jj + j22 + perm[kk + k2 + perm[ll + l2]]]] % 32;
      const gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
      const gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;
      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);
      }
      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);
      }
      let t22 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
      if (t22 < 0) {
        n2 = 0;
      } else {
        t22 *= t22;
        n2 = t22 * t22 * this.dot4(grad4[gi2], x2, y2, z2, w2);
      }
      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
      if (t3 < 0) {
        n3 = 0;
      } else {
        t3 *= t3;
        n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);
      }
      let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
      if (t4 < 0) {
        n4 = 0;
      } else {
        t4 *= t4;
        n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);
      }
      return 27 * (n0 + n1 + n2 + n3 + n4);
    });
    for (let i2 = 0; i2 < 256; i2++) {
      this.p[i2] = Math.floor(r.random() * 256);
    }
    for (let i2 = 0; i2 < 512; i2++) {
      this.perm[i2] = this.p[i2 & 255];
    }
  }
};

// node_modules/three-stdlib/geometries/LightningStrike.js
var LightningStrike = class extends BufferGeometry {
  constructor(rayParameters) {
    super();
    this.type = "LightningStrike";
    rayParameters = rayParameters || {};
    this.init(LightningStrike.copyParameters(rayParameters, rayParameters));
    this.createMesh();
  }
  update(time) {
    if (this.isStatic)
      return;
    if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {
      this.updateMesh(time);
      if (time < this.subrays[0].endPropagationTime) {
        this.state = LightningStrike.RAY_PROPAGATING;
      } else if (time > this.subrays[0].beginVanishingTime) {
        this.state = LightningStrike.RAY_VANISHING;
      } else {
        this.state = LightningStrike.RAY_STEADY;
      }
      this.visible = true;
    } else {
      this.visible = false;
      if (time < this.rayParameters.birthTime) {
        this.state = LightningStrike.RAY_UNBORN;
      } else {
        this.state = LightningStrike.RAY_EXTINGUISHED;
      }
    }
  }
  init(rayParameters) {
    this.rayParameters = rayParameters;
    this.maxIterations = rayParameters.maxIterations !== void 0 ? Math.floor(rayParameters.maxIterations) : 9;
    rayParameters.maxIterations = this.maxIterations;
    this.isStatic = rayParameters.isStatic !== void 0 ? rayParameters.isStatic : false;
    rayParameters.isStatic = this.isStatic;
    this.ramification = rayParameters.ramification !== void 0 ? Math.floor(rayParameters.ramification) : 5;
    rayParameters.ramification = this.ramification;
    this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== void 0 ? Math.floor(rayParameters.maxSubrayRecursion) : 3;
    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;
    this.recursionProbability = rayParameters.recursionProbability !== void 0 ? rayParameters.recursionProbability : 0.6;
    rayParameters.recursionProbability = this.recursionProbability;
    this.generateUVs = rayParameters.generateUVs !== void 0 ? rayParameters.generateUVs : false;
    rayParameters.generateUVs = this.generateUVs;
    if (rayParameters.randomGenerator !== void 0) {
      this.randomGenerator = rayParameters.randomGenerator;
      this.seedGenerator = rayParameters.randomGenerator;
      if (rayParameters.noiseSeed !== void 0) {
        this.seedGenerator.setSeed(rayParameters.noiseSeed);
      }
    } else {
      this.randomGenerator = LightningStrike.createRandomGenerator();
      this.seedGenerator = Math;
    }
    if (rayParameters.onDecideSubrayCreation !== void 0) {
      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;
    } else {
      this.createDefaultSubrayCreationCallbacks();
      if (rayParameters.onSubrayCreation !== void 0) {
        this.onSubrayCreation = rayParameters.onSubrayCreation;
      }
    }
    this.state = LightningStrike.RAY_INITIALIZED;
    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));
    rayParameters.maxSubrays = this.maxSubrays;
    this.maxRaySegments = 2 * (1 << this.maxIterations);
    this.subrays = [];
    for (let i2 = 0; i2 < this.maxSubrays; i2++) {
      this.subrays.push(this.createSubray());
    }
    this.raySegments = [];
    for (let i2 = 0; i2 < this.maxRaySegments; i2++) {
      this.raySegments.push(this.createSegment());
    }
    this.time = 0;
    this.timeFraction = 0;
    this.currentSegmentCallback = null;
    this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;
    this.numSubrays = 0;
    this.currentSubray = null;
    this.currentSegmentIndex = 0;
    this.isInitialSegment = false;
    this.subrayProbability = 0;
    this.currentVertex = 0;
    this.currentIndex = 0;
    this.currentCoordinate = 0;
    this.currentUVCoordinate = 0;
    this.vertices = null;
    this.uvs = null;
    this.indices = null;
    this.positionAttribute = null;
    this.uvsAttribute = null;
    this.simplexX = new SimplexNoise(this.seedGenerator);
    this.simplexY = new SimplexNoise(this.seedGenerator);
    this.simplexZ = new SimplexNoise(this.seedGenerator);
    this.forwards = new Vector3();
    this.forwardsFill = new Vector3();
    this.side = new Vector3();
    this.down = new Vector3();
    this.middlePos = new Vector3();
    this.middleLinPos = new Vector3();
    this.newPos = new Vector3();
    this.vPos = new Vector3();
    this.cross1 = new Vector3();
  }
  createMesh() {
    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;
    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;
    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;
    this.vertices = new Float32Array(maxVerts * 3);
    this.indices = new Uint32Array(maxIndices);
    if (this.generateUVs) {
      this.uvs = new Float32Array(maxVerts * 2);
    }
    this.fillMesh(0);
    this.setIndex(new Uint32BufferAttribute(this.indices, 1));
    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);
    this.setAttribute("position", this.positionAttribute);
    if (this.generateUVs) {
      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);
      this.setAttribute("uv", this.uvsAttribute);
    }
    if (!this.isStatic) {
      this.index.usage = DynamicDrawUsage;
      this.positionAttribute.usage = DynamicDrawUsage;
      if (this.generateUVs) {
        this.uvsAttribute.usage = DynamicDrawUsage;
      }
    }
    this.vertices = this.positionAttribute.array;
    this.indices = this.index.array;
    if (this.generateUVs) {
      this.uvs = this.uvsAttribute.array;
    }
  }
  updateMesh(time) {
    this.fillMesh(time);
    this.drawRange.count = this.currentIndex;
    this.index.needsUpdate = true;
    this.positionAttribute.needsUpdate = true;
    if (this.generateUVs) {
      this.uvsAttribute.needsUpdate = true;
    }
  }
  fillMesh(time) {
    const scope2 = this;
    this.currentVertex = 0;
    this.currentIndex = 0;
    this.currentCoordinate = 0;
    this.currentUVCoordinate = 0;
    this.fractalRay(time, function fillVertices(segment) {
      const subray = scope2.currentSubray;
      if (time < subray.birthTime) {
        return;
      } else if (this.rayParameters.isEternal && scope2.currentSubray.recursion == 0) {
        scope2.createPrism(segment);
        scope2.onDecideSubrayCreation(segment, scope2);
      } else if (time < subray.endPropagationTime) {
        if (scope2.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {
          scope2.createPrism(segment);
          scope2.onDecideSubrayCreation(segment, scope2);
        }
      } else if (time < subray.beginVanishingTime) {
        scope2.createPrism(segment);
        scope2.onDecideSubrayCreation(segment, scope2);
      } else {
        if (scope2.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {
          scope2.createPrism(segment);
        }
        scope2.onDecideSubrayCreation(segment, scope2);
      }
    });
  }
  addNewSubray() {
    return this.subrays[this.numSubrays++];
  }
  initSubray(subray, rayParameters) {
    subray.pos0.copy(rayParameters.sourceOffset);
    subray.pos1.copy(rayParameters.destOffset);
    subray.up0.copy(rayParameters.up0);
    subray.up1.copy(rayParameters.up1);
    subray.radius0 = rayParameters.radius0;
    subray.radius1 = rayParameters.radius1;
    subray.birthTime = rayParameters.birthTime;
    subray.deathTime = rayParameters.deathTime;
    subray.timeScale = rayParameters.timeScale;
    subray.roughness = rayParameters.roughness;
    subray.straightness = rayParameters.straightness;
    subray.propagationTimeFactor = rayParameters.propagationTimeFactor;
    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;
    subray.maxIterations = this.maxIterations;
    subray.seed = rayParameters.noiseSeed !== void 0 ? rayParameters.noiseSeed : 0;
    subray.recursion = 0;
  }
  fractalRay(time, segmentCallback) {
    this.time = time;
    this.currentSegmentCallback = segmentCallback;
    this.numSubrays = 0;
    this.initSubray(this.addNewSubray(), this.rayParameters);
    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {
      const subray = this.subrays[subrayIndex];
      this.currentSubray = subray;
      this.randomGenerator.setSeed(subray.seed);
      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);
      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);
      const random1 = this.randomGenerator.random;
      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);
      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);
      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);
      this.currentSegmentIndex = 0;
      this.isInitialSegment = true;
      const segment = this.getNewSegment();
      segment.iteration = 0;
      segment.pos0.copy(subray.pos0);
      segment.pos1.copy(subray.pos1);
      segment.linPos0.copy(subray.linPos0);
      segment.linPos1.copy(subray.linPos1);
      segment.up0.copy(subray.up0);
      segment.up1.copy(subray.up1);
      segment.radius0 = subray.radius0;
      segment.radius1 = subray.radius1;
      segment.fraction0 = 0;
      segment.fraction1 = 1;
      segment.positionVariationFactor = 1 - subray.straightness;
      this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);
      this.fractalRayRecursive(segment);
    }
    this.currentSegmentCallback = null;
    this.currentSubray = null;
  }
  fractalRayRecursive(segment) {
    if (segment.iteration >= this.currentSubray.maxIterations) {
      this.currentSegmentCallback(segment);
      return;
    }
    this.forwards.subVectors(segment.pos1, segment.pos0);
    let lForwards = this.forwards.length();
    if (lForwards < 1e-6) {
      this.forwards.set(0, 0, 0.01);
      lForwards = this.forwards.length();
    }
    const middleRadius = (segment.radius0 + segment.radius1) * 0.5;
    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;
    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);
    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);
    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);
    const p = this.middleLinPos;
    this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));
    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);
    this.newPos.add(this.middlePos);
    const newSegment1 = this.getNewSegment();
    newSegment1.pos0.copy(segment.pos0);
    newSegment1.pos1.copy(this.newPos);
    newSegment1.linPos0.copy(segment.linPos0);
    newSegment1.linPos1.copy(this.middleLinPos);
    newSegment1.up0.copy(segment.up0);
    newSegment1.up1.copy(segment.up1);
    newSegment1.radius0 = segment.radius0;
    newSegment1.radius1 = middleRadius;
    newSegment1.fraction0 = segment.fraction0;
    newSegment1.fraction1 = middleFraction;
    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;
    newSegment1.iteration = segment.iteration + 1;
    const newSegment2 = this.getNewSegment();
    newSegment2.pos0.copy(this.newPos);
    newSegment2.pos1.copy(segment.pos1);
    newSegment2.linPos0.copy(this.middleLinPos);
    newSegment2.linPos1.copy(segment.linPos1);
    this.cross1.crossVectors(segment.up0, this.forwards.normalize());
    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();
    newSegment2.up1.copy(segment.up1);
    newSegment2.radius0 = middleRadius;
    newSegment2.radius1 = segment.radius1;
    newSegment2.fraction0 = middleFraction;
    newSegment2.fraction1 = segment.fraction1;
    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;
    newSegment2.iteration = segment.iteration + 1;
    this.fractalRayRecursive(newSegment1);
    this.fractalRayRecursive(newSegment2);
  }
  createPrism(segment) {
    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();
    if (this.isInitialSegment) {
      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);
      this.isInitialSegment = false;
    }
    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);
    this.createPrismFaces();
  }
  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {
    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);
    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);
    const p = this.vPos;
    const v = this.vertices;
    p.copy(pos).sub(this.side).add(this.down);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    p.copy(pos).add(this.side).add(this.down);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    p.copy(up).multiplyScalar(radius).add(pos);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    this.currentVertex += 3;
  }
  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {
    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);
    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);
    const p = this.vPos;
    const v = this.vertices;
    const uv2 = this.uvs;
    p.copy(pos).sub(this.side).add(this.down);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    uv2[this.currentUVCoordinate++] = u;
    uv2[this.currentUVCoordinate++] = 0;
    p.copy(pos).add(this.side).add(this.down);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    uv2[this.currentUVCoordinate++] = u;
    uv2[this.currentUVCoordinate++] = 0.5;
    p.copy(up).multiplyScalar(radius).add(pos);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    uv2[this.currentUVCoordinate++] = u;
    uv2[this.currentUVCoordinate++] = 1;
    this.currentVertex += 3;
  }
  createPrismFaces(vertex) {
    const indices = this.indices;
    var vertex = this.currentVertex - 6;
    indices[this.currentIndex++] = vertex + 1;
    indices[this.currentIndex++] = vertex + 2;
    indices[this.currentIndex++] = vertex + 5;
    indices[this.currentIndex++] = vertex + 1;
    indices[this.currentIndex++] = vertex + 5;
    indices[this.currentIndex++] = vertex + 4;
    indices[this.currentIndex++] = vertex + 0;
    indices[this.currentIndex++] = vertex + 1;
    indices[this.currentIndex++] = vertex + 4;
    indices[this.currentIndex++] = vertex + 0;
    indices[this.currentIndex++] = vertex + 4;
    indices[this.currentIndex++] = vertex + 3;
    indices[this.currentIndex++] = vertex + 2;
    indices[this.currentIndex++] = vertex + 0;
    indices[this.currentIndex++] = vertex + 3;
    indices[this.currentIndex++] = vertex + 2;
    indices[this.currentIndex++] = vertex + 3;
    indices[this.currentIndex++] = vertex + 5;
  }
  createDefaultSubrayCreationCallbacks() {
    const random1 = this.randomGenerator.random;
    this.onDecideSubrayCreation = (segment, lightningStrike) => {
      const subray = lightningStrike.currentSubray;
      const period = lightningStrike.rayParameters.subrayPeriod;
      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;
      const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;
      const phase = lightningStrike.time - phase0;
      const currentCycle = Math.floor(phase / period);
      const childSubraySeed = random1() * (currentCycle + 1);
      const isActive = phase % period <= dutyCycle * period;
      let probability = 0;
      if (isActive) {
        probability = lightningStrike.subrayProbability;
      }
      if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {
        const childSubray = lightningStrike.addNewSubray();
        const parentSeed = lightningStrike.randomGenerator.getSeed();
        childSubray.seed = childSubraySeed;
        lightningStrike.randomGenerator.setSeed(childSubraySeed);
        childSubray.recursion = subray.recursion + 1;
        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);
        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);
        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);
        childSubray.up0.copy(subray.up0);
        childSubray.up1.copy(subray.up1);
        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;
        childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);
        childSubray.birthTime = phase0 + currentCycle * period;
        childSubray.deathTime = childSubray.birthTime + period * dutyCycle;
        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {
          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);
          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);
        }
        childSubray.timeScale = subray.timeScale * 2;
        childSubray.roughness = subray.roughness;
        childSubray.straightness = subray.straightness;
        childSubray.propagationTimeFactor = subray.propagationTimeFactor;
        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;
        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);
        lightningStrike.randomGenerator.setSeed(parentSeed);
      }
    };
    const vec1Pos = new Vector3();
    const vec2Forward = new Vector3();
    const vec3Side = new Vector3();
    const vec4Up = new Vector3();
    this.onSubrayCreation = (segment, parentSubray, childSubray, lightningStrike) => {
      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);
    };
    this.subrayConePosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {
      childSubray.pos0.copy(segment.pos0);
      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);
      vec2Forward.copy(vec1Pos).normalize();
      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));
      const length2 = vec1Pos.length();
      vec3Side.crossVectors(parentSubray.up0, vec2Forward);
      const angle = 2 * Math.PI * random1();
      vec3Side.multiplyScalar(Math.cos(angle));
      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));
      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length2 * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);
    };
    this.subrayCylinderPosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {
      childSubray.pos0.copy(segment.pos0);
      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);
      vec2Forward.copy(vec1Pos).normalize();
      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));
      const length2 = vec1Pos.length();
      vec3Side.crossVectors(parentSubray.up0, vec2Forward);
      const angle = 2 * Math.PI * random1();
      vec3Side.multiplyScalar(Math.cos(angle));
      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));
      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length2 * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);
    };
  }
  createSubray() {
    return {
      seed: 0,
      maxIterations: 0,
      recursion: 0,
      pos0: new Vector3(),
      pos1: new Vector3(),
      linPos0: new Vector3(),
      linPos1: new Vector3(),
      up0: new Vector3(),
      up1: new Vector3(),
      radius0: 0,
      radius1: 0,
      birthTime: 0,
      deathTime: 0,
      timeScale: 0,
      roughness: 0,
      straightness: 0,
      propagationTimeFactor: 0,
      vanishingTimeFactor: 0,
      endPropagationTime: 0,
      beginVanishingTime: 0
    };
  }
  createSegment() {
    return {
      iteration: 0,
      pos0: new Vector3(),
      pos1: new Vector3(),
      linPos0: new Vector3(),
      linPos1: new Vector3(),
      up0: new Vector3(),
      up1: new Vector3(),
      radius0: 0,
      radius1: 0,
      fraction0: 0,
      fraction1: 0,
      positionVariationFactor: 0
    };
  }
  getNewSegment() {
    return this.raySegments[this.currentSegmentIndex++];
  }
  copy(source) {
    super.copy(source);
    this.init(LightningStrike.copyParameters({}, source.rayParameters));
    return this;
  }
  clone() {
    return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters));
  }
};
LightningStrike.prototype.isLightningStrike = true;
LightningStrike.RAY_INITIALIZED = 0;
LightningStrike.RAY_UNBORN = 1;
LightningStrike.RAY_PROPAGATING = 2;
LightningStrike.RAY_STEADY = 3;
LightningStrike.RAY_VANISHING = 4;
LightningStrike.RAY_EXTINGUISHED = 5;
LightningStrike.COS30DEG = Math.cos(30 * Math.PI / 180);
LightningStrike.SIN30DEG = Math.sin(30 * Math.PI / 180);
LightningStrike.createRandomGenerator = () => {
  const numSeeds = 2053;
  const seeds = [];
  for (let i2 = 0; i2 < numSeeds; i2++) {
    seeds.push(Math.random());
  }
  const generator = {
    currentSeed: 0,
    random: function() {
      const value = seeds[generator.currentSeed];
      generator.currentSeed = (generator.currentSeed + 1) % numSeeds;
      return value;
    },
    getSeed: function() {
      return generator.currentSeed / numSeeds;
    },
    setSeed: function(seed) {
      generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;
    }
  };
  return generator;
};
LightningStrike.copyParameters = (dest, source) => {
  source = source || {};
  dest = dest || {};
  const vecCopy = (v) => {
    if (source === dest) {
      return v;
    } else {
      return v.clone();
    }
  };
  dest.sourceOffset = source.sourceOffset !== void 0 ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== void 0 ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== void 0 ? source.timeScale : 1, dest.roughness = source.roughness !== void 0 ? source.roughness : 0.9, dest.straightness = source.straightness !== void 0 ? source.straightness : 0.7, dest.up0 = source.up0 !== void 0 ? vecCopy(source.up0) : new Vector3(0, 0, 1);
  dest.up1 = source.up1 !== void 0 ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== void 0 ? source.radius0 : 1, dest.radius1 = source.radius1 !== void 0 ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== void 0 ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== void 0 ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== void 0 ? source.minRadius : 0.2, dest.isEternal = source.isEternal !== void 0 ? source.isEternal : source.birthTime === void 0 || source.deathTime === void 0, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== void 0 ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== void 0 ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== void 0 ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== void 0 ? source.subrayDutyCycle : 0.6;
  dest.maxIterations = source.maxIterations !== void 0 ? source.maxIterations : 9;
  dest.isStatic = source.isStatic !== void 0 ? source.isStatic : false;
  dest.ramification = source.ramification !== void 0 ? source.ramification : 5;
  dest.maxSubrayRecursion = source.maxSubrayRecursion !== void 0 ? source.maxSubrayRecursion : 3;
  dest.recursionProbability = source.recursionProbability !== void 0 ? source.recursionProbability : 0.6;
  dest.generateUVs = source.generateUVs !== void 0 ? source.generateUVs : false;
  dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;
  return dest;
};

// node_modules/three-stdlib/objects/LightningStorm.js
var LightningStorm = class extends Object3D {
  constructor(stormParams = {}) {
    super();
    this.stormParams = stormParams;
    stormParams.size = stormParams.size !== void 0 ? stormParams.size : 1e3;
    stormParams.minHeight = stormParams.minHeight !== void 0 ? stormParams.minHeight : 80;
    stormParams.maxHeight = stormParams.maxHeight !== void 0 ? stormParams.maxHeight : 100;
    stormParams.maxSlope = stormParams.maxSlope !== void 0 ? stormParams.maxSlope : 1.1;
    stormParams.maxLightnings = stormParams.maxLightnings !== void 0 ? stormParams.maxLightnings : 3;
    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== void 0 ? stormParams.lightningMinPeriod : 3;
    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== void 0 ? stormParams.lightningMaxPeriod : 7;
    stormParams.lightningMinDuration = stormParams.lightningMinDuration !== void 0 ? stormParams.lightningMinDuration : 1;
    stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== void 0 ? stormParams.lightningMaxDuration : 2.5;
    this.lightningParameters = LightningStrike.copyParameters(stormParams.lightningParameters, stormParams.lightningParameters);
    this.lightningParameters.isEternal = false;
    this.lightningMaterial = stormParams.lightningMaterial !== void 0 ? stormParams.lightningMaterial : new MeshBasicMaterial({
      color: 11599871
    });
    if (stormParams.onRayPosition !== void 0) {
      this.onRayPosition = stormParams.onRayPosition;
    } else {
      this.onRayPosition = function(source, dest) {
        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);
        const height = MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());
        source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);
      };
    }
    this.onLightningDown = stormParams.onLightningDown;
    this.inited = false;
    this.nextLightningTime = 0;
    this.lightningsMeshes = [];
    this.deadLightningsMeshes = [];
    for (let i2 = 0; i2 < this.stormParams.maxLightnings; i2++) {
      const lightning = new LightningStrike(LightningStrike.copyParameters({}, this.lightningParameters));
      const mesh = new Mesh(lightning, this.lightningMaterial);
      this.deadLightningsMeshes.push(mesh);
    }
  }
  update(time) {
    if (!this.inited) {
      this.nextLightningTime = this.getNextLightningTime(time) * Math.random();
      this.inited = true;
    }
    if (time >= this.nextLightningTime) {
      const lightningMesh = this.deadLightningsMeshes.pop();
      if (lightningMesh) {
        const lightningParams1 = LightningStrike.copyParameters(lightningMesh.geometry.rayParameters, this.lightningParameters);
        lightningParams1.birthTime = time;
        lightningParams1.deathTime = time + MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());
        this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);
        lightningParams1.noiseSeed = Math.random();
        this.add(lightningMesh);
        this.lightningsMeshes.push(lightningMesh);
      }
      this.nextLightningTime = this.getNextLightningTime(time);
    }
    let i2 = 0, il = this.lightningsMeshes.length;
    while (i2 < il) {
      const mesh = this.lightningsMeshes[i2];
      const lightning = mesh.geometry;
      const prevState = lightning.state;
      lightning.update(time);
      if (prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {
        if (this.onLightningDown) {
          this.onLightningDown(lightning);
        }
      }
      if (lightning.state === LightningStrike.RAY_EXTINGUISHED) {
        this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);
        this.deadLightningsMeshes.push(mesh);
        this.remove(mesh);
        il--;
      } else {
        i2++;
      }
    }
  }
  getNextLightningTime(currentTime) {
    return currentTime + MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);
  }
  copy(source) {
    super.copy(source);
    this.stormParams.size = source.stormParams.size;
    this.stormParams.minHeight = source.stormParams.minHeight;
    this.stormParams.maxHeight = source.stormParams.maxHeight;
    this.stormParams.maxSlope = source.stormParams.maxSlope;
    this.stormParams.maxLightnings = source.stormParams.maxLightnings;
    this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;
    this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;
    this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;
    this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;
    this.lightningParameters = LightningStrike.copyParameters({}, source.lightningParameters);
    this.lightningMaterial = source.stormParams.lightningMaterial;
    this.onLightningDown = source.onLightningDown;
    return this;
  }
  clone() {
    return new this.constructor(this.stormParams).copy(this);
  }
};
LightningStorm.prototype.isLightningStorm = true;

// node_modules/three-stdlib/objects/ReflectorRTT.js
var ReflectorRTT = class extends Reflector {
  constructor(geometry, options) {
    super(geometry, options);
    this.geometry.setDrawRange(0, 0);
  }
};

// node_modules/three-stdlib/objects/ReflectorForSSRPass.js
var ReflectorForSSRPass = class extends Mesh {
  constructor(geometry, options = {}) {
    super(geometry);
    this.type = "ReflectorForSSRPass";
    const scope2 = this;
    const color2 = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const shader = options.shader || ReflectorForSSRPass.ReflectorShader;
    const useDepthTexture = options.useDepthTexture === true;
    const yAxis2 = new Vector3(0, 1, 0);
    const vecTemp0 = new Vector3();
    const vecTemp1 = new Vector3();
    scope2.needsUpdate = false;
    scope2.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;
    scope2.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;
    scope2.color = color2;
    scope2.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);
    scope2._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;
    Object.defineProperty(scope2, "distanceAttenuation", {
      get() {
        return scope2._distanceAttenuation;
      },
      set(val) {
        if (scope2._distanceAttenuation === val)
          return;
        scope2._distanceAttenuation = val;
        scope2.material.defines.DISTANCE_ATTENUATION = val;
        scope2.material.needsUpdate = true;
      }
    });
    scope2._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;
    Object.defineProperty(scope2, "fresnel", {
      get() {
        return scope2._fresnel;
      },
      set(val) {
        if (scope2._fresnel === val)
          return;
        scope2._fresnel = val;
        scope2.material.defines.FRESNEL = val;
        scope2.material.needsUpdate = true;
      }
    });
    const normal = new Vector3();
    const reflectorWorldPosition = new Vector3();
    const cameraWorldPosition = new Vector3();
    const rotationMatrix2 = new Matrix4();
    const lookAtPosition = new Vector3(0, 0, -1);
    const view = new Vector3();
    const target = new Vector3();
    const textureMatrix = new Matrix4();
    const virtualCamera = new PerspectiveCamera();
    let depthTexture;
    if (useDepthTexture) {
      depthTexture = new DepthTexture();
      depthTexture.type = UnsignedShortType;
      depthTexture.minFilter = NearestFilter;
      depthTexture.magFilter = NearestFilter;
    }
    const parameters = {
      depthTexture: useDepthTexture ? depthTexture : null
    };
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);
    const material = new ShaderMaterial({
      transparent: useDepthTexture,
      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {
        useDepthTexture
      }),
      uniforms: UniformsUtils.clone(shader.uniforms),
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader
    });
    material.uniforms["tDiffuse"].value = renderTarget.texture;
    material.uniforms["color"].value = scope2.color;
    material.uniforms["textureMatrix"].value = textureMatrix;
    if (useDepthTexture) {
      material.uniforms["tDepth"].value = renderTarget.depthTexture;
    }
    this.material = material;
    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);
    const globalPlanes = [globalPlane];
    this.doRender = function(renderer, scene, camera) {
      material.uniforms["maxDistance"].value = scope2.maxDistance;
      material.uniforms["color"].value = scope2.color;
      material.uniforms["opacity"].value = scope2.opacity;
      vecTemp0.copy(camera.position).normalize();
      vecTemp1.copy(vecTemp0).reflect(yAxis2);
      material.uniforms["fresnelCoe"].value = (vecTemp0.dot(vecTemp1) + 1) / 2;
      reflectorWorldPosition.setFromMatrixPosition(scope2.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix2.extractRotation(scope2.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix2);
      view.subVectors(reflectorWorldPosition, cameraWorldPosition);
      if (view.dot(normal) > 0)
        return;
      view.reflect(normal).negate();
      view.add(reflectorWorldPosition);
      rotationMatrix2.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, -1);
      lookAtPosition.applyMatrix4(rotationMatrix2);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(reflectorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(reflectorWorldPosition);
      virtualCamera.position.copy(view);
      virtualCamera.up.set(0, 1, 0);
      virtualCamera.up.applyMatrix4(rotationMatrix2);
      virtualCamera.up.reflect(normal);
      virtualCamera.lookAt(target);
      virtualCamera.far = camera.far;
      virtualCamera.updateMatrixWorld();
      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
      material.uniforms["virtualCameraNear"].value = camera.near;
      material.uniforms["virtualCameraFar"].value = camera.far;
      material.uniforms["virtualCameraMatrixWorld"].value = virtualCamera.matrixWorld;
      material.uniforms["virtualCameraProjectionMatrix"].value = camera.projectionMatrix;
      material.uniforms["virtualCameraProjectionMatrixInverse"].value = camera.projectionMatrixInverse;
      material.uniforms["resolution"].value = scope2.resolution;
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(virtualCamera.projectionMatrix);
      textureMatrix.multiply(virtualCamera.matrixWorldInverse);
      textureMatrix.multiply(scope2.matrixWorld);
      renderTarget.texture.encoding = renderer.outputEncoding;
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      const currentClippingPlanes = renderer.clippingPlanes;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.clippingPlanes = globalPlanes;
      renderer.setRenderTarget(renderTarget);
      renderer.state.buffers.depth.setMask(true);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.clippingPlanes = currentClippingPlanes;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
  }
};
ReflectorForSSRPass.prototype.isReflectorForSSRPass = true;
ReflectorForSSRPass.ReflectorShader = {
  defines: {
    DISTANCE_ATTENUATION: true,
    FRESNEL: true
  },
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    tDepth: {
      value: null
    },
    textureMatrix: {
      value: new Matrix4()
    },
    maxDistance: {
      value: 180
    },
    opacity: {
      value: 0.5
    },
    fresnelCoe: {
      value: null
    },
    virtualCameraNear: {
      value: null
    },
    virtualCameraFar: {
      value: null
    },
    virtualCameraProjectionMatrix: {
      value: new Matrix4()
    },
    virtualCameraMatrixWorld: {
      value: new Matrix4()
    },
    virtualCameraProjectionMatrixInverse: {
      value: new Matrix4()
    },
    resolution: {
      value: new Vector2()
    }
  },
  vertexShader: `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;
		uniform float maxDistance;
		uniform float opacity;
		uniform float fresnelCoe;
		uniform float virtualCameraNear;
		uniform float virtualCameraFar;
		uniform mat4 virtualCameraProjectionMatrix;
		uniform mat4 virtualCameraProjectionMatrixInverse;
		uniform mat4 virtualCameraMatrixWorld;
		uniform vec2 resolution;
		varying vec4 vUv;
		#include <packing>
		float blendOverlay( float base, float blend ) {
			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );
		}
		vec3 blendOverlay( vec3 base, vec3 blend ) {
			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			return perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view
		}
		void main() {
			vec4 base = texture2DProj( tDiffuse, vUv );
			#ifdef useDepthTexture
				vec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;
				uv.x=1.-uv.x;
				float depth = texture2DProj( tDepth, vUv ).r;
				float viewZ = getViewZ( depth );
				float clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];
				vec3 viewPosition=getViewPosition( uv, depth, clipW );
				vec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;
				if(worldPosition.y>maxDistance) discard;
				float op=opacity;
				#ifdef DISTANCE_ATTENUATION
					float ratio=1.-(worldPosition.y/maxDistance);
					float attenuation=ratio*ratio;
					op=opacity*attenuation;
				#endif
				#ifdef FRESNEL
					op*=fresnelCoe;
				#endif
				gl_FragColor = vec4( blendOverlay( base.rgb, color ), op );
			#else
				gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );
			#endif
		}
	`
};

// node_modules/three-stdlib/objects/Sky.js
var Sky = class extends Mesh {
  constructor() {
    super(new BoxGeometry(1, 1, 1), Sky.material);
  }
};
_defineProperty(Sky, "SkyShader", {
  uniforms: {
    turbidity: {
      value: 2
    },
    rayleigh: {
      value: 1
    },
    mieCoefficient: {
      value: 5e-3
    },
    mieDirectionalG: {
      value: 0.8
    },
    sunPosition: {
      value: new Vector3()
    },
    up: {
      value: new Vector3(0, 1, 0)
    }
  },
  vertexShader: [
    "uniform vec3 sunPosition;",
    "uniform float rayleigh;",
    "uniform float turbidity;",
    "uniform float mieCoefficient;",
    "uniform vec3 up;",
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "const float e = 2.71828182845904523536028747135266249775724709369995957;",
    "const float pi = 3.141592653589793238462643383279502884197169;",
    "const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );",
    "const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );",
    "const float v = 4.0;",
    "const vec3 K = vec3( 0.686, 0.678, 0.666 );",
    "const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );",
    "const float cutoffAngle = 1.6110731556870734;",
    "const float steepness = 1.5;",
    "const float EE = 1000.0;",
    "float sunIntensity( float zenithAngleCos ) {",
    "	zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );",
    "	return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );",
    "}",
    "vec3 totalMie( float T ) {",
    "	float c = ( 0.2 * T ) * 10E-18;",
    "	return 0.434 * c * MieConst;",
    "}",
    "void main() {",
    "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
    "	vWorldPosition = worldPosition.xyz;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "	gl_Position.z = gl_Position.w;",
    "	vSunDirection = normalize( sunPosition );",
    "	vSunE = sunIntensity( dot( vSunDirection, up ) );",
    "	vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );",
    "	float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );",
    "	vBetaR = totalRayleigh * rayleighCoefficient;",
    "	vBetaM = totalMie( turbidity ) * mieCoefficient;",
    "}"
  ].join("\n"),
  fragmentShader: [
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "uniform float mieDirectionalG;",
    "uniform vec3 up;",
    "const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );",
    "const float pi = 3.141592653589793238462643383279502884197169;",
    "const float n = 1.0003;",
    "const float N = 2.545E25;",
    "const float rayleighZenithLength = 8.4E3;",
    "const float mieZenithLength = 1.25E3;",
    "const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;",
    "const float THREE_OVER_SIXTEENPI = 0.05968310365946075;",
    "const float ONE_OVER_FOURPI = 0.07957747154594767;",
    "float rayleighPhase( float cosTheta ) {",
    "	return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );",
    "}",
    "float hgPhase( float cosTheta, float g ) {",
    "	float g2 = pow( g, 2.0 );",
    "	float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );",
    "	return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );",
    "}",
    "void main() {",
    "	vec3 direction = normalize( vWorldPosition - cameraPos );",
    "	float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );",
    "	float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );",
    "	float sR = rayleighZenithLength * inverse;",
    "	float sM = mieZenithLength * inverse;",
    "	vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );",
    "	float cosTheta = dot( direction, vSunDirection );",
    "	float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );",
    "	vec3 betaRTheta = vBetaR * rPhase;",
    "	float mPhase = hgPhase( cosTheta, mieDirectionalG );",
    "	vec3 betaMTheta = vBetaM * mPhase;",
    "	vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );",
    "	Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );",
    "	float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]",
    "	float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]",
    "	vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );",
    "	vec3 L0 = vec3( 0.1 ) * Fex;",
    "	float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );",
    "	L0 += ( vSunE * 19000.0 * Fex ) * sundisk;",
    "	vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );",
    "	vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );",
    "	gl_FragColor = vec4( retColor, 1.0 );",
    "#include <tonemapping_fragment>",
    "#include <encodings_fragment>",
    "}"
  ].join("\n")
});
_defineProperty(Sky, "material", new ShaderMaterial({
  name: "SkyShader",
  fragmentShader: Sky.SkyShader.fragmentShader,
  vertexShader: Sky.SkyShader.vertexShader,
  uniforms: UniformsUtils.clone(Sky.SkyShader.uniforms),
  side: BackSide,
  depthWrite: false
}));

// node_modules/three-stdlib/objects/Water2.js
var Water22 = class extends Mesh {
  constructor(geometry, options = {}) {
    super(geometry);
    this.type = "Water";
    const scope2 = this;
    const color2 = options.color !== void 0 ? new Color(options.color) : new Color(16777215);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const flowDirection = options.flowDirection || new Vector2(1, 0);
    const flowSpeed = options.flowSpeed || 0.03;
    const reflectivity = options.reflectivity || 0.02;
    const scale = options.scale || 1;
    const shader = options.shader || Water.WaterShader;
    const encoding = options.encoding !== void 0 ? options.encoding : LinearEncoding;
    const textureLoader = new TextureLoader();
    const flowMap = options.flowMap || void 0;
    const normalMap0 = options.normalMap0 || textureLoader.load("textures/water/Water_1_M_Normal.jpg");
    const normalMap1 = options.normalMap1 || textureLoader.load("textures/water/Water_2_M_Normal.jpg");
    const cycle = 0.15;
    const halfCycle = cycle * 0.5;
    const textureMatrix = new Matrix4();
    const clock = new Clock();
    if (Reflector === void 0) {
      console.error("THREE.Water: Required component Reflector not found.");
      return;
    }
    if (Refractor === void 0) {
      console.error("THREE.Water: Required component Refractor not found.");
      return;
    }
    const reflector = new Reflector(geometry, {
      textureWidth,
      textureHeight,
      clipBias,
      encoding
    });
    const refractor = new Refractor(geometry, {
      textureWidth,
      textureHeight,
      clipBias,
      encoding
    });
    reflector.matrixAutoUpdate = false;
    refractor.matrixAutoUpdate = false;
    this.material = new ShaderMaterial({
      uniforms: UniformsUtils.merge([UniformsLib["fog"], shader.uniforms]),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      transparent: true,
      fog: true
    });
    if (flowMap !== void 0) {
      this.material.defines.USE_FLOWMAP = "";
      this.material.uniforms["tFlowMap"] = {
        type: "t",
        value: flowMap
      };
    } else {
      this.material.uniforms["flowDirection"] = {
        type: "v2",
        value: flowDirection
      };
    }
    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;
    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;
    this.material.uniforms["tReflectionMap"].value = reflector.getRenderTarget().texture;
    this.material.uniforms["tRefractionMap"].value = refractor.getRenderTarget().texture;
    this.material.uniforms["tNormalMap0"].value = normalMap0;
    this.material.uniforms["tNormalMap1"].value = normalMap1;
    this.material.uniforms["color"].value = color2;
    this.material.uniforms["reflectivity"].value = reflectivity;
    this.material.uniforms["textureMatrix"].value = textureMatrix;
    this.material.uniforms["config"].value.x = 0;
    this.material.uniforms["config"].value.y = halfCycle;
    this.material.uniforms["config"].value.z = halfCycle;
    this.material.uniforms["config"].value.w = scale;
    function updateTextureMatrix(camera) {
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(camera.projectionMatrix);
      textureMatrix.multiply(camera.matrixWorldInverse);
      textureMatrix.multiply(scope2.matrixWorld);
    }
    function updateFlow() {
      const delta = clock.getDelta();
      const config = scope2.material.uniforms["config"];
      config.value.x += flowSpeed * delta;
      config.value.y = config.value.x + halfCycle;
      if (config.value.x >= cycle) {
        config.value.x = 0;
        config.value.y = halfCycle;
      } else if (config.value.y >= cycle) {
        config.value.y = config.value.y - cycle;
      }
    }
    this.onBeforeRender = function(renderer, scene, camera) {
      updateTextureMatrix(camera);
      updateFlow();
      scope2.visible = false;
      reflector.matrixWorld.copy(scope2.matrixWorld);
      refractor.matrixWorld.copy(scope2.matrixWorld);
      reflector.onBeforeRender(renderer, scene, camera);
      refractor.onBeforeRender(renderer, scene, camera);
      scope2.visible = true;
    };
  }
};
Water22.prototype.isWater = true;
Water22.WaterShader = {
  uniforms: {
    color: {
      type: "c",
      value: null
    },
    reflectivity: {
      type: "f",
      value: 0
    },
    tReflectionMap: {
      type: "t",
      value: null
    },
    tRefractionMap: {
      type: "t",
      value: null
    },
    tNormalMap0: {
      type: "t",
      value: null
    },
    tNormalMap1: {
      type: "t",
      value: null
    },
    textureMatrix: {
      type: "m4",
      value: null
    },
    config: {
      type: "v4",
      value: new Vector4()
    }
  },
  vertexShader: `

		#include <common>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>

		uniform mat4 textureMatrix;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			vUv = uv;
			vCoord = textureMatrix * vec4( position, 1.0 );

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vToEye = cameraPosition - worldPosition.xyz;

			vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex
			gl_Position = projectionMatrix * mvPosition;

			#include <logdepthbuf_vertex>
			#include <fog_vertex>

		}`,
  fragmentShader: `

		#include <common>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>

		uniform sampler2D tReflectionMap;
		uniform sampler2D tRefractionMap;
		uniform sampler2D tNormalMap0;
		uniform sampler2D tNormalMap1;

		#ifdef USE_FLOWMAP
			uniform sampler2D tFlowMap;
		#else
			uniform vec2 flowDirection;
		#endif

		uniform vec3 color;
		uniform float reflectivity;
		uniform vec4 config;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			#include <logdepthbuf_fragment>

			float flowMapOffset0 = config.x;
			float flowMapOffset1 = config.y;
			float halfCycle = config.z;
			float scale = config.w;

			vec3 toEye = normalize( vToEye );

			// determine flow direction
			vec2 flow;
			#ifdef USE_FLOWMAP
				flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;
			#else
				flow = flowDirection;
			#endif
			flow.x *= - 1.0;

			// sample normal maps (distort uvs with flowdata)
			vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );
			vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );

			// linear interpolate to get the final normal color
			float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;
			vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );

			// calculate normal vector
			vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );

			// calculate the fresnel term to blend reflection and refraction maps
			float theta = max( dot( toEye, normal ), 0.0 );
			float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );

			// calculate final uv coords
			vec3 coord = vCoord.xyz / vCoord.w;
			vec2 uv = coord.xy + coord.z * normal.xz * 0.05;

			vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );
			vec4 refractColor = texture2D( tRefractionMap, uv );

			// multiply water color with the mix of both textures
			gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>

		}`
};

// node_modules/three-stdlib/objects/GroundProjectedEnv.js
var isCubeTexture = (def) => def && def.isCubeTexture;
var GroundProjectedEnv = class extends Mesh {
  constructor(texture2, options) {
    var _ref, _texture$image$;
    const isCubeMap = isCubeTexture(texture2);
    const w = (_ref = isCubeMap ? (_texture$image$ = texture2.image[0]) === null || _texture$image$ === void 0 ? void 0 : _texture$image$.width : texture2.image.width) != null ? _ref : 1024;
    const cubeSize = w / 4;
    const _lodMax = Math.floor(Math.log2(cubeSize));
    const _cubeSize = Math.pow(2, _lodMax);
    const width = 3 * Math.max(_cubeSize, 16 * 7);
    const height = 4 * _cubeSize;
    const defines = [isCubeMap ? "#define ENVMAP_TYPE_CUBE" : "", `#define CUBEUV_TEXEL_WIDTH ${1 / width}`, `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`, `#define CUBEUV_MAX_MIP ${_lodMax}.0`];
    const vertexShader = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `;
    const fragmentShader = defines.join("\n") + `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <encodings_fragment>
        }
        `;
    const uniforms = {
      map: {
        value: texture2
      },
      height: {
        value: (options === null || options === void 0 ? void 0 : options.height) || 15
      },
      radius: {
        value: (options === null || options === void 0 ? void 0 : options.radius) || 100
      }
    };
    const geometry = new IcosahedronGeometry(1, 16);
    const material = new ShaderMaterial({
      uniforms,
      fragmentShader,
      vertexShader,
      side: DoubleSide
    });
    super(geometry, material);
  }
  set radius(radius) {
    this.material.uniforms.radius.value = radius;
  }
  get radius() {
    return this.material.uniforms.radius.value;
  }
  set height(height) {
    this.material.uniforms.height.value = height;
  }
  get height() {
    return this.material.uniforms.height.value;
  }
};

// node_modules/three-stdlib/utils/SceneUtils.js
var SceneUtils = {
  createMeshesFromInstancedMesh: function(instancedMesh) {
    const group = new Group();
    const count = instancedMesh.count;
    const geometry = instancedMesh.geometry;
    const material = instancedMesh.material;
    for (let i2 = 0; i2 < count; i2++) {
      const mesh = new Mesh(geometry, material);
      instancedMesh.getMatrixAt(i2, mesh.matrix);
      mesh.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);
      group.add(mesh);
    }
    group.copy(instancedMesh);
    group.updateMatrixWorld();
    return group;
  },
  createMultiMaterialObject: function(geometry, materials) {
    const group = new Group();
    for (let i2 = 0, l = materials.length; i2 < l; i2++) {
      group.add(new Mesh(geometry, materials[i2]));
    }
    return group;
  },
  detach: function(child, parent, scene) {
    console.warn("THREE.SceneUtils: detach() has been deprecated. Use scene.attach( child ) instead.");
    scene.attach(child);
  },
  attach: function(child, scene, parent) {
    console.warn("THREE.SceneUtils: attach() has been deprecated. Use parent.attach( child ) instead.");
    parent.attach(child);
  }
};

// node_modules/three-stdlib/utils/UVsDebug.js
var UVsDebug = function(geometry, size2) {
  var abc = "abc";
  var a2 = new Vector2();
  var b3 = new Vector2();
  var uvs = [new Vector2(), new Vector2(), new Vector2()];
  var face = [];
  var canvas = document.createElement("canvas");
  var width = size2 || 1024;
  var height = size2 || 1024;
  canvas.width = width;
  canvas.height = height;
  var ctx = canvas.getContext("2d");
  ctx.lineWidth = 1;
  ctx.strokeStyle = "rgb( 63, 63, 63 )";
  ctx.textAlign = "center";
  ctx.fillStyle = "rgb( 255, 255, 255 )";
  ctx.fillRect(0, 0, width, height);
  if (geometry.isGeometry) {
    console.error("THREE.UVsDebug no longer supports Geometry. Use THREE.BufferGeometry instead.");
    return;
  } else {
    var index = geometry.index;
    var uvAttribute = geometry.attributes.uv;
    if (index) {
      for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
        face[0] = index.getX(i2);
        face[1] = index.getX(i2 + 1);
        face[2] = index.getX(i2 + 2);
        uvs[0].fromBufferAttribute(uvAttribute, face[0]);
        uvs[1].fromBufferAttribute(uvAttribute, face[1]);
        uvs[2].fromBufferAttribute(uvAttribute, face[2]);
        processFace(face, uvs, i2 / 3);
      }
    } else {
      for (let i2 = 0, il = uvAttribute.count; i2 < il; i2 += 3) {
        face[0] = i2;
        face[1] = i2 + 1;
        face[2] = i2 + 2;
        uvs[0].fromBufferAttribute(uvAttribute, face[0]);
        uvs[1].fromBufferAttribute(uvAttribute, face[1]);
        uvs[2].fromBufferAttribute(uvAttribute, face[2]);
        processFace(face, uvs, i2 / 3);
      }
    }
  }
  return canvas;
  function processFace(face2, uvs2, index2) {
    ctx.beginPath();
    a2.set(0, 0);
    for (let j2 = 0, jl2 = uvs2.length; j2 < jl2; j2++) {
      var uv2 = uvs2[j2];
      a2.x += uv2.x;
      a2.y += uv2.y;
      if (j2 === 0) {
        ctx.moveTo(uv2.x * (width - 2) + 0.5, (1 - uv2.y) * (height - 2) + 0.5);
      } else {
        ctx.lineTo(uv2.x * (width - 2) + 0.5, (1 - uv2.y) * (height - 2) + 0.5);
      }
    }
    ctx.closePath();
    ctx.stroke();
    a2.divideScalar(uvs2.length);
    ctx.font = "18px Arial";
    ctx.fillStyle = "rgb( 63, 63, 63 )";
    ctx.fillText(index2, a2.x * width, (1 - a2.y) * height);
    if (a2.x > 0.95) {
      ctx.fillText(index2, a2.x % 1 * width, (1 - a2.y) * height);
    }
    ctx.font = "12px Arial";
    ctx.fillStyle = "rgb( 191, 191, 191 )";
    for (j = 0, jl = uvs2.length; j < jl; j++) {
      var uv2 = uvs2[j];
      b3.addVectors(a2, uv2).divideScalar(2);
      var vnum = face2[j];
      ctx.fillText(abc[j] + vnum, b3.x * width, (1 - b3.y) * height);
      if (b3.x > 0.95) {
        ctx.fillText(abc[j] + vnum, b3.x % 1 * width, (1 - b3.y) * height);
      }
    }
  }
};

// node_modules/three-stdlib/utils/GeometryUtils.js
var hilbert2D = (center = new Vector3(0, 0, 0), size2 = 10, iterations = 1, v0 = 0, v12 = 1, v2 = 2, v3 = 3) => {
  const half = size2 / 2;
  const vec_s = [new Vector3(center.x - half, center.y, center.z - half), new Vector3(center.x - half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z - half)];
  const vec = [vec_s[v0], vec_s[v12], vec_s[v2], vec_s[v3]];
  if (0 <= --iterations) {
    const tmp = [];
    Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v12));
    Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v12, v2, v3));
    Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v12, v2, v3));
    Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v12, v0, v3));
    return tmp;
  }
  return vec;
};
var hilbert3D = (center = new Vector3(0, 0, 0), size2 = 10, iterations = 1, v0 = 0, v12 = 1, v2 = 2, v3 = 3, v4 = 4, v5 = 5, v6 = 6, v7 = 7) => {
  const half = size2 / 2;
  const vec_s = [new Vector3(center.x - half, center.y + half, center.z - half), new Vector3(center.x - half, center.y + half, center.z + half), new Vector3(center.x - half, center.y - half, center.z + half), new Vector3(center.x - half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z + half), new Vector3(center.x + half, center.y + half, center.z + half), new Vector3(center.x + half, center.y + half, center.z - half)];
  const vec = [vec_s[v0], vec_s[v12], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]];
  if (--iterations >= 0) {
    const tmp = [];
    Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v12));
    Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v12, v2, v5, v4, v3));
    Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v12, v2, v5, v4, v3));
    Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v12, v6, v7, v4, v5));
    Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v12, v6, v7, v4, v5));
    Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v12, v0, v7));
    Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v12, v0, v7));
    Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v12, v0, v3, v4, v7));
    return tmp;
  }
  return vec;
};
var gosper = (size2 = 1) => {
  function fractalize(config) {
    let output = "";
    let input = config.axiom;
    for (let i2 = 0, il = config.steps; 0 <= il ? i2 < il : i2 > il; 0 <= il ? i2++ : i2--) {
      output = "";
      for (let j2 = 0, jl2 = input.length; j2 < jl2; j2++) {
        const char = input[j2];
        if (char in config.rules) {
          output += config.rules[char];
        } else {
          output += char;
        }
      }
      input = output;
    }
    return output;
  }
  function toPoints(config) {
    let currX = 0;
    let currY = 0;
    let angle = 0;
    const path = [0, 0, 0];
    const fractal = config.fractal;
    for (let i2 = 0, l = fractal.length; i2 < l; i2++) {
      const char = fractal[i2];
      if (char === "+") {
        angle += config.angle;
      } else if (char === "-") {
        angle -= config.angle;
      } else if (char === "F") {
        currX += config.size * Math.cos(angle);
        currY += -config.size * Math.sin(angle);
        path.push(currX, currY, 0);
      }
    }
    return path;
  }
  const gosper2 = fractalize({
    axiom: "A",
    steps: 4,
    rules: {
      A: "A+BF++BF-FA--FAFA-BF+",
      B: "-FA+BFBF++BF+FA--FA-B"
    }
  });
  const points = toPoints({
    fractal: gosper2,
    size: size2,
    angle: Math.PI / 3
  });
  return points;
};
var GeometryUtils = {
  hilbert3D,
  gosper,
  hilbert2D
};

// node_modules/three-stdlib/utils/RoughnessMipmapper.js
var _mipmapMaterial = _getMipmapMaterial();
var _mesh = new Mesh(new PlaneGeometry(2, 2), _mipmapMaterial);
var _flatCamera = new OrthographicCamera(0, 1, 0, 1, 0, 1);
var _tempTarget = null;
var _renderer = null;
function RoughnessMipmapper(renderer) {
  _renderer = renderer;
  _renderer.compile(_mesh, _flatCamera);
}
RoughnessMipmapper.prototype = {
  constructor: RoughnessMipmapper,
  generateMipmaps: function(material) {
    if ("roughnessMap" in material === false)
      return;
    var {
      roughnessMap,
      normalMap
    } = material;
    if (roughnessMap === null || normalMap === null || !roughnessMap.generateMipmaps || material.userData.roughnessUpdated) {
      return;
    }
    material.userData.roughnessUpdated = true;
    var width = Math.max(roughnessMap.image.width, normalMap.image.width);
    var height = Math.max(roughnessMap.image.height, normalMap.image.height);
    if (!MathUtils.isPowerOfTwo(width) || !MathUtils.isPowerOfTwo(height))
      return;
    var oldTarget = _renderer.getRenderTarget();
    var autoClear = _renderer.autoClear;
    _renderer.autoClear = false;
    if (_tempTarget === null || _tempTarget.width !== width || _tempTarget.height !== height) {
      if (_tempTarget !== null)
        _tempTarget.dispose();
      _tempTarget = new WebGLRenderTarget(width, height, {
        depthBuffer: false
      });
      _tempTarget.scissorTest = true;
    }
    if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {
      var params = {
        wrapS: roughnessMap.wrapS,
        wrapT: roughnessMap.wrapT,
        magFilter: roughnessMap.magFilter,
        minFilter: roughnessMap.minFilter,
        depthBuffer: false
      };
      var newRoughnessTarget = new WebGLRenderTarget(width, height, params);
      newRoughnessTarget.texture.generateMipmaps = true;
      _renderer.setRenderTarget(newRoughnessTarget);
      material.roughnessMap = newRoughnessTarget.texture;
      if (material.metalnessMap == roughnessMap)
        material.metalnessMap = material.roughnessMap;
      if (material.aoMap == roughnessMap)
        material.aoMap = material.roughnessMap;
    }
    _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;
    _mipmapMaterial.uniforms.normalMap.value = normalMap;
    var position = new Vector2(0, 0);
    var texelSize = _mipmapMaterial.uniforms.texelSize.value;
    for (let mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2) {
      texelSize.set(1 / width, 1 / height);
      if (mip == 0)
        texelSize.set(0, 0);
      _tempTarget.viewport.set(position.x, position.y, width, height);
      _tempTarget.scissor.set(position.x, position.y, width, height);
      _renderer.setRenderTarget(_tempTarget);
      _renderer.render(_mesh, _flatCamera);
      _renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);
      _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (roughnessMap !== material.roughnessMap)
      roughnessMap.dispose();
    _renderer.setRenderTarget(oldTarget);
    _renderer.autoClear = autoClear;
  },
  dispose: function() {
    _mipmapMaterial.dispose();
    _mesh.geometry.dispose();
    if (_tempTarget != null)
      _tempTarget.dispose();
  }
};
function _getMipmapMaterial() {
  var shaderMaterial = new RawShaderMaterial({
    uniforms: {
      roughnessMap: {
        value: null
      },
      normalMap: {
        value: null
      },
      texelSize: {
        value: new Vector2(1, 1)
      }
    },
    vertexShader: `
			precision mediump float;
			precision mediump int;

			attribute vec3 position;
			attribute vec2 uv;

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = vec4( position, 1.0 );

			}
		`,
    fragmentShader: `
			precision mediump float;
			precision mediump int;

			varying vec2 vUv;

			uniform sampler2D roughnessMap;
			uniform sampler2D normalMap;
			uniform vec2 texelSize;

			#define ENVMAP_TYPE_CUBE_UV

			vec4 envMapTexelToLinear( vec4 a ) { return a; }

			#include <cube_uv_reflection_fragment>

			float roughnessToVariance( float roughness ) {

				float variance = 0.0;

				if ( roughness >= r1 ) {

					variance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;

				} else if ( roughness >= r4 ) {

					variance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;

				} else if ( roughness >= r5 ) {

					variance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;

				} else {

					float roughness2 = roughness * roughness;

					variance = 1.79 * roughness2 * roughness2;

				}

				return variance;

			}

			float varianceToRoughness( float variance ) {

				float roughness = 0.0;

				if ( variance >= v1 ) {

					roughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;

				} else if ( variance >= v4 ) {

					roughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;

				} else if ( variance >= v5 ) {

					roughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;

				} else {

					roughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79

				}

				return roughness;

			}

			void main() {

				gl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );

				if ( texelSize.x == 0.0 ) return;

				float roughness = gl_FragColor.g;

				float variance = roughnessToVariance( roughness );

				vec3 avgNormal;

				for ( float x = - 1.0; x < 2.0; x += 2.0 ) {

					for ( float y = - 1.0; y < 2.0; y += 2.0 ) {

						vec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;

						avgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );

					}

				}

				variance += 1.0 - 0.25 * length( avgNormal );

				gl_FragColor.g = varianceToRoughness( variance );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  shaderMaterial.type = "RoughnessMipmapper";
  return shaderMaterial;
}

// node_modules/three-stdlib/utils/SkeletonUtils.js
var SkeletonUtils = {
  retarget: function() {
    var pos = new Vector3(), quat = new Quaternion(), scale = new Vector3(), bindBoneMatrix = new Matrix4(), relativeMatrix = new Matrix4(), globalMatrix = new Matrix4();
    return function(target, source, options) {
      options = options || {};
      options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;
      options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;
      options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;
      options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;
      options.hip = options.hip !== void 0 ? options.hip : "hip";
      options.names = options.names || {};
      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source), bones = target.isObject3D ? target.skeleton.bones : this.getBones(target), bindBones, bone, name, boneTo, bonesPosition, i2;
      if (target.isObject3D) {
        target.skeleton.pose();
      } else {
        options.useTargetMatrix = true;
        options.preserveMatrix = false;
      }
      if (options.preservePosition) {
        bonesPosition = [];
        for (i2 = 0; i2 < bones.length; i2++) {
          bonesPosition.push(bones[i2].position.clone());
        }
      }
      if (options.preserveMatrix) {
        target.updateMatrixWorld();
        target.matrixWorld.identity();
        for (i2 = 0; i2 < target.children.length; ++i2) {
          target.children[i2].updateMatrixWorld(true);
        }
      }
      if (options.offsets) {
        bindBones = [];
        for (i2 = 0; i2 < bones.length; ++i2) {
          bone = bones[i2];
          name = options.names[bone.name] || bone.name;
          if (options.offsets && options.offsets[name]) {
            bone.matrix.multiply(options.offsets[name]);
            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            bone.updateMatrixWorld();
          }
          bindBones.push(bone.matrixWorld.clone());
        }
      }
      for (i2 = 0; i2 < bones.length; ++i2) {
        bone = bones[i2];
        name = options.names[bone.name] || bone.name;
        boneTo = this.getBoneByName(name, sourceBones);
        globalMatrix.copy(bone.matrixWorld);
        if (boneTo) {
          boneTo.updateMatrixWorld();
          if (options.useTargetMatrix) {
            relativeMatrix.copy(boneTo.matrixWorld);
          } else {
            relativeMatrix.copy(target.matrixWorld).invert();
            relativeMatrix.multiply(boneTo.matrixWorld);
          }
          scale.setFromMatrixScale(relativeMatrix);
          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));
          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));
          if (target.isObject3D) {
            var boneIndex = bones.indexOf(bone), wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();
            globalMatrix.multiply(wBindMatrix);
          }
          globalMatrix.copyPosition(relativeMatrix);
        }
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(globalMatrix);
        } else {
          bone.matrix.copy(globalMatrix);
        }
        if (options.preserveHipPosition && name === options.hip) {
          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        bone.updateMatrixWorld();
      }
      if (options.preservePosition) {
        for (i2 = 0; i2 < bones.length; ++i2) {
          bone = bones[i2];
          name = options.names[bone.name] || bone.name;
          if (name !== options.hip) {
            bone.position.copy(bonesPosition[i2]);
          }
        }
      }
      if (options.preserveMatrix) {
        target.updateMatrixWorld(true);
      }
    };
  }(),
  retargetClip: function(target, source, clip, options) {
    options = options || {};
    options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;
    options.fps = options.fps !== void 0 ? options.fps : 30;
    options.names = options.names || [];
    if (!source.isObject3D) {
      source = this.getHelperFromSkeleton(source);
    }
    var numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3), delta = 1 / options.fps, convertedTracks = [], mixer = new AnimationMixer(source), bones = this.getBones(target.skeleton), boneDatas = [], positionOffset, bone, boneTo, boneData, name, i2, j2;
    mixer.clipAction(clip).play();
    mixer.update(0);
    source.updateMatrixWorld();
    for (i2 = 0; i2 < numFrames; ++i2) {
      var time = i2 * delta;
      this.retarget(target, source, options);
      for (j2 = 0; j2 < bones.length; ++j2) {
        name = options.names[bones[j2].name] || bones[j2].name;
        boneTo = this.getBoneByName(name, source.skeleton);
        if (boneTo) {
          bone = bones[j2];
          boneData = boneDatas[j2] = boneDatas[j2] || {
            bone
          };
          if (options.hip === name) {
            if (!boneData.pos) {
              boneData.pos = {
                times: new Float32Array(numFrames),
                values: new Float32Array(numFrames * 3)
              };
            }
            if (options.useFirstFramePosition) {
              if (i2 === 0) {
                positionOffset = bone.position.clone();
              }
              bone.position.sub(positionOffset);
            }
            boneData.pos.times[i2] = time;
            bone.position.toArray(boneData.pos.values, i2 * 3);
          }
          if (!boneData.quat) {
            boneData.quat = {
              times: new Float32Array(numFrames),
              values: new Float32Array(numFrames * 4)
            };
          }
          boneData.quat.times[i2] = time;
          bone.quaternion.toArray(boneData.quat.values, i2 * 4);
        }
      }
      mixer.update(delta);
      source.updateMatrixWorld();
    }
    for (i2 = 0; i2 < boneDatas.length; ++i2) {
      boneData = boneDatas[i2];
      if (boneData) {
        if (boneData.pos) {
          convertedTracks.push(new VectorKeyframeTrack(".bones[" + boneData.bone.name + "].position", boneData.pos.times, boneData.pos.values));
        }
        convertedTracks.push(new QuaternionKeyframeTrack(".bones[" + boneData.bone.name + "].quaternion", boneData.quat.times, boneData.quat.values));
      }
    }
    mixer.uncacheAction(clip);
    return new AnimationClip(clip.name, -1, convertedTracks);
  },
  getHelperFromSkeleton: function(skeleton) {
    var source = new SkeletonHelper(skeleton.bones[0]);
    source.skeleton = skeleton;
    return source;
  },
  getSkeletonOffsets: function() {
    var targetParentPos = new Vector3(), targetPos = new Vector3(), sourceParentPos = new Vector3(), sourcePos = new Vector3(), targetDir = new Vector2(), sourceDir = new Vector2();
    return function(target, source, options) {
      options = options || {};
      options.hip = options.hip !== void 0 ? options.hip : "hip";
      options.names = options.names || {};
      if (!source.isObject3D) {
        source = this.getHelperFromSkeleton(source);
      }
      var nameKeys = Object.keys(options.names), nameValues = Object.values(options.names), sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source), bones = target.isObject3D ? target.skeleton.bones : this.getBones(target), offsets = [], bone, boneTo, name, i2;
      target.skeleton.pose();
      for (i2 = 0; i2 < bones.length; ++i2) {
        bone = bones[i2];
        name = options.names[bone.name] || bone.name;
        boneTo = this.getBoneByName(name, sourceBones);
        if (boneTo && name !== options.hip) {
          var boneParent = this.getNearestBone(bone.parent, nameKeys), boneToParent = this.getNearestBone(boneTo.parent, nameValues);
          boneParent.updateMatrixWorld();
          boneToParent.updateMatrixWorld();
          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);
          targetPos.setFromMatrixPosition(bone.matrixWorld);
          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);
          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);
          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();
          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();
          var laterialAngle = targetDir.angle() - sourceDir.angle();
          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));
          bone.matrix.multiply(offset);
          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
          bone.updateMatrixWorld();
          offsets[name] = offset;
        }
      }
      return offsets;
    };
  }(),
  renameBones: function(skeleton, names) {
    var bones = this.getBones(skeleton);
    for (let i2 = 0; i2 < bones.length; ++i2) {
      var bone = bones[i2];
      if (names[bone.name]) {
        bone.name = names[bone.name];
      }
    }
    return this;
  },
  getBones: function(skeleton) {
    return Array.isArray(skeleton) ? skeleton : skeleton.bones;
  },
  getBoneByName: function(name, skeleton) {
    for (let i2 = 0, bones = this.getBones(skeleton); i2 < bones.length; i2++) {
      if (name === bones[i2].name)
        return bones[i2];
    }
  },
  getNearestBone: function(bone, names) {
    while (bone.isBone) {
      if (names.indexOf(bone.name) !== -1) {
        return bone;
      }
      bone = bone.parent;
    }
  },
  findBoneTrackData: function(name, tracks) {
    var regexp = /\[(.*)\]\.(.*)/, result = {
      name
    };
    for (let i2 = 0; i2 < tracks.length; ++i2) {
      var trackData = regexp.exec(tracks[i2].name);
      if (trackData && name === trackData[1]) {
        result[trackData[2]] = i2;
      }
    }
    return result;
  },
  getEqualsBonesNames: function(skeleton, targetSkeleton) {
    var sourceBones = this.getBones(skeleton), targetBones = this.getBones(targetSkeleton), bones = [];
    search:
      for (let i2 = 0; i2 < sourceBones.length; i2++) {
        var boneName = sourceBones[i2].name;
        for (let j2 = 0; j2 < targetBones.length; j2++) {
          if (boneName === targetBones[j2].name) {
            bones.push(boneName);
            continue search;
          }
        }
      }
    return bones;
  },
  clone: function(source) {
    var sourceLookup = /* @__PURE__ */ new Map();
    var cloneLookup = /* @__PURE__ */ new Map();
    var clone = source.clone();
    parallelTraverse(source, clone, function(sourceNode, clonedNode) {
      sourceLookup.set(clonedNode, sourceNode);
      cloneLookup.set(sourceNode, clonedNode);
    });
    clone.traverse(function(node) {
      if (!node.isSkinnedMesh)
        return;
      var clonedMesh = node;
      var sourceMesh = sourceLookup.get(node);
      var sourceBones = sourceMesh.skeleton.bones;
      clonedMesh.skeleton = sourceMesh.skeleton.clone();
      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);
      clonedMesh.skeleton.bones = sourceBones.map(function(bone) {
        return cloneLookup.get(bone);
      });
      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);
    });
    return clone;
  }
};
function parallelTraverse(a2, b3, callback) {
  callback(a2, b3);
  for (let i2 = 0; i2 < a2.children.length; i2++) {
    parallelTraverse(a2.children[i2], b3.children[i2], callback);
  }
}

// node_modules/three-stdlib/shaders/UnpackDepthRGBAShader.js
var UnpackDepthRGBAShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    opacity: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "#include <packing>", "void main() {", "	float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );", "	gl_FragColor = vec4( vec3( depth ), opacity );", "}"].join("\n")
};

// node_modules/three-stdlib/utils/ShadowMapViewer.js
var ShadowMapViewer = function(light) {
  var scope2 = this;
  var doRenderLabel = light.name !== void 0 && light.name !== "";
  var userAutoClearSetting;
  var frame = {
    x: 10,
    y: 10,
    width: 256,
    height: 256
  };
  var camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);
  camera.position.set(0, 0, 2);
  var scene = new Scene();
  var shader = UnpackDepthRGBAShader;
  var uniforms = UniformsUtils.clone(shader.uniforms);
  var material = new ShaderMaterial({
    uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader
  });
  var plane = new PlaneGeometry(frame.width, frame.height);
  var mesh = new Mesh(plane, material);
  scene.add(mesh);
  var labelCanvas, labelMesh;
  if (doRenderLabel) {
    labelCanvas = document.createElement("canvas");
    var context = labelCanvas.getContext("2d");
    context.font = "Bold 20px Arial";
    var labelWidth = context.measureText(light.name).width;
    labelCanvas.width = labelWidth;
    labelCanvas.height = 25;
    context.font = "Bold 20px Arial";
    context.fillStyle = "rgba( 255, 0, 0, 1 )";
    context.fillText(light.name, 0, 20);
    var labelTexture = new Texture(labelCanvas);
    labelTexture.magFilter = LinearFilter;
    labelTexture.minFilter = LinearFilter;
    labelTexture.needsUpdate = true;
    var labelMaterial = new MeshBasicMaterial({
      map: labelTexture,
      side: DoubleSide
    });
    labelMaterial.transparent = true;
    var labelPlane = new PlaneGeometry(labelCanvas.width, labelCanvas.height);
    labelMesh = new Mesh(labelPlane, labelMaterial);
    scene.add(labelMesh);
  }
  function resetPosition() {
    scope2.position.set(scope2.position.x, scope2.position.y);
  }
  this.enabled = true;
  this.size = {
    width: frame.width,
    height: frame.height,
    set: function(width, height) {
      this.width = width;
      this.height = height;
      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1);
      resetPosition();
    }
  };
  this.position = {
    x: frame.x,
    y: frame.y,
    set: function(x, y) {
      this.x = x;
      this.y = y;
      var width = scope2.size.width;
      var height = scope2.size.height;
      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);
      if (doRenderLabel) {
        labelMesh.position.set(mesh.position.x, mesh.position.y - scope2.size.height / 2 + labelCanvas.height / 2, 0);
      }
    }
  };
  this.render = function(renderer) {
    if (this.enabled) {
      uniforms.tDiffuse.value = light.shadow.map.texture;
      userAutoClearSetting = renderer.autoClear;
      renderer.autoClear = false;
      renderer.clearDepth();
      renderer.render(scene, camera);
      renderer.autoClear = userAutoClearSetting;
    }
  };
  this.updateForWindowResize = function() {
    if (this.enabled) {
      camera.left = window.innerWidth / -2;
      camera.right = window.innerWidth / 2;
      camera.top = window.innerHeight / 2;
      camera.bottom = window.innerHeight / -2;
      camera.updateProjectionMatrix();
      this.update();
    }
  };
  this.update = function() {
    this.position.set(this.position.x, this.position.y);
    this.size.set(this.size.width, this.size.height);
  };
  this.update();
};
ShadowMapViewer.prototype.constructor = ShadowMapViewer;

// node_modules/three-stdlib/utils/GeometryCompressionUtils.js
var GeometryCompressionUtils = {
  compressNormals: function(mesh, encodeMethod) {
    if (!mesh.geometry) {
      console.error("Mesh must contain geometry. ");
    }
    const normal = mesh.geometry.attributes.normal;
    if (!normal) {
      console.error("Geometry must contain normal attribute. ");
    }
    if (normal.isPacked)
      return;
    if (normal.itemSize != 3) {
      console.error("normal.itemSize is not 3, which cannot be encoded. ");
    }
    const array = normal.array;
    const count = normal.count;
    let result;
    if (encodeMethod == "DEFAULT") {
      result = new Uint8Array(count * 3);
      for (let idx = 0; idx < array.length; idx += 3) {
        const encoded = this.EncodingFuncs.defaultEncode(array[idx], array[idx + 1], array[idx + 2], 1);
        result[idx + 0] = encoded[0];
        result[idx + 1] = encoded[1];
        result[idx + 2] = encoded[2];
      }
      mesh.geometry.setAttribute("normal", new BufferAttribute(result, 3, true));
      mesh.geometry.attributes.normal.bytes = result.length * 1;
    } else if (encodeMethod == "OCT1Byte") {
      result = new Int8Array(count * 2);
      for (let idx = 0; idx < array.length; idx += 3) {
        const encoded = this.EncodingFuncs.octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 1);
        result[idx / 3 * 2 + 0] = encoded[0];
        result[idx / 3 * 2 + 1] = encoded[1];
      }
      mesh.geometry.setAttribute("normal", new BufferAttribute(result, 2, true));
      mesh.geometry.attributes.normal.bytes = result.length * 1;
    } else if (encodeMethod == "OCT2Byte") {
      result = new Int16Array(count * 2);
      for (let idx = 0; idx < array.length; idx += 3) {
        const encoded = this.EncodingFuncs.octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 2);
        result[idx / 3 * 2 + 0] = encoded[0];
        result[idx / 3 * 2 + 1] = encoded[1];
      }
      mesh.geometry.setAttribute("normal", new BufferAttribute(result, 2, true));
      mesh.geometry.attributes.normal.bytes = result.length * 2;
    } else if (encodeMethod == "ANGLES") {
      result = new Uint16Array(count * 2);
      for (let idx = 0; idx < array.length; idx += 3) {
        const encoded = this.EncodingFuncs.anglesEncode(array[idx], array[idx + 1], array[idx + 2]);
        result[idx / 3 * 2 + 0] = encoded[0];
        result[idx / 3 * 2 + 1] = encoded[1];
      }
      mesh.geometry.setAttribute("normal", new BufferAttribute(result, 2, true));
      mesh.geometry.attributes.normal.bytes = result.length * 2;
    } else {
      console.error("Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ");
    }
    mesh.geometry.attributes.normal.needsUpdate = true;
    mesh.geometry.attributes.normal.isPacked = true;
    mesh.geometry.attributes.normal.packingMethod = encodeMethod;
    if (!(mesh.material instanceof PackedPhongMaterial)) {
      mesh.material = new PackedPhongMaterial().copy(mesh.material);
    }
    if (encodeMethod == "ANGLES") {
      mesh.material.defines.USE_PACKED_NORMAL = 0;
    }
    if (encodeMethod == "OCT1Byte") {
      mesh.material.defines.USE_PACKED_NORMAL = 1;
    }
    if (encodeMethod == "OCT2Byte") {
      mesh.material.defines.USE_PACKED_NORMAL = 1;
    }
    if (encodeMethod == "DEFAULT") {
      mesh.material.defines.USE_PACKED_NORMAL = 2;
    }
  },
  compressPositions: function(mesh) {
    if (!mesh.geometry) {
      console.error("Mesh must contain geometry. ");
    }
    const position = mesh.geometry.attributes.position;
    if (!position) {
      console.error("Geometry must contain position attribute. ");
    }
    if (position.isPacked)
      return;
    if (position.itemSize != 3) {
      console.error("position.itemSize is not 3, which cannot be packed. ");
    }
    const array = position.array;
    const encodingBytes = 2;
    const result = this.EncodingFuncs.quantizedEncode(array, encodingBytes);
    const quantized = result.quantized;
    const decodeMat = result.decodeMat;
    if (mesh.geometry.boundingBox == null)
      mesh.geometry.computeBoundingBox();
    if (mesh.geometry.boundingSphere == null)
      mesh.geometry.computeBoundingSphere();
    mesh.geometry.setAttribute("position", new BufferAttribute(quantized, 3));
    mesh.geometry.attributes.position.isPacked = true;
    mesh.geometry.attributes.position.needsUpdate = true;
    mesh.geometry.attributes.position.bytes = quantized.length * encodingBytes;
    if (!(mesh.material instanceof PackedPhongMaterial)) {
      mesh.material = new PackedPhongMaterial().copy(mesh.material);
    }
    mesh.material.defines.USE_PACKED_POSITION = 0;
    mesh.material.uniforms.quantizeMatPos.value = decodeMat;
    mesh.material.uniforms.quantizeMatPos.needsUpdate = true;
  },
  compressUvs: function(mesh) {
    if (!mesh.geometry) {
      console.error("Mesh must contain geometry property. ");
    }
    const uvs = mesh.geometry.attributes.uv;
    if (!uvs) {
      console.error("Geometry must contain uv attribute. ");
    }
    if (uvs.isPacked)
      return;
    const range = {
      min: Infinity,
      max: -Infinity
    };
    const array = uvs.array;
    for (let i2 = 0; i2 < array.length; i2++) {
      range.min = Math.min(range.min, array[i2]);
      range.max = Math.max(range.max, array[i2]);
    }
    let result;
    if (range.min >= -1 && range.max <= 1) {
      result = new Uint16Array(array.length);
      for (let i2 = 0; i2 < array.length; i2 += 2) {
        const encoded = this.EncodingFuncs.defaultEncode(array[i2], array[i2 + 1], 0, 2);
        result[i2] = encoded[0];
        result[i2 + 1] = encoded[1];
      }
      mesh.geometry.setAttribute("uv", new BufferAttribute(result, 2, true));
      mesh.geometry.attributes.uv.isPacked = true;
      mesh.geometry.attributes.uv.needsUpdate = true;
      mesh.geometry.attributes.uv.bytes = result.length * 2;
      if (!(mesh.material instanceof PackedPhongMaterial)) {
        mesh.material = new PackedPhongMaterial().copy(mesh.material);
      }
      mesh.material.defines.USE_PACKED_UV = 0;
    } else {
      result = this.EncodingFuncs.quantizedEncodeUV(array, 2);
      mesh.geometry.setAttribute("uv", new BufferAttribute(result.quantized, 2));
      mesh.geometry.attributes.uv.isPacked = true;
      mesh.geometry.attributes.uv.needsUpdate = true;
      mesh.geometry.attributes.uv.bytes = result.quantized.length * 2;
      if (!(mesh.material instanceof PackedPhongMaterial)) {
        mesh.material = new PackedPhongMaterial().copy(mesh.material);
      }
      mesh.material.defines.USE_PACKED_UV = 1;
      mesh.material.uniforms.quantizeMatUV.value = result.decodeMat;
      mesh.material.uniforms.quantizeMatUV.needsUpdate = true;
    }
  },
  EncodingFuncs: {
    defaultEncode: function(x, y, z, bytes) {
      if (bytes == 1) {
        const tmpx = Math.round((x + 1) * 0.5 * 255);
        const tmpy = Math.round((y + 1) * 0.5 * 255);
        const tmpz = Math.round((z + 1) * 0.5 * 255);
        return new Uint8Array([tmpx, tmpy, tmpz]);
      } else if (bytes == 2) {
        const tmpx = Math.round((x + 1) * 0.5 * 65535);
        const tmpy = Math.round((y + 1) * 0.5 * 65535);
        const tmpz = Math.round((z + 1) * 0.5 * 65535);
        return new Uint16Array([tmpx, tmpy, tmpz]);
      } else {
        console.error("number of bytes must be 1 or 2");
      }
    },
    defaultDecode: function(array, bytes) {
      if (bytes == 1) {
        return [array[0] / 255 * 2 - 1, array[1] / 255 * 2 - 1, array[2] / 255 * 2 - 1];
      } else if (bytes == 2) {
        return [array[0] / 65535 * 2 - 1, array[1] / 65535 * 2 - 1, array[2] / 65535 * 2 - 1];
      } else {
        console.error("number of bytes must be 1 or 2");
      }
    },
    anglesEncode: function(x, y, z) {
      const normal0 = parseInt(0.5 * (1 + Math.atan2(y, x) / Math.PI) * 65535);
      const normal1 = parseInt(0.5 * (1 + z) * 65535);
      return new Uint16Array([normal0, normal1]);
    },
    octEncodeBest: function(x, y, z, bytes) {
      var oct, dec, best, currentCos, bestCos;
      best = oct = octEncodeVec3(x, y, z, "floor", "floor");
      dec = octDecodeVec2(oct);
      bestCos = dot2(x, y, z, dec);
      oct = octEncodeVec3(x, y, z, "ceil", "floor");
      dec = octDecodeVec2(oct);
      currentCos = dot2(x, y, z, dec);
      if (currentCos > bestCos) {
        best = oct;
        bestCos = currentCos;
      }
      oct = octEncodeVec3(x, y, z, "floor", "ceil");
      dec = octDecodeVec2(oct);
      currentCos = dot2(x, y, z, dec);
      if (currentCos > bestCos) {
        best = oct;
        bestCos = currentCos;
      }
      oct = octEncodeVec3(x, y, z, "ceil", "ceil");
      dec = octDecodeVec2(oct);
      currentCos = dot2(x, y, z, dec);
      if (currentCos > bestCos) {
        best = oct;
      }
      return best;
      function octEncodeVec3(x0, y0, z0, xfunc, yfunc) {
        var x2 = x0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));
        var y2 = y0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));
        if (z < 0) {
          var tempx = (1 - Math.abs(y2)) * (x2 >= 0 ? 1 : -1);
          var tempy = (1 - Math.abs(x2)) * (y2 >= 0 ? 1 : -1);
          x2 = tempx;
          y2 = tempy;
          var diff = 1 - Math.abs(x2) - Math.abs(y2);
          if (diff > 0) {
            diff += 1e-3;
            x2 += x2 > 0 ? diff / 2 : -diff / 2;
            y2 += y2 > 0 ? diff / 2 : -diff / 2;
          }
        }
        if (bytes == 1) {
          return new Int8Array([Math[xfunc](x2 * 127.5 + (x2 < 0 ? 1 : 0)), Math[yfunc](y2 * 127.5 + (y2 < 0 ? 1 : 0))]);
        }
        if (bytes == 2) {
          return new Int16Array([Math[xfunc](x2 * 32767.5 + (x2 < 0 ? 1 : 0)), Math[yfunc](y2 * 32767.5 + (y2 < 0 ? 1 : 0))]);
        }
      }
      function octDecodeVec2(oct2) {
        var x2 = oct2[0];
        var y2 = oct2[1];
        if (bytes == 1) {
          x2 /= x2 < 0 ? 127 : 128;
          y2 /= y2 < 0 ? 127 : 128;
        } else if (bytes == 2) {
          x2 /= x2 < 0 ? 32767 : 32768;
          y2 /= y2 < 0 ? 32767 : 32768;
        }
        var z2 = 1 - Math.abs(x2) - Math.abs(y2);
        if (z2 < 0) {
          var tmpx = x2;
          x2 = (1 - Math.abs(y2)) * (x2 >= 0 ? 1 : -1);
          y2 = (1 - Math.abs(tmpx)) * (y2 >= 0 ? 1 : -1);
        }
        var length2 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
        return [x2 / length2, y2 / length2, z2 / length2];
      }
      function dot2(x2, y2, z2, vec32) {
        return x2 * vec32[0] + y2 * vec32[1] + z2 * vec32[2];
      }
    },
    quantizedEncode: function(array, bytes) {
      let quantized, segments;
      if (bytes == 1) {
        quantized = new Uint8Array(array.length);
        segments = 255;
      } else if (bytes == 2) {
        quantized = new Uint16Array(array.length);
        segments = 65535;
      } else {
        console.error("number of bytes error! ");
      }
      const decodeMat = new Matrix4();
      const min2 = new Float32Array(3);
      const max3 = new Float32Array(3);
      min2[0] = min2[1] = min2[2] = Number.MAX_VALUE;
      max3[0] = max3[1] = max3[2] = -Number.MAX_VALUE;
      for (let i2 = 0; i2 < array.length; i2 += 3) {
        min2[0] = Math.min(min2[0], array[i2 + 0]);
        min2[1] = Math.min(min2[1], array[i2 + 1]);
        min2[2] = Math.min(min2[2], array[i2 + 2]);
        max3[0] = Math.max(max3[0], array[i2 + 0]);
        max3[1] = Math.max(max3[1], array[i2 + 1]);
        max3[2] = Math.max(max3[2], array[i2 + 2]);
      }
      decodeMat.scale(new Vector3((max3[0] - min2[0]) / segments, (max3[1] - min2[1]) / segments, (max3[2] - min2[2]) / segments));
      decodeMat.elements[12] = min2[0];
      decodeMat.elements[13] = min2[1];
      decodeMat.elements[14] = min2[2];
      decodeMat.transpose();
      const multiplier = new Float32Array([max3[0] !== min2[0] ? segments / (max3[0] - min2[0]) : 0, max3[1] !== min2[1] ? segments / (max3[1] - min2[1]) : 0, max3[2] !== min2[2] ? segments / (max3[2] - min2[2]) : 0]);
      for (let i2 = 0; i2 < array.length; i2 += 3) {
        quantized[i2 + 0] = Math.floor((array[i2 + 0] - min2[0]) * multiplier[0]);
        quantized[i2 + 1] = Math.floor((array[i2 + 1] - min2[1]) * multiplier[1]);
        quantized[i2 + 2] = Math.floor((array[i2 + 2] - min2[2]) * multiplier[2]);
      }
      return {
        quantized,
        decodeMat
      };
    },
    quantizedEncodeUV: function(array, bytes) {
      let quantized, segments;
      if (bytes == 1) {
        quantized = new Uint8Array(array.length);
        segments = 255;
      } else if (bytes == 2) {
        quantized = new Uint16Array(array.length);
        segments = 65535;
      } else {
        console.error("number of bytes error! ");
      }
      const decodeMat = new Matrix3();
      const min2 = new Float32Array(2);
      const max3 = new Float32Array(2);
      min2[0] = min2[1] = Number.MAX_VALUE;
      max3[0] = max3[1] = -Number.MAX_VALUE;
      for (let i2 = 0; i2 < array.length; i2 += 2) {
        min2[0] = Math.min(min2[0], array[i2 + 0]);
        min2[1] = Math.min(min2[1], array[i2 + 1]);
        max3[0] = Math.max(max3[0], array[i2 + 0]);
        max3[1] = Math.max(max3[1], array[i2 + 1]);
      }
      decodeMat.scale((max3[0] - min2[0]) / segments, (max3[1] - min2[1]) / segments);
      decodeMat.elements[6] = min2[0];
      decodeMat.elements[7] = min2[1];
      decodeMat.transpose();
      const multiplier = new Float32Array([max3[0] !== min2[0] ? segments / (max3[0] - min2[0]) : 0, max3[1] !== min2[1] ? segments / (max3[1] - min2[1]) : 0]);
      for (let i2 = 0; i2 < array.length; i2 += 2) {
        quantized[i2 + 0] = Math.floor((array[i2 + 0] - min2[0]) * multiplier[0]);
        quantized[i2 + 1] = Math.floor((array[i2 + 1] - min2[1]) * multiplier[1]);
      }
      return {
        quantized,
        decodeMat
      };
    }
  }
};
var PackedPhongMaterial = class extends MeshPhongMaterial {
  constructor(parameters) {
    super();
    this.defines = {};
    this.type = "PackedPhongMaterial";
    this.uniforms = UniformsUtils.merge([ShaderLib.phong.uniforms, {
      quantizeMatPos: {
        value: null
      },
      quantizeMatUV: {
        value: null
      }
    }]);
    this.vertexShader = ["#define PHONG", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "varying vec3 vNormal;", "#endif", ShaderChunk.common, ShaderChunk.uv_pars_vertex, ShaderChunk.uv2_pars_vertex, ShaderChunk.displacementmap_pars_vertex, ShaderChunk.envmap_pars_vertex, ShaderChunk.color_pars_vertex, ShaderChunk.fog_pars_vertex, ShaderChunk.morphtarget_pars_vertex, ShaderChunk.skinning_pars_vertex, ShaderChunk.shadowmap_pars_vertex, ShaderChunk.logdepthbuf_pars_vertex, ShaderChunk.clipping_planes_pars_vertex, `#ifdef USE_PACKED_NORMAL
					#if USE_PACKED_NORMAL == 0
						vec3 decodeNormal(vec3 packedNormal)
						{
							float x = packedNormal.x * 2.0 - 1.0;
							float y = packedNormal.y * 2.0 - 1.0;
							vec2 scth = vec2(sin(x * PI), cos(x * PI));
							vec2 scphi = vec2(sqrt(1.0 - y * y), y);
							return normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );
						}
					#endif

					#if USE_PACKED_NORMAL == 1
						vec3 decodeNormal(vec3 packedNormal)
						{
							vec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));
							if (v.z < 0.0)
							{
								v.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);
							}
							return normalize(v);
						}
					#endif

					#if USE_PACKED_NORMAL == 2
						vec3 decodeNormal(vec3 packedNormal)
						{
							vec3 v = (packedNormal * 2.0) - 1.0;
							return normalize(v);
						}
					#endif
				#endif`, `#ifdef USE_PACKED_POSITION
					#if USE_PACKED_POSITION == 0
						uniform mat4 quantizeMatPos;
					#endif
				#endif`, `#ifdef USE_PACKED_UV
					#if USE_PACKED_UV == 1
						uniform mat3 quantizeMatUV;
					#endif
				#endif`, `#ifdef USE_PACKED_UV
					#if USE_PACKED_UV == 0
						vec2 decodeUV(vec2 packedUV)
						{
							vec2 uv = (packedUV * 2.0) - 1.0;
							return uv;
						}
					#endif

					#if USE_PACKED_UV == 1
						vec2 decodeUV(vec2 packedUV)
						{
							vec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;
							return uv;
						}
					#endif
				#endif`, "void main() {", ShaderChunk.uv_vertex, `#ifdef USE_UV
					#ifdef USE_PACKED_UV
						vUv = decodeUV(vUv);
					#endif
				#endif`, ShaderChunk.uv2_vertex, ShaderChunk.color_vertex, ShaderChunk.beginnormal_vertex, `#ifdef USE_PACKED_NORMAL
					objectNormal = decodeNormal(objectNormal);
				#endif

				#ifdef USE_TANGENT
					vec3 objectTangent = vec3( tangent.xyz );
				#endif
				`, ShaderChunk.morphnormal_vertex, ShaderChunk.skinbase_vertex, ShaderChunk.skinnormal_vertex, ShaderChunk.defaultnormal_vertex, "#ifndef FLAT_SHADED", "	vNormal = normalize( transformedNormal );", "#endif", ShaderChunk.begin_vertex, `#ifdef USE_PACKED_POSITION
					#if USE_PACKED_POSITION == 0
						transformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;
					#endif
				#endif`, ShaderChunk.morphtarget_vertex, ShaderChunk.skinning_vertex, ShaderChunk.displacementmap_vertex, ShaderChunk.project_vertex, ShaderChunk.logdepthbuf_vertex, ShaderChunk.clipping_planes_vertex, "vViewPosition = - mvPosition.xyz;", ShaderChunk.worldpos_vertex, ShaderChunk.envmap_vertex, ShaderChunk.shadowmap_vertex, ShaderChunk.fog_vertex, "}"].join("\n");
    this.fragmentShader = [
      "#define PHONG",
      "uniform vec3 diffuse;",
      "uniform vec3 emissive;",
      "uniform vec3 specular;",
      "uniform float shininess;",
      "uniform float opacity;",
      ShaderChunk.common,
      ShaderChunk.packing,
      ShaderChunk.dithering_pars_fragment,
      ShaderChunk.color_pars_fragment,
      ShaderChunk.uv_pars_fragment,
      ShaderChunk.uv2_pars_fragment,
      ShaderChunk.map_pars_fragment,
      ShaderChunk.alphamap_pars_fragment,
      ShaderChunk.aomap_pars_fragment,
      ShaderChunk.lightmap_pars_fragment,
      ShaderChunk.emissivemap_pars_fragment,
      ShaderChunk.envmap_common_pars_fragment,
      ShaderChunk.envmap_pars_fragment,
      ShaderChunk.cube_uv_reflection_fragment,
      ShaderChunk.fog_pars_fragment,
      ShaderChunk.bsdfs,
      ShaderChunk.lights_pars_begin,
      ShaderChunk.lights_phong_pars_fragment,
      ShaderChunk.shadowmap_pars_fragment,
      ShaderChunk.bumpmap_pars_fragment,
      ShaderChunk.normalmap_pars_fragment,
      ShaderChunk.specularmap_pars_fragment,
      ShaderChunk.logdepthbuf_pars_fragment,
      ShaderChunk.clipping_planes_pars_fragment,
      "void main() {",
      ShaderChunk.clipping_planes_fragment,
      "vec4 diffuseColor = vec4( diffuse, opacity );",
      "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
      "vec3 totalEmissiveRadiance = emissive;",
      ShaderChunk.logdepthbuf_fragment,
      ShaderChunk.map_fragment,
      ShaderChunk.color_fragment,
      ShaderChunk.alphamap_fragment,
      ShaderChunk.alphatest_fragment,
      ShaderChunk.specularmap_fragment,
      ShaderChunk.normal_fragment_begin,
      ShaderChunk.normal_fragment_maps,
      ShaderChunk.emissivemap_fragment,
      ShaderChunk.lights_phong_fragment,
      ShaderChunk.lights_fragment_begin,
      ShaderChunk.lights_fragment_maps,
      ShaderChunk.lights_fragment_end,
      ShaderChunk.aomap_fragment,
      "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",
      ShaderChunk.envmap_fragment,
      "gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
      ShaderChunk.tonemapping_fragment,
      ShaderChunk.encodings_fragment,
      ShaderChunk.fog_fragment,
      ShaderChunk.premultiplied_alpha_fragment,
      ShaderChunk.dithering_fragment,
      "}"
    ].join("\n");
    this.setValues(parameters);
  }
};

// node_modules/three-stdlib/shaders/BokehShader2.js
var BokehShader2 = {
  uniforms: {
    textureWidth: {
      value: 1
    },
    textureHeight: {
      value: 1
    },
    focalDepth: {
      value: 1
    },
    focalLength: {
      value: 24
    },
    fstop: {
      value: 0.9
    },
    tColor: {
      value: null
    },
    tDepth: {
      value: null
    },
    maxblur: {
      value: 1
    },
    showFocus: {
      value: 0
    },
    manualdof: {
      value: 0
    },
    vignetting: {
      value: 0
    },
    depthblur: {
      value: 0
    },
    threshold: {
      value: 0.5
    },
    gain: {
      value: 2
    },
    bias: {
      value: 0.5
    },
    fringe: {
      value: 0.7
    },
    znear: {
      value: 0.1
    },
    zfar: {
      value: 100
    },
    noise: {
      value: 1
    },
    dithering: {
      value: 1e-4
    },
    pentagon: {
      value: 0
    },
    shaderFocus: {
      value: 1
    },
    focusCoords: {
      value: new Vector2()
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", "varying vec2 vUv;", "uniform sampler2D tColor;", "uniform sampler2D tDepth;", "uniform float textureWidth;", "uniform float textureHeight;", "uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below", "uniform float focalLength; //focal length in mm", "uniform float fstop; //f-stop value", "uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)", "/*", "make sure that these two values are the same for your camera, otherwise distances will be wrong.", "*/", "uniform float znear; // camera clipping start", "uniform float zfar; // camera clipping end", "//------------------------------------------", "//user variables", "const int samples = SAMPLES; //samples on the first ring", "const int rings = RINGS; //ring count", "const int maxringsamples = rings * samples;", "uniform bool manualdof; // manual dof calculation", "float ndofstart = 1.0; // near dof blur start", "float ndofdist = 2.0; // near dof blur falloff distance", "float fdofstart = 1.0; // far dof blur start", "float fdofdist = 3.0; // far dof blur falloff distance", "float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)", "uniform bool vignetting; // use optical lens vignetting", "float vignout = 1.3; // vignetting outer border", "float vignin = 0.0; // vignetting inner border", "float vignfade = 22.0; // f-stops till vignete fades", "uniform bool shaderFocus;", "// disable if you use external focalDepth value", "uniform vec2 focusCoords;", "// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)", "// if center of screen use vec2(0.5, 0.5);", "uniform float maxblur;", "//clamp value of max blur (0.0 = no blur, 1.0 default)", "uniform float threshold; // highlight threshold;", "uniform float gain; // highlight gain;", "uniform float bias; // bokeh edge bias", "uniform float fringe; // bokeh chromatic aberration / fringing", "uniform bool noise; //use noise instead of pattern for sample dithering", "uniform float dithering;", "uniform bool depthblur; // blur the depth buffer", "float dbsize = 1.25; // depth blur size", "/*", "next part is experimental", "not looking good with small sample and ring count", "looks okay starting from samples = 4, rings = 4", "*/", "uniform bool pentagon; //use pentagon as bokeh shape?", "float feather = 0.4; //pentagon shape feather", "//------------------------------------------", "float penta(vec2 coords) {", "	//pentagonal shape", "	float scale = float(rings) - 1.3;", "	vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);", "	vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);", "	vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);", "	vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);", "	vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);", "	vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);", "	vec4  one = vec4( 1.0 );", "	vec4 P = vec4((coords),vec2(scale, scale));", "	vec4 dist = vec4(0.0);", "	float inorout = -4.0;", "	dist.x = dot( P, HS0 );", "	dist.y = dot( P, HS1 );", "	dist.z = dot( P, HS2 );", "	dist.w = dot( P, HS3 );", "	dist = smoothstep( -feather, feather, dist );", "	inorout += dot( dist, one );", "	dist.x = dot( P, HS4 );", "	dist.y = HS5.w - abs( P.z );", "	dist = smoothstep( -feather, feather, dist );", "	inorout += dist.x;", "	return clamp( inorout, 0.0, 1.0 );", "}", "float bdepth(vec2 coords) {", "	// Depth buffer blur", "	float d = 0.0;", "	float kernel[9];", "	vec2 offset[9];", "	vec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;", "	offset[0] = vec2(-wh.x,-wh.y);", "	offset[1] = vec2( 0.0, -wh.y);", "	offset[2] = vec2( wh.x -wh.y);", "	offset[3] = vec2(-wh.x,  0.0);", "	offset[4] = vec2( 0.0,   0.0);", "	offset[5] = vec2( wh.x,  0.0);", "	offset[6] = vec2(-wh.x, wh.y);", "	offset[7] = vec2( 0.0,  wh.y);", "	offset[8] = vec2( wh.x, wh.y);", "	kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;", "	kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;", "	kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;", "	for( int i=0; i<9; i++ ) {", "		float tmp = texture2D(tDepth, coords + offset[i]).r;", "		d += tmp * kernel[i];", "	}", "	return d;", "}", "vec3 color(vec2 coords,float blur) {", "	//processing the sample", "	vec3 col = vec3(0.0);", "	vec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);", "	col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;", "	col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;", "	col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;", "	vec3 lumcoeff = vec3(0.299,0.587,0.114);", "	float lum = dot(col.rgb, lumcoeff);", "	float thresh = max((lum-threshold)*gain, 0.0);", "	return col+mix(vec3(0.0),col,thresh*blur);", "}", "vec3 debugFocus(vec3 col, float blur, float depth) {", "	float edge = 0.002*depth; //distance based edge smoothing", "	float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);", "	float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);", "	col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);", "	col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);", "	return col;", "}", "float linearize(float depth) {", "	return -zfar * znear / (depth * (zfar - znear) - zfar);", "}", "float vignette() {", "	float dist = distance(vUv.xy, vec2(0.5,0.5));", "	dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);", "	return clamp(dist,0.0,1.0);", "}", "float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {", "	float rings2 = float(rings);", "	float step = PI*2.0 / float(ringsamples);", "	float pw = cos(j*step)*i;", "	float ph = sin(j*step)*i;", "	float p = 1.0;", "	if (pentagon) {", "		p = penta(vec2(pw,ph));", "	}", "	col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;", "	return 1.0 * mix(1.0, i /rings2, bias) * p;", "}", "void main() {", "	//scene depth calculation", "	float depth = linearize(texture2D(tDepth,vUv.xy).x);", "	// Blur depth?", "	if ( depthblur ) {", "		depth = linearize(bdepth(vUv.xy));", "	}", "	//focal plane calculation", "	float fDepth = focalDepth;", "	if (shaderFocus) {", "		fDepth = linearize(texture2D(tDepth,focusCoords).x);", "	}", "	// dof blur factor calculation", "	float blur = 0.0;", "	if (manualdof) {", "		float a = depth-fDepth; // Focal plane", "		float b = (a-fdofstart)/fdofdist; // Far DoF", "		float c = (-a-ndofstart)/ndofdist; // Near Dof", "		blur = (a>0.0) ? b : c;", "	} else {", "		float f = focalLength; // focal length in mm", "		float d = fDepth*1000.0; // focal plane in mm", "		float o = depth*1000.0; // depth in mm", "		float a = (o*f)/(o-f);", "		float b = (d*f)/(d-f);", "		float c = (d-f)/(d*fstop*CoC);", "		blur = abs(a-b)*c;", "	}", "	blur = clamp(blur,0.0,1.0);", "	// calculation of pattern for dithering", "	vec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;", "	// getting blur x and y step factor", "	float w = (1.0/textureWidth)*blur*maxblur+noise.x;", "	float h = (1.0/textureHeight)*blur*maxblur+noise.y;", "	// calculation of final color", "	vec3 col = vec3(0.0);", "	if(blur < 0.05) {", "		//some optimization thingy", "		col = texture2D(tColor, vUv.xy).rgb;", "	} else {", "		col = texture2D(tColor, vUv.xy).rgb;", "		float s = 1.0;", "		int ringsamples;", "		for (int i = 1; i <= rings; i++) {", "			/*unboxstart*/", "			ringsamples = i * samples;", "			for (int j = 0 ; j < maxringsamples ; j++) {", "				if (j >= ringsamples) break;", "				s += gather(float(i), float(j), ringsamples, col, w, h, blur);", "			}", "			/*unboxend*/", "		}", "		col /= s; //divide by sample count", "	}", "	if (showFocus) {", "		col = debugFocus(col, blur, depth);", "	}", "	if (vignetting) {", "		col *= vignette();", "	}", "	gl_FragColor.rgb = col;", "	gl_FragColor.a = 1.0;", "} "].join("\n")
};
var BokehDepthShader = {
  uniforms: {
    mNear: {
      value: 1
    },
    mFar: {
      value: 1e3
    }
  },
  vertexShader: ["varying float vViewZDepth;", "void main() {", "	#include <begin_vertex>", "	#include <project_vertex>", "	vViewZDepth = - mvPosition.z;", "}"].join("\n"),
  fragmentShader: ["uniform float mNear;", "uniform float mFar;", "varying float vViewZDepth;", "void main() {", "	float color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );", "	gl_FragColor = vec4( vec3( color ), 1.0 );", "} "].join("\n")
};

// node_modules/three-stdlib/cameras/CinematicCamera.js
var CinematicCamera = class extends PerspectiveCamera {
  constructor(fov, aspect, near, far) {
    super(fov, aspect, near, far);
    this.type = "CinematicCamera";
    this.postprocessing = {
      enabled: true
    };
    this.shaderSettings = {
      rings: 3,
      samples: 4
    };
    const depthShader = BokehDepthShader;
    this.materialDepth = new ShaderMaterial({
      uniforms: depthShader.uniforms,
      vertexShader: depthShader.vertexShader,
      fragmentShader: depthShader.fragmentShader
    });
    this.materialDepth.uniforms["mNear"].value = near;
    this.materialDepth.uniforms["mFar"].value = far;
    this.setLens();
    this.initPostProcessing();
  }
  setLens(focalLength, filmGauge, fNumber, coc) {
    if (focalLength === void 0)
      focalLength = 35;
    if (filmGauge !== void 0)
      this.filmGauge = filmGauge;
    this.setFocalLength(focalLength);
    if (fNumber === void 0)
      fNumber = 8;
    if (coc === void 0)
      coc = 0.019;
    this.fNumber = fNumber;
    this.coc = coc;
    this.aperture = focalLength / this.fNumber;
    this.hyperFocal = focalLength * focalLength / (this.aperture * this.coc);
  }
  linearize(depth) {
    const zfar = this.far;
    const znear = this.near;
    return -zfar * znear / (depth * (zfar - znear) - zfar);
  }
  smoothstep(near, far, depth) {
    const x = this.saturate((depth - near) / (far - near));
    return x * x * (3 - 2 * x);
  }
  saturate(x) {
    return Math.max(0, Math.min(1, x));
  }
  focusAt(focusDistance) {
    if (focusDistance === void 0)
      focusDistance = 20;
    const focalLength = this.getFocalLength();
    this.focus = focusDistance;
    this.nearPoint = this.hyperFocal * this.focus / (this.hyperFocal + (this.focus - focalLength));
    this.farPoint = this.hyperFocal * this.focus / (this.hyperFocal - (this.focus - focalLength));
    this.depthOfField = this.farPoint - this.nearPoint;
    if (this.depthOfField < 0)
      this.depthOfField = 0;
    this.sdistance = this.smoothstep(this.near, this.far, this.focus);
    this.ldistance = this.linearize(1 - this.sdistance);
    this.postprocessing.bokeh_uniforms["focalDepth"].value = this.ldistance;
  }
  initPostProcessing() {
    if (this.postprocessing.enabled) {
      this.postprocessing.scene = new Scene();
      this.postprocessing.camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -1e4, 1e4);
      this.postprocessing.scene.add(this.postprocessing.camera);
      this.postprocessing.rtTextureDepth = new WebGLRenderTarget(window.innerWidth, window.innerHeight);
      this.postprocessing.rtTextureColor = new WebGLRenderTarget(window.innerWidth, window.innerHeight);
      const bokeh_shader = BokehShader2;
      this.postprocessing.bokeh_uniforms = UniformsUtils.clone(bokeh_shader.uniforms);
      this.postprocessing.bokeh_uniforms["tColor"].value = this.postprocessing.rtTextureColor.texture;
      this.postprocessing.bokeh_uniforms["tDepth"].value = this.postprocessing.rtTextureDepth.texture;
      this.postprocessing.bokeh_uniforms["manualdof"].value = 0;
      this.postprocessing.bokeh_uniforms["shaderFocus"].value = 0;
      this.postprocessing.bokeh_uniforms["fstop"].value = 2.8;
      this.postprocessing.bokeh_uniforms["showFocus"].value = 1;
      this.postprocessing.bokeh_uniforms["focalDepth"].value = 0.1;
      this.postprocessing.bokeh_uniforms["znear"].value = this.near;
      this.postprocessing.bokeh_uniforms["zfar"].value = this.near;
      this.postprocessing.bokeh_uniforms["textureWidth"].value = window.innerWidth;
      this.postprocessing.bokeh_uniforms["textureHeight"].value = window.innerHeight;
      this.postprocessing.materialBokeh = new ShaderMaterial({
        uniforms: this.postprocessing.bokeh_uniforms,
        vertexShader: bokeh_shader.vertexShader,
        fragmentShader: bokeh_shader.fragmentShader,
        defines: {
          RINGS: this.shaderSettings.rings,
          SAMPLES: this.shaderSettings.samples,
          DEPTH_PACKING: 1
        }
      });
      this.postprocessing.quad = new Mesh(new PlaneGeometry(window.innerWidth, window.innerHeight), this.postprocessing.materialBokeh);
      this.postprocessing.quad.position.z = -500;
      this.postprocessing.scene.add(this.postprocessing.quad);
    }
  }
  renderCinematic(scene, renderer) {
    if (this.postprocessing.enabled) {
      const currentRenderTarget = renderer.getRenderTarget();
      renderer.clear();
      scene.overrideMaterial = null;
      renderer.setRenderTarget(this.postprocessing.rtTextureColor);
      renderer.clear();
      renderer.render(scene, this);
      scene.overrideMaterial = this.materialDepth;
      renderer.setRenderTarget(this.postprocessing.rtTextureDepth);
      renderer.clear();
      renderer.render(scene, this);
      renderer.setRenderTarget(null);
      renderer.render(this.postprocessing.scene, this.postprocessing.camera);
      renderer.setRenderTarget(currentRenderTarget);
    }
  }
};

// node_modules/three-stdlib/math/MeshSurfaceSampler.js
var MeshSurfaceSampler = function() {
  var _face = new Triangle();
  var _color = new Vector3();
  function MeshSurfaceSampler2(mesh) {
    var geometry = mesh.geometry;
    if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {
      throw new Error("THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.");
    }
    if (geometry.index) {
      console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.");
      geometry = geometry.toNonIndexed();
    }
    this.geometry = geometry;
    this.randomFunction = Math.random;
    this.positionAttribute = this.geometry.getAttribute("position");
    this.colorAttribute = this.geometry.getAttribute("color");
    this.weightAttribute = null;
    this.distribution = null;
  }
  MeshSurfaceSampler2.prototype = {
    constructor: MeshSurfaceSampler2,
    setWeightAttribute: function(name) {
      this.weightAttribute = name ? this.geometry.getAttribute(name) : null;
      return this;
    },
    build: function() {
      var positionAttribute = this.positionAttribute;
      var weightAttribute = this.weightAttribute;
      var faceWeights = new Float32Array(positionAttribute.count / 3);
      for (let i2 = 0; i2 < positionAttribute.count; i2 += 3) {
        var faceWeight = 1;
        if (weightAttribute) {
          faceWeight = weightAttribute.getX(i2) + weightAttribute.getX(i2 + 1) + weightAttribute.getX(i2 + 2);
        }
        _face.a.fromBufferAttribute(positionAttribute, i2);
        _face.b.fromBufferAttribute(positionAttribute, i2 + 1);
        _face.c.fromBufferAttribute(positionAttribute, i2 + 2);
        faceWeight *= _face.getArea();
        faceWeights[i2 / 3] = faceWeight;
      }
      this.distribution = new Float32Array(positionAttribute.count / 3);
      var cumulativeTotal = 0;
      for (let i2 = 0; i2 < faceWeights.length; i2++) {
        cumulativeTotal += faceWeights[i2];
        this.distribution[i2] = cumulativeTotal;
      }
      return this;
    },
    setRandomGenerator: function(randomFunction) {
      this.randomFunction = randomFunction;
      return this;
    },
    sample: function(targetPosition2, targetNormal, targetColor) {
      var cumulativeTotal = this.distribution[this.distribution.length - 1];
      var faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal);
      return this.sampleFace(faceIndex, targetPosition2, targetNormal, targetColor);
    },
    binarySearch: function(x) {
      var dist = this.distribution;
      var start = 0;
      var end = dist.length - 1;
      var index = -1;
      while (start <= end) {
        var mid = Math.ceil((start + end) / 2);
        if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {
          index = mid;
          break;
        } else if (x < dist[mid]) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return index;
    },
    sampleFace: function(faceIndex, targetPosition2, targetNormal, targetColor) {
      var u = this.randomFunction();
      var v = this.randomFunction();
      if (u + v > 1) {
        u = 1 - u;
        v = 1 - v;
      }
      _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);
      _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);
      _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);
      targetPosition2.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));
      if (targetNormal !== void 0) {
        _face.getNormal(targetNormal);
      }
      if (targetColor !== void 0 && this.colorAttribute !== void 0) {
        _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);
        _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);
        _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);
        _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));
        targetColor.r = _color.x;
        targetColor.g = _color.y;
        targetColor.b = _color.z;
      }
      return this;
    }
  };
  return MeshSurfaceSampler2;
}();

// node_modules/three-stdlib/math/OBB.js
var a = {
  c: null,
  u: [new Vector3(), new Vector3(), new Vector3()],
  e: []
};
var b = {
  c: null,
  u: [new Vector3(), new Vector3(), new Vector3()],
  e: []
};
var R = [[], [], []];
var AbsR = [[], [], []];
var t = [];
var xAxis = new Vector3();
var yAxis = new Vector3();
var zAxis = new Vector3();
var v1 = new Vector3();
var size = new Vector3();
var closestPoint = new Vector3();
var rotationMatrix = new Matrix3();
var aabb = new Box3();
var matrix2 = new Matrix4();
var inverse = new Matrix4();
var localRay = new Ray();
function OBB(center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3()) {
  this.center = center;
  this.halfSize = halfSize;
  this.rotation = rotation;
}
Object.assign(OBB.prototype, {
  set: function(center, halfSize, rotation) {
    this.center = center;
    this.halfSize = halfSize;
    this.rotation = rotation;
    return this;
  },
  copy: function(obb2) {
    this.center.copy(obb2.center);
    this.halfSize.copy(obb2.halfSize);
    this.rotation.copy(obb2.rotation);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  getSize: function(result) {
    return result.copy(this.halfSize).multiplyScalar(2);
  },
  clampPoint: function(point, result) {
    var halfSize = this.halfSize;
    v1.subVectors(point, this.center);
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    result.copy(this.center);
    var x = MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x);
    result.add(xAxis.multiplyScalar(x));
    var y = MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y);
    result.add(yAxis.multiplyScalar(y));
    var z = MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z);
    result.add(zAxis.multiplyScalar(z));
    return result;
  },
  containsPoint: function(point) {
    v1.subVectors(point, this.center);
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    return Math.abs(v1.dot(xAxis)) <= this.halfSize.x && Math.abs(v1.dot(yAxis)) <= this.halfSize.y && Math.abs(v1.dot(zAxis)) <= this.halfSize.z;
  },
  intersectsBox3: function(box3) {
    return this.intersectsOBB(obb.fromBox3(box3));
  },
  intersectsSphere: function(sphere) {
    this.clampPoint(sphere.center, closestPoint);
    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  },
  intersectsOBB: function(obb2, epsilon = Number.EPSILON) {
    a.c = this.center;
    a.e[0] = this.halfSize.x;
    a.e[1] = this.halfSize.y;
    a.e[2] = this.halfSize.z;
    this.rotation.extractBasis(a.u[0], a.u[1], a.u[2]);
    b.c = obb2.center;
    b.e[0] = obb2.halfSize.x;
    b.e[1] = obb2.halfSize.y;
    b.e[2] = obb2.halfSize.z;
    obb2.rotation.extractBasis(b.u[0], b.u[1], b.u[2]);
    for (let i2 = 0; i2 < 3; i2++) {
      for (let j2 = 0; j2 < 3; j2++) {
        R[i2][j2] = a.u[i2].dot(b.u[j2]);
      }
    }
    v1.subVectors(b.c, a.c);
    t[0] = v1.dot(a.u[0]);
    t[1] = v1.dot(a.u[1]);
    t[2] = v1.dot(a.u[2]);
    for (let i2 = 0; i2 < 3; i2++) {
      for (let j2 = 0; j2 < 3; j2++) {
        AbsR[i2][j2] = Math.abs(R[i2][j2]) + epsilon;
      }
    }
    var ra, rb;
    for (let i2 = 0; i2 < 3; i2++) {
      ra = a.e[i2];
      rb = b.e[0] * AbsR[i2][0] + b.e[1] * AbsR[i2][1] + b.e[2] * AbsR[i2][2];
      if (Math.abs(t[i2]) > ra + rb)
        return false;
    }
    for (let i2 = 0; i2 < 3; i2++) {
      ra = a.e[0] * AbsR[0][i2] + a.e[1] * AbsR[1][i2] + a.e[2] * AbsR[2][i2];
      rb = b.e[i2];
      if (Math.abs(t[0] * R[0][i2] + t[1] * R[1][i2] + t[2] * R[2][i2]) > ra + rb)
        return false;
    }
    ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0];
    rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];
    if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb)
      return false;
    ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1];
    rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];
    if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb)
      return false;
    ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2];
    rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];
    if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0];
    rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];
    if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1];
    rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];
    if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2];
    rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];
    if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0];
    rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];
    if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1];
    rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];
    if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2];
    rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];
    if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb)
      return false;
    return true;
  },
  intersectsPlane: function(plane) {
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    const r = this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) + this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) + this.halfSize.z * Math.abs(plane.normal.dot(zAxis));
    const d = plane.normal.dot(this.center) - plane.constant;
    return Math.abs(d) <= r;
  },
  intersectRay: function(ray, result) {
    this.getSize(size);
    aabb.setFromCenterAndSize(v1.set(0, 0, 0), size);
    matrix4FromRotationMatrix(matrix2, this.rotation);
    matrix2.setPosition(this.center);
    inverse.copy(matrix2).invert();
    localRay.copy(ray).applyMatrix4(inverse);
    if (localRay.intersectBox(aabb, result)) {
      return result.applyMatrix4(matrix2);
    } else {
      return null;
    }
  },
  intersectsRay: function(ray) {
    return this.intersectRay(ray, v1) !== null;
  },
  fromBox3: function(box3) {
    box3.getCenter(this.center);
    box3.getSize(this.halfSize).multiplyScalar(0.5);
    this.rotation.identity();
    return this;
  },
  equals: function(obb2) {
    return obb2.center.equals(this.center) && obb2.halfSize.equals(this.halfSize) && obb2.rotation.equals(this.rotation);
  },
  applyMatrix4: function(matrix3) {
    var e = matrix3.elements;
    var sx = v1.set(e[0], e[1], e[2]).length();
    var sy = v1.set(e[4], e[5], e[6]).length();
    var sz = v1.set(e[8], e[9], e[10]).length();
    var det = matrix3.determinant();
    if (det < 0)
      sx = -sx;
    rotationMatrix.setFromMatrix4(matrix3);
    var invSX = 1 / sx;
    var invSY = 1 / sy;
    var invSZ = 1 / sz;
    rotationMatrix.elements[0] *= invSX;
    rotationMatrix.elements[1] *= invSX;
    rotationMatrix.elements[2] *= invSX;
    rotationMatrix.elements[3] *= invSY;
    rotationMatrix.elements[4] *= invSY;
    rotationMatrix.elements[5] *= invSY;
    rotationMatrix.elements[6] *= invSZ;
    rotationMatrix.elements[7] *= invSZ;
    rotationMatrix.elements[8] *= invSZ;
    this.rotation.multiply(rotationMatrix);
    this.halfSize.x *= sx;
    this.halfSize.y *= sy;
    this.halfSize.z *= sz;
    v1.setFromMatrixPosition(matrix3);
    this.center.add(v1);
    return this;
  }
});
function matrix4FromRotationMatrix(matrix4, matrix3) {
  var e = matrix4.elements;
  var me = matrix3.elements;
  e[0] = me[0];
  e[1] = me[1];
  e[2] = me[2];
  e[3] = 0;
  e[4] = me[3];
  e[5] = me[4];
  e[6] = me[5];
  e[7] = 0;
  e[8] = me[6];
  e[9] = me[7];
  e[10] = me[8];
  e[11] = 0;
  e[12] = 0;
  e[13] = 0;
  e[14] = 0;
  e[15] = 1;
}
var obb = new OBB();

// node_modules/three-stdlib/math/Capsule.js
var Capsule = function() {
  var _v14 = new Vector3();
  var _v23 = new Vector3();
  var _v3 = new Vector3();
  var EPS = 1e-10;
  function Capsule2(start, end, radius) {
    this.start = start == void 0 ? new Vector3(0, 0, 0) : start;
    this.end = end == void 0 ? new Vector3(0, 1, 0) : end;
    this.radius = radius == void 0 ? 1 : radius;
  }
  Object.assign(Capsule2.prototype, {
    clone: function() {
      return new Capsule2(this.start.clone(), this.end.clone(), this.radius);
    },
    set: function(start, end, radius) {
      this.start.copy(start);
      this.end.copy(end);
      this.radius = radius;
    },
    copy: function(capsule) {
      this.start.copy(capsule.start);
      this.end.copy(capsule.end);
      this.radius = capsule.radius;
    },
    getCenter: function(target) {
      return target.copy(this.end).add(this.start).multiplyScalar(0.5);
    },
    translate: function(v) {
      this.start.add(v);
      this.end.add(v);
    },
    checkAABBAxis: function(p1x, p1y, p2x, p2y, minx, maxx, miny, maxy, radius) {
      return (minx - p1x < radius || minx - p2x < radius) && (p1x - maxx < radius || p2x - maxx < radius) && (miny - p1y < radius || miny - p2y < radius) && (p1y - maxy < radius || p2y - maxy < radius);
    },
    intersectsBox: function(box) {
      return this.checkAABBAxis(this.start.x, this.start.y, this.end.x, this.end.y, box.min.x, box.max.x, box.min.y, box.max.y, this.radius) && this.checkAABBAxis(this.start.x, this.start.z, this.end.x, this.end.z, box.min.x, box.max.x, box.min.z, box.max.z, this.radius) && this.checkAABBAxis(this.start.y, this.start.z, this.end.y, this.end.z, box.min.y, box.max.y, box.min.z, box.max.z, this.radius);
    },
    lineLineMinimumPoints: function(line1, line2) {
      var r = _v14.copy(line1.end).sub(line1.start);
      var s = _v23.copy(line2.end).sub(line2.start);
      var w = _v3.copy(line2.start).sub(line1.start);
      var a2 = r.dot(s), b3 = r.dot(r), c = s.dot(s), d = s.dot(w), e = r.dot(w);
      var t1, t2, divisor = b3 * c - a2 * a2;
      if (Math.abs(divisor) < EPS) {
        var d1 = -d / c;
        var d2 = (a2 - d) / c;
        if (Math.abs(d1 - 0.5) < Math.abs(d2 - 0.5)) {
          t1 = 0;
          t2 = d1;
        } else {
          t1 = 1;
          t2 = d2;
        }
      } else {
        t1 = (d * a2 + e * c) / divisor;
        t2 = (t1 * a2 - d) / c;
      }
      t2 = Math.max(0, Math.min(1, t2));
      t1 = Math.max(0, Math.min(1, t1));
      var point1 = r.multiplyScalar(t1).add(line1.start);
      var point2 = s.multiplyScalar(t2).add(line2.start);
      return [point1, point2];
    }
  });
  return Capsule2;
}();

// node_modules/three-stdlib/math/ColorConverter.js
var ColorConverter = {
  setHSV: function(color2, h, s, v) {
    h = MathUtils.euclideanModulo(h, 1);
    s = MathUtils.clamp(s, 0, 1);
    v = MathUtils.clamp(v, 0, 1);
    return color2.setHSL(h, s * v / ((h = (2 - s) * v) < 1 ? h : 2 - h), h * 0.5);
  },
  getHSV: function() {
    var hsl = {};
    return function getHSV(color2, target) {
      if (target === void 0) {
        console.warn("THREE.ColorConverter: .getHSV() target is now required");
        target = {
          h: 0,
          s: 0,
          l: 0
        };
      }
      color2.getHSL(hsl);
      hsl.s *= hsl.l < 0.5 ? hsl.l : 1 - hsl.l;
      target.h = hsl.h;
      target.s = 2 * hsl.s / (hsl.l + hsl.s);
      target.v = hsl.l + hsl.s;
      return target;
    };
  }(),
  setCMYK: function(color2, c, m, y, k) {
    var r = (1 - c) * (1 - k);
    var g2 = (1 - m) * (1 - k);
    var b3 = (1 - y) * (1 - k);
    return color2.setRGB(r, g2, b3);
  },
  getCMYK: function(color2, target) {
    if (target === void 0) {
      console.warn("THREE.ColorConverter: .getCMYK() target is now required");
      target = {
        c: 0,
        m: 0,
        y: 0,
        k: 0
      };
    }
    var r = color2.r;
    var g2 = color2.g;
    var b3 = color2.b;
    var k = 1 - Math.max(r, g2, b3);
    var c = (1 - r - k) / (1 - k);
    var m = (1 - g2 - k) / (1 - k);
    var y = (1 - b3 - k) / (1 - k);
    target.c = c;
    target.m = m;
    target.y = y;
    target.k = k;
    return target;
  }
};

// node_modules/three-stdlib/math/ImprovedNoise.js
var ImprovedNoise = function() {
  var p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];
  for (let i2 = 0; i2 < 256; i2++) {
    p[256 + i2] = p[i2];
  }
  function fade(t2) {
    return t2 * t2 * t2 * (t2 * (t2 * 6 - 15) + 10);
  }
  function lerp(t2, a2, b3) {
    return a2 + t2 * (b3 - a2);
  }
  function grad(hash, x, y, z) {
    var h = hash & 15;
    var u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z;
    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
  }
  return {
    noise: function(x, y, z) {
      var floorX = Math.floor(x), floorY = Math.floor(y), floorZ = Math.floor(z);
      var X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;
      x -= floorX;
      y -= floorY;
      z -= floorZ;
      var xMinus1 = x - 1, yMinus1 = y - 1, zMinus1 = z - 1;
      var u = fade(x), v = fade(y), w = fade(z);
      var A2 = p[X] + Y, AA = p[A2] + Z, AB = p[A2 + 1] + Z, B2 = p[X + 1] + Y, BA = p[B2] + Z, BB = p[B2 + 1] + Z;
      return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), grad(p[BA], xMinus1, y, z)), lerp(u, grad(p[AB], x, yMinus1, z), grad(p[BB], xMinus1, yMinus1, z))), lerp(v, lerp(u, grad(p[AA + 1], x, y, zMinus1), grad(p[BA + 1], xMinus1, y, zMinus1)), lerp(u, grad(p[AB + 1], x, yMinus1, zMinus1), grad(p[BB + 1], xMinus1, yMinus1, zMinus1))));
    }
  };
};

// node_modules/three-stdlib/math/Octree.js
var Octree = function() {
  var _v14 = new Vector3();
  var _v23 = new Vector3();
  var _plane2 = new Plane();
  var _line1 = new Line3();
  var _line2 = new Line3();
  var _sphere2 = new Sphere();
  var _capsule = new Capsule();
  function Octree2(box) {
    this.triangles = [];
    this.box = box;
    this.subTrees = [];
  }
  Object.assign(Octree2.prototype, {
    addTriangle: function(triangle) {
      if (!this.bounds)
        this.bounds = new Box3();
      this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x);
      this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y);
      this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z);
      this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x);
      this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y);
      this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z);
      this.triangles.push(triangle);
      return this;
    },
    calcBox: function() {
      this.box = this.bounds.clone();
      this.box.min.x -= 0.01;
      this.box.min.y -= 0.01;
      this.box.min.z -= 0.01;
      return this;
    },
    split: function(level) {
      if (!this.box)
        return;
      var subTrees = [], halfsize = _v23.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5), box, v, triangle;
      for (let x = 0; x < 2; x++) {
        for (let y = 0; y < 2; y++) {
          for (let z = 0; z < 2; z++) {
            box = new Box3();
            v = _v14.set(x, y, z);
            box.min.copy(this.box.min).add(v.multiply(halfsize));
            box.max.copy(box.min).add(halfsize);
            subTrees.push(new Octree2(box));
          }
        }
      }
      while (triangle = this.triangles.pop()) {
        for (let i2 = 0; i2 < subTrees.length; i2++) {
          if (subTrees[i2].box.intersectsTriangle(triangle)) {
            subTrees[i2].triangles.push(triangle);
          }
        }
      }
      for (let i2 = 0; i2 < subTrees.length; i2++) {
        var len = subTrees[i2].triangles.length;
        if (len > 8 && level < 16) {
          subTrees[i2].split(level + 1);
        }
        if (len != 0) {
          this.subTrees.push(subTrees[i2]);
        }
      }
      return this;
    },
    build: function() {
      this.calcBox();
      this.split(0);
      return this;
    },
    getRayTriangles: function(ray, triangles) {
      for (let i2 = 0; i2 < this.subTrees.length; i2++) {
        var subTree = this.subTrees[i2];
        if (!ray.intersectsBox(subTree.box))
          continue;
        if (subTree.triangles.length > 0) {
          for (let j2 = 0; j2 < subTree.triangles.length; j2++) {
            if (triangles.indexOf(subTree.triangles[j2]) === -1)
              triangles.push(subTree.triangles[j2]);
          }
        } else {
          subTree.getRayTriangles(ray, triangles);
        }
      }
      return triangles;
    },
    triangleCapsuleIntersect: function(capsule, triangle) {
      var point1, point2, line1, line2;
      triangle.getPlane(_plane2);
      var d1 = _plane2.distanceToPoint(capsule.start) - capsule.radius;
      var d2 = _plane2.distanceToPoint(capsule.end) - capsule.radius;
      if (d1 > 0 && d2 > 0 || d1 < -capsule.radius && d2 < -capsule.radius) {
        return false;
      }
      var delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)));
      var intersectPoint = _v14.copy(capsule.start).lerp(capsule.end, delta);
      if (triangle.containsPoint(intersectPoint)) {
        return {
          normal: _plane2.normal.clone(),
          point: intersectPoint.clone(),
          depth: Math.abs(Math.min(d1, d2))
        };
      }
      var r2 = capsule.radius * capsule.radius;
      line1 = _line1.set(capsule.start, capsule.end);
      var lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];
      for (let i2 = 0; i2 < lines.length; i2++) {
        line2 = _line2.set(lines[i2][0], lines[i2][1]);
        [point1, point2] = capsule.lineLineMinimumPoints(line1, line2);
        if (point1.distanceToSquared(point2) < r2) {
          return {
            normal: point1.clone().sub(point2).normalize(),
            point: point2.clone(),
            depth: capsule.radius - point1.distanceTo(point2)
          };
        }
      }
      return false;
    },
    triangleSphereIntersect: function(sphere, triangle) {
      triangle.getPlane(_plane2);
      if (!sphere.intersectsPlane(_plane2))
        return false;
      var depth = Math.abs(_plane2.distanceToSphere(sphere));
      var r2 = sphere.radius * sphere.radius - depth * depth;
      var plainPoint = _plane2.projectPoint(sphere.center, _v14);
      if (triangle.containsPoint(sphere.center)) {
        return {
          normal: _plane2.normal.clone(),
          point: plainPoint.clone(),
          depth: Math.abs(_plane2.distanceToSphere(sphere))
        };
      }
      var lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];
      for (let i2 = 0; i2 < lines.length; i2++) {
        _line1.set(lines[i2][0], lines[i2][1]);
        _line1.closestPointToPoint(plainPoint, true, _v23);
        var d = _v23.distanceToSquared(sphere.center);
        if (d < r2) {
          return {
            normal: sphere.center.clone().sub(_v23).normalize(),
            point: _v23.clone(),
            depth: sphere.radius - Math.sqrt(d)
          };
        }
      }
      return false;
    },
    getSphereTriangles: function(sphere, triangles) {
      for (let i2 = 0; i2 < this.subTrees.length; i2++) {
        var subTree = this.subTrees[i2];
        if (!sphere.intersectsBox(subTree.box))
          continue;
        if (subTree.triangles.length > 0) {
          for (let j2 = 0; j2 < subTree.triangles.length; j2++) {
            if (triangles.indexOf(subTree.triangles[j2]) === -1)
              triangles.push(subTree.triangles[j2]);
          }
        } else {
          subTree.getSphereTriangles(sphere, triangles);
        }
      }
    },
    getCapsuleTriangles: function(capsule, triangles) {
      for (let i2 = 0; i2 < this.subTrees.length; i2++) {
        var subTree = this.subTrees[i2];
        if (!capsule.intersectsBox(subTree.box))
          continue;
        if (subTree.triangles.length > 0) {
          for (let j2 = 0; j2 < subTree.triangles.length; j2++) {
            if (triangles.indexOf(subTree.triangles[j2]) === -1)
              triangles.push(subTree.triangles[j2]);
          }
        } else {
          subTree.getCapsuleTriangles(capsule, triangles);
        }
      }
    },
    sphereIntersect(sphere) {
      _sphere2.copy(sphere);
      var triangles = [], result, hit = false;
      this.getSphereTriangles(sphere, triangles);
      for (let i2 = 0; i2 < triangles.length; i2++) {
        if (result = this.triangleSphereIntersect(_sphere2, triangles[i2])) {
          hit = true;
          _sphere2.center.add(result.normal.multiplyScalar(result.depth));
        }
      }
      if (hit) {
        var collisionVector = _sphere2.center.clone().sub(sphere.center);
        var depth = collisionVector.length();
        return {
          normal: collisionVector.normalize(),
          depth
        };
      }
      return false;
    },
    capsuleIntersect: function(capsule) {
      _capsule.copy(capsule);
      var triangles = [], result, hit = false;
      this.getCapsuleTriangles(_capsule, triangles);
      for (let i2 = 0; i2 < triangles.length; i2++) {
        if (result = this.triangleCapsuleIntersect(_capsule, triangles[i2])) {
          hit = true;
          _capsule.translate(result.normal.multiplyScalar(result.depth));
        }
      }
      if (hit) {
        var collisionVector = _capsule.getCenter(new Vector3()).sub(capsule.getCenter(_v14));
        var depth = collisionVector.length();
        return {
          normal: collisionVector.normalize(),
          depth
        };
      }
      return false;
    },
    rayIntersect: function(ray) {
      if (ray.direction.length() === 0)
        return;
      var triangles = [], triangle, position, distance2 = 1e100, result;
      this.getRayTriangles(ray, triangles);
      for (let i2 = 0; i2 < triangles.length; i2++) {
        result = ray.intersectTriangle(triangles[i2].a, triangles[i2].b, triangles[i2].c, true, _v14);
        if (result) {
          var newdistance = result.sub(ray.origin).length();
          if (distance2 > newdistance) {
            position = result.clone().add(ray.origin);
            distance2 = newdistance;
            triangle = triangles[i2];
          }
        }
      }
      return distance2 < 1e100 ? {
        distance: distance2,
        triangle,
        position
      } : false;
    },
    fromGraphNode: function(group) {
      group.traverse((obj) => {
        if (obj.type === "Mesh") {
          obj.updateMatrix();
          obj.updateWorldMatrix();
          var geometry, isTemp = false;
          if (obj.geometry.index) {
            isTemp = true;
            geometry = obj.geometry.clone().toNonIndexed();
          } else {
            geometry = obj.geometry;
          }
          var positions = geometry.attributes.position.array;
          var transform = obj.matrixWorld;
          for (let i2 = 0; i2 < positions.length; i2 += 9) {
            var v12 = new Vector3(positions[i2], positions[i2 + 1], positions[i2 + 2]);
            var v2 = new Vector3(positions[i2 + 3], positions[i2 + 4], positions[i2 + 5]);
            var v3 = new Vector3(positions[i2 + 6], positions[i2 + 7], positions[i2 + 8]);
            v12.applyMatrix4(transform);
            v2.applyMatrix4(transform);
            v3.applyMatrix4(transform);
            this.addTriangle(new Triangle(v12, v2, v3));
          }
          if (isTemp) {
            geometry.dispose();
          }
        }
      });
      this.build();
      return this;
    }
  });
  return Octree2;
}();

// node_modules/three-stdlib/math/Lut.js
var Lut = function(colormap, numberofcolors) {
  this.lut = [];
  this.setColorMap(colormap, numberofcolors);
  return this;
};
Lut.prototype = {
  constructor: Lut,
  lut: [],
  map: [],
  n: 256,
  minV: 0,
  maxV: 1,
  set: function(value) {
    if (value instanceof Lut) {
      this.copy(value);
    }
    return this;
  },
  setMin: function(min2) {
    this.minV = min2;
    return this;
  },
  setMax: function(max3) {
    this.maxV = max3;
    return this;
  },
  setColorMap: function(colormap, numberofcolors) {
    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;
    this.n = numberofcolors || 32;
    var step2 = 1 / this.n;
    this.lut.length = 0;
    for (let i2 = 0; i2 <= 1; i2 += step2) {
      for (let j2 = 0; j2 < this.map.length - 1; j2++) {
        if (i2 >= this.map[j2][0] && i2 < this.map[j2 + 1][0]) {
          var min2 = this.map[j2][0];
          var max3 = this.map[j2 + 1][0];
          var minColor = new Color(this.map[j2][1]);
          var maxColor = new Color(this.map[j2 + 1][1]);
          var color2 = minColor.lerp(maxColor, (i2 - min2) / (max3 - min2));
          this.lut.push(color2);
        }
      }
    }
    return this;
  },
  copy: function(lut) {
    this.lut = lut.lut;
    this.map = lut.map;
    this.n = lut.n;
    this.minV = lut.minV;
    this.maxV = lut.maxV;
    return this;
  },
  getColor: function(alpha) {
    if (alpha <= this.minV) {
      alpha = this.minV;
    } else if (alpha >= this.maxV) {
      alpha = this.maxV;
    }
    alpha = (alpha - this.minV) / (this.maxV - this.minV);
    var colorPosition = Math.round(alpha * this.n);
    colorPosition == this.n ? colorPosition -= 1 : colorPosition;
    return this.lut[colorPosition];
  },
  addColorMap: function(colormapName, arrayOfColors) {
    ColorMapKeywords[colormapName] = arrayOfColors;
  },
  createCanvas: function() {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = this.n;
    this.updateCanvas(canvas);
    return canvas;
  },
  updateCanvas: function(canvas) {
    var ctx = canvas.getContext("2d", {
      alpha: false
    });
    var imageData = ctx.getImageData(0, 0, 1, this.n);
    var data = imageData.data;
    var k = 0;
    var step2 = 1 / this.n;
    for (let i2 = 1; i2 >= 0; i2 -= step2) {
      for (let j2 = this.map.length - 1; j2 >= 0; j2--) {
        if (i2 < this.map[j2][0] && i2 >= this.map[j2 - 1][0]) {
          var min2 = this.map[j2 - 1][0];
          var max3 = this.map[j2][0];
          var minColor = new Color(this.map[j2 - 1][1]);
          var maxColor = new Color(this.map[j2][1]);
          var color2 = minColor.lerp(maxColor, (i2 - min2) / (max3 - min2));
          data[k * 4] = Math.round(color2.r * 255);
          data[k * 4 + 1] = Math.round(color2.g * 255);
          data[k * 4 + 2] = Math.round(color2.b * 255);
          data[k * 4 + 3] = 255;
          k += 1;
        }
      }
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas;
  }
};
var ColorMapKeywords = {
  rainbow: [[0, 255], [0.2, 65535], [0.5, 65280], [0.8, 16776960], [1, 16711680]],
  cooltowarm: [[0, 3952322], [0.2, 10206463], [0.5, 14474460], [0.8, 16163717], [1, 11797542]],
  blackbody: [[0, 0], [0.2, 7864320], [0.5, 15086080], [0.8, 16776960], [1, 16777215]],
  grayscale: [[0, 0], [0.2, 4210752], [0.5, 8355712], [0.8, 12566463], [1, 16777215]]
};

// node_modules/three-stdlib/controls/experimental/CameraControls.js
var STATE;
(function(STATE3) {
  STATE3[STATE3["NONE"] = -1] = "NONE";
  STATE3[STATE3["ROTATE"] = 0] = "ROTATE";
  STATE3[STATE3["DOLLY"] = 1] = "DOLLY";
  STATE3[STATE3["PAN"] = 2] = "PAN";
  STATE3[STATE3["TOUCH_ROTATE"] = 3] = "TOUCH_ROTATE";
  STATE3[STATE3["TOUCH_PAN"] = 4] = "TOUCH_PAN";
  STATE3[STATE3["TOUCH_DOLLY_PAN"] = 5] = "TOUCH_DOLLY_PAN";
  STATE3[STATE3["TOUCH_DOLLY_ROTATE"] = 6] = "TOUCH_DOLLY_ROTATE";
})(STATE || (STATE = {}));
var CameraControls = class extends EventDispatcher {
  constructor(object, domElement) {
    super();
    _defineProperty(this, "object", void 0);
    _defineProperty(this, "domElement", void 0);
    _defineProperty(this, "enabled", true);
    _defineProperty(this, "target", new Vector3());
    _defineProperty(this, "trackball", false);
    _defineProperty(this, "minDistance", 0);
    _defineProperty(this, "maxDistance", Infinity);
    _defineProperty(this, "minZoom", 0);
    _defineProperty(this, "maxZoom", Infinity);
    _defineProperty(this, "minPolarAngle", 0);
    _defineProperty(this, "maxPolarAngle", Math.PI);
    _defineProperty(this, "minAzimuthAngle", -Infinity);
    _defineProperty(this, "maxAzimuthAngle", Infinity);
    _defineProperty(this, "enableDamping", false);
    _defineProperty(this, "dampingFactor", 0.05);
    _defineProperty(this, "enableZoom", true);
    _defineProperty(this, "zoomSpeed", 1);
    _defineProperty(this, "enableRotate", true);
    _defineProperty(this, "rotateSpeed", 1);
    _defineProperty(this, "enablePan", true);
    _defineProperty(this, "panSpeed", 1);
    _defineProperty(this, "screenSpacePanning", false);
    _defineProperty(this, "keyPanSpeed", 7);
    _defineProperty(this, "autoRotate", false);
    _defineProperty(this, "autoRotateSpeed", 2);
    _defineProperty(this, "enableKeys", true);
    _defineProperty(this, "keys", {
      LEFT: "ArrowLeft",
      UP: "ArrowUp",
      RIGHT: "ArrowRight",
      BOTTOM: "ArrowDown"
    });
    _defineProperty(this, "mouseButtons", void 0);
    _defineProperty(this, "touches", {
      ONE: TOUCH.ROTATE,
      TWO: TOUCH.DOLLY_PAN
    });
    _defineProperty(this, "target0", void 0);
    _defineProperty(this, "position0", void 0);
    _defineProperty(this, "quaternion0", void 0);
    _defineProperty(this, "zoom0", void 0);
    _defineProperty(this, "spherical", new Spherical());
    _defineProperty(this, "sphericalDelta", new Spherical());
    _defineProperty(this, "changeEvent", {
      type: "change"
    });
    _defineProperty(this, "startEvent", {
      type: "start"
    });
    _defineProperty(this, "endEvent", {
      type: "end"
    });
    _defineProperty(this, "state", STATE.NONE);
    _defineProperty(this, "EPS", 1e-6);
    _defineProperty(this, "scale", 1);
    _defineProperty(this, "panOffset", new Vector3());
    _defineProperty(this, "zoomChanged", false);
    _defineProperty(this, "rotateStart", new Vector2());
    _defineProperty(this, "rotateEnd", new Vector2());
    _defineProperty(this, "rotateDelta", new Vector2());
    _defineProperty(this, "panStart", new Vector2());
    _defineProperty(this, "panEnd", new Vector2());
    _defineProperty(this, "panDelta", new Vector2());
    _defineProperty(this, "dollyStart", new Vector2());
    _defineProperty(this, "dollyEnd", new Vector2());
    _defineProperty(this, "dollyDelta", new Vector2());
    _defineProperty(this, "offset", new Vector3());
    _defineProperty(this, "lastPosition", new Vector3());
    _defineProperty(this, "lastQuaternion", new Quaternion());
    _defineProperty(this, "q", new Quaternion());
    _defineProperty(this, "v", new Vector3());
    _defineProperty(this, "vec", new Vector3());
    _defineProperty(this, "quat", void 0);
    _defineProperty(this, "quatInverse", void 0);
    _defineProperty(this, "getPolarAngle", () => this.spherical.phi);
    _defineProperty(this, "getAzimuthalAngle", () => this.spherical.theta);
    _defineProperty(this, "saveState", () => {
      this.target0.copy(this.target);
      this.position0.copy(this.object.position);
      this.quaternion0.copy(this.object.quaternion);
      this.zoom0 = this.object.zoom;
    });
    _defineProperty(this, "reset", () => {
      this.target.copy(this.target0);
      this.object.position.copy(this.position0);
      this.object.quaternion.copy(this.quaternion0);
      this.object.zoom = this.zoom0;
      this.object.updateProjectionMatrix();
      this.dispatchEvent(this.changeEvent);
      this.update();
      this.state = STATE.NONE;
    });
    _defineProperty(this, "dispose", () => {
      this.domElement.removeEventListener("contextmenu", this.onContextMenu, false);
      this.domElement.removeEventListener("mousedown", this.onMouseDown, false);
      this.domElement.removeEventListener("wheel", this.onMouseWheel, false);
      this.domElement.removeEventListener("touchstart", this.onTouchStart, false);
      this.domElement.removeEventListener("touchend", this.onTouchEnd, false);
      this.domElement.removeEventListener("touchmove", this.onTouchMove, false);
      document.removeEventListener("mousemove", this.onMouseMove, false);
      document.removeEventListener("mouseup", this.onMouseUp, false);
      this.domElement.removeEventListener("keydown", this.onKeyDown, false);
    });
    _defineProperty(this, "update", () => {
      const position = this.object.position;
      this.offset.copy(position).sub(this.target);
      if (this.trackball) {
        if (this.sphericalDelta.theta) {
          this.vec.set(0, 1, 0).applyQuaternion(this.object.quaternion);
          const factor = this.enableDamping ? this.dampingFactor : 1;
          this.q.setFromAxisAngle(this.vec, this.sphericalDelta.theta * factor);
          this.object.quaternion.premultiply(this.q);
          this.offset.applyQuaternion(this.q);
        }
        if (this.sphericalDelta.phi) {
          this.vec.set(1, 0, 0).applyQuaternion(this.object.quaternion);
          const factor = this.enableDamping ? this.dampingFactor : 1;
          this.q.setFromAxisAngle(this.vec, this.sphericalDelta.phi * factor);
          this.object.quaternion.premultiply(this.q);
          this.offset.applyQuaternion(this.q);
        }
        this.offset.multiplyScalar(this.scale);
        this.offset.clampLength(this.minDistance, this.maxDistance);
      } else {
        this.offset.applyQuaternion(this.quat);
        if (this.autoRotate && this.state === STATE.NONE) {
          this.rotateLeft(this.getAutoRotationAngle());
        }
        this.spherical.setFromVector3(this.offset);
        if (this.enableDamping) {
          this.spherical.theta += this.sphericalDelta.theta * this.dampingFactor;
          this.spherical.phi += this.sphericalDelta.phi * this.dampingFactor;
        } else {
          this.spherical.theta += this.sphericalDelta.theta;
          this.spherical.phi += this.sphericalDelta.phi;
        }
        this.spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, this.spherical.theta));
        this.spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this.spherical.phi));
        this.spherical.makeSafe();
        this.spherical.radius *= this.scale;
        this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));
        this.offset.setFromSpherical(this.spherical);
        this.offset.applyQuaternion(this.quatInverse);
      }
      if (this.enableDamping === true) {
        this.target.addScaledVector(this.panOffset, this.dampingFactor);
      } else {
        this.target.add(this.panOffset);
      }
      position.copy(this.target).add(this.offset);
      if (this.trackball === false) {
        this.object.lookAt(this.target);
      }
      if (this.enableDamping === true) {
        this.sphericalDelta.theta *= 1 - this.dampingFactor;
        this.sphericalDelta.phi *= 1 - this.dampingFactor;
        this.panOffset.multiplyScalar(1 - this.dampingFactor);
      } else {
        this.sphericalDelta.set(0, 0, 0);
        this.panOffset.set(0, 0, 0);
      }
      this.scale = 1;
      if (this.zoomChanged || this.lastPosition.distanceToSquared(this.object.position) > this.EPS || 8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > this.EPS) {
        this.dispatchEvent(this.changeEvent);
        this.lastPosition.copy(this.object.position);
        this.lastQuaternion.copy(this.object.quaternion);
        this.zoomChanged = false;
        return true;
      }
      return false;
    });
    _defineProperty(this, "getAutoRotationAngle", () => 2 * Math.PI / 60 / 60 * this.autoRotateSpeed);
    _defineProperty(this, "getZoomScale", () => Math.pow(0.95, this.zoomSpeed));
    _defineProperty(this, "rotateLeft", (angle) => {
      this.sphericalDelta.theta -= angle;
    });
    _defineProperty(this, "rotateUp", (angle) => {
      this.sphericalDelta.phi -= angle;
    });
    _defineProperty(this, "panLeft", (distance2, objectMatrix) => {
      this.v.setFromMatrixColumn(objectMatrix, 0);
      this.v.multiplyScalar(-distance2);
      this.panOffset.add(this.v);
    });
    _defineProperty(this, "panUp", (distance2, objectMatrix) => {
      if (this.screenSpacePanning === true) {
        this.v.setFromMatrixColumn(objectMatrix, 1);
      } else {
        this.v.setFromMatrixColumn(objectMatrix, 0);
        this.v.crossVectors(this.object.up, this.v);
      }
      this.v.multiplyScalar(distance2);
      this.panOffset.add(this.v);
    });
    _defineProperty(this, "pan", (deltaX, deltaY) => {
      const element2 = this.domElement;
      if (this.object instanceof PerspectiveCamera) {
        const position = this.object.position;
        this.offset.copy(position).sub(this.target);
        let targetDistance = this.offset.length();
        targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180);
        this.panLeft(2 * deltaX * targetDistance / element2.clientHeight, this.object.matrix);
        this.panUp(2 * deltaY * targetDistance / element2.clientHeight, this.object.matrix);
      } else if (this.object.isOrthographicCamera) {
        this.panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element2.clientWidth, this.object.matrix);
        this.panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element2.clientHeight, this.object.matrix);
      } else {
        console.warn("WARNING: CameraControls.js encountered an unknown camera type - pan disabled.");
        this.enablePan = false;
      }
    });
    _defineProperty(this, "dollyIn", (dollyScale) => {
      if (this.object instanceof PerspectiveCamera) {
        this.scale /= dollyScale;
      } else if (this.object instanceof OrthographicCamera) {
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale));
        this.object.updateProjectionMatrix();
        this.zoomChanged = true;
      } else {
        console.warn("WARNING: CameraControls.js encountered an unknown camera type - dolly/zoom disabled.");
        this.enableZoom = false;
      }
    });
    _defineProperty(this, "dollyOut", (dollyScale) => {
      if (this.object instanceof PerspectiveCamera) {
        this.scale *= dollyScale;
      } else if (this.object instanceof OrthographicCamera) {
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale));
        this.object.updateProjectionMatrix();
        this.zoomChanged = true;
      } else {
        console.warn("WARNING: CameraControls.js encountered an unknown camera type - dolly/zoom disabled.");
        this.enableZoom = false;
      }
    });
    _defineProperty(this, "handleMouseDownRotate", (event) => {
      this.rotateStart.set(event.clientX, event.clientY);
    });
    _defineProperty(this, "handleMouseDownDolly", (event) => {
      this.dollyStart.set(event.clientX, event.clientY);
    });
    _defineProperty(this, "handleMouseDownPan", (event) => {
      this.panStart.set(event.clientX, event.clientY);
    });
    _defineProperty(this, "handleMouseMoveRotate", (event) => {
      this.rotateEnd.set(event.clientX, event.clientY);
      this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);
      const element2 = this.domElement;
      this.rotateLeft(2 * Math.PI * this.rotateDelta.x / element2.clientHeight);
      this.rotateUp(2 * Math.PI * this.rotateDelta.y / element2.clientHeight);
      this.rotateStart.copy(this.rotateEnd);
      this.update();
    });
    _defineProperty(this, "handleMouseMoveDolly", (event) => {
      this.dollyEnd.set(event.clientX, event.clientY);
      this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart);
      if (this.dollyDelta.y > 0) {
        this.dollyIn(this.getZoomScale());
      } else if (this.dollyDelta.y < 0) {
        this.dollyOut(this.getZoomScale());
      }
      this.dollyStart.copy(this.dollyEnd);
      this.update();
    });
    _defineProperty(this, "handleMouseMovePan", (event) => {
      this.panEnd.set(event.clientX, event.clientY);
      this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.panSpeed);
      this.pan(this.panDelta.x, this.panDelta.y);
      this.panStart.copy(this.panEnd);
      this.update();
    });
    _defineProperty(this, "handleMouseWheel", (event) => {
      if (event.deltaY < 0) {
        this.dollyOut(this.getZoomScale());
      } else if (event.deltaY > 0) {
        this.dollyIn(this.getZoomScale());
      }
      this.update();
    });
    _defineProperty(this, "handleKeyDown", (event) => {
      let needsUpdate = false;
      switch (event.code) {
        case this.keys.UP:
          this.pan(0, this.keyPanSpeed);
          needsUpdate = true;
          break;
        case this.keys.BOTTOM:
          this.pan(0, -this.keyPanSpeed);
          needsUpdate = true;
          break;
        case this.keys.LEFT:
          this.pan(this.keyPanSpeed, 0);
          needsUpdate = true;
          break;
        case this.keys.RIGHT:
          this.pan(-this.keyPanSpeed, 0);
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        this.update();
      }
    });
    _defineProperty(this, "handleTouchStartRotate", (event) => {
      if (event.touches.length == 1) {
        this.rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        this.rotateStart.set(x, y);
      }
    });
    _defineProperty(this, "handleTouchStartPan", (event) => {
      if (event.touches.length == 1) {
        this.panStart.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        this.panStart.set(x, y);
      }
    });
    _defineProperty(this, "handleTouchStartDolly", (event) => {
      const dx = event.touches[0].pageX - event.touches[1].pageX;
      const dy = event.touches[0].pageY - event.touches[1].pageY;
      const distance2 = Math.sqrt(dx * dx + dy * dy);
      this.dollyStart.set(0, distance2);
    });
    _defineProperty(this, "handleTouchStartDollyPan", (event) => {
      if (this.enableZoom)
        this.handleTouchStartDolly(event);
      if (this.enablePan)
        this.handleTouchStartPan(event);
    });
    _defineProperty(this, "handleTouchStartDollyRotate", (event) => {
      if (this.enableZoom)
        this.handleTouchStartDolly(event);
      if (this.enableRotate)
        this.handleTouchStartRotate(event);
    });
    _defineProperty(this, "handleTouchMoveRotate", (event) => {
      if (event.touches.length == 1) {
        this.rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        this.rotateEnd.set(x, y);
      }
      this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);
      const element2 = this.domElement;
      this.rotateLeft(2 * Math.PI * this.rotateDelta.x / element2.clientHeight);
      this.rotateUp(2 * Math.PI * this.rotateDelta.y / element2.clientHeight);
      this.rotateStart.copy(this.rotateEnd);
    });
    _defineProperty(this, "handleTouchMovePan", (event) => {
      if (event.touches.length == 1) {
        this.panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        this.panEnd.set(x, y);
      }
      this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.panSpeed);
      this.pan(this.panDelta.x, this.panDelta.y);
      this.panStart.copy(this.panEnd);
    });
    _defineProperty(this, "handleTouchMoveDolly", (event) => {
      const dx = event.touches[0].pageX - event.touches[1].pageX;
      const dy = event.touches[0].pageY - event.touches[1].pageY;
      const distance2 = Math.sqrt(dx * dx + dy * dy);
      this.dollyEnd.set(0, distance2);
      this.dollyDelta.set(0, Math.pow(this.dollyEnd.y / this.dollyStart.y, this.zoomSpeed));
      this.dollyIn(this.dollyDelta.y);
      this.dollyStart.copy(this.dollyEnd);
    });
    _defineProperty(this, "handleTouchMoveDollyPan", (event) => {
      if (this.enableZoom)
        this.handleTouchMoveDolly(event);
      if (this.enablePan)
        this.handleTouchMovePan(event);
    });
    _defineProperty(this, "handleTouchMoveDollyRotate", (event) => {
      if (this.enableZoom)
        this.handleTouchMoveDolly(event);
      if (this.enableRotate)
        this.handleTouchMoveRotate(event);
    });
    _defineProperty(this, "onMouseDown", (event) => {
      if (this.enabled === false)
        return;
      event.preventDefault();
      this.domElement.focus ? this.domElement.focus() : window.focus();
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = this.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = this.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = this.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (this.enableZoom === false)
            return;
          this.handleMouseDownDolly(event);
          this.state = STATE.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (this.enablePan === false)
              return;
            this.handleMouseDownPan(event);
            this.state = STATE.PAN;
          } else {
            if (this.enableRotate === false)
              return;
            this.handleMouseDownRotate(event);
            this.state = STATE.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (this.enableRotate === false)
              return;
            this.handleMouseDownRotate(event);
            this.state = STATE.ROTATE;
          } else {
            if (this.enablePan === false)
              return;
            this.handleMouseDownPan(event);
            this.state = STATE.PAN;
          }
          break;
        default:
          this.state = STATE.NONE;
      }
      if (this.state !== STATE.NONE) {
        document.addEventListener("mousemove", this.onMouseMove, false);
        document.addEventListener("mouseup", this.onMouseUp, false);
        this.dispatchEvent(this.startEvent);
      }
    });
    _defineProperty(this, "onMouseMove", (event) => {
      if (this.enabled === false)
        return;
      event.preventDefault();
      switch (this.state) {
        case STATE.ROTATE:
          if (this.enableRotate === false)
            return;
          this.handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (this.enableZoom === false)
            return;
          this.handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (this.enablePan === false)
            return;
          this.handleMouseMovePan(event);
          break;
      }
    });
    _defineProperty(this, "onMouseUp", () => {
      if (this.enabled === false)
        return;
      document.removeEventListener("mousemove", this.onMouseMove, false);
      document.removeEventListener("mouseup", this.onMouseUp, false);
      this.dispatchEvent(this.endEvent);
      this.state = STATE.NONE;
    });
    _defineProperty(this, "onMouseWheel", (event) => {
      if (this.enabled === false || this.enableZoom === false || this.state !== STATE.NONE && this.state !== STATE.ROTATE) {
        return;
      }
      event.preventDefault();
      this.dispatchEvent(this.startEvent);
      this.handleMouseWheel(event);
      this.dispatchEvent(this.endEvent);
    });
    _defineProperty(this, "onKeyDown", (event) => {
      if (this.enabled === false || this.enableKeys === false || this.enablePan === false)
        return;
      this.handleKeyDown(event);
    });
    _defineProperty(this, "onTouchStart", (event) => {
      if (this.enabled === false)
        return;
      event.preventDefault();
      switch (event.touches.length) {
        case 1:
          switch (this.touches.ONE) {
            case TOUCH.ROTATE:
              if (this.enableRotate === false)
                return;
              this.handleTouchStartRotate(event);
              this.state = STATE.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (this.enablePan === false)
                return;
              this.handleTouchStartPan(event);
              this.state = STATE.TOUCH_PAN;
              break;
            default:
              this.state = STATE.NONE;
          }
          break;
        case 2:
          switch (this.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (this.enableZoom === false && this.enablePan === false)
                return;
              this.handleTouchStartDollyPan(event);
              this.state = STATE.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (this.enableZoom === false && this.enableRotate === false)
                return;
              this.handleTouchStartDollyRotate(event);
              this.state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              this.state = STATE.NONE;
          }
          break;
        default:
          this.state = STATE.NONE;
      }
      if (this.state !== STATE.NONE) {
        this.dispatchEvent(this.startEvent);
      }
    });
    _defineProperty(this, "onTouchMove", (event) => {
      if (this.enabled === false)
        return;
      event.preventDefault();
      switch (this.state) {
        case STATE.TOUCH_ROTATE:
          if (this.enableRotate === false)
            return;
          this.handleTouchMoveRotate(event);
          this.update();
          break;
        case STATE.TOUCH_PAN:
          if (this.enablePan === false)
            return;
          this.handleTouchMovePan(event);
          this.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (this.enableZoom === false && this.enablePan === false)
            return;
          this.handleTouchMoveDollyPan(event);
          this.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (this.enableZoom === false && this.enableRotate === false)
            return;
          this.handleTouchMoveDollyRotate(event);
          this.update();
          break;
        default:
          this.state = STATE.NONE;
      }
    });
    _defineProperty(this, "onTouchEnd", () => {
      if (this.enabled === false)
        return;
      this.dispatchEvent(this.endEvent);
      this.state = STATE.NONE;
    });
    _defineProperty(this, "onContextMenu", (event) => {
      if (this.enabled === false)
        return;
      event.preventDefault();
    });
    if (domElement === void 0) {
      console.warn('THREE.CameraControls: The second parameter "domElement" is now mandatory.');
    }
    if (domElement instanceof Document) {
      console.error('THREE.CameraControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
    }
    this.object = object;
    this.domElement = domElement;
    this.mouseButtons = {
      LEFT: MOUSE.ROTATE,
      MIDDLE: MOUSE.DOLLY,
      RIGHT: MOUSE.PAN
    };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.quaternion0 = this.object.quaternion.clone();
    this.zoom0 = this.object.zoom;
    this.quat = new Quaternion().setFromUnitVectors(this.object.up, new Vector3(0, 1, 0));
    this.quatInverse = this.quat.clone().invert();
    this.lastPosition = new Vector3();
    this.lastQuaternion = new Quaternion();
    this.domElement.addEventListener("contextmenu", this.onContextMenu, false);
    this.domElement.addEventListener("mousedown", this.onMouseDown, false);
    this.domElement.addEventListener("wheel", this.onMouseWheel, false);
    this.domElement.addEventListener("touchstart", this.onTouchStart, false);
    this.domElement.addEventListener("touchend", this.onTouchEnd, false);
    this.domElement.addEventListener("touchmove", this.onTouchMove, false);
    this.domElement.addEventListener("keydown", this.onKeyDown, false);
    if (this.domElement.tabIndex === -1) {
      this.domElement.tabIndex = 0;
    }
    this.object.lookAt(this.target);
    this.update();
    this.saveState();
  }
  handleMouseUp() {
  }
  handleTouchEnd() {
  }
};
var OrbitControlsExp = class extends CameraControls {
  constructor(object, domElement) {
    super(object, domElement);
    _defineProperty(this, "mouseButtons", void 0);
    _defineProperty(this, "touches", void 0);
    this.mouseButtons = {
      LEFT: MOUSE.ROTATE,
      RIGHT: MOUSE.PAN
    };
    this.touches = {
      ONE: TOUCH.ROTATE,
      TWO: TOUCH.DOLLY_PAN
    };
  }
};
var MapControlsExp = class extends CameraControls {
  constructor(object, domElement) {
    super(object, domElement);
    _defineProperty(this, "mouseButtons", void 0);
    _defineProperty(this, "touches", void 0);
    this.mouseButtons = {
      LEFT: MOUSE.PAN,
      RIGHT: MOUSE.ROTATE
    };
    this.touches = {
      ONE: TOUCH.PAN,
      TWO: TOUCH.DOLLY_ROTATE
    };
  }
};
var TrackballControlsExp = class extends CameraControls {
  constructor(object, domElement) {
    super(object, domElement);
    _defineProperty(this, "trackball", void 0);
    _defineProperty(this, "screenSpacePanning", void 0);
    _defineProperty(this, "autoRotate", void 0);
    _defineProperty(this, "mouseButtons", void 0);
    _defineProperty(this, "touches", void 0);
    this.trackball = true;
    this.screenSpacePanning = true;
    this.autoRotate = false;
    this.mouseButtons = {
      LEFT: MOUSE.ROTATE,
      RIGHT: MOUSE.PAN
    };
    this.touches = {
      ONE: TOUCH.ROTATE,
      TWO: TOUCH.DOLLY_PAN
    };
  }
};

// node_modules/three-stdlib/controls/FirstPersonControls.js
var targetPosition = new Vector3();
var FirstPersonControls = class extends EventDispatcher {
  constructor(object, _domElement) {
    super();
    _defineProperty(this, "object", void 0);
    _defineProperty(this, "domElement", void 0);
    _defineProperty(this, "enabled", true);
    _defineProperty(this, "movementSpeed", 1);
    _defineProperty(this, "lookSpeed", 5e-3);
    _defineProperty(this, "lookVertical", true);
    _defineProperty(this, "autoForward", false);
    _defineProperty(this, "activeLook", true);
    _defineProperty(this, "heightSpeed", false);
    _defineProperty(this, "heightCoef", 1);
    _defineProperty(this, "heightMin", 0);
    _defineProperty(this, "heightMax", 1);
    _defineProperty(this, "constrainVertical", false);
    _defineProperty(this, "verticalMin", 0);
    _defineProperty(this, "verticalMax", Math.PI);
    _defineProperty(this, "mouseDragOn", false);
    _defineProperty(this, "autoSpeedFactor", 0);
    _defineProperty(this, "mouseX", 0);
    _defineProperty(this, "mouseY", 0);
    _defineProperty(this, "moveForward", false);
    _defineProperty(this, "moveBackward", false);
    _defineProperty(this, "moveLeft", false);
    _defineProperty(this, "moveRight", false);
    _defineProperty(this, "moveUp", false);
    _defineProperty(this, "moveDown", false);
    _defineProperty(this, "viewHalfX", 0);
    _defineProperty(this, "viewHalfY", 0);
    _defineProperty(this, "lat", 0);
    _defineProperty(this, "lon", 0);
    _defineProperty(this, "lookDirection", new Vector3());
    _defineProperty(this, "spherical", new Spherical());
    _defineProperty(this, "target", new Vector3());
    _defineProperty(this, "connect", (domElement) => {
      domElement.setAttribute("tabindex", "-1");
      domElement.style.touchAction = "none";
      domElement.addEventListener("contextmenu", this.contextmenu);
      domElement.addEventListener("mousemove", this.onMouseMove);
      domElement.addEventListener("mousedown", this.onMouseDown);
      domElement.addEventListener("mouseup", this.onMouseUp);
      this.domElement = domElement;
      window.addEventListener("keydown", this.onKeyDown);
      window.addEventListener("keyup", this.onKeyUp);
      this.handleResize();
    });
    _defineProperty(this, "dispose", () => {
      var _this$domElement, _this$domElement2, _this$domElement3, _this$domElement4;
      (_this$domElement = this.domElement) === null || _this$domElement === void 0 ? void 0 : _this$domElement.removeEventListener("contextmenu", this.contextmenu);
      (_this$domElement2 = this.domElement) === null || _this$domElement2 === void 0 ? void 0 : _this$domElement2.removeEventListener("mousedown", this.onMouseDown);
      (_this$domElement3 = this.domElement) === null || _this$domElement3 === void 0 ? void 0 : _this$domElement3.removeEventListener("mousemove", this.onMouseMove);
      (_this$domElement4 = this.domElement) === null || _this$domElement4 === void 0 ? void 0 : _this$domElement4.removeEventListener("mouseup", this.onMouseUp);
      window.removeEventListener("keydown", this.onKeyDown);
      window.removeEventListener("keyup", this.onKeyUp);
    });
    _defineProperty(this, "handleResize", () => {
      if (this.domElement) {
        this.viewHalfX = this.domElement.offsetWidth / 2;
        this.viewHalfY = this.domElement.offsetHeight / 2;
      }
    });
    _defineProperty(this, "onMouseDown", (event) => {
      var _this$domElement5;
      (_this$domElement5 = this.domElement) === null || _this$domElement5 === void 0 ? void 0 : _this$domElement5.focus();
      if (this.activeLook) {
        switch (event.button) {
          case 0:
            this.moveForward = true;
            break;
          case 2:
            this.moveBackward = true;
            break;
        }
      }
      this.mouseDragOn = true;
    });
    _defineProperty(this, "onMouseUp", (event) => {
      if (this.activeLook) {
        switch (event.button) {
          case 0:
            this.moveForward = false;
            break;
          case 2:
            this.moveBackward = false;
            break;
        }
      }
      this.mouseDragOn = false;
    });
    _defineProperty(this, "onMouseMove", (event) => {
      if (this.domElement) {
        this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;
        this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;
      }
    });
    _defineProperty(this, "onKeyDown", (event) => {
      switch (event.code) {
        case "ArrowUp":
        case "KeyW":
          this.moveForward = true;
          break;
        case "ArrowLeft":
        case "KeyA":
          this.moveLeft = true;
          break;
        case "ArrowDown":
        case "KeyS":
          this.moveBackward = true;
          break;
        case "ArrowRight":
        case "KeyD":
          this.moveRight = true;
          break;
        case "KeyR":
          this.moveUp = true;
          break;
        case "KeyF":
          this.moveDown = true;
          break;
      }
    });
    _defineProperty(this, "onKeyUp", (event) => {
      switch (event.code) {
        case "ArrowUp":
        case "KeyW":
          this.moveForward = false;
          break;
        case "ArrowLeft":
        case "KeyA":
          this.moveLeft = false;
          break;
        case "ArrowDown":
        case "KeyS":
          this.moveBackward = false;
          break;
        case "ArrowRight":
        case "KeyD":
          this.moveRight = false;
          break;
        case "KeyR":
          this.moveUp = false;
          break;
        case "KeyF":
          this.moveDown = false;
          break;
      }
    });
    _defineProperty(this, "lookAt", (x, y, z) => {
      if (x instanceof Vector3) {
        this.target.copy(x);
      } else if (y && z) {
        this.target.set(x, y, z);
      }
      this.object.lookAt(this.target);
      this.setOrientation();
      return this;
    });
    _defineProperty(this, "update", (delta) => {
      if (!this.enabled)
        return;
      if (this.heightSpeed) {
        const y = MathUtils.clamp(this.object.position.y, this.heightMin, this.heightMax);
        const heightDelta = y - this.heightMin;
        this.autoSpeedFactor = delta * (heightDelta * this.heightCoef);
      } else {
        this.autoSpeedFactor = 0;
      }
      const actualMoveSpeed = delta * this.movementSpeed;
      if (this.moveForward || this.autoForward && !this.moveBackward) {
        this.object.translateZ(-(actualMoveSpeed + this.autoSpeedFactor));
      }
      if (this.moveBackward)
        this.object.translateZ(actualMoveSpeed);
      if (this.moveLeft)
        this.object.translateX(-actualMoveSpeed);
      if (this.moveRight)
        this.object.translateX(actualMoveSpeed);
      if (this.moveUp)
        this.object.translateY(actualMoveSpeed);
      if (this.moveDown)
        this.object.translateY(-actualMoveSpeed);
      let actualLookSpeed = delta * this.lookSpeed;
      if (!this.activeLook) {
        actualLookSpeed = 0;
      }
      let verticalLookRatio = 1;
      if (this.constrainVertical) {
        verticalLookRatio = Math.PI / (this.verticalMax - this.verticalMin);
      }
      this.lon -= this.mouseX * actualLookSpeed;
      if (this.lookVertical)
        this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;
      this.lat = Math.max(-85, Math.min(85, this.lat));
      let phi = MathUtils.degToRad(90 - this.lat);
      const theta = MathUtils.degToRad(this.lon);
      if (this.constrainVertical) {
        phi = MathUtils.mapLinear(phi, 0, Math.PI, this.verticalMin, this.verticalMax);
      }
      const position = this.object.position;
      targetPosition.setFromSphericalCoords(1, phi, theta).add(position);
      this.object.lookAt(targetPosition);
    });
    _defineProperty(this, "contextmenu", (event) => event.preventDefault());
    _defineProperty(this, "setOrientation", () => {
      this.lookDirection.set(0, 0, -1).applyQuaternion(this.object.quaternion);
      this.spherical.setFromVector3(this.lookDirection);
      this.lat = 90 - MathUtils.radToDeg(this.spherical.phi);
      this.lon = MathUtils.radToDeg(this.spherical.theta);
    });
    this.object = object;
    this.domElement = _domElement;
    this.setOrientation();
    if (_domElement)
      this.connect(_domElement);
  }
};

// node_modules/three-stdlib/controls/TransformControls.js
var TransformControls = class extends Object3D {
  constructor(camera, _domElement) {
    super();
    _defineProperty(this, "isTransformControls", true);
    _defineProperty(this, "visible", false);
    _defineProperty(this, "domElement", void 0);
    _defineProperty(this, "raycaster", new Raycaster());
    _defineProperty(this, "gizmo", void 0);
    _defineProperty(this, "plane", void 0);
    _defineProperty(this, "tempVector", new Vector3());
    _defineProperty(this, "tempVector2", new Vector3());
    _defineProperty(this, "tempQuaternion", new Quaternion());
    _defineProperty(this, "unit", {
      X: new Vector3(1, 0, 0),
      Y: new Vector3(0, 1, 0),
      Z: new Vector3(0, 0, 1)
    });
    _defineProperty(this, "pointStart", new Vector3());
    _defineProperty(this, "pointEnd", new Vector3());
    _defineProperty(this, "offset", new Vector3());
    _defineProperty(this, "rotationAxis", new Vector3());
    _defineProperty(this, "startNorm", new Vector3());
    _defineProperty(this, "endNorm", new Vector3());
    _defineProperty(this, "rotationAngle", 0);
    _defineProperty(this, "cameraPosition", new Vector3());
    _defineProperty(this, "cameraQuaternion", new Quaternion());
    _defineProperty(this, "cameraScale", new Vector3());
    _defineProperty(this, "parentPosition", new Vector3());
    _defineProperty(this, "parentQuaternion", new Quaternion());
    _defineProperty(this, "parentQuaternionInv", new Quaternion());
    _defineProperty(this, "parentScale", new Vector3());
    _defineProperty(this, "worldPositionStart", new Vector3());
    _defineProperty(this, "worldQuaternionStart", new Quaternion());
    _defineProperty(this, "worldScaleStart", new Vector3());
    _defineProperty(this, "worldPosition", new Vector3());
    _defineProperty(this, "worldQuaternion", new Quaternion());
    _defineProperty(this, "worldQuaternionInv", new Quaternion());
    _defineProperty(this, "worldScale", new Vector3());
    _defineProperty(this, "eye", new Vector3());
    _defineProperty(this, "positionStart", new Vector3());
    _defineProperty(this, "quaternionStart", new Quaternion());
    _defineProperty(this, "scaleStart", new Vector3());
    _defineProperty(this, "camera", void 0);
    _defineProperty(this, "object", void 0);
    _defineProperty(this, "enabled", true);
    _defineProperty(this, "axis", null);
    _defineProperty(this, "mode", "translate");
    _defineProperty(this, "translationSnap", null);
    _defineProperty(this, "rotationSnap", null);
    _defineProperty(this, "scaleSnap", null);
    _defineProperty(this, "space", "world");
    _defineProperty(this, "size", 1);
    _defineProperty(this, "dragging", false);
    _defineProperty(this, "showX", true);
    _defineProperty(this, "showY", true);
    _defineProperty(this, "showZ", true);
    _defineProperty(this, "changeEvent", {
      type: "change"
    });
    _defineProperty(this, "mouseDownEvent", {
      type: "mouseDown",
      mode: this.mode
    });
    _defineProperty(this, "mouseUpEvent", {
      type: "mouseUp",
      mode: this.mode
    });
    _defineProperty(this, "objectChangeEvent", {
      type: "objectChange"
    });
    _defineProperty(this, "intersectObjectWithRay", (object, raycaster, includeInvisible) => {
      const allIntersections = raycaster.intersectObject(object, true);
      for (let i2 = 0; i2 < allIntersections.length; i2++) {
        if (allIntersections[i2].object.visible || includeInvisible) {
          return allIntersections[i2];
        }
      }
      return false;
    });
    _defineProperty(this, "attach", (object) => {
      this.object = object;
      this.visible = true;
      return this;
    });
    _defineProperty(this, "detach", () => {
      this.object = void 0;
      this.visible = false;
      this.axis = null;
      return this;
    });
    _defineProperty(this, "reset", () => {
      if (!this.enabled)
        return this;
      if (this.dragging) {
        if (this.object !== void 0) {
          this.object.position.copy(this.positionStart);
          this.object.quaternion.copy(this.quaternionStart);
          this.object.scale.copy(this.scaleStart);
          this.dispatchEvent(this.changeEvent);
          this.dispatchEvent(this.objectChangeEvent);
          this.pointStart.copy(this.pointEnd);
        }
      }
      return this;
    });
    _defineProperty(this, "updateMatrixWorld", () => {
      if (this.object !== void 0) {
        this.object.updateMatrixWorld();
        if (this.object.parent === null) {
          console.error("TransformControls: The attached 3D object must be a part of the scene graph.");
        } else {
          this.object.parent.matrixWorld.decompose(this.parentPosition, this.parentQuaternion, this.parentScale);
        }
        this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this.worldScale);
        this.parentQuaternionInv.copy(this.parentQuaternion).invert();
        this.worldQuaternionInv.copy(this.worldQuaternion).invert();
      }
      this.camera.updateMatrixWorld();
      this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this.cameraScale);
      this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize();
      super.updateMatrixWorld();
    });
    _defineProperty(this, "pointerHover", (pointer) => {
      if (this.object === void 0 || this.dragging === true)
        return;
      this.raycaster.setFromCamera(pointer, this.camera);
      const intersect = this.intersectObjectWithRay(this.gizmo.picker[this.mode], this.raycaster);
      if (intersect) {
        this.axis = intersect.object.name;
      } else {
        this.axis = null;
      }
    });
    _defineProperty(this, "pointerDown", (pointer) => {
      if (this.object === void 0 || this.dragging === true || pointer.button !== 0)
        return;
      if (this.axis !== null) {
        this.raycaster.setFromCamera(pointer, this.camera);
        const planeIntersect = this.intersectObjectWithRay(this.plane, this.raycaster, true);
        if (planeIntersect) {
          let space = this.space;
          if (this.mode === "scale") {
            space = "local";
          } else if (this.axis === "E" || this.axis === "XYZE" || this.axis === "XYZ") {
            space = "world";
          }
          if (space === "local" && this.mode === "rotate") {
            const snap = this.rotationSnap;
            if (this.axis === "X" && snap)
              this.object.rotation.x = Math.round(this.object.rotation.x / snap) * snap;
            if (this.axis === "Y" && snap)
              this.object.rotation.y = Math.round(this.object.rotation.y / snap) * snap;
            if (this.axis === "Z" && snap)
              this.object.rotation.z = Math.round(this.object.rotation.z / snap) * snap;
          }
          this.object.updateMatrixWorld();
          if (this.object.parent) {
            this.object.parent.updateMatrixWorld();
          }
          this.positionStart.copy(this.object.position);
          this.quaternionStart.copy(this.object.quaternion);
          this.scaleStart.copy(this.object.scale);
          this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this.worldScaleStart);
          this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
        }
        this.dragging = true;
        this.mouseDownEvent.mode = this.mode;
        this.dispatchEvent(this.mouseDownEvent);
      }
    });
    _defineProperty(this, "pointerMove", (pointer) => {
      const axis = this.axis;
      const mode = this.mode;
      const object = this.object;
      let space = this.space;
      if (mode === "scale") {
        space = "local";
      } else if (axis === "E" || axis === "XYZE" || axis === "XYZ") {
        space = "world";
      }
      if (object === void 0 || axis === null || this.dragging === false || pointer.button !== -1)
        return;
      this.raycaster.setFromCamera(pointer, this.camera);
      const planeIntersect = this.intersectObjectWithRay(this.plane, this.raycaster, true);
      if (!planeIntersect)
        return;
      this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
      if (mode === "translate") {
        this.offset.copy(this.pointEnd).sub(this.pointStart);
        if (space === "local" && axis !== "XYZ") {
          this.offset.applyQuaternion(this.worldQuaternionInv);
        }
        if (axis.indexOf("X") === -1)
          this.offset.x = 0;
        if (axis.indexOf("Y") === -1)
          this.offset.y = 0;
        if (axis.indexOf("Z") === -1)
          this.offset.z = 0;
        if (space === "local" && axis !== "XYZ") {
          this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale);
        } else {
          this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale);
        }
        object.position.copy(this.offset).add(this.positionStart);
        if (this.translationSnap) {
          if (space === "local") {
            object.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert());
            if (axis.search("X") !== -1) {
              object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
            }
            if (axis.search("Y") !== -1) {
              object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
            }
            if (axis.search("Z") !== -1) {
              object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
            }
            object.position.applyQuaternion(this.quaternionStart);
          }
          if (space === "world") {
            if (object.parent) {
              object.position.add(this.tempVector.setFromMatrixPosition(object.parent.matrixWorld));
            }
            if (axis.search("X") !== -1) {
              object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
            }
            if (axis.search("Y") !== -1) {
              object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
            }
            if (axis.search("Z") !== -1) {
              object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
            }
            if (object.parent) {
              object.position.sub(this.tempVector.setFromMatrixPosition(object.parent.matrixWorld));
            }
          }
        }
      } else if (mode === "scale") {
        if (axis.search("XYZ") !== -1) {
          let d = this.pointEnd.length() / this.pointStart.length();
          if (this.pointEnd.dot(this.pointStart) < 0)
            d *= -1;
          this.tempVector2.set(d, d, d);
        } else {
          this.tempVector.copy(this.pointStart);
          this.tempVector2.copy(this.pointEnd);
          this.tempVector.applyQuaternion(this.worldQuaternionInv);
          this.tempVector2.applyQuaternion(this.worldQuaternionInv);
          this.tempVector2.divide(this.tempVector);
          if (axis.search("X") === -1) {
            this.tempVector2.x = 1;
          }
          if (axis.search("Y") === -1) {
            this.tempVector2.y = 1;
          }
          if (axis.search("Z") === -1) {
            this.tempVector2.z = 1;
          }
        }
        object.scale.copy(this.scaleStart).multiply(this.tempVector2);
        if (this.scaleSnap && this.object) {
          if (axis.search("X") !== -1) {
            this.object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
          }
          if (axis.search("Y") !== -1) {
            object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
          }
          if (axis.search("Z") !== -1) {
            object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
          }
        }
      } else if (mode === "rotate") {
        this.offset.copy(this.pointEnd).sub(this.pointStart);
        const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));
        if (axis === "E") {
          this.rotationAxis.copy(this.eye);
          this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
          this.startNorm.copy(this.pointStart).normalize();
          this.endNorm.copy(this.pointEnd).normalize();
          this.rotationAngle *= this.endNorm.cross(this.startNorm).dot(this.eye) < 0 ? 1 : -1;
        } else if (axis === "XYZE") {
          this.rotationAxis.copy(this.offset).cross(this.eye).normalize();
          this.rotationAngle = this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
        } else if (axis === "X" || axis === "Y" || axis === "Z") {
          this.rotationAxis.copy(this.unit[axis]);
          this.tempVector.copy(this.unit[axis]);
          if (space === "local") {
            this.tempVector.applyQuaternion(this.worldQuaternion);
          }
          this.rotationAngle = this.offset.dot(this.tempVector.cross(this.eye).normalize()) * ROTATION_SPEED;
        }
        if (this.rotationSnap) {
          this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;
        }
        if (space === "local" && axis !== "E" && axis !== "XYZE") {
          object.quaternion.copy(this.quaternionStart);
          object.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
        } else {
          this.rotationAxis.applyQuaternion(this.parentQuaternionInv);
          object.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
          object.quaternion.multiply(this.quaternionStart).normalize();
        }
      }
      this.dispatchEvent(this.changeEvent);
      this.dispatchEvent(this.objectChangeEvent);
    });
    _defineProperty(this, "pointerUp", (pointer) => {
      if (pointer.button !== 0)
        return;
      if (this.dragging && this.axis !== null) {
        this.mouseUpEvent.mode = this.mode;
        this.dispatchEvent(this.mouseUpEvent);
      }
      this.dragging = false;
      this.axis = null;
    });
    _defineProperty(this, "getPointer", (event) => {
      var _this$domElement$owne;
      if (this.domElement && (_this$domElement$owne = this.domElement.ownerDocument) !== null && _this$domElement$owne !== void 0 && _this$domElement$owne.pointerLockElement) {
        return {
          x: 0,
          y: 0,
          button: event.button
        };
      } else {
        var _this$domElement;
        const pointer = event.changedTouches ? event.changedTouches[0] : event;
        const rect = (_this$domElement = this.domElement) === null || _this$domElement === void 0 ? void 0 : _this$domElement.getBoundingClientRect();
        return {
          x: (pointer.clientX - rect.left) / rect.width * 2 - 1,
          y: -(pointer.clientY - rect.top) / rect.height * 2 + 1,
          button: event.button
        };
      }
    });
    _defineProperty(this, "onPointerHover", (event) => {
      if (!this.enabled)
        return;
      switch (event.pointerType) {
        case "mouse":
        case "pen":
          this.pointerHover(this.getPointer(event));
          break;
      }
    });
    _defineProperty(this, "onPointerDown", (event) => {
      if (!this.enabled || !this.domElement)
        return;
      this.domElement.style.touchAction = "none";
      this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove);
      this.pointerHover(this.getPointer(event));
      this.pointerDown(this.getPointer(event));
    });
    _defineProperty(this, "onPointerMove", (event) => {
      if (!this.enabled)
        return;
      this.pointerMove(this.getPointer(event));
    });
    _defineProperty(this, "onPointerUp", (event) => {
      if (!this.enabled || !this.domElement)
        return;
      this.domElement.style.touchAction = "";
      this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove);
      this.pointerUp(this.getPointer(event));
    });
    _defineProperty(this, "getMode", () => this.mode);
    _defineProperty(this, "setMode", (mode) => {
      this.mode = mode;
    });
    _defineProperty(this, "setTranslationSnap", (translationSnap) => {
      this.translationSnap = translationSnap;
    });
    _defineProperty(this, "setRotationSnap", (rotationSnap) => {
      this.rotationSnap = rotationSnap;
    });
    _defineProperty(this, "setScaleSnap", (scaleSnap) => {
      this.scaleSnap = scaleSnap;
    });
    _defineProperty(this, "setSize", (size2) => {
      this.size = size2;
    });
    _defineProperty(this, "setSpace", (space) => {
      this.space = space;
    });
    _defineProperty(this, "update", () => {
      console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.");
    });
    _defineProperty(this, "connect", (domElement) => {
      if (domElement === document) {
        console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
      }
      this.domElement = domElement;
      this.domElement.addEventListener("pointerdown", this.onPointerDown);
      this.domElement.addEventListener("pointermove", this.onPointerHover);
      this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp);
    });
    _defineProperty(this, "dispose", () => {
      var _this$domElement2, _this$domElement3, _this$domElement4, _this$domElement4$own, _this$domElement5, _this$domElement5$own;
      (_this$domElement2 = this.domElement) === null || _this$domElement2 === void 0 ? void 0 : _this$domElement2.removeEventListener("pointerdown", this.onPointerDown);
      (_this$domElement3 = this.domElement) === null || _this$domElement3 === void 0 ? void 0 : _this$domElement3.removeEventListener("pointermove", this.onPointerHover);
      (_this$domElement4 = this.domElement) === null || _this$domElement4 === void 0 ? void 0 : (_this$domElement4$own = _this$domElement4.ownerDocument) === null || _this$domElement4$own === void 0 ? void 0 : _this$domElement4$own.removeEventListener("pointermove", this.onPointerMove);
      (_this$domElement5 = this.domElement) === null || _this$domElement5 === void 0 ? void 0 : (_this$domElement5$own = _this$domElement5.ownerDocument) === null || _this$domElement5$own === void 0 ? void 0 : _this$domElement5$own.removeEventListener("pointerup", this.onPointerUp);
      this.traverse((child) => {
        const mesh = child;
        if (mesh.geometry) {
          mesh.geometry.dispose();
        }
        if (mesh.material) {
          mesh.material.dispose();
        }
      });
    });
    this.domElement = _domElement;
    this.camera = camera;
    this.gizmo = new TransformControlsGizmo();
    this.add(this.gizmo);
    this.plane = new TransformControlsPlane();
    this.add(this.plane);
    const defineProperty = (propName, defaultValue) => {
      let propValue = defaultValue;
      Object.defineProperty(this, propName, {
        get: function() {
          return propValue !== void 0 ? propValue : defaultValue;
        },
        set: function(value) {
          if (propValue !== value) {
            propValue = value;
            this.plane[propName] = value;
            this.gizmo[propName] = value;
            this.dispatchEvent({
              type: propName + "-changed",
              value
            });
            this.dispatchEvent(this.changeEvent);
          }
        }
      });
      this[propName] = defaultValue;
      this.plane[propName] = defaultValue;
      this.gizmo[propName] = defaultValue;
    };
    defineProperty("camera", this.camera);
    defineProperty("object", this.object);
    defineProperty("enabled", this.enabled);
    defineProperty("axis", this.axis);
    defineProperty("mode", this.mode);
    defineProperty("translationSnap", this.translationSnap);
    defineProperty("rotationSnap", this.rotationSnap);
    defineProperty("scaleSnap", this.scaleSnap);
    defineProperty("space", this.space);
    defineProperty("size", this.size);
    defineProperty("dragging", this.dragging);
    defineProperty("showX", this.showX);
    defineProperty("showY", this.showY);
    defineProperty("showZ", this.showZ);
    defineProperty("worldPosition", this.worldPosition);
    defineProperty("worldPositionStart", this.worldPositionStart);
    defineProperty("worldQuaternion", this.worldQuaternion);
    defineProperty("worldQuaternionStart", this.worldQuaternionStart);
    defineProperty("cameraPosition", this.cameraPosition);
    defineProperty("cameraQuaternion", this.cameraQuaternion);
    defineProperty("pointStart", this.pointStart);
    defineProperty("pointEnd", this.pointEnd);
    defineProperty("rotationAxis", this.rotationAxis);
    defineProperty("rotationAngle", this.rotationAngle);
    defineProperty("eye", this.eye);
    if (_domElement !== void 0)
      this.connect(_domElement);
  }
};
var TransformControlsGizmo = class extends Object3D {
  constructor() {
    super();
    _defineProperty(this, "isTransformControlsGizmo", true);
    _defineProperty(this, "type", "TransformControlsGizmo");
    _defineProperty(this, "tempVector", new Vector3(0, 0, 0));
    _defineProperty(this, "tempEuler", new Euler());
    _defineProperty(this, "alignVector", new Vector3(0, 1, 0));
    _defineProperty(this, "zeroVector", new Vector3(0, 0, 0));
    _defineProperty(this, "lookAtMatrix", new Matrix4());
    _defineProperty(this, "tempQuaternion", new Quaternion());
    _defineProperty(this, "tempQuaternion2", new Quaternion());
    _defineProperty(this, "identityQuaternion", new Quaternion());
    _defineProperty(this, "unitX", new Vector3(1, 0, 0));
    _defineProperty(this, "unitY", new Vector3(0, 1, 0));
    _defineProperty(this, "unitZ", new Vector3(0, 0, 1));
    _defineProperty(this, "gizmo", void 0);
    _defineProperty(this, "picker", void 0);
    _defineProperty(this, "helper", void 0);
    _defineProperty(this, "rotationAxis", new Vector3());
    _defineProperty(this, "cameraPosition", new Vector3());
    _defineProperty(this, "worldPositionStart", new Vector3());
    _defineProperty(this, "worldQuaternionStart", new Quaternion());
    _defineProperty(this, "worldPosition", new Vector3());
    _defineProperty(this, "worldQuaternion", new Quaternion());
    _defineProperty(this, "eye", new Vector3());
    _defineProperty(this, "camera", null);
    _defineProperty(this, "enabled", true);
    _defineProperty(this, "axis", null);
    _defineProperty(this, "mode", "translate");
    _defineProperty(this, "space", "world");
    _defineProperty(this, "size", 1);
    _defineProperty(this, "dragging", false);
    _defineProperty(this, "showX", true);
    _defineProperty(this, "showY", true);
    _defineProperty(this, "showZ", true);
    _defineProperty(this, "updateMatrixWorld", () => {
      let space = this.space;
      if (this.mode === "scale") {
        space = "local";
      }
      const quaternion = space === "local" ? this.worldQuaternion : this.identityQuaternion;
      this.gizmo["translate"].visible = this.mode === "translate";
      this.gizmo["rotate"].visible = this.mode === "rotate";
      this.gizmo["scale"].visible = this.mode === "scale";
      this.helper["translate"].visible = this.mode === "translate";
      this.helper["rotate"].visible = this.mode === "rotate";
      this.helper["scale"].visible = this.mode === "scale";
      let handles = [];
      handles = handles.concat(this.picker[this.mode].children);
      handles = handles.concat(this.gizmo[this.mode].children);
      handles = handles.concat(this.helper[this.mode].children);
      for (let i2 = 0; i2 < handles.length; i2++) {
        const handle = handles[i2];
        handle.visible = true;
        handle.rotation.set(0, 0, 0);
        handle.position.copy(this.worldPosition);
        let factor;
        if (this.camera.isOrthographicCamera) {
          factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;
        } else {
          factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);
        }
        handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 7);
        if (handle.tag === "helper") {
          handle.visible = false;
          if (handle.name === "AXIS") {
            handle.position.copy(this.worldPositionStart);
            handle.visible = !!this.axis;
            if (this.axis === "X") {
              this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, 0));
              handle.quaternion.copy(quaternion).multiply(this.tempQuaternion);
              if (Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
                handle.visible = false;
              }
            }
            if (this.axis === "Y") {
              this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, Math.PI / 2));
              handle.quaternion.copy(quaternion).multiply(this.tempQuaternion);
              if (Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
                handle.visible = false;
              }
            }
            if (this.axis === "Z") {
              this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0));
              handle.quaternion.copy(quaternion).multiply(this.tempQuaternion);
              if (Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
                handle.visible = false;
              }
            }
            if (this.axis === "XYZE") {
              this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0));
              this.alignVector.copy(this.rotationAxis);
              handle.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.zeroVector, this.alignVector, this.unitY));
              handle.quaternion.multiply(this.tempQuaternion);
              handle.visible = this.dragging;
            }
            if (this.axis === "E") {
              handle.visible = false;
            }
          } else if (handle.name === "START") {
            handle.position.copy(this.worldPositionStart);
            handle.visible = this.dragging;
          } else if (handle.name === "END") {
            handle.position.copy(this.worldPosition);
            handle.visible = this.dragging;
          } else if (handle.name === "DELTA") {
            handle.position.copy(this.worldPositionStart);
            handle.quaternion.copy(this.worldQuaternionStart);
            this.tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);
            this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());
            handle.scale.copy(this.tempVector);
            handle.visible = this.dragging;
          } else {
            handle.quaternion.copy(quaternion);
            if (this.dragging) {
              handle.position.copy(this.worldPositionStart);
            } else {
              handle.position.copy(this.worldPosition);
            }
            if (this.axis) {
              handle.visible = this.axis.search(handle.name) !== -1;
            }
          }
          continue;
        }
        handle.quaternion.copy(quaternion);
        if (this.mode === "translate" || this.mode === "scale") {
          const AXIS_HIDE_TRESHOLD = 0.99;
          const PLANE_HIDE_TRESHOLD = 0.2;
          const AXIS_FLIP_TRESHOLD = 0;
          if (handle.name === "X" || handle.name === "XYZX") {
            if (Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {
              handle.scale.set(1e-10, 1e-10, 1e-10);
              handle.visible = false;
            }
          }
          if (handle.name === "Y" || handle.name === "XYZY") {
            if (Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {
              handle.scale.set(1e-10, 1e-10, 1e-10);
              handle.visible = false;
            }
          }
          if (handle.name === "Z" || handle.name === "XYZZ") {
            if (Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {
              handle.scale.set(1e-10, 1e-10, 1e-10);
              handle.visible = false;
            }
          }
          if (handle.name === "XY") {
            if (Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {
              handle.scale.set(1e-10, 1e-10, 1e-10);
              handle.visible = false;
            }
          }
          if (handle.name === "YZ") {
            if (Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {
              handle.scale.set(1e-10, 1e-10, 1e-10);
              handle.visible = false;
            }
          }
          if (handle.name === "XZ") {
            if (Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {
              handle.scale.set(1e-10, 1e-10, 1e-10);
              handle.visible = false;
            }
          }
          if (handle.name.search("X") !== -1) {
            if (this.alignVector.copy(this.unitX).applyQuaternion(quaternion).dot(this.eye) < AXIS_FLIP_TRESHOLD) {
              if (handle.tag === "fwd") {
                handle.visible = false;
              } else {
                handle.scale.x *= -1;
              }
            } else if (handle.tag === "bwd") {
              handle.visible = false;
            }
          }
          if (handle.name.search("Y") !== -1) {
            if (this.alignVector.copy(this.unitY).applyQuaternion(quaternion).dot(this.eye) < AXIS_FLIP_TRESHOLD) {
              if (handle.tag === "fwd") {
                handle.visible = false;
              } else {
                handle.scale.y *= -1;
              }
            } else if (handle.tag === "bwd") {
              handle.visible = false;
            }
          }
          if (handle.name.search("Z") !== -1) {
            if (this.alignVector.copy(this.unitZ).applyQuaternion(quaternion).dot(this.eye) < AXIS_FLIP_TRESHOLD) {
              if (handle.tag === "fwd") {
                handle.visible = false;
              } else {
                handle.scale.z *= -1;
              }
            } else if (handle.tag === "bwd") {
              handle.visible = false;
            }
          }
        } else if (this.mode === "rotate") {
          this.tempQuaternion2.copy(quaternion);
          this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(quaternion).invert());
          if (handle.name.search("E") !== -1) {
            handle.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye, this.zeroVector, this.unitY));
          }
          if (handle.name === "X") {
            this.tempQuaternion.setFromAxisAngle(this.unitX, Math.atan2(-this.alignVector.y, this.alignVector.z));
            this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion);
            handle.quaternion.copy(this.tempQuaternion);
          }
          if (handle.name === "Y") {
            this.tempQuaternion.setFromAxisAngle(this.unitY, Math.atan2(this.alignVector.x, this.alignVector.z));
            this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion);
            handle.quaternion.copy(this.tempQuaternion);
          }
          if (handle.name === "Z") {
            this.tempQuaternion.setFromAxisAngle(this.unitZ, Math.atan2(this.alignVector.y, this.alignVector.x));
            this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion);
            handle.quaternion.copy(this.tempQuaternion);
          }
        }
        handle.visible = handle.visible && (handle.name.indexOf("X") === -1 || this.showX);
        handle.visible = handle.visible && (handle.name.indexOf("Y") === -1 || this.showY);
        handle.visible = handle.visible && (handle.name.indexOf("Z") === -1 || this.showZ);
        handle.visible = handle.visible && (handle.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ);
        handle.material.tempOpacity = handle.material.tempOpacity || handle.material.opacity;
        handle.material.tempColor = handle.material.tempColor || handle.material.color.clone();
        handle.material.color.copy(handle.material.tempColor);
        handle.material.opacity = handle.material.tempOpacity;
        if (!this.enabled) {
          handle.material.opacity *= 0.5;
          handle.material.color.lerp(new Color(1, 1, 1), 0.5);
        } else if (this.axis) {
          if (handle.name === this.axis) {
            handle.material.opacity = 1;
            handle.material.color.lerp(new Color(1, 1, 1), 0.5);
          } else if (this.axis.split("").some(function(a2) {
            return handle.name === a2;
          })) {
            handle.material.opacity = 1;
            handle.material.color.lerp(new Color(1, 1, 1), 0.5);
          } else {
            handle.material.opacity *= 0.25;
            handle.material.color.lerp(new Color(1, 1, 1), 0.5);
          }
        }
      }
      super.updateMatrixWorld();
    });
    const gizmoMaterial = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      transparent: true,
      side: DoubleSide,
      fog: false,
      toneMapped: false
    });
    const gizmoLineMaterial = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      transparent: true,
      linewidth: 1,
      fog: false,
      toneMapped: false
    });
    const matInvisible = gizmoMaterial.clone();
    matInvisible.opacity = 0.15;
    const matHelper = gizmoMaterial.clone();
    matHelper.opacity = 0.33;
    const matRed = gizmoMaterial.clone();
    matRed.color.set(16711680);
    const matGreen = gizmoMaterial.clone();
    matGreen.color.set(65280);
    const matBlue = gizmoMaterial.clone();
    matBlue.color.set(255);
    const matWhiteTransparent = gizmoMaterial.clone();
    matWhiteTransparent.opacity = 0.25;
    const matYellowTransparent = matWhiteTransparent.clone();
    matYellowTransparent.color.set(16776960);
    const matCyanTransparent = matWhiteTransparent.clone();
    matCyanTransparent.color.set(65535);
    const matMagentaTransparent = matWhiteTransparent.clone();
    matMagentaTransparent.color.set(16711935);
    const matYellow = gizmoMaterial.clone();
    matYellow.color.set(16776960);
    const matLineRed = gizmoLineMaterial.clone();
    matLineRed.color.set(16711680);
    const matLineGreen = gizmoLineMaterial.clone();
    matLineGreen.color.set(65280);
    const matLineBlue = gizmoLineMaterial.clone();
    matLineBlue.color.set(255);
    const matLineCyan = gizmoLineMaterial.clone();
    matLineCyan.color.set(65535);
    const matLineMagenta = gizmoLineMaterial.clone();
    matLineMagenta.color.set(16711935);
    const matLineYellow = gizmoLineMaterial.clone();
    matLineYellow.color.set(16776960);
    const matLineGray = gizmoLineMaterial.clone();
    matLineGray.color.set(7895160);
    const matLineYellowTransparent = matLineYellow.clone();
    matLineYellowTransparent.opacity = 0.25;
    const arrowGeometry = new CylinderGeometry(0, 0.05, 0.2, 12, 1, false);
    const scaleHandleGeometry = new BoxGeometry(0.125, 0.125, 0.125);
    const lineGeometry = new BufferGeometry();
    lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const CircleGeometry = (radius, arc) => {
      const geometry = new BufferGeometry();
      const vertices = [];
      for (let i2 = 0; i2 <= 64 * arc; ++i2) {
        vertices.push(0, Math.cos(i2 / 32 * Math.PI) * radius, Math.sin(i2 / 32 * Math.PI) * radius);
      }
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      return geometry;
    };
    const TranslateHelperGeometry = () => {
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
      return geometry;
    };
    const gizmoTranslate = {
      X: [[new Mesh(arrowGeometry, matRed), [1, 0, 0], [0, 0, -Math.PI / 2], null, "fwd"], [new Mesh(arrowGeometry, matRed), [1, 0, 0], [0, 0, Math.PI / 2], null, "bwd"], [new Line(lineGeometry, matLineRed)]],
      Y: [[new Mesh(arrowGeometry, matGreen), [0, 1, 0], null, null, "fwd"], [new Mesh(arrowGeometry, matGreen), [0, 1, 0], [Math.PI, 0, 0], null, "bwd"], [new Line(lineGeometry, matLineGreen), null, [0, 0, Math.PI / 2]]],
      Z: [[new Mesh(arrowGeometry, matBlue), [0, 0, 1], [Math.PI / 2, 0, 0], null, "fwd"], [new Mesh(arrowGeometry, matBlue), [0, 0, 1], [-Math.PI / 2, 0, 0], null, "bwd"], [new Line(lineGeometry, matLineBlue), null, [0, -Math.PI / 2, 0]]],
      XYZ: [[new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0], [0, 0, 0]]],
      XY: [[new Mesh(new PlaneGeometry(0.295, 0.295), matYellowTransparent.clone()), [0.15, 0.15, 0]], [new Line(lineGeometry, matLineYellow), [0.18, 0.3, 0], null, [0.125, 1, 1]], [new Line(lineGeometry, matLineYellow), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]],
      YZ: [[new Mesh(new PlaneGeometry(0.295, 0.295), matCyanTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]], [new Line(lineGeometry, matLineCyan), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]], [new Line(lineGeometry, matLineCyan), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],
      XZ: [[new Mesh(new PlaneGeometry(0.295, 0.295), matMagentaTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]], [new Line(lineGeometry, matLineMagenta), [0.18, 0, 0.3], null, [0.125, 1, 1]], [new Line(lineGeometry, matLineMagenta), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]]
    };
    const pickerTranslate = {
      X: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), matInvisible), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), matInvisible), [0, 0.6, 0]]],
      Z: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), matInvisible), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
      XYZ: [[new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]],
      XY: [[new Mesh(new PlaneGeometry(0.4, 0.4), matInvisible), [0.2, 0.2, 0]]],
      YZ: [[new Mesh(new PlaneGeometry(0.4, 0.4), matInvisible), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],
      XZ: [[new Mesh(new PlaneGeometry(0.4, 0.4), matInvisible), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]
    };
    const helperTranslate = {
      START: [[new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]],
      END: [[new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]],
      DELTA: [[new Line(TranslateHelperGeometry(), matHelper), null, null, null, "helper"]],
      X: [[new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    };
    const gizmoRotate = {
      X: [[new Line(CircleGeometry(1, 0.5), matLineRed)], [new Mesh(new OctahedronGeometry(0.04, 0), matRed), [0, 0, 0.99], null, [1, 3, 1]]],
      Y: [[new Line(CircleGeometry(1, 0.5), matLineGreen), null, [0, 0, -Math.PI / 2]], [new Mesh(new OctahedronGeometry(0.04, 0), matGreen), [0, 0, 0.99], null, [3, 1, 1]]],
      Z: [[new Line(CircleGeometry(1, 0.5), matLineBlue), null, [0, Math.PI / 2, 0]], [new Mesh(new OctahedronGeometry(0.04, 0), matBlue), [0.99, 0, 0], null, [1, 3, 1]]],
      E: [[new Line(CircleGeometry(1.25, 1), matLineYellowTransparent), null, [0, Math.PI / 2, 0]], [new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [1.17, 0, 0], [0, 0, -Math.PI / 2], [1, 1, 1e-3]], [new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [-1.17, 0, 0], [0, 0, Math.PI / 2], [1, 1, 1e-3]], [new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [0, -1.17, 0], [Math.PI, 0, 0], [1, 1, 1e-3]], [new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [0, 1.17, 0], [0, 0, 0], [1, 1, 1e-3]]],
      XYZE: [[new Line(CircleGeometry(1, 1), matLineGray), null, [0, Math.PI / 2, 0]]]
    };
    const helperRotate = {
      AXIS: [[new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
    };
    const pickerRotate = {
      X: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
      Y: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]],
      Z: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]],
      E: [[new Mesh(new TorusGeometry(1.25, 0.1, 2, 24), matInvisible)]],
      XYZE: [[new Mesh(new SphereGeometry(0.7, 10, 8), matInvisible)]]
    };
    const gizmoScale = {
      X: [[new Mesh(scaleHandleGeometry, matRed), [0.8, 0, 0], [0, 0, -Math.PI / 2]], [new Line(lineGeometry, matLineRed), null, null, [0.8, 1, 1]]],
      Y: [[new Mesh(scaleHandleGeometry, matGreen), [0, 0.8, 0]], [new Line(lineGeometry, matLineGreen), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]],
      Z: [[new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.8], [Math.PI / 2, 0, 0]], [new Line(lineGeometry, matLineBlue), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]],
      XY: [[new Mesh(scaleHandleGeometry, matYellowTransparent), [0.85, 0.85, 0], null, [2, 2, 0.2]], [new Line(lineGeometry, matLineYellow), [0.855, 0.98, 0], null, [0.125, 1, 1]], [new Line(lineGeometry, matLineYellow), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]],
      YZ: [[new Mesh(scaleHandleGeometry, matCyanTransparent), [0, 0.85, 0.85], null, [0.2, 2, 2]], [new Line(lineGeometry, matLineCyan), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]], [new Line(lineGeometry, matLineCyan), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],
      XZ: [[new Mesh(scaleHandleGeometry, matMagentaTransparent), [0.85, 0, 0.85], null, [2, 0.2, 2]], [new Line(lineGeometry, matLineMagenta), [0.855, 0, 0.98], null, [0.125, 1, 1]], [new Line(lineGeometry, matLineMagenta), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],
      XYZX: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), matWhiteTransparent.clone()), [1.1, 0, 0]]],
      XYZY: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), matWhiteTransparent.clone()), [0, 1.1, 0]]],
      XYZZ: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), matWhiteTransparent.clone()), [0, 0, 1.1]]]
    };
    const pickerScale = {
      X: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), matInvisible), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), matInvisible), [0, 0.5, 0]]],
      Z: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), matInvisible), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],
      XY: [[new Mesh(scaleHandleGeometry, matInvisible), [0.85, 0.85, 0], null, [3, 3, 0.2]]],
      YZ: [[new Mesh(scaleHandleGeometry, matInvisible), [0, 0.85, 0.85], null, [0.2, 3, 3]]],
      XZ: [[new Mesh(scaleHandleGeometry, matInvisible), [0.85, 0, 0.85], null, [3, 0.2, 3]]],
      XYZX: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [1.1, 0, 0]]],
      XYZY: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 1.1, 0]]],
      XYZZ: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 1.1]]]
    };
    const helperScale = {
      X: [[new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    };
    const setupGizmo = (gizmoMap) => {
      const gizmo = new Object3D();
      for (let name in gizmoMap) {
        for (let i2 = gizmoMap[name].length; i2--; ) {
          const object = gizmoMap[name][i2][0].clone();
          const position = gizmoMap[name][i2][1];
          const rotation = gizmoMap[name][i2][2];
          const scale = gizmoMap[name][i2][3];
          const tag = gizmoMap[name][i2][4];
          object.name = name;
          object.tag = tag;
          if (position) {
            object.position.set(position[0], position[1], position[2]);
          }
          if (rotation) {
            object.rotation.set(rotation[0], rotation[1], rotation[2]);
          }
          if (scale) {
            object.scale.set(scale[0], scale[1], scale[2]);
          }
          object.updateMatrix();
          const tempGeometry = object.geometry.clone();
          tempGeometry.applyMatrix4(object.matrix);
          object.geometry = tempGeometry;
          object.renderOrder = Infinity;
          object.position.set(0, 0, 0);
          object.rotation.set(0, 0, 0);
          object.scale.set(1, 1, 1);
          gizmo.add(object);
        }
      }
      return gizmo;
    };
    this.gizmo = {};
    this.picker = {};
    this.helper = {};
    this.add(this.gizmo["translate"] = setupGizmo(gizmoTranslate));
    this.add(this.gizmo["rotate"] = setupGizmo(gizmoRotate));
    this.add(this.gizmo["scale"] = setupGizmo(gizmoScale));
    this.add(this.picker["translate"] = setupGizmo(pickerTranslate));
    this.add(this.picker["rotate"] = setupGizmo(pickerRotate));
    this.add(this.picker["scale"] = setupGizmo(pickerScale));
    this.add(this.helper["translate"] = setupGizmo(helperTranslate));
    this.add(this.helper["rotate"] = setupGizmo(helperRotate));
    this.add(this.helper["scale"] = setupGizmo(helperScale));
    this.picker["translate"].visible = false;
    this.picker["rotate"].visible = false;
    this.picker["scale"].visible = false;
  }
};
var TransformControlsPlane = class extends Mesh {
  constructor() {
    super(new PlaneGeometry(1e5, 1e5, 2, 2), new MeshBasicMaterial({
      visible: false,
      wireframe: true,
      side: DoubleSide,
      transparent: true,
      opacity: 0.1,
      toneMapped: false
    }));
    _defineProperty(this, "isTransformControlsPlane", true);
    _defineProperty(this, "type", "TransformControlsPlane");
    _defineProperty(this, "unitX", new Vector3(1, 0, 0));
    _defineProperty(this, "unitY", new Vector3(0, 1, 0));
    _defineProperty(this, "unitZ", new Vector3(0, 0, 1));
    _defineProperty(this, "tempVector", new Vector3());
    _defineProperty(this, "dirVector", new Vector3());
    _defineProperty(this, "alignVector", new Vector3());
    _defineProperty(this, "tempMatrix", new Matrix4());
    _defineProperty(this, "identityQuaternion", new Quaternion());
    _defineProperty(this, "cameraQuaternion", new Quaternion());
    _defineProperty(this, "worldPosition", new Vector3());
    _defineProperty(this, "worldQuaternion", new Quaternion());
    _defineProperty(this, "eye", new Vector3());
    _defineProperty(this, "axis", null);
    _defineProperty(this, "mode", "translate");
    _defineProperty(this, "space", "world");
    _defineProperty(this, "updateMatrixWorld", () => {
      let space = this.space;
      this.position.copy(this.worldPosition);
      if (this.mode === "scale")
        space = "local";
      this.unitX.set(1, 0, 0).applyQuaternion(space === "local" ? this.worldQuaternion : this.identityQuaternion);
      this.unitY.set(0, 1, 0).applyQuaternion(space === "local" ? this.worldQuaternion : this.identityQuaternion);
      this.unitZ.set(0, 0, 1).applyQuaternion(space === "local" ? this.worldQuaternion : this.identityQuaternion);
      this.alignVector.copy(this.unitY);
      switch (this.mode) {
        case "translate":
        case "scale":
          switch (this.axis) {
            case "X":
              this.alignVector.copy(this.eye).cross(this.unitX);
              this.dirVector.copy(this.unitX).cross(this.alignVector);
              break;
            case "Y":
              this.alignVector.copy(this.eye).cross(this.unitY);
              this.dirVector.copy(this.unitY).cross(this.alignVector);
              break;
            case "Z":
              this.alignVector.copy(this.eye).cross(this.unitZ);
              this.dirVector.copy(this.unitZ).cross(this.alignVector);
              break;
            case "XY":
              this.dirVector.copy(this.unitZ);
              break;
            case "YZ":
              this.dirVector.copy(this.unitX);
              break;
            case "XZ":
              this.alignVector.copy(this.unitZ);
              this.dirVector.copy(this.unitY);
              break;
            case "XYZ":
            case "E":
              this.dirVector.set(0, 0, 0);
              break;
          }
          break;
        case "rotate":
        default:
          this.dirVector.set(0, 0, 0);
      }
      if (this.dirVector.length() === 0) {
        this.quaternion.copy(this.cameraQuaternion);
      } else {
        this.tempMatrix.lookAt(this.tempVector.set(0, 0, 0), this.dirVector, this.alignVector);
        this.quaternion.setFromRotationMatrix(this.tempMatrix);
      }
      super.updateMatrixWorld();
    });
  }
};

// node_modules/three-stdlib/controls/DragControls.js
var DragControls = class extends EventDispatcher {
  constructor(_objects, _camera, _domElement) {
    super();
    _defineProperty(this, "enabled", true);
    _defineProperty(this, "transformGroup", false);
    _defineProperty(this, "_objects", void 0);
    _defineProperty(this, "_camera", void 0);
    _defineProperty(this, "_domElement", void 0);
    _defineProperty(this, "_plane", new Plane());
    _defineProperty(this, "_raycaster", new Raycaster());
    _defineProperty(this, "_mouse", new Vector2());
    _defineProperty(this, "_offset", new Vector3());
    _defineProperty(this, "_intersection", new Vector3());
    _defineProperty(this, "_worldPosition", new Vector3());
    _defineProperty(this, "_inverseMatrix", new Matrix4());
    _defineProperty(this, "_intersections", []);
    _defineProperty(this, "_selected", null);
    _defineProperty(this, "_hovered", null);
    _defineProperty(this, "activate", () => {
      this._domElement.addEventListener("pointermove", this.onPointerMove);
      this._domElement.addEventListener("pointerdown", this.onPointerDown);
      this._domElement.addEventListener("pointerup", this.onPointerCancel);
      this._domElement.addEventListener("pointerleave", this.onPointerCancel);
      this._domElement.addEventListener("touchmove", this.onTouchMove);
      this._domElement.addEventListener("touchstart", this.onTouchStart);
      this._domElement.addEventListener("touchend", this.onTouchEnd);
    });
    _defineProperty(this, "deactivate", () => {
      this._domElement.removeEventListener("pointermove", this.onPointerMove);
      this._domElement.removeEventListener("pointerdown", this.onPointerDown);
      this._domElement.removeEventListener("pointerup", this.onPointerCancel);
      this._domElement.removeEventListener("pointerleave", this.onPointerCancel);
      this._domElement.removeEventListener("touchmove", this.onTouchMove);
      this._domElement.removeEventListener("touchstart", this.onTouchStart);
      this._domElement.removeEventListener("touchend", this.onTouchEnd);
      this._domElement.style.cursor = "";
    });
    _defineProperty(this, "dispose", () => this.deactivate());
    _defineProperty(this, "getObjects", () => this._objects);
    _defineProperty(this, "getRaycaster", () => this._raycaster);
    _defineProperty(this, "onMouseMove", (event) => {
      const rect = this._domElement.getBoundingClientRect();
      this._mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;
      this._mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      this._raycaster.setFromCamera(this._mouse, this._camera);
      if (this._selected && this.enabled) {
        if (this._raycaster.ray.intersectPlane(this._plane, this._intersection)) {
          this._selected.position.copy(this._intersection.sub(this._offset).applyMatrix4(this._inverseMatrix));
        }
        this.dispatchEvent({
          type: "drag",
          object: this._selected
        });
        return;
      }
      this._intersections.length = 0;
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.intersectObjects(this._objects, true, this._intersections);
      if (this._intersections.length > 0) {
        const object = this._intersections[0].object;
        this._plane.setFromNormalAndCoplanarPoint(this._camera.getWorldDirection(this._plane.normal), this._worldPosition.setFromMatrixPosition(object.matrixWorld));
        if (this._hovered !== object) {
          this.dispatchEvent({
            type: "hoveron",
            object
          });
          this._domElement.style.cursor = "pointer";
          this._hovered = object;
        }
      } else {
        if (this._hovered !== null) {
          this.dispatchEvent({
            type: "hoveroff",
            object: this._hovered
          });
          this._domElement.style.cursor = "auto";
          this._hovered = null;
        }
      }
    });
    _defineProperty(this, "onMouseDown", () => {
      this._intersections.length = 0;
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.intersectObjects(this._objects, true, this._intersections);
      if (this._intersections.length > 0) {
        this._selected = this.transformGroup === true ? this._objects[0] : this._intersections[0].object;
        if (this._raycaster.ray.intersectPlane(this._plane, this._intersection) && this._selected.parent) {
          this._inverseMatrix.copy(this._selected.parent.matrixWorld).invert();
          this._offset.copy(this._intersection).sub(this._worldPosition.setFromMatrixPosition(this._selected.matrixWorld));
        }
        this._domElement.style.cursor = "move";
        this.dispatchEvent({
          type: "dragstart",
          object: this._selected
        });
      }
    });
    _defineProperty(this, "onMouseCancel", () => {
      if (this._selected) {
        this.dispatchEvent({
          type: "dragend",
          object: this._selected
        });
        this._selected = null;
      }
      this._domElement.style.cursor = this._hovered ? "pointer" : "auto";
    });
    _defineProperty(this, "onPointerMove", (event) => {
      switch (event.pointerType) {
        case "mouse":
        case "pen":
          this.onMouseMove(event);
          break;
      }
    });
    _defineProperty(this, "onPointerDown", (event) => {
      switch (event.pointerType) {
        case "mouse":
        case "pen":
          this.onMouseDown();
          break;
      }
    });
    _defineProperty(this, "onPointerCancel", (event) => {
      switch (event.pointerType) {
        case "mouse":
        case "pen":
          this.onMouseCancel();
          break;
      }
    });
    _defineProperty(this, "onTouchMove", (event) => {
      event.preventDefault();
      const newEvent = event.changedTouches[0];
      const rect = this._domElement.getBoundingClientRect();
      this._mouse.x = (newEvent.clientX - rect.left) / rect.width * 2 - 1;
      this._mouse.y = -((newEvent.clientY - rect.top) / rect.height) * 2 + 1;
      this._raycaster.setFromCamera(this._mouse, this._camera);
      if (this._selected && this.enabled) {
        if (this._raycaster.ray.intersectPlane(this._plane, this._intersection)) {
          this._selected.position.copy(this._intersection.sub(this._offset).applyMatrix4(this._inverseMatrix));
        }
        this.dispatchEvent({
          type: "drag",
          object: this._selected
        });
        return;
      }
    });
    _defineProperty(this, "onTouchStart", (event) => {
      event.preventDefault();
      const newEvent = event.changedTouches[0];
      const rect = this._domElement.getBoundingClientRect();
      this._mouse.x = (newEvent.clientX - rect.left) / rect.width * 2 - 1;
      this._mouse.y = -((newEvent.clientY - rect.top) / rect.height) * 2 + 1;
      this._intersections.length = 0;
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.intersectObjects(this._objects, true, this._intersections);
      if (this._intersections.length > 0) {
        this._selected = this.transformGroup === true ? this._objects[0] : this._intersections[0].object;
        this._plane.setFromNormalAndCoplanarPoint(this._camera.getWorldDirection(this._plane.normal), this._worldPosition.setFromMatrixPosition(this._selected.matrixWorld));
        if (this._raycaster.ray.intersectPlane(this._plane, this._intersection) && this._selected.parent) {
          this._inverseMatrix.copy(this._selected.parent.matrixWorld).invert();
          this._offset.copy(this._intersection).sub(this._worldPosition.setFromMatrixPosition(this._selected.matrixWorld));
        }
        this._domElement.style.cursor = "move";
        this.dispatchEvent({
          type: "dragstart",
          object: this._selected
        });
      }
    });
    _defineProperty(this, "onTouchEnd", (event) => {
      event.preventDefault();
      if (this._selected) {
        this.dispatchEvent({
          type: "dragend",
          object: this._selected
        });
        this._selected = null;
      }
      this._domElement.style.cursor = "auto";
    });
    this._objects = _objects;
    this._camera = _camera;
    this._domElement = _domElement;
    this.activate();
  }
};

// node_modules/three-stdlib/controls/PointerLockControls.js
var PointerLockControls = class extends EventDispatcher {
  constructor(camera, _domElement) {
    super();
    _defineProperty(this, "camera", void 0);
    _defineProperty(this, "domElement", void 0);
    _defineProperty(this, "isLocked", false);
    _defineProperty(this, "minPolarAngle", 0);
    _defineProperty(this, "maxPolarAngle", Math.PI);
    _defineProperty(this, "changeEvent", {
      type: "change"
    });
    _defineProperty(this, "lockEvent", {
      type: "lock"
    });
    _defineProperty(this, "unlockEvent", {
      type: "unlock"
    });
    _defineProperty(this, "euler", new Euler(0, 0, 0, "YXZ"));
    _defineProperty(this, "PI_2", Math.PI / 2);
    _defineProperty(this, "vec", new Vector3());
    _defineProperty(this, "onMouseMove", (event) => {
      if (!this.domElement || this.isLocked === false)
        return;
      const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
      const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
      this.euler.setFromQuaternion(this.camera.quaternion);
      this.euler.y -= movementX * 2e-3;
      this.euler.x -= movementY * 2e-3;
      this.euler.x = Math.max(this.PI_2 - this.maxPolarAngle, Math.min(this.PI_2 - this.minPolarAngle, this.euler.x));
      this.camera.quaternion.setFromEuler(this.euler);
      this.dispatchEvent(this.changeEvent);
    });
    _defineProperty(this, "onPointerlockChange", () => {
      if (!this.domElement)
        return;
      if (this.domElement.ownerDocument.pointerLockElement === this.domElement) {
        this.dispatchEvent(this.lockEvent);
        this.isLocked = true;
      } else {
        this.dispatchEvent(this.unlockEvent);
        this.isLocked = false;
      }
    });
    _defineProperty(this, "onPointerlockError", () => {
      console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
    });
    _defineProperty(this, "connect", (domElement) => {
      this.domElement = domElement || this.domElement;
      if (!this.domElement)
        return;
      this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove);
      this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange);
      this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError);
    });
    _defineProperty(this, "disconnect", () => {
      if (!this.domElement)
        return;
      this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove);
      this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange);
      this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError);
    });
    _defineProperty(this, "dispose", () => {
      this.disconnect();
    });
    _defineProperty(this, "getObject", () => this.camera);
    _defineProperty(this, "direction", new Vector3(0, 0, -1));
    _defineProperty(this, "getDirection", (v) => v.copy(this.direction).applyQuaternion(this.camera.quaternion));
    _defineProperty(this, "moveForward", (distance2) => {
      this.vec.setFromMatrixColumn(this.camera.matrix, 0);
      this.vec.crossVectors(this.camera.up, this.vec);
      this.camera.position.addScaledVector(this.vec, distance2);
    });
    _defineProperty(this, "moveRight", (distance2) => {
      this.vec.setFromMatrixColumn(this.camera.matrix, 0);
      this.camera.position.addScaledVector(this.vec, distance2);
    });
    _defineProperty(this, "lock", () => {
      if (!this.domElement)
        return;
      this.domElement.requestPointerLock();
    });
    _defineProperty(this, "unlock", () => {
      if (!this.domElement)
        return;
      this.domElement.ownerDocument.exitPointerLock();
    });
    this.domElement = _domElement;
    this.camera = camera;
    if (this.domElement)
      this.connect(this.domElement);
  }
};

// node_modules/three-stdlib/controls/DeviceOrientationControls.js
var DeviceOrientationControls = class extends EventDispatcher {
  constructor(object) {
    super();
    _defineProperty(this, "object", void 0);
    _defineProperty(this, "changeEvent", {
      type: "change"
    });
    _defineProperty(this, "EPS", 1e-6);
    _defineProperty(this, "enabled", true);
    _defineProperty(this, "deviceOrientation", {
      alpha: 0,
      beta: 0,
      gamma: 0
    });
    _defineProperty(this, "screenOrientation", 0);
    _defineProperty(this, "alphaOffset", 0);
    _defineProperty(this, "onDeviceOrientationChangeEvent", (event) => {
      this.deviceOrientation = event;
    });
    _defineProperty(this, "onScreenOrientationChangeEvent", () => {
      this.screenOrientation = window.orientation || 0;
    });
    _defineProperty(this, "zee", new Vector3(0, 0, 1));
    _defineProperty(this, "euler", new Euler());
    _defineProperty(this, "q0", new Quaternion());
    _defineProperty(this, "q1", new Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)));
    _defineProperty(this, "setObjectQuaternion", (quaternion, alpha, beta, gamma, orient) => {
      this.euler.set(beta, alpha, -gamma, "YXZ");
      quaternion.setFromEuler(this.euler);
      quaternion.multiply(this.q1);
      quaternion.multiply(this.q0.setFromAxisAngle(this.zee, -orient));
    });
    _defineProperty(this, "connect", () => {
      this.onScreenOrientationChangeEvent();
      if (window.DeviceOrientationEvent !== void 0 && typeof window.DeviceOrientationEvent.requestPermission === "function") {
        window.DeviceOrientationEvent.requestPermission().then((response) => {
          if (response == "granted") {
            window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent);
            window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent);
          }
        }).catch((error) => {
          console.error("THREE.DeviceOrientationControls: Unable to use DeviceOrientation API:", error);
        });
      } else {
        window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent);
        window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent);
      }
      this.enabled = true;
    });
    _defineProperty(this, "disconnect", () => {
      window.removeEventListener("orientationchange", this.onScreenOrientationChangeEvent);
      window.removeEventListener("deviceorientation", this.onDeviceOrientationChangeEvent);
      this.enabled = false;
    });
    _defineProperty(this, "lastQuaternion", new Quaternion());
    _defineProperty(this, "update", () => {
      if (this.enabled === false)
        return;
      const device = this.deviceOrientation;
      if (device) {
        const alpha = device.alpha ? MathUtils.degToRad(device.alpha) + this.alphaOffset : 0;
        const beta = device.beta ? MathUtils.degToRad(device.beta) : 0;
        const gamma = device.gamma ? MathUtils.degToRad(device.gamma) : 0;
        const orient = this.screenOrientation ? MathUtils.degToRad(this.screenOrientation) : 0;
        this.setObjectQuaternion(this.object.quaternion, alpha, beta, gamma, orient);
        if (8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > this.EPS) {
          this.lastQuaternion.copy(this.object.quaternion);
          this.dispatchEvent(this.changeEvent);
        }
      }
    });
    _defineProperty(this, "dispose", () => this.disconnect());
    this.object = object;
    this.object.rotation.reorder("YXZ");
    this.connect();
  }
};

// node_modules/three-stdlib/controls/TrackballControls.js
var TrackballControls = class extends EventDispatcher {
  constructor(object, _domElement) {
    super();
    _defineProperty(this, "enabled", true);
    _defineProperty(this, "screen", {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    });
    _defineProperty(this, "rotateSpeed", 1);
    _defineProperty(this, "zoomSpeed", 1.2);
    _defineProperty(this, "panSpeed", 0.3);
    _defineProperty(this, "noRotate", false);
    _defineProperty(this, "noZoom", false);
    _defineProperty(this, "noPan", false);
    _defineProperty(this, "staticMoving", false);
    _defineProperty(this, "dynamicDampingFactor", 0.2);
    _defineProperty(this, "minDistance", 0);
    _defineProperty(this, "maxDistance", Infinity);
    _defineProperty(this, "keys", [
      "KeyA",
      "KeyS",
      "KeyD"
    ]);
    _defineProperty(this, "mouseButtons", {
      LEFT: MOUSE.ROTATE,
      MIDDLE: MOUSE.DOLLY,
      RIGHT: MOUSE.PAN
    });
    _defineProperty(this, "object", void 0);
    _defineProperty(this, "domElement", void 0);
    _defineProperty(this, "cursorZoom", false);
    _defineProperty(this, "target", new Vector3());
    _defineProperty(this, "mousePosition", new Vector2());
    _defineProperty(this, "STATE", {
      NONE: -1,
      ROTATE: 0,
      ZOOM: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_ZOOM_PAN: 4
    });
    _defineProperty(this, "EPS", 1e-6);
    _defineProperty(this, "lastZoom", 1);
    _defineProperty(this, "lastPosition", new Vector3());
    _defineProperty(this, "cursorVector", new Vector3());
    _defineProperty(this, "targetVector", new Vector3());
    _defineProperty(this, "_state", this.STATE.NONE);
    _defineProperty(this, "_keyState", this.STATE.NONE);
    _defineProperty(this, "_eye", new Vector3());
    _defineProperty(this, "_movePrev", new Vector2());
    _defineProperty(this, "_moveCurr", new Vector2());
    _defineProperty(this, "_lastAxis", new Vector3());
    _defineProperty(this, "_lastAngle", 0);
    _defineProperty(this, "_zoomStart", new Vector2());
    _defineProperty(this, "_zoomEnd", new Vector2());
    _defineProperty(this, "_touchZoomDistanceStart", 0);
    _defineProperty(this, "_touchZoomDistanceEnd", 0);
    _defineProperty(this, "_panStart", new Vector2());
    _defineProperty(this, "_panEnd", new Vector2());
    _defineProperty(this, "target0", void 0);
    _defineProperty(this, "position0", void 0);
    _defineProperty(this, "up0", void 0);
    _defineProperty(this, "zoom0", void 0);
    _defineProperty(this, "changeEvent", {
      type: "change"
    });
    _defineProperty(this, "startEvent", {
      type: "start"
    });
    _defineProperty(this, "endEvent", {
      type: "end"
    });
    _defineProperty(this, "onScreenVector", new Vector2());
    _defineProperty(this, "getMouseOnScreen", (pageX, pageY) => {
      this.onScreenVector.set((pageX - this.screen.left) / this.screen.width, (pageY - this.screen.top) / this.screen.height);
      return this.onScreenVector;
    });
    _defineProperty(this, "onCircleVector", new Vector2());
    _defineProperty(this, "getMouseOnCircle", (pageX, pageY) => {
      this.onCircleVector.set(
        (pageX - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5),
        (this.screen.height + 2 * (this.screen.top - pageY)) / this.screen.width
      );
      return this.onCircleVector;
    });
    _defineProperty(this, "axis", new Vector3());
    _defineProperty(this, "quaternion", new Quaternion());
    _defineProperty(this, "eyeDirection", new Vector3());
    _defineProperty(this, "objectUpDirection", new Vector3());
    _defineProperty(this, "objectSidewaysDirection", new Vector3());
    _defineProperty(this, "moveDirection", new Vector3());
    _defineProperty(this, "angle", 0);
    _defineProperty(this, "rotateCamera", () => {
      this.moveDirection.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);
      this.angle = this.moveDirection.length();
      if (this.angle) {
        this._eye.copy(this.object.position).sub(this.target);
        this.eyeDirection.copy(this._eye).normalize();
        this.objectUpDirection.copy(this.object.up).normalize();
        this.objectSidewaysDirection.crossVectors(this.objectUpDirection, this.eyeDirection).normalize();
        this.objectUpDirection.setLength(this._moveCurr.y - this._movePrev.y);
        this.objectSidewaysDirection.setLength(this._moveCurr.x - this._movePrev.x);
        this.moveDirection.copy(this.objectUpDirection.add(this.objectSidewaysDirection));
        this.axis.crossVectors(this.moveDirection, this._eye).normalize();
        this.angle *= this.rotateSpeed;
        this.quaternion.setFromAxisAngle(this.axis, this.angle);
        this._eye.applyQuaternion(this.quaternion);
        this.object.up.applyQuaternion(this.quaternion);
        this._lastAxis.copy(this.axis);
        this._lastAngle = this.angle;
      } else if (!this.staticMoving && this._lastAngle) {
        this._lastAngle *= Math.sqrt(1 - this.dynamicDampingFactor);
        this._eye.copy(this.object.position).sub(this.target);
        this.quaternion.setFromAxisAngle(this._lastAxis, this._lastAngle);
        this._eye.applyQuaternion(this.quaternion);
        this.object.up.applyQuaternion(this.quaternion);
      }
      this._movePrev.copy(this._moveCurr);
    });
    _defineProperty(this, "zoomCamera", () => {
      let factor;
      if (this._state === this.STATE.TOUCH_ZOOM_PAN) {
        factor = this._touchZoomDistanceStart / this._touchZoomDistanceEnd;
        this._touchZoomDistanceStart = this._touchZoomDistanceEnd;
        if (this.object.isPerspectiveCamera) {
          this._eye.multiplyScalar(factor);
        } else if (this.object.isOrthographicCamera) {
          this.object.zoom /= factor;
          this.object.updateProjectionMatrix();
        } else {
          console.warn("THREE.TrackballControls: Unsupported camera type");
        }
      } else {
        factor = 1 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed;
        if (Math.abs(factor - 1) > this.EPS && factor > 0) {
          if (this.object.isPerspectiveCamera) {
            if (factor > 1 && this._eye.length() >= this.maxDistance - this.EPS) {
              factor = 1;
            }
            this._eye.multiplyScalar(factor);
          } else if (this.object.isOrthographicCamera) {
            if (factor > 1 && this.object.zoom < this.maxDistance * this.maxDistance) {
              factor = 1;
            }
            this.object.zoom /= factor;
          } else {
            console.warn("THREE.TrackballControls: Unsupported camera type");
          }
        }
        if (this.staticMoving) {
          this._zoomStart.copy(this._zoomEnd);
        } else {
          this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor;
        }
        if (this.cursorZoom) {
          this.targetVector.copy(this.target).project(this.object);
          let worldPos = this.cursorVector.set(this.mousePosition.x, this.mousePosition.y, this.targetVector.z).unproject(this.object);
          this.target.lerpVectors(worldPos, this.target, factor);
        }
        if (this.object.isOrthographicCamera) {
          this.object.updateProjectionMatrix();
        }
      }
    });
    _defineProperty(this, "mouseChange", new Vector2());
    _defineProperty(this, "objectUp", new Vector3());
    _defineProperty(this, "pan", new Vector3());
    _defineProperty(this, "panCamera", () => {
      if (!this.domElement)
        return;
      this.mouseChange.copy(this._panEnd).sub(this._panStart);
      if (this.mouseChange.lengthSq() > this.EPS) {
        if (this.object.isOrthographicCamera) {
          const orthoObject = this.object;
          const scale_x = (orthoObject.right - orthoObject.left) / this.object.zoom;
          const scale_y = (orthoObject.top - orthoObject.bottom) / this.object.zoom;
          this.mouseChange.x *= scale_x;
          this.mouseChange.y *= scale_y;
        } else {
          this.mouseChange.multiplyScalar(this._eye.length() * this.panSpeed);
        }
        this.pan.copy(this._eye).cross(this.object.up).setLength(this.mouseChange.x);
        this.pan.add(this.objectUp.copy(this.object.up).setLength(this.mouseChange.y));
        this.object.position.add(this.pan);
        this.target.add(this.pan);
        if (this.staticMoving) {
          this._panStart.copy(this._panEnd);
        } else {
          this._panStart.add(this.mouseChange.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));
        }
      }
    });
    _defineProperty(this, "checkDistances", () => {
      if (!this.noZoom || !this.noPan) {
        if (this._eye.lengthSq() > this.maxDistance * this.maxDistance) {
          this.object.position.addVectors(this.target, this._eye.setLength(this.maxDistance));
          this._zoomStart.copy(this._zoomEnd);
        }
        if (this._eye.lengthSq() < this.minDistance * this.minDistance) {
          this.object.position.addVectors(this.target, this._eye.setLength(this.minDistance));
          this._zoomStart.copy(this._zoomEnd);
        }
      }
    });
    _defineProperty(this, "handleResize", () => {
      if (!this.domElement)
        return;
      const box = this.domElement.getBoundingClientRect();
      const d = this.domElement.ownerDocument.documentElement;
      this.screen.left = box.left + window.pageXOffset - d.clientLeft;
      this.screen.top = box.top + window.pageYOffset - d.clientTop;
      this.screen.width = box.width;
      this.screen.height = box.height;
    });
    _defineProperty(this, "update", () => {
      this._eye.subVectors(this.object.position, this.target);
      if (!this.noRotate) {
        this.rotateCamera();
      }
      if (!this.noZoom) {
        this.zoomCamera();
      }
      if (!this.noPan) {
        this.panCamera();
      }
      this.object.position.addVectors(this.target, this._eye);
      if (this.object.isPerspectiveCamera) {
        this.checkDistances();
        this.object.lookAt(this.target);
        if (this.lastPosition.distanceToSquared(this.object.position) > this.EPS) {
          this.dispatchEvent(this.changeEvent);
          this.lastPosition.copy(this.object.position);
        }
      } else if (this.object.isOrthographicCamera) {
        this.object.lookAt(this.target);
        if (this.lastPosition.distanceToSquared(this.object.position) > this.EPS || this.lastZoom !== this.object.zoom) {
          this.dispatchEvent(this.changeEvent);
          this.lastPosition.copy(this.object.position);
          this.lastZoom = this.object.zoom;
        }
      } else {
        console.warn("THREE.TrackballControls: Unsupported camera type");
      }
    });
    _defineProperty(this, "reset", () => {
      this._state = this.STATE.NONE;
      this._keyState = this.STATE.NONE;
      this.target.copy(this.target0);
      this.object.position.copy(this.position0);
      this.object.up.copy(this.up0);
      this.object.zoom = this.zoom0;
      this.object.updateProjectionMatrix();
      this._eye.subVectors(this.object.position, this.target);
      this.object.lookAt(this.target);
      this.dispatchEvent(this.changeEvent);
      this.lastPosition.copy(this.object.position);
      this.lastZoom = this.object.zoom;
    });
    _defineProperty(this, "keydown", (event) => {
      if (this.enabled === false)
        return;
      window.removeEventListener("keydown", this.keydown);
      if (this._keyState !== this.STATE.NONE) {
        return;
      } else if (event.code === this.keys[this.STATE.ROTATE] && !this.noRotate) {
        this._keyState = this.STATE.ROTATE;
      } else if (event.code === this.keys[this.STATE.ZOOM] && !this.noZoom) {
        this._keyState = this.STATE.ZOOM;
      } else if (event.code === this.keys[this.STATE.PAN] && !this.noPan) {
        this._keyState = this.STATE.PAN;
      }
    });
    _defineProperty(this, "onPointerDown", (event) => {
      if (this.enabled === false)
        return;
      switch (event.pointerType) {
        case "mouse":
        case "pen":
          this.onMouseDown(event);
          break;
      }
    });
    _defineProperty(this, "onPointerMove", (event) => {
      if (this.enabled === false)
        return;
      switch (event.pointerType) {
        case "mouse":
        case "pen":
          this.onMouseMove(event);
          break;
      }
    });
    _defineProperty(this, "onPointerUp", (event) => {
      if (this.enabled === false)
        return;
      switch (event.pointerType) {
        case "mouse":
        case "pen":
          this.onMouseUp();
          break;
      }
    });
    _defineProperty(this, "keyup", () => {
      if (this.enabled === false)
        return;
      this._keyState = this.STATE.NONE;
      window.addEventListener("keydown", this.keydown);
    });
    _defineProperty(this, "onMouseDown", (event) => {
      if (!this.domElement)
        return;
      if (this._state === this.STATE.NONE) {
        switch (event.button) {
          case this.mouseButtons.LEFT:
            this._state = this.STATE.ROTATE;
            break;
          case this.mouseButtons.MIDDLE:
            this._state = this.STATE.ZOOM;
            break;
          case this.mouseButtons.RIGHT:
            this._state = this.STATE.PAN;
            break;
          default:
            this._state = this.STATE.NONE;
        }
      }
      const state = this._keyState !== this.STATE.NONE ? this._keyState : this._state;
      if (state === this.STATE.ROTATE && !this.noRotate) {
        this._moveCurr.copy(this.getMouseOnCircle(event.pageX, event.pageY));
        this._movePrev.copy(this._moveCurr);
      } else if (state === this.STATE.ZOOM && !this.noZoom) {
        this._zoomStart.copy(this.getMouseOnScreen(event.pageX, event.pageY));
        this._zoomEnd.copy(this._zoomStart);
      } else if (state === this.STATE.PAN && !this.noPan) {
        this._panStart.copy(this.getMouseOnScreen(event.pageX, event.pageY));
        this._panEnd.copy(this._panStart);
      }
      this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove);
      this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp);
      this.dispatchEvent(this.startEvent);
    });
    _defineProperty(this, "onMouseMove", (event) => {
      if (this.enabled === false)
        return;
      const state = this._keyState !== this.STATE.NONE ? this._keyState : this._state;
      if (state === this.STATE.ROTATE && !this.noRotate) {
        this._movePrev.copy(this._moveCurr);
        this._moveCurr.copy(this.getMouseOnCircle(event.pageX, event.pageY));
      } else if (state === this.STATE.ZOOM && !this.noZoom) {
        this._zoomEnd.copy(this.getMouseOnScreen(event.pageX, event.pageY));
      } else if (state === this.STATE.PAN && !this.noPan) {
        this._panEnd.copy(this.getMouseOnScreen(event.pageX, event.pageY));
      }
    });
    _defineProperty(this, "onMouseUp", () => {
      if (!this.domElement)
        return;
      if (this.enabled === false)
        return;
      this._state = this.STATE.NONE;
      this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove);
      this.domElement.ownerDocument.removeEventListener("pointerup", this.onPointerUp);
      this.dispatchEvent(this.endEvent);
    });
    _defineProperty(this, "mousewheel", (event) => {
      if (this.enabled === false)
        return;
      if (this.noZoom === true)
        return;
      event.preventDefault();
      switch (event.deltaMode) {
        case 2:
          this._zoomStart.y -= event.deltaY * 0.025;
          break;
        case 1:
          this._zoomStart.y -= event.deltaY * 0.01;
          break;
        default:
          this._zoomStart.y -= event.deltaY * 25e-5;
          break;
      }
      this.mousePosition.x = event.offsetX / this.screen.width * 2 - 1;
      this.mousePosition.y = -(event.offsetY / this.screen.height) * 2 + 1;
      this.dispatchEvent(this.startEvent);
      this.dispatchEvent(this.endEvent);
    });
    _defineProperty(this, "touchstart", (event) => {
      if (this.enabled === false)
        return;
      event.preventDefault();
      switch (event.touches.length) {
        case 1:
          this._state = this.STATE.TOUCH_ROTATE;
          this._moveCurr.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
          this._movePrev.copy(this._moveCurr);
          break;
        default:
          this._state = this.STATE.TOUCH_ZOOM_PAN;
          const dx = event.touches[0].pageX - event.touches[1].pageX;
          const dy = event.touches[0].pageY - event.touches[1].pageY;
          this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
          const x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          const y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          this._panStart.copy(this.getMouseOnScreen(x, y));
          this._panEnd.copy(this._panStart);
          break;
      }
      this.dispatchEvent(this.startEvent);
    });
    _defineProperty(this, "touchmove", (event) => {
      if (this.enabled === false)
        return;
      event.preventDefault();
      switch (event.touches.length) {
        case 1:
          this._movePrev.copy(this._moveCurr);
          this._moveCurr.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
          break;
        default:
          const dx = event.touches[0].pageX - event.touches[1].pageX;
          const dy = event.touches[0].pageY - event.touches[1].pageY;
          this._touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);
          const x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          const y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          this._panEnd.copy(this.getMouseOnScreen(x, y));
          break;
      }
    });
    _defineProperty(this, "touchend", (event) => {
      if (this.enabled === false)
        return;
      switch (event.touches.length) {
        case 0:
          this._state = this.STATE.NONE;
          break;
        case 1:
          this._state = this.STATE.TOUCH_ROTATE;
          this._moveCurr.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
          this._movePrev.copy(this._moveCurr);
          break;
      }
      this.dispatchEvent(this.endEvent);
    });
    _defineProperty(this, "contextmenu", (event) => {
      if (this.enabled === false)
        return;
      event.preventDefault();
    });
    _defineProperty(this, "connect", (domElement) => {
      if (domElement === document) {
        console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
      }
      this.domElement = domElement;
      this.domElement.addEventListener("contextmenu", this.contextmenu);
      this.domElement.addEventListener("pointerdown", this.onPointerDown);
      this.domElement.addEventListener("wheel", this.mousewheel);
      this.domElement.addEventListener("touchstart", this.touchstart);
      this.domElement.addEventListener("touchend", this.touchend);
      this.domElement.addEventListener("touchmove", this.touchmove);
      this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove);
      this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp);
      window.addEventListener("keydown", this.keydown);
      window.addEventListener("keyup", this.keyup);
      this.handleResize();
    });
    _defineProperty(this, "dispose", () => {
      if (!this.domElement)
        return;
      this.domElement.removeEventListener("contextmenu", this.contextmenu);
      this.domElement.removeEventListener("pointerdown", this.onPointerDown);
      this.domElement.removeEventListener("wheel", this.mousewheel);
      this.domElement.removeEventListener("touchstart", this.touchstart);
      this.domElement.removeEventListener("touchend", this.touchend);
      this.domElement.removeEventListener("touchmove", this.touchmove);
      this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove);
      this.domElement.ownerDocument.removeEventListener("pointerup", this.onPointerUp);
      window.removeEventListener("keydown", this.keydown);
      window.removeEventListener("keyup", this.keyup);
    });
    this.object = object;
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.up0 = this.object.up.clone();
    this.zoom0 = this.object.zoom;
    if (_domElement !== void 0)
      this.connect(_domElement);
    this.update();
  }
};

// node_modules/three-stdlib/controls/OrbitControls.js
var moduloWrapAround = (offset, capacity) => (offset % capacity + capacity) % capacity;
var OrbitControls = class extends EventDispatcher {
  constructor(object, domElement) {
    super();
    _defineProperty(this, "object", void 0);
    _defineProperty(this, "domElement", void 0);
    _defineProperty(this, "enabled", true);
    _defineProperty(this, "target", new Vector3());
    _defineProperty(this, "minDistance", 0);
    _defineProperty(this, "maxDistance", Infinity);
    _defineProperty(this, "minZoom", 0);
    _defineProperty(this, "maxZoom", Infinity);
    _defineProperty(this, "minPolarAngle", 0);
    _defineProperty(this, "maxPolarAngle", Math.PI);
    _defineProperty(this, "minAzimuthAngle", -Infinity);
    _defineProperty(this, "maxAzimuthAngle", Infinity);
    _defineProperty(this, "enableDamping", false);
    _defineProperty(this, "dampingFactor", 0.05);
    _defineProperty(this, "enableZoom", true);
    _defineProperty(this, "zoomSpeed", 1);
    _defineProperty(this, "enableRotate", true);
    _defineProperty(this, "rotateSpeed", 1);
    _defineProperty(this, "enablePan", true);
    _defineProperty(this, "panSpeed", 1);
    _defineProperty(this, "screenSpacePanning", true);
    _defineProperty(this, "keyPanSpeed", 7);
    _defineProperty(this, "autoRotate", false);
    _defineProperty(this, "autoRotateSpeed", 2);
    _defineProperty(this, "reverseOrbit", false);
    _defineProperty(this, "keys", {
      LEFT: "ArrowLeft",
      UP: "ArrowUp",
      RIGHT: "ArrowRight",
      BOTTOM: "ArrowDown"
    });
    _defineProperty(this, "mouseButtons", {
      LEFT: MOUSE.ROTATE,
      MIDDLE: MOUSE.DOLLY,
      RIGHT: MOUSE.PAN
    });
    _defineProperty(this, "touches", {
      ONE: TOUCH.ROTATE,
      TWO: TOUCH.DOLLY_PAN
    });
    _defineProperty(this, "target0", void 0);
    _defineProperty(this, "position0", void 0);
    _defineProperty(this, "zoom0", void 0);
    _defineProperty(this, "_domElementKeyEvents", null);
    _defineProperty(this, "getPolarAngle", void 0);
    _defineProperty(this, "getAzimuthalAngle", void 0);
    _defineProperty(this, "setPolarAngle", void 0);
    _defineProperty(this, "setAzimuthalAngle", void 0);
    _defineProperty(this, "getDistance", void 0);
    _defineProperty(this, "listenToKeyEvents", void 0);
    _defineProperty(this, "saveState", void 0);
    _defineProperty(this, "reset", void 0);
    _defineProperty(this, "update", void 0);
    _defineProperty(this, "connect", void 0);
    _defineProperty(this, "dispose", void 0);
    this.object = object;
    this.domElement = domElement;
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object instanceof PerspectiveCamera ? this.object.zoom : 1;
    this.getPolarAngle = () => spherical.phi;
    this.getAzimuthalAngle = () => spherical.theta;
    this.setPolarAngle = (value) => {
      let phi = moduloWrapAround(value, 2 * Math.PI);
      let currentPhi = spherical.phi;
      if (currentPhi < 0)
        currentPhi += 2 * Math.PI;
      if (phi < 0)
        phi += 2 * Math.PI;
      let phiDist = Math.abs(phi - currentPhi);
      if (2 * Math.PI - phiDist < phiDist) {
        if (phi < currentPhi) {
          phi += 2 * Math.PI;
        } else {
          currentPhi += 2 * Math.PI;
        }
      }
      sphericalDelta.phi = phi - currentPhi;
      scope2.update();
    };
    this.setAzimuthalAngle = (value) => {
      let theta = moduloWrapAround(value, 2 * Math.PI);
      let currentTheta = spherical.theta;
      if (currentTheta < 0)
        currentTheta += 2 * Math.PI;
      if (theta < 0)
        theta += 2 * Math.PI;
      let thetaDist = Math.abs(theta - currentTheta);
      if (2 * Math.PI - thetaDist < thetaDist) {
        if (theta < currentTheta) {
          theta += 2 * Math.PI;
        } else {
          currentTheta += 2 * Math.PI;
        }
      }
      sphericalDelta.theta = theta - currentTheta;
      scope2.update();
    };
    this.getDistance = () => scope2.object.position.distanceTo(scope2.target);
    this.listenToKeyEvents = (domElement2) => {
      domElement2.addEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = domElement2;
    };
    this.saveState = () => {
      scope2.target0.copy(scope2.target);
      scope2.position0.copy(scope2.object.position);
      scope2.zoom0 = scope2.object instanceof PerspectiveCamera ? scope2.object.zoom : 1;
    };
    this.reset = () => {
      scope2.target.copy(scope2.target0);
      scope2.object.position.copy(scope2.position0);
      if (scope2.object instanceof PerspectiveCamera) {
        scope2.object.zoom = scope2.zoom0;
        scope2.object.updateProjectionMatrix();
      }
      scope2.dispatchEvent(changeEvent);
      scope2.update();
      state = STATE3.NONE;
    };
    this.update = (() => {
      const offset = new Vector3();
      const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
      const quatInverse = quat.clone().invert();
      const lastPosition = new Vector3();
      const lastQuaternion = new Quaternion();
      const twoPI = 2 * Math.PI;
      return function update() {
        const position = scope2.object.position;
        offset.copy(position).sub(scope2.target);
        offset.applyQuaternion(quat);
        spherical.setFromVector3(offset);
        if (scope2.autoRotate && state === STATE3.NONE) {
          rotateLeft(getAutoRotationAngle());
        }
        if (scope2.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope2.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope2.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        let min2 = scope2.minAzimuthAngle;
        let max3 = scope2.maxAzimuthAngle;
        if (isFinite(min2) && isFinite(max3)) {
          if (min2 < -Math.PI)
            min2 += twoPI;
          else if (min2 > Math.PI)
            min2 -= twoPI;
          if (max3 < -Math.PI)
            max3 += twoPI;
          else if (max3 > Math.PI)
            max3 -= twoPI;
          if (min2 <= max3) {
            spherical.theta = Math.max(min2, Math.min(max3, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min2 + max3) / 2 ? Math.max(min2, spherical.theta) : Math.min(max3, spherical.theta);
          }
        }
        spherical.phi = Math.max(scope2.minPolarAngle, Math.min(scope2.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= scale;
        spherical.radius = Math.max(scope2.minDistance, Math.min(scope2.maxDistance, spherical.radius));
        if (scope2.enableDamping === true) {
          scope2.target.addScaledVector(panOffset, scope2.dampingFactor);
        } else {
          scope2.target.add(panOffset);
        }
        offset.setFromSpherical(spherical);
        offset.applyQuaternion(quatInverse);
        position.copy(scope2.target).add(offset);
        scope2.object.lookAt(scope2.target);
        if (scope2.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope2.dampingFactor;
          sphericalDelta.phi *= 1 - scope2.dampingFactor;
          panOffset.multiplyScalar(1 - scope2.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        scale = 1;
        if (zoomChanged || lastPosition.distanceToSquared(scope2.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope2.object.quaternion)) > EPS) {
          scope2.dispatchEvent(changeEvent);
          lastPosition.copy(scope2.object.position);
          lastQuaternion.copy(scope2.object.quaternion);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    })();
    this.connect = (domElement2) => {
      if (domElement2 === document) {
        console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
      }
      scope2.domElement = domElement2;
      scope2.domElement.style.touchAction = "none";
      scope2.domElement.addEventListener("contextmenu", onContextMenu);
      scope2.domElement.addEventListener("pointerdown", onPointerDown);
      scope2.domElement.addEventListener("pointercancel", onPointerCancel);
      scope2.domElement.addEventListener("wheel", onMouseWheel);
    };
    this.dispose = () => {
      var _scope$domElement, _scope$domElement2, _scope$domElement3, _scope$domElement4, _scope$domElement5, _scope$domElement6;
      (_scope$domElement = scope2.domElement) === null || _scope$domElement === void 0 ? void 0 : _scope$domElement.removeEventListener("contextmenu", onContextMenu);
      (_scope$domElement2 = scope2.domElement) === null || _scope$domElement2 === void 0 ? void 0 : _scope$domElement2.removeEventListener("pointerdown", onPointerDown);
      (_scope$domElement3 = scope2.domElement) === null || _scope$domElement3 === void 0 ? void 0 : _scope$domElement3.removeEventListener("pointercancel", onPointerCancel);
      (_scope$domElement4 = scope2.domElement) === null || _scope$domElement4 === void 0 ? void 0 : _scope$domElement4.removeEventListener("wheel", onMouseWheel);
      (_scope$domElement5 = scope2.domElement) === null || _scope$domElement5 === void 0 ? void 0 : _scope$domElement5.ownerDocument.removeEventListener("pointermove", onPointerMove);
      (_scope$domElement6 = scope2.domElement) === null || _scope$domElement6 === void 0 ? void 0 : _scope$domElement6.ownerDocument.removeEventListener("pointerup", onPointerUp);
      if (scope2._domElementKeyEvents !== null) {
        scope2._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
      }
    };
    const scope2 = this;
    const changeEvent = {
      type: "change"
    };
    const startEvent = {
      type: "start"
    };
    const endEvent = {
      type: "end"
    };
    const STATE3 = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let state = STATE3.NONE;
    const EPS = 1e-6;
    const spherical = new Spherical();
    const sphericalDelta = new Spherical();
    let scale = 1;
    const panOffset = new Vector3();
    let zoomChanged = false;
    const rotateStart = new Vector2();
    const rotateEnd = new Vector2();
    const rotateDelta = new Vector2();
    const panStart = new Vector2();
    const panEnd = new Vector2();
    const panDelta = new Vector2();
    const dollyStart = new Vector2();
    const dollyEnd = new Vector2();
    const dollyDelta = new Vector2();
    const pointers = [];
    const pointerPositions = {};
    function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * scope2.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope2.zoomSpeed);
    }
    function rotateLeft(angle) {
      if (scope2.reverseOrbit) {
        sphericalDelta.theta += angle;
      } else {
        sphericalDelta.theta -= angle;
      }
    }
    function rotateUp(angle) {
      if (scope2.reverseOrbit) {
        sphericalDelta.phi += angle;
      } else {
        sphericalDelta.phi -= angle;
      }
    }
    const panLeft = (() => {
      const v = new Vector3();
      return function panLeft2(distance2, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.multiplyScalar(-distance2);
        panOffset.add(v);
      };
    })();
    const panUp = (() => {
      const v = new Vector3();
      return function panUp2(distance2, objectMatrix) {
        if (scope2.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(scope2.object.up, v);
        }
        v.multiplyScalar(distance2);
        panOffset.add(v);
      };
    })();
    const pan = (() => {
      const offset = new Vector3();
      return function pan2(deltaX, deltaY) {
        const element2 = scope2.domElement;
        if (element2 && scope2.object instanceof PerspectiveCamera && scope2.object.isPerspectiveCamera) {
          const position = scope2.object.position;
          offset.copy(position).sub(scope2.target);
          let targetDistance = offset.length();
          targetDistance *= Math.tan(scope2.object.fov / 2 * Math.PI / 180);
          panLeft(2 * deltaX * targetDistance / element2.clientHeight, scope2.object.matrix);
          panUp(2 * deltaY * targetDistance / element2.clientHeight, scope2.object.matrix);
        } else if (element2 && scope2.object instanceof OrthographicCamera && scope2.object.isOrthographicCamera) {
          panLeft(deltaX * (scope2.object.right - scope2.object.left) / scope2.object.zoom / element2.clientWidth, scope2.object.matrix);
          panUp(deltaY * (scope2.object.top - scope2.object.bottom) / scope2.object.zoom / element2.clientHeight, scope2.object.matrix);
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
          scope2.enablePan = false;
        }
      };
    })();
    function dollyOut(dollyScale) {
      if (scope2.object instanceof PerspectiveCamera && scope2.object.isPerspectiveCamera) {
        scale /= dollyScale;
      } else if (scope2.object instanceof OrthographicCamera && scope2.object.isOrthographicCamera) {
        scope2.object.zoom = Math.max(scope2.minZoom, Math.min(scope2.maxZoom, scope2.object.zoom * dollyScale));
        scope2.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope2.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope2.object instanceof PerspectiveCamera && scope2.object.isPerspectiveCamera) {
        scale *= dollyScale;
      } else if (scope2.object instanceof OrthographicCamera && scope2.object.isOrthographicCamera) {
        scope2.object.zoom = Math.max(scope2.minZoom, Math.min(scope2.maxZoom, scope2.object.zoom / dollyScale));
        scope2.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope2.enableZoom = false;
      }
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope2.rotateSpeed);
      const element2 = scope2.domElement;
      if (element2) {
        rotateLeft(2 * Math.PI * rotateDelta.x / element2.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element2.clientHeight);
      }
      rotateStart.copy(rotateEnd);
      scope2.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope2.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope2.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope2.update();
    }
    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope2.update();
    }
    function handleKeyDown(event) {
      let needsUpdate = false;
      switch (event.code) {
        case scope2.keys.UP:
          pan(0, scope2.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope2.keys.BOTTOM:
          pan(0, -scope2.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope2.keys.LEFT:
          pan(scope2.keyPanSpeed, 0);
          needsUpdate = true;
          break;
        case scope2.keys.RIGHT:
          pan(-scope2.keyPanSpeed, 0);
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope2.update();
      }
    }
    function handleTouchStartRotate() {
      if (pointers.length == 1) {
        rotateStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        rotateStart.set(x, y);
      }
    }
    function handleTouchStartPan() {
      if (pointers.length == 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        panStart.set(x, y);
      }
    }
    function handleTouchStartDolly() {
      const dx = pointers[0].pageX - pointers[1].pageX;
      const dy = pointers[0].pageY - pointers[1].pageY;
      const distance2 = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance2);
    }
    function handleTouchStartDollyPan() {
      if (scope2.enableZoom)
        handleTouchStartDolly();
      if (scope2.enablePan)
        handleTouchStartPan();
    }
    function handleTouchStartDollyRotate() {
      if (scope2.enableZoom)
        handleTouchStartDolly();
      if (scope2.enableRotate)
        handleTouchStartRotate();
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        rotateEnd.set(x, y);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope2.rotateSpeed);
      const element2 = scope2.domElement;
      if (element2) {
        rotateLeft(2 * Math.PI * rotateDelta.x / element2.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element2.clientHeight);
      }
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length == 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        panEnd.set(x, y);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope2.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      const position = getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      const distance2 = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance2);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope2.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope2.enableZoom)
        handleTouchMoveDolly(event);
      if (scope2.enablePan)
        handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope2.enableZoom)
        handleTouchMoveDolly(event);
      if (scope2.enableRotate)
        handleTouchMoveRotate(event);
    }
    function onPointerDown(event) {
      if (scope2.enabled === false)
        return;
      if (pointers.length === 0) {
        var _scope$domElement7, _scope$domElement8;
        (_scope$domElement7 = scope2.domElement) === null || _scope$domElement7 === void 0 ? void 0 : _scope$domElement7.ownerDocument.addEventListener("pointermove", onPointerMove);
        (_scope$domElement8 = scope2.domElement) === null || _scope$domElement8 === void 0 ? void 0 : _scope$domElement8.ownerDocument.addEventListener("pointerup", onPointerUp);
      }
      addPointer(event);
      if (event.pointerType === "touch") {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove(event) {
      if (scope2.enabled === false)
        return;
      if (event.pointerType === "touch") {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp(event) {
      removePointer(event);
      if (pointers.length === 0) {
        var _scope$domElement9, _scope$domElement10, _scope$domElement11;
        (_scope$domElement9 = scope2.domElement) === null || _scope$domElement9 === void 0 ? void 0 : _scope$domElement9.releasePointerCapture(event.pointerId);
        (_scope$domElement10 = scope2.domElement) === null || _scope$domElement10 === void 0 ? void 0 : _scope$domElement10.ownerDocument.removeEventListener("pointermove", onPointerMove);
        (_scope$domElement11 = scope2.domElement) === null || _scope$domElement11 === void 0 ? void 0 : _scope$domElement11.ownerDocument.removeEventListener("pointerup", onPointerUp);
      }
      scope2.dispatchEvent(endEvent);
      state = STATE3.NONE;
    }
    function onPointerCancel(event) {
      removePointer(event);
    }
    function onMouseDown(event) {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope2.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope2.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope2.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope2.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE3.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope2.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE3.PAN;
          } else {
            if (scope2.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE3.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope2.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE3.ROTATE;
          } else {
            if (scope2.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE3.PAN;
          }
          break;
        default:
          state = STATE3.NONE;
      }
      if (state !== STATE3.NONE) {
        scope2.dispatchEvent(startEvent);
      }
    }
    function onMouseMove(event) {
      if (scope2.enabled === false)
        return;
      switch (state) {
        case STATE3.ROTATE:
          if (scope2.enableRotate === false)
            return;
          handleMouseMoveRotate(event);
          break;
        case STATE3.DOLLY:
          if (scope2.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE3.PAN:
          if (scope2.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseWheel(event) {
      if (scope2.enabled === false || scope2.enableZoom === false || state !== STATE3.NONE && state !== STATE3.ROTATE) {
        return;
      }
      event.preventDefault();
      scope2.dispatchEvent(startEvent);
      handleMouseWheel(event);
      scope2.dispatchEvent(endEvent);
    }
    function onKeyDown(event) {
      if (scope2.enabled === false || scope2.enablePan === false)
        return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope2.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope2.enableRotate === false)
                return;
              handleTouchStartRotate();
              state = STATE3.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope2.enablePan === false)
                return;
              handleTouchStartPan();
              state = STATE3.TOUCH_PAN;
              break;
            default:
              state = STATE3.NONE;
          }
          break;
        case 2:
          switch (scope2.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope2.enableZoom === false && scope2.enablePan === false)
                return;
              handleTouchStartDollyPan();
              state = STATE3.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope2.enableZoom === false && scope2.enableRotate === false)
                return;
              handleTouchStartDollyRotate();
              state = STATE3.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE3.NONE;
          }
          break;
        default:
          state = STATE3.NONE;
      }
      if (state !== STATE3.NONE) {
        scope2.dispatchEvent(startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE3.TOUCH_ROTATE:
          if (scope2.enableRotate === false)
            return;
          handleTouchMoveRotate(event);
          scope2.update();
          break;
        case STATE3.TOUCH_PAN:
          if (scope2.enablePan === false)
            return;
          handleTouchMovePan(event);
          scope2.update();
          break;
        case STATE3.TOUCH_DOLLY_PAN:
          if (scope2.enableZoom === false && scope2.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          scope2.update();
          break;
        case STATE3.TOUCH_DOLLY_ROTATE:
          if (scope2.enableZoom === false && scope2.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope2.update();
          break;
        default:
          state = STATE3.NONE;
      }
    }
    function onContextMenu(event) {
      if (scope2.enabled === false)
        return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i2 = 0; i2 < pointers.length; i2++) {
        if (pointers[i2].pointerId == event.pointerId) {
          pointers.splice(i2, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId];
      if (position === void 0) {
        position = new Vector2();
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
      return pointerPositions[pointer.pointerId];
    }
    if (domElement !== void 0)
      this.connect(domElement);
    this.update();
  }
};
var MapControls = class extends OrbitControls {
  constructor(object, domElement) {
    super(object, domElement);
    this.screenSpacePanning = false;
    this.mouseButtons.LEFT = MOUSE.PAN;
    this.mouseButtons.RIGHT = MOUSE.ROTATE;
    this.touches.ONE = TOUCH.PAN;
    this.touches.TWO = TOUCH.DOLLY_ROTATE;
  }
};

// node_modules/three-stdlib/controls/ArcballControls.js
var STATE2 = {
  IDLE: Symbol(),
  ROTATE: Symbol(),
  PAN: Symbol(),
  SCALE: Symbol(),
  FOV: Symbol(),
  FOCUS: Symbol(),
  ZROTATE: Symbol(),
  TOUCH_MULTI: Symbol(),
  ANIMATION_FOCUS: Symbol(),
  ANIMATION_ROTATE: Symbol()
};
var INPUT = {
  NONE: Symbol(),
  ONE_FINGER: Symbol(),
  ONE_FINGER_SWITCHED: Symbol(),
  TWO_FINGER: Symbol(),
  MULT_FINGER: Symbol(),
  CURSOR: Symbol()
};
var _center = {
  x: 0,
  y: 0
};
var _transformation = {
  camera: new Matrix4(),
  gizmos: new Matrix4()
};
var _changeEvent = {
  type: "change"
};
var _startEvent = {
  type: "start"
};
var _endEvent = {
  type: "end"
};
var ArcballControls = class extends EventDispatcher {
  constructor(_camera, _domElement = null, scene = null) {
    super();
    _defineProperty(this, "camera", void 0);
    _defineProperty(this, "domElement", void 0);
    _defineProperty(this, "scene", void 0);
    _defineProperty(this, "mouseActions", void 0);
    _defineProperty(this, "_mouseOp", void 0);
    _defineProperty(this, "_v2_1", void 0);
    _defineProperty(this, "_v3_1", void 0);
    _defineProperty(this, "_v3_2", void 0);
    _defineProperty(this, "_m4_1", void 0);
    _defineProperty(this, "_m4_2", void 0);
    _defineProperty(this, "_quat", void 0);
    _defineProperty(this, "_translationMatrix", void 0);
    _defineProperty(this, "_rotationMatrix", void 0);
    _defineProperty(this, "_scaleMatrix", void 0);
    _defineProperty(this, "_rotationAxis", void 0);
    _defineProperty(this, "_cameraMatrixState", void 0);
    _defineProperty(this, "_cameraProjectionState", void 0);
    _defineProperty(this, "_fovState", void 0);
    _defineProperty(this, "_upState", void 0);
    _defineProperty(this, "_zoomState", void 0);
    _defineProperty(this, "_nearPos", void 0);
    _defineProperty(this, "_farPos", void 0);
    _defineProperty(this, "_gizmoMatrixState", void 0);
    _defineProperty(this, "_up0", void 0);
    _defineProperty(this, "_zoom0", void 0);
    _defineProperty(this, "_fov0", void 0);
    _defineProperty(this, "_initialNear", void 0);
    _defineProperty(this, "_nearPos0", void 0);
    _defineProperty(this, "_initialFar", void 0);
    _defineProperty(this, "_farPos0", void 0);
    _defineProperty(this, "_cameraMatrixState0", void 0);
    _defineProperty(this, "_gizmoMatrixState0", void 0);
    _defineProperty(this, "_button", void 0);
    _defineProperty(this, "_touchStart", void 0);
    _defineProperty(this, "_touchCurrent", void 0);
    _defineProperty(this, "_input", void 0);
    _defineProperty(this, "_switchSensibility", void 0);
    _defineProperty(this, "_startFingerDistance", void 0);
    _defineProperty(this, "_currentFingerDistance", void 0);
    _defineProperty(this, "_startFingerRotation", void 0);
    _defineProperty(this, "_currentFingerRotation", void 0);
    _defineProperty(this, "_devPxRatio", void 0);
    _defineProperty(this, "_downValid", void 0);
    _defineProperty(this, "_nclicks", void 0);
    _defineProperty(this, "_downEvents", void 0);
    _defineProperty(this, "_clickStart", void 0);
    _defineProperty(this, "_maxDownTime", void 0);
    _defineProperty(this, "_maxInterval", void 0);
    _defineProperty(this, "_posThreshold", void 0);
    _defineProperty(this, "_movementThreshold", void 0);
    _defineProperty(this, "_currentCursorPosition", void 0);
    _defineProperty(this, "_startCursorPosition", void 0);
    _defineProperty(this, "_grid", void 0);
    _defineProperty(this, "_gridPosition", void 0);
    _defineProperty(this, "_gizmos", void 0);
    _defineProperty(this, "_curvePts", void 0);
    _defineProperty(this, "_timeStart", void 0);
    _defineProperty(this, "_animationId", void 0);
    _defineProperty(this, "focusAnimationTime", void 0);
    _defineProperty(this, "_timePrev", void 0);
    _defineProperty(this, "_timeCurrent", void 0);
    _defineProperty(this, "_anglePrev", void 0);
    _defineProperty(this, "_angleCurrent", void 0);
    _defineProperty(this, "_cursorPosPrev", void 0);
    _defineProperty(this, "_cursorPosCurr", void 0);
    _defineProperty(this, "_wPrev", void 0);
    _defineProperty(this, "_wCurr", void 0);
    _defineProperty(this, "adjustNearFar", void 0);
    _defineProperty(this, "scaleFactor", void 0);
    _defineProperty(this, "dampingFactor", void 0);
    _defineProperty(this, "wMax", void 0);
    _defineProperty(this, "enableAnimations", void 0);
    _defineProperty(this, "enableGrid", void 0);
    _defineProperty(this, "cursorZoom", void 0);
    _defineProperty(this, "minFov", void 0);
    _defineProperty(this, "maxFov", void 0);
    _defineProperty(this, "enabled", void 0);
    _defineProperty(this, "enablePan", void 0);
    _defineProperty(this, "enableRotate", void 0);
    _defineProperty(this, "enableZoom", void 0);
    _defineProperty(this, "minDistance", void 0);
    _defineProperty(this, "maxDistance", void 0);
    _defineProperty(this, "minZoom", void 0);
    _defineProperty(this, "maxZoom", void 0);
    _defineProperty(this, "target", void 0);
    _defineProperty(this, "_currentTarget", void 0);
    _defineProperty(this, "_tbRadius", void 0);
    _defineProperty(this, "_state", void 0);
    _defineProperty(this, "onWindowResize", () => {
      const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;
      if (this.camera) {
        const tbRadius = this.calculateTbRadius(this.camera);
        if (tbRadius !== void 0) {
          this._tbRadius = tbRadius;
        }
      }
      const newRadius = this._tbRadius / scale;
      const curve = new EllipseCurve(0, 0, newRadius, newRadius);
      const points = curve.getPoints(this._curvePts);
      const curveGeometry = new BufferGeometry().setFromPoints(points);
      for (const gizmo in this._gizmos.children) {
        const child = this._gizmos.children[gizmo];
        child.geometry = curveGeometry;
      }
      this.dispatchEvent(_changeEvent);
    });
    _defineProperty(this, "onContextMenu", (event) => {
      if (!this.enabled) {
        return;
      }
      for (let i2 = 0; i2 < this.mouseActions.length; i2++) {
        if (this.mouseActions[i2].mouse == 2) {
          event.preventDefault();
          break;
        }
      }
    });
    _defineProperty(this, "onPointerCancel", () => {
      this._touchStart.splice(0, this._touchStart.length);
      this._touchCurrent.splice(0, this._touchCurrent.length);
      this._input = INPUT.NONE;
    });
    _defineProperty(this, "onPointerDown", (event) => {
      if (event.button == 0 && event.isPrimary) {
        this._downValid = true;
        this._downEvents.push(event);
      } else {
        this._downValid = false;
      }
      if (event.pointerType == "touch" && this._input != INPUT.CURSOR) {
        this._touchStart.push(event);
        this._touchCurrent.push(event);
        switch (this._input) {
          case INPUT.NONE:
            this._input = INPUT.ONE_FINGER;
            this.onSinglePanStart(event, "ROTATE");
            window.addEventListener("pointermove", this.onPointerMove);
            window.addEventListener("pointerup", this.onPointerUp);
            break;
          case INPUT.ONE_FINGER:
          case INPUT.ONE_FINGER_SWITCHED:
            this._input = INPUT.TWO_FINGER;
            this.onRotateStart();
            this.onPinchStart();
            this.onDoublePanStart();
            break;
          case INPUT.TWO_FINGER:
            this._input = INPUT.MULT_FINGER;
            this.onTriplePanStart();
            break;
        }
      } else if (event.pointerType != "touch" && this._input == INPUT.NONE) {
        let modifier = null;
        if (event.ctrlKey || event.metaKey) {
          modifier = "CTRL";
        } else if (event.shiftKey) {
          modifier = "SHIFT";
        }
        this._mouseOp = this.getOpFromAction(event.button, modifier);
        if (this._mouseOp) {
          window.addEventListener("pointermove", this.onPointerMove);
          window.addEventListener("pointerup", this.onPointerUp);
          this._input = INPUT.CURSOR;
          this._button = event.button;
          this.onSinglePanStart(event, this._mouseOp);
        }
      }
    });
    _defineProperty(this, "onPointerMove", (event) => {
      if (event.pointerType == "touch" && this._input != INPUT.CURSOR) {
        switch (this._input) {
          case INPUT.ONE_FINGER:
            this.updateTouchEvent(event);
            this.onSinglePanMove(event, STATE2.ROTATE);
            break;
          case INPUT.ONE_FINGER_SWITCHED:
            const movement = this.calculatePointersDistance(this._touchCurrent[0], event) * this._devPxRatio;
            if (movement >= this._switchSensibility) {
              this._input = INPUT.ONE_FINGER;
              this.updateTouchEvent(event);
              this.onSinglePanStart(event, "ROTATE");
              break;
            }
            break;
          case INPUT.TWO_FINGER:
            this.updateTouchEvent(event);
            this.onRotateMove();
            this.onPinchMove();
            this.onDoublePanMove();
            break;
          case INPUT.MULT_FINGER:
            this.updateTouchEvent(event);
            this.onTriplePanMove();
            break;
        }
      } else if (event.pointerType != "touch" && this._input == INPUT.CURSOR) {
        let modifier = null;
        if (event.ctrlKey || event.metaKey) {
          modifier = "CTRL";
        } else if (event.shiftKey) {
          modifier = "SHIFT";
        }
        const mouseOpState = this.getOpStateFromAction(this._button, modifier);
        if (mouseOpState) {
          this.onSinglePanMove(event, mouseOpState);
        }
      }
      if (this._downValid) {
        const movement = this.calculatePointersDistance(this._downEvents[this._downEvents.length - 1], event) * this._devPxRatio;
        if (movement > this._movementThreshold) {
          this._downValid = false;
        }
      }
    });
    _defineProperty(this, "onPointerUp", (event) => {
      if (event.pointerType == "touch" && this._input != INPUT.CURSOR) {
        const nTouch = this._touchCurrent.length;
        for (let i2 = 0; i2 < nTouch; i2++) {
          if (this._touchCurrent[i2].pointerId == event.pointerId) {
            this._touchCurrent.splice(i2, 1);
            this._touchStart.splice(i2, 1);
            break;
          }
        }
        switch (this._input) {
          case INPUT.ONE_FINGER:
          case INPUT.ONE_FINGER_SWITCHED:
            window.removeEventListener("pointermove", this.onPointerMove);
            window.removeEventListener("pointerup", this.onPointerUp);
            this._input = INPUT.NONE;
            this.onSinglePanEnd();
            break;
          case INPUT.TWO_FINGER:
            this.onDoublePanEnd();
            this.onPinchEnd();
            this.onRotateEnd();
            this._input = INPUT.ONE_FINGER_SWITCHED;
            break;
          case INPUT.MULT_FINGER:
            if (this._touchCurrent.length == 0) {
              window.removeEventListener("pointermove", this.onPointerMove);
              window.removeEventListener("pointerup", this.onPointerUp);
              this._input = INPUT.NONE;
              this.onTriplePanEnd();
            }
            break;
        }
      } else if (event.pointerType != "touch" && this._input == INPUT.CURSOR) {
        window.removeEventListener("pointermove", this.onPointerMove);
        window.removeEventListener("pointerup", this.onPointerUp);
        this._input = INPUT.NONE;
        this.onSinglePanEnd();
        this._button = -1;
      }
      if (event.isPrimary) {
        if (this._downValid) {
          const downTime = event.timeStamp - this._downEvents[this._downEvents.length - 1].timeStamp;
          if (downTime <= this._maxDownTime) {
            if (this._nclicks == 0) {
              this._nclicks = 1;
              this._clickStart = performance.now();
            } else {
              const clickInterval = event.timeStamp - this._clickStart;
              const movement = this.calculatePointersDistance(this._downEvents[1], this._downEvents[0]) * this._devPxRatio;
              if (clickInterval <= this._maxInterval && movement <= this._posThreshold) {
                this._nclicks = 0;
                this._downEvents.splice(0, this._downEvents.length);
                this.onDoubleTap(event);
              } else {
                this._nclicks = 1;
                this._downEvents.shift();
                this._clickStart = performance.now();
              }
            }
          } else {
            this._downValid = false;
            this._nclicks = 0;
            this._downEvents.splice(0, this._downEvents.length);
          }
        } else {
          this._nclicks = 0;
          this._downEvents.splice(0, this._downEvents.length);
        }
      }
    });
    _defineProperty(this, "onWheel", (event) => {
      var _this$camera3;
      if (this.enabled && this.enableZoom && this.domElement) {
        let modifier = null;
        if (event.ctrlKey || event.metaKey) {
          modifier = "CTRL";
        } else if (event.shiftKey) {
          modifier = "SHIFT";
        }
        const mouseOp = this.getOpFromAction("WHEEL", modifier);
        if (mouseOp) {
          event.preventDefault();
          this.dispatchEvent(_startEvent);
          const notchDeltaY = 125;
          let sgn = event.deltaY / notchDeltaY;
          let size2 = 1;
          if (sgn > 0) {
            size2 = 1 / this.scaleFactor;
          } else if (sgn < 0) {
            size2 = this.scaleFactor;
          }
          switch (mouseOp) {
            case "ZOOM":
              this.updateTbState(STATE2.SCALE, true);
              if (sgn > 0) {
                size2 = 1 / Math.pow(this.scaleFactor, sgn);
              } else if (sgn < 0) {
                size2 = Math.pow(this.scaleFactor, -sgn);
              }
              if (this.cursorZoom && this.enablePan) {
                var _this$camera, _this$camera2;
                let scalePoint;
                if (((_this$camera = this.camera) === null || _this$camera === void 0 ? void 0 : _this$camera.type) === "OrthographicCamera") {
                  var _this$unprojectOnTbPl;
                  scalePoint = (_this$unprojectOnTbPl = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement)) === null || _this$unprojectOnTbPl === void 0 ? void 0 : _this$unprojectOnTbPl.applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);
                }
                if (((_this$camera2 = this.camera) === null || _this$camera2 === void 0 ? void 0 : _this$camera2.type) === "PerspectiveCamera") {
                  var _this$unprojectOnTbPl2;
                  scalePoint = (_this$unprojectOnTbPl2 = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement)) === null || _this$unprojectOnTbPl2 === void 0 ? void 0 : _this$unprojectOnTbPl2.applyQuaternion(this.camera.quaternion).add(this._gizmos.position);
                }
                if (scalePoint !== void 0)
                  this.applyTransformMatrix(this.applyScale(size2, scalePoint));
              } else {
                this.applyTransformMatrix(this.applyScale(size2, this._gizmos.position));
              }
              if (this._grid) {
                this.disposeGrid();
                this.drawGrid();
              }
              this.updateTbState(STATE2.IDLE, false);
              this.dispatchEvent(_changeEvent);
              this.dispatchEvent(_endEvent);
              break;
            case "FOV":
              if (((_this$camera3 = this.camera) === null || _this$camera3 === void 0 ? void 0 : _this$camera3.type) === "PerspectiveCamera") {
                this.updateTbState(STATE2.FOV, true);
                if (event.deltaX != 0) {
                  sgn = event.deltaX / notchDeltaY;
                  size2 = 1;
                  if (sgn > 0) {
                    size2 = 1 / Math.pow(this.scaleFactor, sgn);
                  } else if (sgn < 0) {
                    size2 = Math.pow(this.scaleFactor, -sgn);
                  }
                }
                this._v3_1.setFromMatrixPosition(this._cameraMatrixState);
                const x = this._v3_1.distanceTo(this._gizmos.position);
                let xNew = x / size2;
                xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);
                const y = x * Math.tan(MathUtils.DEG2RAD * this.camera.fov * 0.5);
                let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);
                if (newFov > this.maxFov) {
                  newFov = this.maxFov;
                } else if (newFov < this.minFov) {
                  newFov = this.minFov;
                }
                const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));
                size2 = x / newDistance;
                this.setFov(newFov);
                this.applyTransformMatrix(this.applyScale(size2, this._gizmos.position, false));
              }
              if (this._grid) {
                this.disposeGrid();
                this.drawGrid();
              }
              this.updateTbState(STATE2.IDLE, false);
              this.dispatchEvent(_changeEvent);
              this.dispatchEvent(_endEvent);
              break;
          }
        }
      }
    });
    _defineProperty(this, "onSinglePanStart", (event, operation) => {
      var _this$camera4;
      if (this.enabled && this.domElement) {
        this.dispatchEvent(_startEvent);
        this.setCenter(event.clientX, event.clientY);
        switch (operation) {
          case "PAN":
            if (!this.enablePan)
              return;
            if (this._animationId != -1) {
              cancelAnimationFrame(this._animationId);
              this._animationId = -1;
              this._timeStart = -1;
              this.activateGizmos(false);
              this.dispatchEvent(_changeEvent);
            }
            if (this.camera) {
              this.updateTbState(STATE2.PAN, true);
              const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement);
              if (rayDir !== void 0) {
                this._startCursorPosition.copy(rayDir);
              }
              if (this.enableGrid) {
                this.drawGrid();
                this.dispatchEvent(_changeEvent);
              }
            }
            break;
          case "ROTATE":
            if (!this.enableRotate)
              return;
            if (this._animationId != -1) {
              cancelAnimationFrame(this._animationId);
              this._animationId = -1;
              this._timeStart = -1;
            }
            if (this.camera) {
              this.updateTbState(STATE2.ROTATE, true);
              const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius);
              if (rayDir !== void 0) {
                this._startCursorPosition.copy(rayDir);
              }
              this.activateGizmos(true);
              if (this.enableAnimations) {
                this._timePrev = this._timeCurrent = performance.now();
                this._angleCurrent = this._anglePrev = 0;
                this._cursorPosPrev.copy(this._startCursorPosition);
                this._cursorPosCurr.copy(this._cursorPosPrev);
                this._wCurr = 0;
                this._wPrev = this._wCurr;
              }
            }
            this.dispatchEvent(_changeEvent);
            break;
          case "FOV":
            if (!this.enableZoom)
              return;
            if (((_this$camera4 = this.camera) === null || _this$camera4 === void 0 ? void 0 : _this$camera4.type) === "PerspectiveCamera") {
              if (this._animationId != -1) {
                cancelAnimationFrame(this._animationId);
                this._animationId = -1;
                this._timeStart = -1;
                this.activateGizmos(false);
                this.dispatchEvent(_changeEvent);
              }
              this.updateTbState(STATE2.FOV, true);
              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);
              this._currentCursorPosition.copy(this._startCursorPosition);
            }
            break;
          case "ZOOM":
            if (!this.enableZoom)
              return;
            if (this._animationId != -1) {
              cancelAnimationFrame(this._animationId);
              this._animationId = -1;
              this._timeStart = -1;
              this.activateGizmos(false);
              this.dispatchEvent(_changeEvent);
            }
            this.updateTbState(STATE2.SCALE, true);
            this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);
            this._currentCursorPosition.copy(this._startCursorPosition);
            break;
        }
      }
    });
    _defineProperty(this, "onSinglePanMove", (event, opState) => {
      var _this$camera5;
      if (this.enabled && this.domElement) {
        const restart = opState != this._state;
        this.setCenter(event.clientX, event.clientY);
        switch (opState) {
          case STATE2.PAN:
            if (this.enablePan && this.camera) {
              if (restart) {
                this.dispatchEvent(_endEvent);
                this.dispatchEvent(_startEvent);
                this.updateTbState(opState, true);
                const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement);
                if (rayDir !== void 0) {
                  this._startCursorPosition.copy(rayDir);
                }
                if (this.enableGrid) {
                  this.drawGrid();
                }
                this.activateGizmos(false);
              } else {
                const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement);
                if (rayDir !== void 0) {
                  this._currentCursorPosition.copy(rayDir);
                }
                this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition));
              }
            }
            break;
          case STATE2.ROTATE:
            if (this.enableRotate && this.camera) {
              if (restart) {
                this.dispatchEvent(_endEvent);
                this.dispatchEvent(_startEvent);
                this.updateTbState(opState, true);
                const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius);
                if (rayDir !== void 0) {
                  this._startCursorPosition.copy(rayDir);
                }
                if (this.enableGrid) {
                  this.disposeGrid();
                }
                this.activateGizmos(true);
              } else {
                const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius);
                if (rayDir !== void 0) {
                  this._currentCursorPosition.copy(rayDir);
                }
                const distance2 = this._startCursorPosition.distanceTo(this._currentCursorPosition);
                const angle = this._startCursorPosition.angleTo(this._currentCursorPosition);
                const amount = Math.max(distance2 / this._tbRadius, angle);
                this.applyTransformMatrix(this.rotate(this.calculateRotationAxis(this._startCursorPosition, this._currentCursorPosition), amount));
                if (this.enableAnimations) {
                  this._timePrev = this._timeCurrent;
                  this._timeCurrent = performance.now();
                  this._anglePrev = this._angleCurrent;
                  this._angleCurrent = amount;
                  this._cursorPosPrev.copy(this._cursorPosCurr);
                  this._cursorPosCurr.copy(this._currentCursorPosition);
                  this._wPrev = this._wCurr;
                  this._wCurr = this.calculateAngularSpeed(this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent);
                }
              }
            }
            break;
          case STATE2.SCALE:
            if (this.enableZoom) {
              if (restart) {
                this.dispatchEvent(_endEvent);
                this.dispatchEvent(_startEvent);
                this.updateTbState(opState, true);
                this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);
                this._currentCursorPosition.copy(this._startCursorPosition);
                if (this.enableGrid) {
                  this.disposeGrid();
                }
                this.activateGizmos(false);
              } else {
                const screenNotches = 8;
                this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);
                const movement = this._currentCursorPosition.y - this._startCursorPosition.y;
                let size2 = 1;
                if (movement < 0) {
                  size2 = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);
                } else if (movement > 0) {
                  size2 = Math.pow(this.scaleFactor, movement * screenNotches);
                }
                this.applyTransformMatrix(this.applyScale(size2, this._gizmos.position));
              }
            }
            break;
          case STATE2.FOV:
            if (this.enableZoom && ((_this$camera5 = this.camera) === null || _this$camera5 === void 0 ? void 0 : _this$camera5.type) === "PerspectiveCamera") {
              if (restart) {
                this.dispatchEvent(_endEvent);
                this.dispatchEvent(_startEvent);
                this.updateTbState(opState, true);
                this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);
                this._currentCursorPosition.copy(this._startCursorPosition);
                if (this.enableGrid) {
                  this.disposeGrid();
                }
                this.activateGizmos(false);
              } else {
                const screenNotches = 8;
                this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);
                const movement = this._currentCursorPosition.y - this._startCursorPosition.y;
                let size2 = 1;
                if (movement < 0) {
                  size2 = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);
                } else if (movement > 0) {
                  size2 = Math.pow(this.scaleFactor, movement * screenNotches);
                }
                this._v3_1.setFromMatrixPosition(this._cameraMatrixState);
                const x = this._v3_1.distanceTo(this._gizmos.position);
                let xNew = x / size2;
                xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);
                const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5);
                let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);
                newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);
                const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));
                size2 = x / newDistance;
                this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);
                this.setFov(newFov);
                this.applyTransformMatrix(this.applyScale(size2, this._v3_2, false));
                const direction = this._gizmos.position.clone().sub(this.camera.position).normalize().multiplyScalar(newDistance / x);
                this._m4_1.makeTranslation(direction.x, direction.y, direction.z);
              }
            }
            break;
        }
        this.dispatchEvent(_changeEvent);
      }
    });
    _defineProperty(this, "onSinglePanEnd", () => {
      if (this._state == STATE2.ROTATE) {
        if (!this.enableRotate) {
          return;
        }
        if (this.enableAnimations) {
          const deltaTime = performance.now() - this._timeCurrent;
          if (deltaTime < 120) {
            const w = Math.abs((this._wPrev + this._wCurr) / 2);
            const self2 = this;
            this._animationId = window.requestAnimationFrame(function(t2) {
              self2.updateTbState(STATE2.ANIMATION_ROTATE, true);
              const rotationAxis = self2.calculateRotationAxis(self2._cursorPosPrev, self2._cursorPosCurr);
              self2.onRotationAnim(t2, rotationAxis, Math.min(w, self2.wMax));
            });
          } else {
            this.updateTbState(STATE2.IDLE, false);
            this.activateGizmos(false);
            this.dispatchEvent(_changeEvent);
          }
        } else {
          this.updateTbState(STATE2.IDLE, false);
          this.activateGizmos(false);
          this.dispatchEvent(_changeEvent);
        }
      } else if (this._state == STATE2.PAN || this._state == STATE2.IDLE) {
        this.updateTbState(STATE2.IDLE, false);
        if (this.enableGrid) {
          this.disposeGrid();
        }
        this.activateGizmos(false);
        this.dispatchEvent(_changeEvent);
      }
      this.dispatchEvent(_endEvent);
    });
    _defineProperty(this, "onDoubleTap", (event) => {
      if (this.enabled && this.enablePan && this.scene && this.camera && this.domElement) {
        this.dispatchEvent(_startEvent);
        this.setCenter(event.clientX, event.clientY);
        const hitP = this.unprojectOnObj(this.getCursorNDC(_center.x, _center.y, this.domElement), this.camera);
        if (hitP && this.enableAnimations) {
          const self2 = this;
          if (this._animationId != -1) {
            window.cancelAnimationFrame(this._animationId);
          }
          this._timeStart = -1;
          this._animationId = window.requestAnimationFrame(function(t2) {
            self2.updateTbState(STATE2.ANIMATION_FOCUS, true);
            self2.onFocusAnim(t2, hitP, self2._cameraMatrixState, self2._gizmoMatrixState);
          });
        } else if (hitP && !this.enableAnimations) {
          this.updateTbState(STATE2.FOCUS, true);
          this.focus(hitP, this.scaleFactor);
          this.updateTbState(STATE2.IDLE, false);
          this.dispatchEvent(_changeEvent);
        }
      }
      this.dispatchEvent(_endEvent);
    });
    _defineProperty(this, "onDoublePanStart", () => {
      if (this.enabled && this.enablePan && this.camera && this.domElement) {
        this.dispatchEvent(_startEvent);
        this.updateTbState(STATE2.PAN, true);
        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);
        const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true);
        if (rayDir !== void 0) {
          this._startCursorPosition.copy(rayDir);
        }
        this._currentCursorPosition.copy(this._startCursorPosition);
        this.activateGizmos(false);
      }
    });
    _defineProperty(this, "onDoublePanMove", () => {
      if (this.enabled && this.enablePan && this.camera && this.domElement) {
        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);
        if (this._state != STATE2.PAN) {
          this.updateTbState(STATE2.PAN, true);
          this._startCursorPosition.copy(this._currentCursorPosition);
        }
        const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true);
        if (rayDir !== void 0)
          this._currentCursorPosition.copy(rayDir);
        this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition, true));
        this.dispatchEvent(_changeEvent);
      }
    });
    _defineProperty(this, "onDoublePanEnd", () => {
      this.updateTbState(STATE2.IDLE, false);
      this.dispatchEvent(_endEvent);
    });
    _defineProperty(this, "onRotateStart", () => {
      if (this.enabled && this.enableRotate) {
        var _this$camera6;
        this.dispatchEvent(_startEvent);
        this.updateTbState(STATE2.ZROTATE, true);
        this._startFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);
        this._currentFingerRotation = this._startFingerRotation;
        (_this$camera6 = this.camera) === null || _this$camera6 === void 0 ? void 0 : _this$camera6.getWorldDirection(this._rotationAxis);
        if (!this.enablePan && !this.enableZoom) {
          this.activateGizmos(true);
        }
      }
    });
    _defineProperty(this, "onRotateMove", () => {
      if (this.enabled && this.enableRotate && this.camera && this.domElement) {
        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);
        let rotationPoint;
        if (this._state != STATE2.ZROTATE) {
          this.updateTbState(STATE2.ZROTATE, true);
          this._startFingerRotation = this._currentFingerRotation;
        }
        this._currentFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);
        if (!this.enablePan) {
          rotationPoint = new Vector3().setFromMatrixPosition(this._gizmoMatrixState);
        } else if (this.camera) {
          var _this$unprojectOnTbPl3;
          this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);
          rotationPoint = (_this$unprojectOnTbPl3 = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)) === null || _this$unprojectOnTbPl3 === void 0 ? void 0 : _this$unprojectOnTbPl3.applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._v3_2);
        }
        const amount = MathUtils.DEG2RAD * (this._startFingerRotation - this._currentFingerRotation);
        if (rotationPoint !== void 0) {
          this.applyTransformMatrix(this.zRotate(rotationPoint, amount));
        }
        this.dispatchEvent(_changeEvent);
      }
    });
    _defineProperty(this, "onRotateEnd", () => {
      this.updateTbState(STATE2.IDLE, false);
      this.activateGizmos(false);
      this.dispatchEvent(_endEvent);
    });
    _defineProperty(this, "onPinchStart", () => {
      if (this.enabled && this.enableZoom) {
        this.dispatchEvent(_startEvent);
        this.updateTbState(STATE2.SCALE, true);
        this._startFingerDistance = this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]);
        this._currentFingerDistance = this._startFingerDistance;
        this.activateGizmos(false);
      }
    });
    _defineProperty(this, "onPinchMove", () => {
      if (this.enabled && this.enableZoom && this.domElement) {
        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);
        const minDistance = 12;
        if (this._state != STATE2.SCALE) {
          this._startFingerDistance = this._currentFingerDistance;
          this.updateTbState(STATE2.SCALE, true);
        }
        this._currentFingerDistance = Math.max(this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]), minDistance * this._devPxRatio);
        const amount = this._currentFingerDistance / this._startFingerDistance;
        let scalePoint;
        if (!this.enablePan) {
          scalePoint = this._gizmos.position;
        } else {
          var _this$camera7, _this$camera8;
          if (((_this$camera7 = this.camera) === null || _this$camera7 === void 0 ? void 0 : _this$camera7.type) === "OrthographicCamera") {
            var _this$unprojectOnTbPl4;
            scalePoint = (_this$unprojectOnTbPl4 = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)) === null || _this$unprojectOnTbPl4 === void 0 ? void 0 : _this$unprojectOnTbPl4.applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);
          } else if (((_this$camera8 = this.camera) === null || _this$camera8 === void 0 ? void 0 : _this$camera8.type) === "PerspectiveCamera") {
            var _this$unprojectOnTbPl5;
            scalePoint = (_this$unprojectOnTbPl5 = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)) === null || _this$unprojectOnTbPl5 === void 0 ? void 0 : _this$unprojectOnTbPl5.applyQuaternion(this.camera.quaternion).add(this._gizmos.position);
          }
        }
        if (scalePoint !== void 0) {
          this.applyTransformMatrix(this.applyScale(amount, scalePoint));
        }
        this.dispatchEvent(_changeEvent);
      }
    });
    _defineProperty(this, "onPinchEnd", () => {
      this.updateTbState(STATE2.IDLE, false);
      this.dispatchEvent(_endEvent);
    });
    _defineProperty(this, "onTriplePanStart", () => {
      if (this.enabled && this.enableZoom && this.domElement) {
        this.dispatchEvent(_startEvent);
        this.updateTbState(STATE2.SCALE, true);
        let clientX = 0;
        let clientY = 0;
        const nFingers = this._touchCurrent.length;
        for (let i2 = 0; i2 < nFingers; i2++) {
          clientX += this._touchCurrent[i2].clientX;
          clientY += this._touchCurrent[i2].clientY;
        }
        this.setCenter(clientX / nFingers, clientY / nFingers);
        this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);
        this._currentCursorPosition.copy(this._startCursorPosition);
      }
    });
    _defineProperty(this, "onTriplePanMove", () => {
      if (this.enabled && this.enableZoom && this.camera && this.domElement) {
        let clientX = 0;
        let clientY = 0;
        const nFingers = this._touchCurrent.length;
        for (let i2 = 0; i2 < nFingers; i2++) {
          clientX += this._touchCurrent[i2].clientX;
          clientY += this._touchCurrent[i2].clientY;
        }
        this.setCenter(clientX / nFingers, clientY / nFingers);
        const screenNotches = 8;
        this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);
        const movement = this._currentCursorPosition.y - this._startCursorPosition.y;
        let size2 = 1;
        if (movement < 0) {
          size2 = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);
        } else if (movement > 0) {
          size2 = Math.pow(this.scaleFactor, movement * screenNotches);
        }
        this._v3_1.setFromMatrixPosition(this._cameraMatrixState);
        const x = this._v3_1.distanceTo(this._gizmos.position);
        let xNew = x / size2;
        xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);
        const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5);
        let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);
        newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);
        const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));
        size2 = x / newDistance;
        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);
        this.setFov(newFov);
        this.applyTransformMatrix(this.applyScale(size2, this._v3_2, false));
        const direction = this._gizmos.position.clone().sub(this.camera.position).normalize().multiplyScalar(newDistance / x);
        this._m4_1.makeTranslation(direction.x, direction.y, direction.z);
        this.dispatchEvent(_changeEvent);
      }
    });
    _defineProperty(this, "onTriplePanEnd", () => {
      this.updateTbState(STATE2.IDLE, false);
      this.dispatchEvent(_endEvent);
    });
    _defineProperty(this, "setCenter", (clientX, clientY) => {
      _center.x = clientX;
      _center.y = clientY;
    });
    _defineProperty(this, "initializeMouseActions", () => {
      this.setMouseAction("PAN", 0, "CTRL");
      this.setMouseAction("PAN", 2);
      this.setMouseAction("ROTATE", 0);
      this.setMouseAction("ZOOM", "WHEEL");
      this.setMouseAction("ZOOM", 1);
      this.setMouseAction("FOV", "WHEEL", "SHIFT");
      this.setMouseAction("FOV", 1, "SHIFT");
    });
    _defineProperty(this, "setMouseAction", (operation, mouse, key = null) => {
      const operationInput = ["PAN", "ROTATE", "ZOOM", "FOV"];
      const mouseInput = [0, 1, 2, "WHEEL"];
      const keyInput = ["CTRL", "SHIFT", null];
      let state;
      if (!operationInput.includes(operation) || !mouseInput.includes(mouse) || !keyInput.includes(key)) {
        return false;
      }
      if (mouse == "WHEEL") {
        if (operation != "ZOOM" && operation != "FOV") {
          return false;
        }
      }
      switch (operation) {
        case "PAN":
          state = STATE2.PAN;
          break;
        case "ROTATE":
          state = STATE2.ROTATE;
          break;
        case "ZOOM":
          state = STATE2.SCALE;
          break;
        case "FOV":
          state = STATE2.FOV;
          break;
      }
      const action = {
        operation,
        mouse,
        key,
        state
      };
      for (let i2 = 0; i2 < this.mouseActions.length; i2++) {
        if (this.mouseActions[i2].mouse == action.mouse && this.mouseActions[i2].key == action.key) {
          this.mouseActions.splice(i2, 1, action);
          return true;
        }
      }
      this.mouseActions.push(action);
      return true;
    });
    _defineProperty(this, "getOpFromAction", (mouse, key) => {
      let action;
      for (let i2 = 0; i2 < this.mouseActions.length; i2++) {
        action = this.mouseActions[i2];
        if (action.mouse == mouse && action.key == key) {
          return action.operation;
        }
      }
      if (key) {
        for (let i2 = 0; i2 < this.mouseActions.length; i2++) {
          action = this.mouseActions[i2];
          if (action.mouse == mouse && action.key == null) {
            return action.operation;
          }
        }
      }
      return null;
    });
    _defineProperty(this, "getOpStateFromAction", (mouse, key) => {
      let action;
      for (let i2 = 0; i2 < this.mouseActions.length; i2++) {
        action = this.mouseActions[i2];
        if (action.mouse == mouse && action.key == key) {
          return action.state;
        }
      }
      if (key) {
        for (let i2 = 0; i2 < this.mouseActions.length; i2++) {
          action = this.mouseActions[i2];
          if (action.mouse == mouse && action.key == null) {
            return action.state;
          }
        }
      }
      return null;
    });
    _defineProperty(this, "getAngle", (p1, p2) => {
      return Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180 / Math.PI;
    });
    _defineProperty(this, "updateTouchEvent", (event) => {
      for (let i2 = 0; i2 < this._touchCurrent.length; i2++) {
        if (this._touchCurrent[i2].pointerId == event.pointerId) {
          this._touchCurrent.splice(i2, 1, event);
          break;
        }
      }
    });
    _defineProperty(this, "calculateAngularSpeed", (p0, p1, t0, t1) => {
      const s = p1 - p0;
      const t2 = (t1 - t0) / 1e3;
      if (t2 == 0) {
        return 0;
      }
      return s / t2;
    });
    _defineProperty(this, "calculatePointersDistance", (p0, p1) => {
      return Math.sqrt(Math.pow(p1.clientX - p0.clientX, 2) + Math.pow(p1.clientY - p0.clientY, 2));
    });
    _defineProperty(this, "calculateRotationAxis", (vec1, vec22) => {
      this._rotationMatrix.extractRotation(this._cameraMatrixState);
      this._quat.setFromRotationMatrix(this._rotationMatrix);
      this._rotationAxis.crossVectors(vec1, vec22).applyQuaternion(this._quat);
      return this._rotationAxis.normalize().clone();
    });
    _defineProperty(this, "calculateTbRadius", (camera) => {
      const factor = 0.67;
      const distance2 = camera.position.distanceTo(this._gizmos.position);
      if (camera.type == "PerspectiveCamera") {
        const halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5;
        const halfFovH = Math.atan(camera.aspect * Math.tan(halfFovV));
        return Math.tan(Math.min(halfFovV, halfFovH)) * distance2 * factor;
      } else if (camera.type == "OrthographicCamera") {
        return Math.min(camera.top, camera.right) * factor;
      }
    });
    _defineProperty(this, "focus", (point, size2, amount = 1) => {
      if (this.camera) {
        const focusPoint = point.clone();
        focusPoint.sub(this._gizmos.position).multiplyScalar(amount);
        this._translationMatrix.makeTranslation(focusPoint.x, focusPoint.y, focusPoint.z);
        const gizmoStateTemp = this._gizmoMatrixState.clone();
        this._gizmoMatrixState.premultiply(this._translationMatrix);
        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);
        const cameraStateTemp = this._cameraMatrixState.clone();
        this._cameraMatrixState.premultiply(this._translationMatrix);
        this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);
        if (this.enableZoom) {
          this.applyTransformMatrix(this.applyScale(size2, this._gizmos.position));
        }
        this._gizmoMatrixState.copy(gizmoStateTemp);
        this._cameraMatrixState.copy(cameraStateTemp);
      }
    });
    _defineProperty(this, "drawGrid", () => {
      if (this.scene) {
        var _this$camera9, _this$camera10;
        const color2 = 8947848;
        const multiplier = 3;
        let size2, divisions, maxLength, tick;
        if (((_this$camera9 = this.camera) === null || _this$camera9 === void 0 ? void 0 : _this$camera9.type) === "OrthographicCamera") {
          const width = this.camera.right - this.camera.left;
          const height = this.camera.bottom - this.camera.top;
          maxLength = Math.max(width, height);
          tick = maxLength / 20;
          size2 = maxLength / this.camera.zoom * multiplier;
          divisions = size2 / tick * this.camera.zoom;
        } else if (((_this$camera10 = this.camera) === null || _this$camera10 === void 0 ? void 0 : _this$camera10.type) === "PerspectiveCamera") {
          const distance2 = this.camera.position.distanceTo(this._gizmos.position);
          const halfFovV = MathUtils.DEG2RAD * this.camera.fov * 0.5;
          const halfFovH = Math.atan(this.camera.aspect * Math.tan(halfFovV));
          maxLength = Math.tan(Math.max(halfFovV, halfFovH)) * distance2 * 2;
          tick = maxLength / 20;
          size2 = maxLength * multiplier;
          divisions = size2 / tick;
        }
        if (this._grid == null && this.camera) {
          this._grid = new GridHelper(size2, divisions, color2, color2);
          this._grid.position.copy(this._gizmos.position);
          this._gridPosition.copy(this._grid.position);
          this._grid.quaternion.copy(this.camera.quaternion);
          this._grid.rotateX(Math.PI * 0.5);
          this.scene.add(this._grid);
        }
      }
    });
    _defineProperty(this, "connect", (domElement) => {
      if (domElement === document) {
        console.error('THREE.ArcballControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
      }
      this.domElement = domElement;
      this.domElement.style.touchAction = "none";
      this.domElement.addEventListener("contextmenu", this.onContextMenu);
      this.domElement.addEventListener("pointerdown", this.onPointerDown);
      this.domElement.addEventListener("pointercancel", this.onPointerCancel);
      this.domElement.addEventListener("wheel", this.onWheel);
    });
    _defineProperty(this, "dispose", () => {
      var _this$domElement, _this$domElement2, _this$domElement3, _this$domElement4, _this$scene;
      if (this._animationId != -1) {
        window.cancelAnimationFrame(this._animationId);
      }
      (_this$domElement = this.domElement) === null || _this$domElement === void 0 ? void 0 : _this$domElement.removeEventListener("pointerdown", this.onPointerDown);
      (_this$domElement2 = this.domElement) === null || _this$domElement2 === void 0 ? void 0 : _this$domElement2.removeEventListener("pointercancel", this.onPointerCancel);
      (_this$domElement3 = this.domElement) === null || _this$domElement3 === void 0 ? void 0 : _this$domElement3.removeEventListener("wheel", this.onWheel);
      (_this$domElement4 = this.domElement) === null || _this$domElement4 === void 0 ? void 0 : _this$domElement4.removeEventListener("contextmenu", this.onContextMenu);
      window.removeEventListener("pointermove", this.onPointerMove);
      window.removeEventListener("pointerup", this.onPointerUp);
      window.removeEventListener("resize", this.onWindowResize);
      (_this$scene = this.scene) === null || _this$scene === void 0 ? void 0 : _this$scene.remove(this._gizmos);
      this.disposeGrid();
    });
    _defineProperty(this, "disposeGrid", () => {
      if (this._grid && this.scene) {
        this.scene.remove(this._grid);
        this._grid = null;
      }
    });
    _defineProperty(this, "easeOutCubic", (t2) => {
      return 1 - Math.pow(1 - t2, 3);
    });
    _defineProperty(this, "activateGizmos", (isActive) => {
      for (const gizmo of this._gizmos.children) {
        gizmo.material.setValues({
          opacity: isActive ? 1 : 0.6
        });
      }
    });
    _defineProperty(this, "getCursorNDC", (cursorX, cursorY, canvas) => {
      const canvasRect = canvas.getBoundingClientRect();
      this._v2_1.setX((cursorX - canvasRect.left) / canvasRect.width * 2 - 1);
      this._v2_1.setY((canvasRect.bottom - cursorY) / canvasRect.height * 2 - 1);
      return this._v2_1.clone();
    });
    _defineProperty(this, "getCursorPosition", (cursorX, cursorY, canvas) => {
      var _this$camera11;
      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));
      if (((_this$camera11 = this.camera) === null || _this$camera11 === void 0 ? void 0 : _this$camera11.type) === "OrthographicCamera") {
        this._v2_1.x *= (this.camera.right - this.camera.left) * 0.5;
        this._v2_1.y *= (this.camera.top - this.camera.bottom) * 0.5;
      }
      return this._v2_1.clone();
    });
    _defineProperty(this, "setCamera", (camera) => {
      if (camera) {
        camera.lookAt(this.target);
        camera.updateMatrix();
        if ((camera === null || camera === void 0 ? void 0 : camera.type) == "PerspectiveCamera") {
          this._fov0 = camera.fov;
          this._fovState = camera.fov;
        }
        this._cameraMatrixState0.copy(camera.matrix);
        this._cameraMatrixState.copy(this._cameraMatrixState0);
        this._cameraProjectionState.copy(camera.projectionMatrix);
        this._zoom0 = camera.zoom;
        this._zoomState = this._zoom0;
        this._initialNear = camera.near;
        this._nearPos0 = camera.position.distanceTo(this.target) - camera.near;
        this._nearPos = this._initialNear;
        this._initialFar = camera.far;
        this._farPos0 = camera.position.distanceTo(this.target) - camera.far;
        this._farPos = this._initialFar;
        this._up0.copy(camera.up);
        this._upState.copy(camera.up);
        this.camera = camera;
        this.camera.updateProjectionMatrix();
        const tbRadius = this.calculateTbRadius(camera);
        if (tbRadius !== void 0) {
          this._tbRadius = tbRadius;
        }
        this.makeGizmos(this.target, this._tbRadius);
      }
    });
    _defineProperty(this, "makeGizmos", (tbCenter, tbRadius) => {
      const curve = new EllipseCurve(0, 0, tbRadius, tbRadius);
      const points = curve.getPoints(this._curvePts);
      const curveGeometry = new BufferGeometry().setFromPoints(points);
      const curveMaterialX = new LineBasicMaterial({
        color: 16744576,
        fog: false,
        transparent: true,
        opacity: 0.6
      });
      const curveMaterialY = new LineBasicMaterial({
        color: 8454016,
        fog: false,
        transparent: true,
        opacity: 0.6
      });
      const curveMaterialZ = new LineBasicMaterial({
        color: 8421631,
        fog: false,
        transparent: true,
        opacity: 0.6
      });
      const gizmoX = new Line(curveGeometry, curveMaterialX);
      const gizmoY = new Line(curveGeometry, curveMaterialY);
      const gizmoZ = new Line(curveGeometry, curveMaterialZ);
      const rotation = Math.PI * 0.5;
      gizmoX.rotation.x = rotation;
      gizmoY.rotation.y = rotation;
      this._gizmoMatrixState0.identity().setPosition(tbCenter);
      this._gizmoMatrixState.copy(this._gizmoMatrixState0);
      if (this.camera && this.camera.zoom != 1) {
        const size2 = 1 / this.camera.zoom;
        this._scaleMatrix.makeScale(size2, size2, size2);
        this._translationMatrix.makeTranslation(-tbCenter.x, -tbCenter.y, -tbCenter.z);
        this._gizmoMatrixState.premultiply(this._translationMatrix).premultiply(this._scaleMatrix);
        this._translationMatrix.makeTranslation(tbCenter.x, tbCenter.y, tbCenter.z);
        this._gizmoMatrixState.premultiply(this._translationMatrix);
      }
      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);
      this._gizmos.clear();
      this._gizmos.add(gizmoX);
      this._gizmos.add(gizmoY);
      this._gizmos.add(gizmoZ);
    });
    _defineProperty(this, "onFocusAnim", (time, point, cameraMatrix, gizmoMatrix) => {
      if (this._timeStart == -1) {
        this._timeStart = time;
      }
      if (this._state == STATE2.ANIMATION_FOCUS) {
        const deltaTime = time - this._timeStart;
        const animTime = deltaTime / this.focusAnimationTime;
        this._gizmoMatrixState.copy(gizmoMatrix);
        if (animTime >= 1) {
          this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);
          this.focus(point, this.scaleFactor);
          this._timeStart = -1;
          this.updateTbState(STATE2.IDLE, false);
          this.activateGizmos(false);
          this.dispatchEvent(_changeEvent);
        } else {
          const amount = this.easeOutCubic(animTime);
          const size2 = 1 - amount + this.scaleFactor * amount;
          this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);
          this.focus(point, size2, amount);
          this.dispatchEvent(_changeEvent);
          const self2 = this;
          this._animationId = window.requestAnimationFrame(function(t2) {
            self2.onFocusAnim(t2, point, cameraMatrix, gizmoMatrix.clone());
          });
        }
      } else {
        this._animationId = -1;
        this._timeStart = -1;
      }
    });
    _defineProperty(this, "onRotationAnim", (time, rotationAxis, w0) => {
      if (this._timeStart == -1) {
        this._anglePrev = 0;
        this._angleCurrent = 0;
        this._timeStart = time;
      }
      if (this._state == STATE2.ANIMATION_ROTATE) {
        const deltaTime = (time - this._timeStart) / 1e3;
        const w = w0 + -this.dampingFactor * deltaTime;
        if (w > 0) {
          this._angleCurrent = 0.5 * -this.dampingFactor * Math.pow(deltaTime, 2) + w0 * deltaTime + 0;
          this.applyTransformMatrix(this.rotate(rotationAxis, this._angleCurrent));
          this.dispatchEvent(_changeEvent);
          const self2 = this;
          this._animationId = window.requestAnimationFrame(function(t2) {
            self2.onRotationAnim(t2, rotationAxis, w0);
          });
        } else {
          this._animationId = -1;
          this._timeStart = -1;
          this.updateTbState(STATE2.IDLE, false);
          this.activateGizmos(false);
          this.dispatchEvent(_changeEvent);
        }
      } else {
        this._animationId = -1;
        this._timeStart = -1;
        if (this._state != STATE2.ROTATE) {
          this.activateGizmos(false);
          this.dispatchEvent(_changeEvent);
        }
      }
    });
    _defineProperty(this, "pan", (p0, p1, adjust = false) => {
      if (this.camera) {
        const movement = p0.clone().sub(p1);
        if (this.camera.type === "OrthographicCamera") {
          movement.multiplyScalar(1 / this.camera.zoom);
        }
        if (this.camera.type === "PerspectiveCamera" && adjust) {
          this._v3_1.setFromMatrixPosition(this._cameraMatrixState0);
          this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0);
          const distanceFactor = this._v3_1.distanceTo(this._v3_2) / this.camera.position.distanceTo(this._gizmos.position);
          movement.multiplyScalar(1 / distanceFactor);
        }
        this._v3_1.set(movement.x, movement.y, 0).applyQuaternion(this.camera.quaternion);
        this._m4_1.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z);
        this.setTransformationMatrices(this._m4_1, this._m4_1);
      }
      return _transformation;
    });
    _defineProperty(this, "reset", () => {
      if (this.camera) {
        this.camera.zoom = this._zoom0;
        if (this.camera.type === "PerspectiveCamera") {
          this.camera.fov = this._fov0;
        }
        this.camera.near = this._nearPos;
        this.camera.far = this._farPos;
        this._cameraMatrixState.copy(this._cameraMatrixState0);
        this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);
        this.camera.up.copy(this._up0);
        this.camera.updateMatrix();
        this.camera.updateProjectionMatrix();
        this._gizmoMatrixState.copy(this._gizmoMatrixState0);
        this._gizmoMatrixState0.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);
        this._gizmos.updateMatrix();
        const tbRadius = this.calculateTbRadius(this.camera);
        if (tbRadius !== void 0) {
          this._tbRadius = tbRadius;
        }
        this.makeGizmos(this._gizmos.position, this._tbRadius);
        this.camera.lookAt(this._gizmos.position);
        this.updateTbState(STATE2.IDLE, false);
        this.dispatchEvent(_changeEvent);
      }
    });
    _defineProperty(this, "rotate", (axis, angle) => {
      const point = this._gizmos.position;
      this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);
      this._rotationMatrix.makeRotationAxis(axis, -angle);
      this._m4_1.makeTranslation(point.x, point.y, point.z);
      this._m4_1.multiply(this._rotationMatrix);
      this._m4_1.multiply(this._translationMatrix);
      this.setTransformationMatrices(this._m4_1);
      return _transformation;
    });
    _defineProperty(this, "copyState", () => {
      if (this.camera) {
        var _this$camera12;
        const state = JSON.stringify(((_this$camera12 = this.camera) === null || _this$camera12 === void 0 ? void 0 : _this$camera12.type) === "OrthographicCamera" ? {
          arcballState: {
            cameraFar: this.camera.far,
            cameraMatrix: this.camera.matrix,
            cameraNear: this.camera.near,
            cameraUp: this.camera.up,
            cameraZoom: this.camera.zoom,
            gizmoMatrix: this._gizmos.matrix
          }
        } : {
          arcballState: {
            cameraFar: this.camera.far,
            cameraFov: this.camera.fov,
            cameraMatrix: this.camera.matrix,
            cameraNear: this.camera.near,
            cameraUp: this.camera.up,
            cameraZoom: this.camera.zoom,
            gizmoMatrix: this._gizmos.matrix
          }
        });
        navigator.clipboard.writeText(state);
      }
    });
    _defineProperty(this, "pasteState", () => {
      const self2 = this;
      navigator.clipboard.readText().then(function resolved(value) {
        self2.setStateFromJSON(value);
      });
    });
    _defineProperty(this, "saveState", () => {
      if (!this.camera)
        return;
      this._cameraMatrixState0.copy(this.camera.matrix);
      this._gizmoMatrixState0.copy(this._gizmos.matrix);
      this._nearPos = this.camera.near;
      this._farPos = this.camera.far;
      this._zoom0 = this.camera.zoom;
      this._up0.copy(this.camera.up);
      if (this.camera.type === "PerspectiveCamera") {
        this._fov0 = this.camera.fov;
      }
    });
    _defineProperty(this, "applyScale", (size2, point, scaleGizmos = true) => {
      if (!this.camera)
        return;
      const scalePoint = point.clone();
      let sizeInverse = 1 / size2;
      if (this.camera.type === "OrthographicCamera") {
        this.camera.zoom = this._zoomState;
        this.camera.zoom *= size2;
        if (this.camera.zoom > this.maxZoom) {
          this.camera.zoom = this.maxZoom;
          sizeInverse = this._zoomState / this.maxZoom;
        } else if (this.camera.zoom < this.minZoom) {
          this.camera.zoom = this.minZoom;
          sizeInverse = this._zoomState / this.minZoom;
        }
        this.camera.updateProjectionMatrix();
        this._v3_1.setFromMatrixPosition(this._gizmoMatrixState);
        this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);
        this._translationMatrix.makeTranslation(-this._v3_1.x, -this._v3_1.y, -this._v3_1.z);
        this._m4_2.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z).multiply(this._scaleMatrix);
        this._m4_2.multiply(this._translationMatrix);
        scalePoint.sub(this._v3_1);
        const amount = scalePoint.clone().multiplyScalar(sizeInverse);
        scalePoint.sub(amount);
        this._m4_1.makeTranslation(scalePoint.x, scalePoint.y, scalePoint.z);
        this._m4_2.premultiply(this._m4_1);
        this.setTransformationMatrices(this._m4_1, this._m4_2);
        return _transformation;
      }
      if (this.camera.type === "PerspectiveCamera") {
        this._v3_1.setFromMatrixPosition(this._cameraMatrixState);
        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);
        let distance2 = this._v3_1.distanceTo(scalePoint);
        let amount = distance2 - distance2 * sizeInverse;
        const newDistance = distance2 - amount;
        if (newDistance < this.minDistance) {
          sizeInverse = this.minDistance / distance2;
          amount = distance2 - distance2 * sizeInverse;
        } else if (newDistance > this.maxDistance) {
          sizeInverse = this.maxDistance / distance2;
          amount = distance2 - distance2 * sizeInverse;
        }
        let direction = scalePoint.clone().sub(this._v3_1).normalize().multiplyScalar(amount);
        this._m4_1.makeTranslation(direction.x, direction.y, direction.z);
        if (scaleGizmos) {
          const pos = this._v3_2;
          distance2 = pos.distanceTo(scalePoint);
          amount = distance2 - distance2 * sizeInverse;
          direction = scalePoint.clone().sub(this._v3_2).normalize().multiplyScalar(amount);
          this._translationMatrix.makeTranslation(pos.x, pos.y, pos.z);
          this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);
          this._m4_2.makeTranslation(direction.x, direction.y, direction.z).multiply(this._translationMatrix);
          this._m4_2.multiply(this._scaleMatrix);
          this._translationMatrix.makeTranslation(-pos.x, -pos.y, -pos.z);
          this._m4_2.multiply(this._translationMatrix);
          this.setTransformationMatrices(this._m4_1, this._m4_2);
        } else {
          this.setTransformationMatrices(this._m4_1);
        }
        return _transformation;
      }
    });
    _defineProperty(this, "setFov", (value) => {
      var _this$camera13;
      if (((_this$camera13 = this.camera) === null || _this$camera13 === void 0 ? void 0 : _this$camera13.type) === "PerspectiveCamera") {
        this.camera.fov = MathUtils.clamp(value, this.minFov, this.maxFov);
        this.camera.updateProjectionMatrix();
      }
    });
    _defineProperty(this, "setTarget", (x, y, z) => {
      if (this.camera) {
        this.target.set(x, y, z);
        this._gizmos.position.set(x, y, z);
        const tbRadius = this.calculateTbRadius(this.camera);
        if (tbRadius !== void 0) {
          this._tbRadius = tbRadius;
        }
        this.makeGizmos(this.target, this._tbRadius);
        this.camera.lookAt(this.target);
      }
    });
    _defineProperty(this, "zRotate", (point, angle) => {
      this._rotationMatrix.makeRotationAxis(this._rotationAxis, angle);
      this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);
      this._m4_1.makeTranslation(point.x, point.y, point.z);
      this._m4_1.multiply(this._rotationMatrix);
      this._m4_1.multiply(this._translationMatrix);
      this._v3_1.setFromMatrixPosition(this._gizmoMatrixState).sub(point);
      this._v3_2.copy(this._v3_1).applyAxisAngle(this._rotationAxis, angle);
      this._v3_2.sub(this._v3_1);
      this._m4_2.makeTranslation(this._v3_2.x, this._v3_2.y, this._v3_2.z);
      this.setTransformationMatrices(this._m4_1, this._m4_2);
      return _transformation;
    });
    _defineProperty(this, "unprojectOnObj", (cursor, camera) => {
      if (!this.scene)
        return null;
      const raycaster = new Raycaster();
      raycaster.near = camera.near;
      raycaster.far = camera.far;
      raycaster.setFromCamera(cursor, camera);
      const intersect = raycaster.intersectObjects(this.scene.children, true);
      for (let i2 = 0; i2 < intersect.length; i2++) {
        if (intersect[i2].object.uuid != this._gizmos.uuid && intersect[i2].face) {
          return intersect[i2].point.clone();
        }
      }
      return null;
    });
    _defineProperty(this, "unprojectOnTbSurface", (camera, cursorX, cursorY, canvas, tbRadius) => {
      if (camera.type == "OrthographicCamera") {
        this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));
        this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);
        const x2 = Math.pow(this._v2_1.x, 2);
        const y2 = Math.pow(this._v2_1.y, 2);
        const r2 = Math.pow(this._tbRadius, 2);
        if (x2 + y2 <= r2 * 0.5) {
          this._v3_1.setZ(Math.sqrt(r2 - (x2 + y2)));
        } else {
          this._v3_1.setZ(r2 * 0.5 / Math.sqrt(x2 + y2));
        }
        return this._v3_1;
      }
      if (camera.type == "PerspectiveCamera") {
        this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));
        this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);
        this._v3_1.applyMatrix4(camera.projectionMatrixInverse);
        const rayDir = this._v3_1.clone().normalize();
        const cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);
        const radius2 = Math.pow(tbRadius, 2);
        const h = this._v3_1.z;
        const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));
        if (l == 0) {
          rayDir.set(this._v3_1.x, this._v3_1.y, tbRadius);
          return rayDir;
        }
        const m = h / l;
        const q = cameraGizmoDistance;
        let a2 = Math.pow(m, 2) + 1;
        let b3 = 2 * m * q;
        let c = Math.pow(q, 2) - radius2;
        let delta = Math.pow(b3, 2) - 4 * a2 * c;
        if (delta >= 0) {
          this._v2_1.setX((-b3 - Math.sqrt(delta)) / (2 * a2));
          this._v2_1.setY(m * this._v2_1.x + q);
          const angle = MathUtils.RAD2DEG * this._v2_1.angle();
          if (angle >= 45) {
            const rayLength2 = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));
            rayDir.multiplyScalar(rayLength2);
            rayDir.z += cameraGizmoDistance;
            return rayDir;
          }
        }
        a2 = m;
        b3 = q;
        c = -radius2 * 0.5;
        delta = Math.pow(b3, 2) - 4 * a2 * c;
        this._v2_1.setX((-b3 - Math.sqrt(delta)) / (2 * a2));
        this._v2_1.setY(m * this._v2_1.x + q);
        const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));
        rayDir.multiplyScalar(rayLength);
        rayDir.z += cameraGizmoDistance;
        return rayDir;
      }
    });
    _defineProperty(this, "unprojectOnTbPlane", (camera, cursorX, cursorY, canvas, initialDistance = false) => {
      if (camera.type == "OrthographicCamera") {
        this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));
        this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);
        return this._v3_1.clone();
      }
      if (camera.type == "PerspectiveCamera") {
        this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));
        this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);
        this._v3_1.applyMatrix4(camera.projectionMatrixInverse);
        const rayDir = this._v3_1.clone().normalize();
        const h = this._v3_1.z;
        const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));
        let cameraGizmoDistance;
        if (initialDistance) {
          cameraGizmoDistance = this._v3_1.setFromMatrixPosition(this._cameraMatrixState0).distanceTo(this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0));
        } else {
          cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);
        }
        if (l == 0) {
          rayDir.set(0, 0, 0);
          return rayDir;
        }
        const m = h / l;
        const q = cameraGizmoDistance;
        const x = -q / m;
        const rayLength = Math.sqrt(Math.pow(q, 2) + Math.pow(x, 2));
        rayDir.multiplyScalar(rayLength);
        rayDir.z = 0;
        return rayDir;
      }
    });
    _defineProperty(this, "updateMatrixState", () => {
      if (!this.camera)
        return;
      this._cameraMatrixState.copy(this.camera.matrix);
      this._gizmoMatrixState.copy(this._gizmos.matrix);
      if (this.camera.type === "OrthographicCamera") {
        this._cameraProjectionState.copy(this.camera.projectionMatrix);
        this.camera.updateProjectionMatrix();
        this._zoomState = this.camera.zoom;
      }
      if (this.camera.type === "PerspectiveCamera") {
        this._fovState = this.camera.fov;
      }
    });
    _defineProperty(this, "updateTbState", (newState, updateMatrices) => {
      this._state = newState;
      if (updateMatrices) {
        this.updateMatrixState();
      }
    });
    _defineProperty(this, "update", () => {
      const EPS = 1e-6;
      if (!this.target.equals(this._currentTarget) && this.camera) {
        this._gizmos.position.set(this.target.x, this.target.y, this.target.z);
        const tbRadius = this.calculateTbRadius(this.camera);
        if (tbRadius !== void 0) {
          this._tbRadius = tbRadius;
        }
        this.makeGizmos(this.target, this._tbRadius);
        this._currentTarget.copy(this.target);
      }
      if (!this.camera)
        return;
      if (this.camera.type === "OrthographicCamera") {
        if (this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom) {
          const newZoom = MathUtils.clamp(this.camera.zoom, this.minZoom, this.maxZoom);
          this.applyTransformMatrix(this.applyScale(newZoom / this.camera.zoom, this._gizmos.position, true));
        }
      }
      if (this.camera.type === "PerspectiveCamera") {
        const distance2 = this.camera.position.distanceTo(this._gizmos.position);
        if (distance2 > this.maxDistance + EPS || distance2 < this.minDistance - EPS) {
          const newDistance = MathUtils.clamp(distance2, this.minDistance, this.maxDistance);
          this.applyTransformMatrix(this.applyScale(newDistance / distance2, this._gizmos.position));
          this.updateMatrixState();
        }
        if (this.camera.fov < this.minFov || this.camera.fov > this.maxFov) {
          this.camera.fov = MathUtils.clamp(this.camera.fov, this.minFov, this.maxFov);
          this.camera.updateProjectionMatrix();
        }
        const oldRadius = this._tbRadius;
        const tbRadius = this.calculateTbRadius(this.camera);
        if (tbRadius !== void 0) {
          this._tbRadius = tbRadius;
        }
        if (oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS) {
          const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;
          const newRadius = this._tbRadius / scale;
          const curve = new EllipseCurve(0, 0, newRadius, newRadius);
          const points = curve.getPoints(this._curvePts);
          const curveGeometry = new BufferGeometry().setFromPoints(points);
          for (const gizmo in this._gizmos.children) {
            const child = this._gizmos.children[gizmo];
            child.geometry = curveGeometry;
          }
        }
      }
      this.camera.lookAt(this._gizmos.position);
    });
    _defineProperty(this, "setStateFromJSON", (json) => {
      const state = JSON.parse(json);
      if (state.arcballState && this.camera) {
        this._cameraMatrixState.fromArray(state.arcballState.cameraMatrix.elements);
        this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);
        this.camera.up.copy(state.arcballState.cameraUp);
        this.camera.near = state.arcballState.cameraNear;
        this.camera.far = state.arcballState.cameraFar;
        this.camera.zoom = state.arcballState.cameraZoom;
        if (this.camera.type === "PerspectiveCamera") {
          this.camera.fov = state.arcballState.cameraFov;
        }
        this._gizmoMatrixState.fromArray(state.arcballState.gizmoMatrix.elements);
        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);
        this.camera.updateMatrix();
        this.camera.updateProjectionMatrix();
        this._gizmos.updateMatrix();
        const tbRadius = this.calculateTbRadius(this.camera);
        if (tbRadius !== void 0) {
          this._tbRadius = tbRadius;
        }
        const gizmoTmp = new Matrix4().copy(this._gizmoMatrixState0);
        this.makeGizmos(this._gizmos.position, this._tbRadius);
        this._gizmoMatrixState0.copy(gizmoTmp);
        this.camera.lookAt(this._gizmos.position);
        this.updateTbState(STATE2.IDLE, false);
        this.dispatchEvent(_changeEvent);
      }
    });
    this.camera = null;
    this.domElement = _domElement;
    this.scene = scene;
    this.mouseActions = [];
    this._mouseOp = null;
    this._v2_1 = new Vector2();
    this._v3_1 = new Vector3();
    this._v3_2 = new Vector3();
    this._m4_1 = new Matrix4();
    this._m4_2 = new Matrix4();
    this._quat = new Quaternion();
    this._translationMatrix = new Matrix4();
    this._rotationMatrix = new Matrix4();
    this._scaleMatrix = new Matrix4();
    this._rotationAxis = new Vector3();
    this._cameraMatrixState = new Matrix4();
    this._cameraProjectionState = new Matrix4();
    this._fovState = 1;
    this._upState = new Vector3();
    this._zoomState = 1;
    this._nearPos = 0;
    this._farPos = 0;
    this._gizmoMatrixState = new Matrix4();
    this._up0 = new Vector3();
    this._zoom0 = 1;
    this._fov0 = 0;
    this._initialNear = 0;
    this._nearPos0 = 0;
    this._initialFar = 0;
    this._farPos0 = 0;
    this._cameraMatrixState0 = new Matrix4();
    this._gizmoMatrixState0 = new Matrix4();
    this._button = -1;
    this._touchStart = [];
    this._touchCurrent = [];
    this._input = INPUT.NONE;
    this._switchSensibility = 32;
    this._startFingerDistance = 0;
    this._currentFingerDistance = 0;
    this._startFingerRotation = 0;
    this._currentFingerRotation = 0;
    this._devPxRatio = 0;
    this._downValid = true;
    this._nclicks = 0;
    this._downEvents = [];
    this._clickStart = 0;
    this._maxDownTime = 250;
    this._maxInterval = 300;
    this._posThreshold = 24;
    this._movementThreshold = 24;
    this._currentCursorPosition = new Vector3();
    this._startCursorPosition = new Vector3();
    this._grid = null;
    this._gridPosition = new Vector3();
    this._gizmos = new Group();
    this._curvePts = 128;
    this._timeStart = -1;
    this._animationId = -1;
    this.focusAnimationTime = 500;
    this._timePrev = 0;
    this._timeCurrent = 0;
    this._anglePrev = 0;
    this._angleCurrent = 0;
    this._cursorPosPrev = new Vector3();
    this._cursorPosCurr = new Vector3();
    this._wPrev = 0;
    this._wCurr = 0;
    this.adjustNearFar = false;
    this.scaleFactor = 1.1;
    this.dampingFactor = 25;
    this.wMax = 20;
    this.enableAnimations = true;
    this.enableGrid = false;
    this.cursorZoom = false;
    this.minFov = 5;
    this.maxFov = 90;
    this.enabled = true;
    this.enablePan = true;
    this.enableRotate = true;
    this.enableZoom = true;
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.target = new Vector3(0, 0, 0);
    this._currentTarget = new Vector3(0, 0, 0);
    this._tbRadius = 1;
    this._state = STATE2.IDLE;
    this.setCamera(_camera);
    if (this.scene) {
      this.scene.add(this._gizmos);
    }
    this._devPxRatio = window.devicePixelRatio;
    this.initializeMouseActions();
    if (this.domElement)
      this.connect(this.domElement);
    window.addEventListener("resize", this.onWindowResize);
  }
  applyTransformMatrix(transformation) {
    if (transformation !== null && transformation !== void 0 && transformation.camera && this.camera) {
      this._m4_1.copy(this._cameraMatrixState).premultiply(transformation.camera);
      this._m4_1.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);
      this.camera.updateMatrix();
      if (this._state == STATE2.ROTATE || this._state == STATE2.ZROTATE || this._state == STATE2.ANIMATION_ROTATE) {
        this.camera.up.copy(this._upState).applyQuaternion(this.camera.quaternion);
      }
    }
    if (transformation !== null && transformation !== void 0 && transformation.gizmos) {
      this._m4_1.copy(this._gizmoMatrixState).premultiply(transformation.gizmos);
      this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);
      this._gizmos.updateMatrix();
    }
    if ((this._state == STATE2.SCALE || this._state == STATE2.FOCUS || this._state == STATE2.ANIMATION_FOCUS) && this.camera) {
      const tbRadius = this.calculateTbRadius(this.camera);
      if (tbRadius !== void 0) {
        this._tbRadius = tbRadius;
      }
      if (this.adjustNearFar) {
        const cameraDistance = this.camera.position.distanceTo(this._gizmos.position);
        const bb = new Box3();
        bb.setFromObject(this._gizmos);
        const sphere = new Sphere();
        bb.getBoundingSphere(sphere);
        const adjustedNearPosition = Math.max(this._nearPos0, sphere.radius + sphere.center.length());
        const regularNearPosition = cameraDistance - this._initialNear;
        const minNearPos = Math.min(adjustedNearPosition, regularNearPosition);
        this.camera.near = cameraDistance - minNearPos;
        const adjustedFarPosition = Math.min(this._farPos0, -sphere.radius + sphere.center.length());
        const regularFarPosition = cameraDistance - this._initialFar;
        const minFarPos = Math.min(adjustedFarPosition, regularFarPosition);
        this.camera.far = cameraDistance - minFarPos;
        this.camera.updateProjectionMatrix();
      } else {
        let update = false;
        if (this.camera.near != this._initialNear) {
          this.camera.near = this._initialNear;
          update = true;
        }
        if (this.camera.far != this._initialFar) {
          this.camera.far = this._initialFar;
          update = true;
        }
        if (update) {
          this.camera.updateProjectionMatrix();
        }
      }
    }
  }
  setGizmosVisible(value) {
    this._gizmos.visible = value;
    this.dispatchEvent(_changeEvent);
  }
  setTransformationMatrices(camera = null, gizmos = null) {
    if (camera) {
      if (_transformation.camera) {
        _transformation.camera.copy(camera);
      } else {
        _transformation.camera = camera.clone();
      }
    } else {
      _transformation.camera = null;
    }
    if (gizmos) {
      if (_transformation.gizmos) {
        _transformation.gizmos.copy(gizmos);
      } else {
        _transformation.gizmos = gizmos.clone();
      }
    } else {
      _transformation.gizmos = null;
    }
  }
};

// node_modules/three-stdlib/controls/FlyControls.js
function contextmenu(event) {
  event.preventDefault();
}
var FlyControls = class extends EventDispatcher {
  constructor(object, _domElement) {
    super();
    _defineProperty(this, "object", void 0);
    _defineProperty(this, "domElement", null);
    _defineProperty(this, "movementSpeed", 1);
    _defineProperty(this, "rollSpeed", 5e-3);
    _defineProperty(this, "dragToLook", false);
    _defineProperty(this, "autoForward", false);
    _defineProperty(this, "changeEvent", {
      type: "change"
    });
    _defineProperty(this, "EPS", 1e-6);
    _defineProperty(this, "tmpQuaternion", new Quaternion());
    _defineProperty(this, "mouseStatus", 0);
    _defineProperty(this, "movementSpeedMultiplier", 1);
    _defineProperty(this, "moveState", {
      up: 0,
      down: 0,
      left: 0,
      right: 0,
      forward: 0,
      back: 0,
      pitchUp: 0,
      pitchDown: 0,
      yawLeft: 0,
      yawRight: 0,
      rollLeft: 0,
      rollRight: 0
    });
    _defineProperty(this, "moveVector", new Vector3(0, 0, 0));
    _defineProperty(this, "rotationVector", new Vector3(0, 0, 0));
    _defineProperty(this, "keydown", (event) => {
      if (event.altKey) {
        return;
      }
      switch (event.code) {
        case "ShiftLeft":
        case "ShiftRight":
          this.movementSpeedMultiplier = 0.1;
          break;
        case "KeyW":
          this.moveState.forward = 1;
          break;
        case "KeyS":
          this.moveState.back = 1;
          break;
        case "KeyA":
          this.moveState.left = 1;
          break;
        case "KeyD":
          this.moveState.right = 1;
          break;
        case "KeyR":
          this.moveState.up = 1;
          break;
        case "KeyF":
          this.moveState.down = 1;
          break;
        case "ArrowUp":
          this.moveState.pitchUp = 1;
          break;
        case "ArrowDown":
          this.moveState.pitchDown = 1;
          break;
        case "ArrowLeft":
          this.moveState.yawLeft = 1;
          break;
        case "ArrowRight":
          this.moveState.yawRight = 1;
          break;
        case "KeyQ":
          this.moveState.rollLeft = 1;
          break;
        case "KeyE":
          this.moveState.rollRight = 1;
          break;
      }
      this.updateMovementVector();
      this.updateRotationVector();
    });
    _defineProperty(this, "keyup", (event) => {
      switch (event.code) {
        case "ShiftLeft":
        case "ShiftRight":
          this.movementSpeedMultiplier = 1;
          break;
        case "KeyW":
          this.moveState.forward = 0;
          break;
        case "KeyS":
          this.moveState.back = 0;
          break;
        case "KeyA":
          this.moveState.left = 0;
          break;
        case "KeyD":
          this.moveState.right = 0;
          break;
        case "KeyR":
          this.moveState.up = 0;
          break;
        case "KeyF":
          this.moveState.down = 0;
          break;
        case "ArrowUp":
          this.moveState.pitchUp = 0;
          break;
        case "ArrowDown":
          this.moveState.pitchDown = 0;
          break;
        case "ArrowLeft":
          this.moveState.yawLeft = 0;
          break;
        case "ArrowRight":
          this.moveState.yawRight = 0;
          break;
        case "KeyQ":
          this.moveState.rollLeft = 0;
          break;
        case "KeyE":
          this.moveState.rollRight = 0;
          break;
      }
      this.updateMovementVector();
      this.updateRotationVector();
    });
    _defineProperty(this, "pointerdown", (event) => {
      if (this.dragToLook) {
        this.mouseStatus++;
      } else {
        switch (event.button) {
          case 0:
            this.moveState.forward = 1;
            break;
          case 2:
            this.moveState.back = 1;
            break;
        }
        this.updateMovementVector();
      }
    });
    _defineProperty(this, "pointermove", (event) => {
      if (!this.dragToLook || this.mouseStatus > 0) {
        const container = this.getContainerDimensions();
        const halfWidth = container.size[0] / 2;
        const halfHeight = container.size[1] / 2;
        this.moveState.yawLeft = -(event.pageX - container.offset[0] - halfWidth) / halfWidth;
        this.moveState.pitchDown = (event.pageY - container.offset[1] - halfHeight) / halfHeight;
        this.updateRotationVector();
      }
    });
    _defineProperty(this, "pointerup", (event) => {
      if (this.dragToLook) {
        this.mouseStatus--;
        this.moveState.yawLeft = this.moveState.pitchDown = 0;
      } else {
        switch (event.button) {
          case 0:
            this.moveState.forward = 0;
            break;
          case 2:
            this.moveState.back = 0;
            break;
        }
        this.updateMovementVector();
      }
      this.updateRotationVector();
    });
    _defineProperty(this, "lastQuaternion", new Quaternion());
    _defineProperty(this, "lastPosition", new Vector3());
    _defineProperty(this, "update", (delta) => {
      const moveMult = delta * this.movementSpeed;
      const rotMult = delta * this.rollSpeed;
      this.object.translateX(this.moveVector.x * moveMult);
      this.object.translateY(this.moveVector.y * moveMult);
      this.object.translateZ(this.moveVector.z * moveMult);
      this.tmpQuaternion.set(this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1).normalize();
      this.object.quaternion.multiply(this.tmpQuaternion);
      if (this.lastPosition.distanceToSquared(this.object.position) > this.EPS || 8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > this.EPS) {
        this.dispatchEvent(this.changeEvent);
        this.lastQuaternion.copy(this.object.quaternion);
        this.lastPosition.copy(this.object.position);
      }
    });
    _defineProperty(this, "updateMovementVector", () => {
      const forward = this.moveState.forward || this.autoForward && !this.moveState.back ? 1 : 0;
      this.moveVector.x = -this.moveState.left + this.moveState.right;
      this.moveVector.y = -this.moveState.down + this.moveState.up;
      this.moveVector.z = -forward + this.moveState.back;
    });
    _defineProperty(this, "updateRotationVector", () => {
      this.rotationVector.x = -this.moveState.pitchDown + this.moveState.pitchUp;
      this.rotationVector.y = -this.moveState.yawRight + this.moveState.yawLeft;
      this.rotationVector.z = -this.moveState.rollRight + this.moveState.rollLeft;
    });
    _defineProperty(this, "getContainerDimensions", () => {
      if (this.domElement != document && !(this.domElement instanceof Document)) {
        return {
          size: [this.domElement.offsetWidth, this.domElement.offsetHeight],
          offset: [this.domElement.offsetLeft, this.domElement.offsetTop]
        };
      } else {
        return {
          size: [window.innerWidth, window.innerHeight],
          offset: [0, 0]
        };
      }
    });
    _defineProperty(this, "connect", (domElement) => {
      this.domElement = domElement;
      if (domElement && !(domElement instanceof Document)) {
        domElement.setAttribute("tabindex", -1);
      }
      this.domElement.addEventListener("contextmenu", contextmenu);
      this.domElement.addEventListener("pointermove", this.pointermove);
      this.domElement.addEventListener("pointerdown", this.pointerdown);
      this.domElement.addEventListener("pointerup", this.pointerup);
      window.addEventListener("keydown", this.keydown);
      window.addEventListener("keyup", this.keyup);
    });
    _defineProperty(this, "dispose", () => {
      this.domElement.removeEventListener("contextmenu", contextmenu);
      this.domElement.removeEventListener("pointermove", this.pointermove);
      this.domElement.removeEventListener("pointerdown", this.pointerdown);
      this.domElement.removeEventListener("pointerup", this.pointerup);
      window.removeEventListener("keydown", this.keydown);
      window.removeEventListener("keyup", this.keyup);
    });
    this.object = object;
    if (_domElement !== void 0)
      this.connect(_domElement);
    this.updateMovementVector();
    this.updateRotationVector();
  }
};

// node_modules/three-stdlib/postprocessing/Pass.js
var Pass = class {
  constructor() {
    _defineProperty(this, "enabled", true);
    _defineProperty(this, "needsSwap", true);
    _defineProperty(this, "clear", false);
    _defineProperty(this, "renderToScreen", false);
  }
  setSize(width, height) {
  }
  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
};
var FullScreenQuad = class {
  constructor(material) {
    _defineProperty(this, "camera", new OrthographicCamera(-1, 1, 1, -1, 0, 1));
    _defineProperty(this, "geometry", new PlaneGeometry(2, 2));
    _defineProperty(this, "mesh", void 0);
    this.mesh = new Mesh(this.geometry, material);
  }
  get material() {
    return this.mesh.material;
  }
  set material(value) {
    this.mesh.material = value;
  }
  dispose() {
    this.mesh.geometry.dispose();
  }
  render(renderer) {
    renderer.render(this.mesh, this.camera);
  }
};

// node_modules/three-stdlib/postprocessing/ShaderPass.js
var ShaderPass = class extends Pass {
  constructor(shader, textureID = "tDiffuse") {
    super();
    _defineProperty(this, "textureID", void 0);
    _defineProperty(this, "uniforms", void 0);
    _defineProperty(this, "material", void 0);
    _defineProperty(this, "fsQuad", void 0);
    this.textureID = textureID;
    if (shader instanceof ShaderMaterial) {
      this.uniforms = shader.uniforms;
      this.material = shader;
    } else {
      this.uniforms = UniformsUtils.clone(shader.uniforms);
      this.material = new ShaderMaterial({
        defines: Object.assign({}, shader.defines),
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
    }
    this.fsQuad = new FullScreenQuad(this.material);
  }
  render(renderer, writeBuffer, readBuffer) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }
    this.fsQuad.material = this.material;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      this.fsQuad.render(renderer);
    }
  }
};

// node_modules/three-stdlib/postprocessing/LUTPass.js
var LUTShader = {
  defines: {
    USE_3DTEXTURE: 1
  },
  uniforms: {
    lut3d: {
      value: null
    },
    lut: {
      value: null
    },
    lutSize: {
      value: 0
    },
    tDiffuse: {
      value: null
    },
    intensity: {
      value: 1
    }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`,
  fragmentShader: `
		precision highp sampler3D;

		uniform float lutSize;
		#if USE_3DTEXTURE
		uniform sampler3D lut3d;
		#else
		uniform sampler2D lut;

		vec3 lutLookup( sampler2D tex, float size, vec3 rgb ) {

			float sliceHeight = 1.0 / size;
			float yPixelHeight = 1.0 / ( size * size );

			// Get the slices on either side of the sample
			float slice = rgb.b * size;
			float interp = fract( slice );
			float slice0 = slice - interp;
			float centeredInterp = interp - 0.5;

			float slice1 = slice0 + sign( centeredInterp );

			// Pull y sample in by half a pixel in each direction to avoid color
			// bleeding from adjacent slices.
			float greenOffset = clamp( rgb.g * sliceHeight, yPixelHeight * 0.5, sliceHeight - yPixelHeight * 0.5 );

			vec2 uv0 = vec2(
				rgb.r,
				slice0 * sliceHeight + greenOffset
			);
			vec2 uv1 = vec2(
				rgb.r,
				slice1 * sliceHeight + greenOffset
			);

			vec3 sample0 = texture2D( tex, uv0 ).rgb;
			vec3 sample1 = texture2D( tex, uv1 ).rgb;

			return mix( sample0, sample1, abs( centeredInterp ) );

		}
		#endif

		varying vec2 vUv;
		uniform float intensity;
		uniform sampler2D tDiffuse;
		void main() {

			vec4 val = texture2D( tDiffuse, vUv );
			vec4 lutVal;

			// pull the sample in by half a pixel so the sample begins
			// at the center of the edge pixels.
			float pixelWidth = 1.0 / lutSize;
			float halfPixelWidth = 0.5 / lutSize;
			vec3 uvw = vec3( halfPixelWidth ) + val.rgb * ( 1.0 - pixelWidth );

			#if USE_3DTEXTURE

			lutVal = vec4( texture( lut3d, uvw ).rgb, val.a );

			#else

			lutVal = vec4( lutLookup( lut, lutSize, uvw ), val.a );

			#endif

			gl_FragColor = vec4( mix( val, lutVal, intensity ) );

		}

	`
};
var LUTPass = class extends ShaderPass {
  set lut(v) {
    const material = this.material;
    if (v !== this.lut) {
      material.uniforms.lut3d.value = null;
      material.uniforms.lut.value = null;
      if (v) {
        const is3dTextureDefine = v.isDataTexture3D ? 1 : 0;
        if (is3dTextureDefine !== material.defines.USE_3DTEXTURE) {
          material.defines.USE_3DTEXTURE = is3dTextureDefine;
          material.needsUpdate = true;
        }
        material.uniforms.lutSize.value = v.image.width;
        if (v.isDataTexture3D) {
          material.uniforms.lut3d.value = v;
        } else {
          material.uniforms.lut.value = v;
        }
      }
    }
  }
  get lut() {
    return this.material.uniforms.lut.value || this.material.uniforms.lut3d.value;
  }
  set intensity(v) {
    this.material.uniforms.intensity.value = v;
  }
  get intensity() {
    return this.material.uniforms.intensity.value;
  }
  constructor(options = {}) {
    super(LUTShader);
    this.lut = options.lut || null;
    this.intensity = "intensity" in options ? options.intensity : 1;
  }
};

// node_modules/three-stdlib/postprocessing/ClearPass.js
var ClearPass = class extends Pass {
  constructor(clearColor, clearAlpha) {
    super();
    _defineProperty(this, "clearColor", void 0);
    _defineProperty(this, "clearAlpha", void 0);
    _defineProperty(this, "_oldClearColor", void 0);
    this.needsSwap = false;
    this.clearColor = clearColor !== void 0 ? clearColor : 0;
    this.clearAlpha = clearAlpha !== void 0 ? clearAlpha : 0;
    this._oldClearColor = new Color();
  }
  render(renderer, writeBuffer, readBuffer) {
    let oldClearAlpha;
    if (this.clearColor) {
      renderer.getClearColor(this._oldClearColor);
      oldClearAlpha = renderer.getClearAlpha();
      renderer.setClearColor(this.clearColor, this.clearAlpha);
    }
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    renderer.clear();
    if (this.clearColor) {
      renderer.setClearColor(this._oldClearColor, oldClearAlpha);
    }
  }
};

// node_modules/three-stdlib/shaders/DigitalGlitch.js
var DigitalGlitch = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    tDisp: {
      value: null
    },
    byp: {
      value: 0
    },
    amount: {
      value: 0.08
    },
    angle: {
      value: 0.02
    },
    seed: {
      value: 0.02
    },
    seed_x: {
      value: 0.02
    },
    seed_y: {
      value: 0.02
    },
    distortion_x: {
      value: 0.5
    },
    distortion_y: {
      value: 0.6
    },
    col_s: {
      value: 0.05
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform int byp;",
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tDisp;",
    "uniform float amount;",
    "uniform float angle;",
    "uniform float seed;",
    "uniform float seed_x;",
    "uniform float seed_y;",
    "uniform float distortion_x;",
    "uniform float distortion_y;",
    "uniform float col_s;",
    "varying vec2 vUv;",
    "float rand(vec2 co){",
    "	return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);",
    "}",
    "void main() {",
    "	if(byp<1) {",
    "		vec2 p = vUv;",
    "		float xs = floor(gl_FragCoord.x / 0.5);",
    "		float ys = floor(gl_FragCoord.y / 0.5);",
    "		vec4 normal = texture2D (tDisp, p*seed*seed);",
    "		if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {",
    "			if(seed_x>0.){",
    "				p.y = 1. - (p.y + distortion_y);",
    "			}",
    "			else {",
    "				p.y = distortion_y;",
    "			}",
    "		}",
    "		if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {",
    "			if(seed_y>0.){",
    "				p.x=distortion_x;",
    "			}",
    "			else {",
    "				p.x = 1. - (p.x + distortion_x);",
    "			}",
    "		}",
    "		p.x+=normal.x*seed_x*(seed/5.);",
    "		p.y+=normal.y*seed_y*(seed/5.);",
    "		vec2 offset = amount * vec2( cos(angle), sin(angle));",
    "		vec4 cr = texture2D(tDiffuse, p + offset);",
    "		vec4 cga = texture2D(tDiffuse, p);",
    "		vec4 cb = texture2D(tDiffuse, p - offset);",
    "		gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",
    "		vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);",
    "		gl_FragColor = gl_FragColor+ snow;",
    "	}",
    "	else {",
    "		gl_FragColor=texture2D (tDiffuse, vUv);",
    "	}",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/postprocessing/GlitchPass.js
var GlitchPass = class extends Pass {
  constructor(dt_size = 64) {
    super();
    _defineProperty(this, "material", void 0);
    _defineProperty(this, "fsQuad", void 0);
    _defineProperty(this, "goWild", void 0);
    _defineProperty(this, "curF", void 0);
    _defineProperty(this, "randX", void 0);
    _defineProperty(this, "uniforms", void 0);
    if (DigitalGlitch === void 0)
      console.error("THREE.GlitchPass relies on DigitalGlitch");
    const shader = DigitalGlitch;
    this.uniforms = UniformsUtils.clone(shader.uniforms);
    this.uniforms["tDisp"].value = this.generateHeightmap(dt_size);
    this.material = new ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader
    });
    this.fsQuad = new FullScreenQuad(this.material);
    this.goWild = false;
    this.curF = 0;
    this.generateTrigger();
  }
  render(renderer, writeBuffer, readBuffer) {
    if (renderer.capabilities.isWebGL2 === false)
      this.uniforms["tDisp"].value.format = LuminanceFormat;
    this.uniforms["tDiffuse"].value = readBuffer.texture;
    this.uniforms["seed"].value = Math.random();
    this.uniforms["byp"].value = 0;
    if (this.curF % this.randX == 0 || this.goWild == true) {
      this.uniforms["amount"].value = Math.random() / 30;
      this.uniforms["angle"].value = MathUtils.randFloat(-Math.PI, Math.PI);
      this.uniforms["seed_x"].value = MathUtils.randFloat(-1, 1);
      this.uniforms["seed_y"].value = MathUtils.randFloat(-1, 1);
      this.uniforms["distortion_x"].value = MathUtils.randFloat(0, 1);
      this.uniforms["distortion_y"].value = MathUtils.randFloat(0, 1);
      this.curF = 0;
      this.generateTrigger();
    } else if (this.curF % this.randX < this.randX / 5) {
      this.uniforms["amount"].value = Math.random() / 90;
      this.uniforms["angle"].value = MathUtils.randFloat(-Math.PI, Math.PI);
      this.uniforms["distortion_x"].value = MathUtils.randFloat(0, 1);
      this.uniforms["distortion_y"].value = MathUtils.randFloat(0, 1);
      this.uniforms["seed_x"].value = MathUtils.randFloat(-0.3, 0.3);
      this.uniforms["seed_y"].value = MathUtils.randFloat(-0.3, 0.3);
    } else if (this.goWild == false) {
      this.uniforms["byp"].value = 1;
    }
    this.curF++;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear();
      this.fsQuad.render(renderer);
    }
  }
  generateTrigger() {
    this.randX = MathUtils.randInt(120, 240);
  }
  generateHeightmap(dt_size) {
    const data_arr = new Float32Array(dt_size * dt_size);
    const length2 = dt_size * dt_size;
    for (let i2 = 0; i2 < length2; i2++) {
      const val = MathUtils.randFloat(0, 1);
      data_arr[i2] = val;
    }
    const texture2 = new DataTexture(data_arr, dt_size, dt_size, RedFormat, FloatType);
    texture2.needsUpdate = true;
    return texture2;
  }
};

// node_modules/three-stdlib/shaders/HalftoneShader.js
var HalftoneShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    shape: {
      value: 1
    },
    radius: {
      value: 4
    },
    rotateR: {
      value: Math.PI / 12 * 1
    },
    rotateG: {
      value: Math.PI / 12 * 2
    },
    rotateB: {
      value: Math.PI / 12 * 3
    },
    scatter: {
      value: 0
    },
    width: {
      value: 1
    },
    height: {
      value: 1
    },
    blending: {
      value: 1
    },
    blendingMode: {
      value: 1
    },
    greyscale: {
      value: false
    },
    disable: {
      value: false
    }
  },
  vertexShader: ["varying vec2 vUV;", "void main() {", "	vUV = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}"].join("\n"),
  fragmentShader: [
    "#define SQRT2_MINUS_ONE 0.41421356",
    "#define SQRT2_HALF_MINUS_ONE 0.20710678",
    "#define PI2 6.28318531",
    "#define SHAPE_DOT 1",
    "#define SHAPE_ELLIPSE 2",
    "#define SHAPE_LINE 3",
    "#define SHAPE_SQUARE 4",
    "#define BLENDING_LINEAR 1",
    "#define BLENDING_MULTIPLY 2",
    "#define BLENDING_ADD 3",
    "#define BLENDING_LIGHTER 4",
    "#define BLENDING_DARKER 5",
    "uniform sampler2D tDiffuse;",
    "uniform float radius;",
    "uniform float rotateR;",
    "uniform float rotateG;",
    "uniform float rotateB;",
    "uniform float scatter;",
    "uniform float width;",
    "uniform float height;",
    "uniform int shape;",
    "uniform bool disable;",
    "uniform float blending;",
    "uniform int blendingMode;",
    "varying vec2 vUV;",
    "uniform bool greyscale;",
    "const int samples = 8;",
    "float blend( float a, float b, float t ) {",
    "	return a * ( 1.0 - t ) + b * t;",
    "}",
    "float hypot( float x, float y ) {",
    "	return sqrt( x * x + y * y );",
    "}",
    "float rand( vec2 seed ){",
    "return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );",
    "}",
    "float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {",
    "	float dist = hypot( coord.x - p.x, coord.y - p.y );",
    "	float rad = channel;",
    "	if ( shape == SHAPE_DOT ) {",
    "		rad = pow( abs( rad ), 1.125 ) * rad_max;",
    "	} else if ( shape == SHAPE_ELLIPSE ) {",
    "		rad = pow( abs( rad ), 1.125 ) * rad_max;",
    "		if ( dist != 0.0 ) {",
    "			float dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );",
    "			dist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;",
    "		}",
    "	} else if ( shape == SHAPE_LINE ) {",
    "		rad = pow( abs( rad ), 1.5) * rad_max;",
    "		float dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;",
    "		dist = hypot( normal.x * dot_p, normal.y * dot_p );",
    "	} else if ( shape == SHAPE_SQUARE ) {",
    "		float theta = atan( p.y - coord.y, p.x - coord.x ) - angle;",
    "		float sin_t = abs( sin( theta ) );",
    "		float cos_t = abs( cos( theta ) );",
    "		rad = pow( abs( rad ), 1.4 );",
    "		rad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );",
    "	}",
    "	return rad - dist;",
    "}",
    "struct Cell {",
    "	vec2 normal;",
    "	vec2 p1;",
    "	vec2 p2;",
    "	vec2 p3;",
    "	vec2 p4;",
    "	float samp2;",
    "	float samp1;",
    "	float samp3;",
    "	float samp4;",
    "};",
    "vec4 getSample( vec2 point ) {",
    "	vec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );",
    "	float base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;",
    "	float step = PI2 / float( samples );",
    "	float dist = radius * 0.66;",
    "	for ( int i = 0; i < samples; ++i ) {",
    "		float r = base + step * float( i );",
    "		vec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );",
    "		tex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );",
    "	}",
    "	tex /= float( samples ) + 1.0;",
    "	return tex;",
    "}",
    "float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {",
    "	float dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;",
    "	if ( channel == 0 ) {",
    "		c.samp1 = getSample( c.p1 ).r;",
    "		c.samp2 = getSample( c.p2 ).r;",
    "		c.samp3 = getSample( c.p3 ).r;",
    "		c.samp4 = getSample( c.p4 ).r;",
    "	} else if (channel == 1) {",
    "		c.samp1 = getSample( c.p1 ).g;",
    "		c.samp2 = getSample( c.p2 ).g;",
    "		c.samp3 = getSample( c.p3 ).g;",
    "		c.samp4 = getSample( c.p4 ).g;",
    "	} else {",
    "		c.samp1 = getSample( c.p1 ).b;",
    "		c.samp3 = getSample( c.p3 ).b;",
    "		c.samp2 = getSample( c.p2 ).b;",
    "		c.samp4 = getSample( c.p4 ).b;",
    "	}",
    "	dist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );",
    "	dist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );",
    "	dist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );",
    "	dist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );",
    "	res = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;",
    "	res += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;",
    "	res += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;",
    "	res += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;",
    "	res = clamp( res, 0.0, 1.0 );",
    "	return res;",
    "}",
    "Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {",
    "	Cell c;",
    "	vec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );",
    "	float threshold = step * 0.5;",
    "	float dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );",
    "	float dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );",
    "	vec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );",
    "	float offset_normal = mod( hypot( offset.x, offset.y ), step );",
    "	float normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;",
    "	float normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;",
    "	float offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );",
    "	float line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;",
    "	float line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;",
    "	c.normal = n;",
    "	c.p1.x = p.x - n.x * normal_scale + n.y * line_scale;",
    "	c.p1.y = p.y - n.y * normal_scale - n.x * line_scale;",
    "	if ( scatter != 0.0 ) {",
    "		float off_mag = scatter * threshold * 0.5;",
    "		float off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;",
    "		c.p1.x += cos( off_angle ) * off_mag;",
    "		c.p1.y += sin( off_angle ) * off_mag;",
    "	}",
    "	float normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );",
    "	float line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );",
    "	c.p2.x = c.p1.x - n.x * normal_step;",
    "	c.p2.y = c.p1.y - n.y * normal_step;",
    "	c.p3.x = c.p1.x + n.y * line_step;",
    "	c.p3.y = c.p1.y - n.x * line_step;",
    "	c.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;",
    "	c.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;",
    "	return c;",
    "}",
    "float blendColour( float a, float b, float t ) {",
    "	if ( blendingMode == BLENDING_LINEAR ) {",
    "		return blend( a, b, 1.0 - t );",
    "	} else if ( blendingMode == BLENDING_ADD ) {",
    "		return blend( a, min( 1.0, a + b ), t );",
    "	} else if ( blendingMode == BLENDING_MULTIPLY ) {",
    "		return blend( a, max( 0.0, a * b ), t );",
    "	} else if ( blendingMode == BLENDING_LIGHTER ) {",
    "		return blend( a, max( a, b ), t );",
    "	} else if ( blendingMode == BLENDING_DARKER ) {",
    "		return blend( a, min( a, b ), t );",
    "	} else {",
    "		return blend( a, b, 1.0 - t );",
    "	}",
    "}",
    "void main() {",
    "	if ( ! disable ) {",
    "		vec2 p = vec2( vUV.x * width, vUV.y * height );",
    "		vec2 origin = vec2( 0, 0 );",
    "		float aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;",
    "		Cell cell_r = getReferenceCell( p, origin, rotateR, radius );",
    "		Cell cell_g = getReferenceCell( p, origin, rotateG, radius );",
    "		Cell cell_b = getReferenceCell( p, origin, rotateB, radius );",
    "		float r = getDotColour( cell_r, p, 0, rotateR, aa );",
    "		float g = getDotColour( cell_g, p, 1, rotateG, aa );",
    "		float b = getDotColour( cell_b, p, 2, rotateB, aa );",
    "		vec4 colour = texture2D( tDiffuse, vUV );",
    "		r = blendColour( r, colour.r, blending );",
    "		g = blendColour( g, colour.g, blending );",
    "		b = blendColour( b, colour.b, blending );",
    "		if ( greyscale ) {",
    "			r = g = b = (r + b + g) / 3.0;",
    "		}",
    "		gl_FragColor = vec4( r, g, b, 1.0 );",
    "	} else {",
    "		gl_FragColor = texture2D( tDiffuse, vUV );",
    "	}",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/postprocessing/HalftonePass.js
var HalftonePass = class extends Pass {
  constructor(width, height, params) {
    super();
    _defineProperty(this, "material", void 0);
    _defineProperty(this, "fsQuad", void 0);
    _defineProperty(this, "uniforms", void 0);
    if (HalftoneShader === void 0) {
      console.error("THREE.HalftonePass requires HalftoneShader");
    }
    this.uniforms = UniformsUtils.clone(HalftoneShader.uniforms);
    this.material = new ShaderMaterial({
      uniforms: this.uniforms,
      fragmentShader: HalftoneShader.fragmentShader,
      vertexShader: HalftoneShader.vertexShader
    });
    this.uniforms.width.value = width;
    this.uniforms.height.value = height;
    for (const key in params) {
      if (params.hasOwnProperty(key) && this.uniforms.hasOwnProperty(key)) {
        this.uniforms[key].value = params[key];
      }
    }
    this.fsQuad = new FullScreenQuad(this.material);
  }
  render(renderer, writeBuffer, readBuffer) {
    this.material.uniforms["tDiffuse"].value = readBuffer.texture;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear();
      this.fsQuad.render(renderer);
    }
  }
  setSize(width, height) {
    this.uniforms.width.value = width;
    this.uniforms.height.value = height;
  }
};

// node_modules/three-stdlib/shaders/SMAAShader.js
var SMAAEdgesShader = {
  defines: {
    SMAA_THRESHOLD: "0.1"
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2(1 / 1024, 1 / 512)
    }
  },
  vertexShader: [
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 3 ];",
    "void SMAAEdgeDetectionVS( vec2 texcoord ) {",
    "	vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );",
    "	vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );",
    "	vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );",
    "}",
    "void main() {",
    "	vUv = uv;",
    "	SMAAEdgeDetectionVS( vUv );",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 3 ];",
    "vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {",
    "	vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );",
    "	vec4 delta;",
    "	vec3 C = texture2D( colorTex, texcoord ).rgb;",
    "	vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;",
    "	vec3 t = abs( C - Cleft );",
    "	delta.x = max( max( t.r, t.g ), t.b );",
    "	vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;",
    "	t = abs( C - Ctop );",
    "	delta.y = max( max( t.r, t.g ), t.b );",
    "	vec2 edges = step( threshold, delta.xy );",
    "	if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )",
    "		discard;",
    "	vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;",
    "	t = abs( C - Cright );",
    "	delta.z = max( max( t.r, t.g ), t.b );",
    "	vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;",
    "	t = abs( C - Cbottom );",
    "	delta.w = max( max( t.r, t.g ), t.b );",
    "	float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );",
    "	vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;",
    "	t = abs( C - Cleftleft );",
    "	delta.z = max( max( t.r, t.g ), t.b );",
    "	vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;",
    "	t = abs( C - Ctoptop );",
    "	delta.w = max( max( t.r, t.g ), t.b );",
    "	maxDelta = max( max( maxDelta, delta.z ), delta.w );",
    "	edges.xy *= step( 0.5 * maxDelta, delta.xy );",
    "	return vec4( edges, 0.0, 0.0 );",
    "}",
    "void main() {",
    "	gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );",
    "}"
  ].join("\n")
};
var SMAAWeightsShader = {
  defines: {
    SMAA_MAX_SEARCH_STEPS: "8",
    SMAA_AREATEX_MAX_DISTANCE: "16",
    SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )",
    SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )"
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    tArea: {
      value: null
    },
    tSearch: {
      value: null
    },
    resolution: {
      value: new Vector2(1 / 1024, 1 / 512)
    }
  },
  vertexShader: [
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 3 ];",
    "varying vec2 vPixcoord;",
    "void SMAABlendingWeightCalculationVS( vec2 texcoord ) {",
    "	vPixcoord = texcoord / resolution;",
    "	vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );",
    "	vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );",
    "	vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );",
    "}",
    "void main() {",
    "	vUv = uv;",
    "	SMAABlendingWeightCalculationVS( vUv );",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )",
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tArea;",
    "uniform sampler2D tSearch;",
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[3];",
    "varying vec2 vPixcoord;",
    "#if __VERSION__ == 100",
    "vec2 round( vec2 x ) {",
    "	return sign( x ) * floor( abs( x ) + 0.5 );",
    "}",
    "#endif",
    "float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {",
    "	e.r = bias + e.r * scale;",
    "	return 255.0 * texture2D( searchTex, e, 0.0 ).r;",
    "}",
    "float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "	vec2 e = vec2( 0.0, 1.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord -= vec2( 2.0, 0.0 ) * resolution;",
    "		if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;",
    "	}",
    "	texcoord.x += 0.25 * resolution.x;",
    "	texcoord.x += resolution.x;",
    "	texcoord.x += 2.0 * resolution.x;",
    "	texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);",
    "	return texcoord.x;",
    "}",
    "float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "	vec2 e = vec2( 0.0, 1.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord += vec2( 2.0, 0.0 ) * resolution;",
    "		if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;",
    "	}",
    "	texcoord.x -= 0.25 * resolution.x;",
    "	texcoord.x -= resolution.x;",
    "	texcoord.x -= 2.0 * resolution.x;",
    "	texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );",
    "	return texcoord.x;",
    "}",
    "float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "	vec2 e = vec2( 1.0, 0.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord += vec2( 0.0, 2.0 ) * resolution;",
    "		if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
    "	}",
    "	texcoord.y -= 0.25 * resolution.y;",
    "	texcoord.y -= resolution.y;",
    "	texcoord.y -= 2.0 * resolution.y;",
    "	texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );",
    "	return texcoord.y;",
    "}",
    "float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "	vec2 e = vec2( 1.0, 0.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord -= vec2( 0.0, 2.0 ) * resolution;",
    "		if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
    "	}",
    "	texcoord.y += 0.25 * resolution.y;",
    "	texcoord.y += resolution.y;",
    "	texcoord.y += 2.0 * resolution.y;",
    "	texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );",
    "	return texcoord.y;",
    "}",
    "vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {",
    "	vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;",
    "	texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );",
    "	texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;",
    "	return texture2D( areaTex, texcoord, 0.0 ).rg;",
    "}",
    "vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {",
    "	vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );",
    "	vec2 e = texture2D( edgesTex, texcoord ).rg;",
    "	if ( e.g > 0.0 ) {",
    "		vec2 d;",
    "		vec2 coords;",
    "		coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );",
    "		coords.y = offset[ 1 ].y;",
    "		d.x = coords.x;",
    "		float e1 = texture2D( edgesTex, coords, 0.0 ).r;",
    "		coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );",
    "		d.y = coords.x;",
    "		d = d / resolution.x - pixcoord.x;",
    "		vec2 sqrt_d = sqrt( abs( d ) );",
    "		coords.y -= 1.0 * resolution.y;",
    "		float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;",
    "		weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );",
    "	}",
    "	if ( e.r > 0.0 ) {",
    "		vec2 d;",
    "		vec2 coords;",
    "		coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );",
    "		coords.x = offset[ 0 ].x;",
    "		d.x = coords.y;",
    "		float e1 = texture2D( edgesTex, coords, 0.0 ).g;",
    "		coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );",
    "		d.y = coords.y;",
    "		d = d / resolution.y - pixcoord.y;",
    "		vec2 sqrt_d = sqrt( abs( d ) );",
    "		coords.y -= 1.0 * resolution.y;",
    "		float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;",
    "		weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );",
    "	}",
    "	return weights;",
    "}",
    "void main() {",
    "	gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );",
    "}"
  ].join("\n")
};
var SMAABlendShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    tColor: {
      value: null
    },
    resolution: {
      value: new Vector2(1 / 1024, 1 / 512)
    }
  },
  vertexShader: [
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 2 ];",
    "void SMAANeighborhoodBlendingVS( vec2 texcoord ) {",
    "	vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );",
    "	vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );",
    "}",
    "void main() {",
    "	vUv = uv;",
    "	SMAANeighborhoodBlendingVS( vUv );",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tColor;",
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 2 ];",
    "vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {",
    "	vec4 a;",
    "	a.xz = texture2D( blendTex, texcoord ).xz;",
    "	a.y = texture2D( blendTex, offset[ 1 ].zw ).g;",
    "	a.w = texture2D( blendTex, offset[ 1 ].xy ).a;",
    "	if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {",
    "		return texture2D( colorTex, texcoord, 0.0 );",
    "	} else {",
    "		vec2 offset;",
    "		offset.x = a.a > a.b ? a.a : -a.b;",
    "		offset.y = a.g > a.r ? -a.g : a.r;",
    "		if ( abs( offset.x ) > abs( offset.y )) {",
    "			offset.y = 0.0;",
    "		} else {",
    "			offset.x = 0.0;",
    "		}",
    "		vec4 C = texture2D( colorTex, texcoord, 0.0 );",
    "		texcoord += sign( offset ) * resolution;",
    "		vec4 Cop = texture2D( colorTex, texcoord, 0.0 );",
    "		float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );",
    "		C.xyz = pow(C.xyz, vec3(2.2));",
    "		Cop.xyz = pow(Cop.xyz, vec3(2.2));",
    "		vec4 mixed = mix(C, Cop, s);",
    "		mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));",
    "		return mixed;",
    "	}",
    "}",
    "void main() {",
    "	gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/postprocessing/SMAAPass.js
var SMAAPass = class extends Pass {
  constructor(width, height) {
    super();
    this.edgesRT = new WebGLRenderTarget(width, height, {
      depthBuffer: false
    });
    this.edgesRT.texture.name = "SMAAPass.edges";
    this.weightsRT = new WebGLRenderTarget(width, height, {
      depthBuffer: false
    });
    this.weightsRT.texture.name = "SMAAPass.weights";
    const scope2 = this;
    const areaTextureImage = new Image();
    areaTextureImage.src = this.getAreaTexture();
    areaTextureImage.onload = function() {
      scope2.areaTexture.needsUpdate = true;
    };
    this.areaTexture = new Texture();
    this.areaTexture.name = "SMAAPass.area";
    this.areaTexture.image = areaTextureImage;
    this.areaTexture.minFilter = LinearFilter;
    this.areaTexture.generateMipmaps = false;
    this.areaTexture.flipY = false;
    const searchTextureImage = new Image();
    searchTextureImage.src = this.getSearchTexture();
    searchTextureImage.onload = function() {
      scope2.searchTexture.needsUpdate = true;
    };
    this.searchTexture = new Texture();
    this.searchTexture.name = "SMAAPass.search";
    this.searchTexture.image = searchTextureImage;
    this.searchTexture.magFilter = NearestFilter;
    this.searchTexture.minFilter = NearestFilter;
    this.searchTexture.generateMipmaps = false;
    this.searchTexture.flipY = false;
    if (SMAAEdgesShader === void 0) {
      console.error("THREE.SMAAPass relies on SMAAShader");
    }
    this.uniformsEdges = UniformsUtils.clone(SMAAEdgesShader.uniforms);
    this.uniformsEdges["resolution"].value.set(1 / width, 1 / height);
    this.materialEdges = new ShaderMaterial({
      defines: Object.assign({}, SMAAEdgesShader.defines),
      uniforms: this.uniformsEdges,
      vertexShader: SMAAEdgesShader.vertexShader,
      fragmentShader: SMAAEdgesShader.fragmentShader
    });
    this.uniformsWeights = UniformsUtils.clone(SMAAWeightsShader.uniforms);
    this.uniformsWeights["resolution"].value.set(1 / width, 1 / height);
    this.uniformsWeights["tDiffuse"].value = this.edgesRT.texture;
    this.uniformsWeights["tArea"].value = this.areaTexture;
    this.uniformsWeights["tSearch"].value = this.searchTexture;
    this.materialWeights = new ShaderMaterial({
      defines: Object.assign({}, SMAAWeightsShader.defines),
      uniforms: this.uniformsWeights,
      vertexShader: SMAAWeightsShader.vertexShader,
      fragmentShader: SMAAWeightsShader.fragmentShader
    });
    this.uniformsBlend = UniformsUtils.clone(SMAABlendShader.uniforms);
    this.uniformsBlend["resolution"].value.set(1 / width, 1 / height);
    this.uniformsBlend["tDiffuse"].value = this.weightsRT.texture;
    this.materialBlend = new ShaderMaterial({
      uniforms: this.uniformsBlend,
      vertexShader: SMAABlendShader.vertexShader,
      fragmentShader: SMAABlendShader.fragmentShader
    });
    this.needsSwap = false;
    this.fsQuad = new FullScreenQuad(null);
  }
  render(renderer, writeBuffer, readBuffer) {
    this.uniformsEdges["tDiffuse"].value = readBuffer.texture;
    this.fsQuad.material = this.materialEdges;
    renderer.setRenderTarget(this.edgesRT);
    if (this.clear)
      renderer.clear();
    this.fsQuad.render(renderer);
    this.fsQuad.material = this.materialWeights;
    renderer.setRenderTarget(this.weightsRT);
    if (this.clear)
      renderer.clear();
    this.fsQuad.render(renderer);
    this.uniformsBlend["tColor"].value = readBuffer.texture;
    this.fsQuad.material = this.materialBlend;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear();
      this.fsQuad.render(renderer);
    }
  }
  setSize(width, height) {
    this.edgesRT.setSize(width, height);
    this.weightsRT.setSize(width, height);
    this.materialEdges.uniforms["resolution"].value.set(1 / width, 1 / height);
    this.materialWeights.uniforms["resolution"].value.set(1 / width, 1 / height);
    this.materialBlend.uniforms["resolution"].value.set(1 / width, 1 / height);
  }
  getAreaTexture() {
    return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=";
  }
  getSearchTexture() {
    return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=";
  }
};

// node_modules/three-stdlib/shaders/FilmShader.js
var FilmShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    time: {
      value: 0
    },
    nIntensity: {
      value: 0.5
    },
    sIntensity: {
      value: 0.05
    },
    sCount: {
      value: 4096
    },
    grayscale: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#include <common>",
    "uniform float time;",
    "uniform bool grayscale;",
    "uniform float nIntensity;",
    "uniform float sIntensity;",
    "uniform float sCount;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 cTextureScreen = texture2D( tDiffuse, vUv );",
    "	float dx = rand( vUv + time );",
    "	vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );",
    "	vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );",
    "	cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;",
    "	cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );",
    "	if( grayscale ) {",
    "		cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );",
    "	}",
    "	gl_FragColor =  vec4( cResult, cTextureScreen.a );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/postprocessing/FilmPass.js
var FilmPass = class extends Pass {
  constructor(noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale) {
    super();
    _defineProperty(this, "material", void 0);
    _defineProperty(this, "fsQuad", void 0);
    _defineProperty(this, "uniforms", void 0);
    if (FilmShader === void 0)
      console.error("THREE.FilmPass relies on FilmShader");
    const shader = FilmShader;
    this.uniforms = UniformsUtils.clone(shader.uniforms);
    this.material = new ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader
    });
    if (grayscale !== void 0)
      this.uniforms.grayscale.value = grayscale;
    if (noiseIntensity !== void 0)
      this.uniforms.nIntensity.value = noiseIntensity;
    if (scanlinesIntensity !== void 0)
      this.uniforms.sIntensity.value = scanlinesIntensity;
    if (scanlinesCount !== void 0)
      this.uniforms.sCount.value = scanlinesCount;
    this.fsQuad = new FullScreenQuad(this.material);
  }
  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    this.uniforms["tDiffuse"].value = readBuffer.texture;
    this.uniforms["time"].value += deltaTime;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear();
      this.fsQuad.render(renderer);
    }
  }
};

// node_modules/three-stdlib/shaders/CopyShader.js
var CopyShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    opacity: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	gl_FragColor = opacity * texel;", "}"].join("\n")
};

// node_modules/three-stdlib/postprocessing/OutlinePass.js
var OutlinePass = class extends Pass {
  constructor(resolution, scene, camera, selectedObjects) {
    super();
    _defineProperty(this, "renderScene", void 0);
    _defineProperty(this, "renderCamera", void 0);
    _defineProperty(this, "selectedObjects", void 0);
    _defineProperty(this, "visibleEdgeColor", void 0);
    _defineProperty(this, "hiddenEdgeColor", void 0);
    _defineProperty(this, "edgeGlow", void 0);
    _defineProperty(this, "usePatternTexture", void 0);
    _defineProperty(this, "edgeThickness", void 0);
    _defineProperty(this, "edgeStrength", void 0);
    _defineProperty(this, "downSampleRatio", void 0);
    _defineProperty(this, "pulsePeriod", void 0);
    _defineProperty(this, "resolution", void 0);
    _defineProperty(this, "renderTargetMaskBuffer", void 0);
    _defineProperty(this, "depthMaterial", void 0);
    _defineProperty(this, "prepareMaskMaterial", void 0);
    _defineProperty(this, "renderTargetDepthBuffer", void 0);
    _defineProperty(this, "renderTargetMaskDownSampleBuffer", void 0);
    _defineProperty(this, "renderTargetBlurBuffer1", void 0);
    _defineProperty(this, "renderTargetBlurBuffer2", void 0);
    _defineProperty(this, "edgeDetectionMaterial", void 0);
    _defineProperty(this, "renderTargetEdgeBuffer1", void 0);
    _defineProperty(this, "renderTargetEdgeBuffer2", void 0);
    _defineProperty(this, "separableBlurMaterial1", void 0);
    _defineProperty(this, "separableBlurMaterial2", void 0);
    _defineProperty(this, "overlayMaterial", void 0);
    _defineProperty(this, "materialCopy", void 0);
    _defineProperty(this, "oldClearAlpha", void 0);
    _defineProperty(this, "fsQuad", void 0);
    _defineProperty(this, "tempPulseColor1", void 0);
    _defineProperty(this, "tempPulseColor2", void 0);
    _defineProperty(this, "textureMatrix", void 0);
    _defineProperty(this, "patternTexture", void 0);
    _defineProperty(this, "_visibilityCache", void 0);
    _defineProperty(this, "_oldClearColor", void 0);
    _defineProperty(this, "copyUniforms", void 0);
    _defineProperty(this, "BlurDirectionX", new Vector2(1, 0));
    _defineProperty(this, "BlurDirectionY", new Vector2(0, 1));
    this.renderScene = scene;
    this.renderCamera = camera;
    this.selectedObjects = selectedObjects !== void 0 ? selectedObjects : [];
    this.visibleEdgeColor = new Color(1, 1, 1);
    this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);
    this.edgeGlow = 0;
    this.usePatternTexture = false;
    this.edgeThickness = 1;
    this.edgeStrength = 3;
    this.downSampleRatio = 2;
    this.pulsePeriod = 0;
    this._visibilityCache = /* @__PURE__ */ new Map();
    this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);
    const resx = Math.round(this.resolution.x / this.downSampleRatio);
    const resy = Math.round(this.resolution.y / this.downSampleRatio);
    this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);
    this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask";
    this.renderTargetMaskBuffer.texture.generateMipmaps = false;
    this.depthMaterial = new MeshDepthMaterial();
    this.depthMaterial.side = DoubleSide;
    this.depthMaterial.depthPacking = RGBADepthPacking;
    this.depthMaterial.blending = NoBlending;
    this.prepareMaskMaterial = this.getPrepareMaskMaterial();
    this.prepareMaskMaterial.side = DoubleSide;
    this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);
    this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);
    this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth";
    this.renderTargetDepthBuffer.texture.generateMipmaps = false;
    this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);
    this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample";
    this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;
    this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);
    this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1";
    this.renderTargetBlurBuffer1.texture.generateMipmaps = false;
    this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));
    this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2";
    this.renderTargetBlurBuffer2.texture.generateMipmaps = false;
    this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();
    this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);
    this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1";
    this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;
    this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));
    this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2";
    this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;
    const MAX_EDGE_THICKNESS = 4;
    const MAX_EDGE_GLOW = 4;
    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);
    this.separableBlurMaterial1.uniforms["texSize"].value.set(resx, resy);
    this.separableBlurMaterial1.uniforms["kernelRadius"].value = 1;
    this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);
    this.separableBlurMaterial2.uniforms["texSize"].value.set(Math.round(resx / 2), Math.round(resy / 2));
    this.separableBlurMaterial2.uniforms["kernelRadius"].value = MAX_EDGE_GLOW;
    this.overlayMaterial = this.getOverlayMaterial();
    if (CopyShader === void 0)
      console.error("THREE.OutlinePass relies on CopyShader");
    const copyShader = CopyShader;
    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
    this.copyUniforms["opacity"].value = 1;
    this.materialCopy = new ShaderMaterial({
      uniforms: this.copyUniforms,
      vertexShader: copyShader.vertexShader,
      fragmentShader: copyShader.fragmentShader,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this.enabled = true;
    this.needsSwap = false;
    this._oldClearColor = new Color();
    this.oldClearAlpha = 1;
    this.fsQuad = new FullScreenQuad(this.materialCopy);
    this.tempPulseColor1 = new Color();
    this.tempPulseColor2 = new Color();
    this.textureMatrix = new Matrix4();
    function replaceDepthToViewZ(string, camera2) {
      const type2 = camera2.isPerspectiveCamera ? "perspective" : "orthographic";
      return string.replace(/DEPTH_TO_VIEW_Z/g, type2 + "DepthToViewZ");
    }
  }
  dispose() {
    this.renderTargetMaskBuffer.dispose();
    this.renderTargetDepthBuffer.dispose();
    this.renderTargetMaskDownSampleBuffer.dispose();
    this.renderTargetBlurBuffer1.dispose();
    this.renderTargetBlurBuffer2.dispose();
    this.renderTargetEdgeBuffer1.dispose();
    this.renderTargetEdgeBuffer2.dispose();
  }
  setSize(width, height) {
    this.renderTargetMaskBuffer.setSize(width, height);
    this.renderTargetDepthBuffer.setSize(width, height);
    let resx = Math.round(width / this.downSampleRatio);
    let resy = Math.round(height / this.downSampleRatio);
    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);
    this.renderTargetBlurBuffer1.setSize(resx, resy);
    this.renderTargetEdgeBuffer1.setSize(resx, resy);
    this.separableBlurMaterial1.uniforms["texSize"].value.set(resx, resy);
    resx = Math.round(resx / 2);
    resy = Math.round(resy / 2);
    this.renderTargetBlurBuffer2.setSize(resx, resy);
    this.renderTargetEdgeBuffer2.setSize(resx, resy);
    this.separableBlurMaterial2.uniforms["texSize"].value.set(resx, resy);
  }
  changeVisibilityOfSelectedObjects(bVisible) {
    const cache = this._visibilityCache;
    function gatherSelectedMeshesCallBack(object) {
      if (object.isMesh) {
        if (bVisible === true) {
          object.visible = cache.get(object);
        } else {
          cache.set(object, object.visible);
          object.visible = bVisible;
        }
      }
    }
    for (let i2 = 0; i2 < this.selectedObjects.length; i2++) {
      const selectedObject = this.selectedObjects[i2];
      selectedObject.traverse(gatherSelectedMeshesCallBack);
    }
  }
  changeVisibilityOfNonSelectedObjects(bVisible) {
    const cache = this._visibilityCache;
    const selectedMeshes = [];
    function gatherSelectedMeshesCallBack(object) {
      if (object.isMesh)
        selectedMeshes.push(object);
    }
    for (let i2 = 0; i2 < this.selectedObjects.length; i2++) {
      const selectedObject = this.selectedObjects[i2];
      selectedObject.traverse(gatherSelectedMeshesCallBack);
    }
    function VisibilityChangeCallBack(object) {
      if (object.isMesh || object.isSprite) {
        let bFound = false;
        for (let i2 = 0; i2 < selectedMeshes.length; i2++) {
          const selectedObjectId = selectedMeshes[i2].id;
          if (selectedObjectId === object.id) {
            bFound = true;
            break;
          }
        }
        if (bFound === false) {
          const visibility = object.visible;
          if (bVisible === false || cache.get(object) === true) {
            object.visible = bVisible;
          }
          cache.set(object, visibility);
        }
      } else if (object.isPoints || object.isLine) {
        if (bVisible === true) {
          object.visible = cache.get(object);
        } else {
          cache.set(object, object.visible);
          object.visible = bVisible;
        }
      }
    }
    this.renderScene.traverse(VisibilityChangeCallBack);
  }
  updateTextureMatrix() {
    this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);
    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
  }
  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    if (this.selectedObjects.length > 0) {
      renderer.getClearColor(this._oldClearColor);
      this.oldClearAlpha = renderer.getClearAlpha();
      const oldAutoClear = renderer.autoClear;
      renderer.autoClear = false;
      if (maskActive)
        renderer.state.buffers.stencil.setTest(false);
      renderer.setClearColor(16777215, 1);
      this.changeVisibilityOfSelectedObjects(false);
      const currentBackground = this.renderScene.background;
      this.renderScene.background = null;
      this.renderScene.overrideMaterial = this.depthMaterial;
      renderer.setRenderTarget(this.renderTargetDepthBuffer);
      renderer.clear();
      renderer.render(this.renderScene, this.renderCamera);
      this.changeVisibilityOfSelectedObjects(true);
      this._visibilityCache.clear();
      this.updateTextureMatrix();
      this.changeVisibilityOfNonSelectedObjects(false);
      this.renderScene.overrideMaterial = this.prepareMaskMaterial;
      this.prepareMaskMaterial.uniforms["cameraNearFar"].value.set(this.renderCamera.near, this.renderCamera.far);
      this.prepareMaskMaterial.uniforms["depthTexture"].value = this.renderTargetDepthBuffer.texture;
      this.prepareMaskMaterial.uniforms["textureMatrix"].value = this.textureMatrix;
      renderer.setRenderTarget(this.renderTargetMaskBuffer);
      renderer.clear();
      renderer.render(this.renderScene, this.renderCamera);
      this.renderScene.overrideMaterial = null;
      this.changeVisibilityOfNonSelectedObjects(true);
      this._visibilityCache.clear();
      this.renderScene.background = currentBackground;
      this.fsQuad.material = this.materialCopy;
      this.copyUniforms["tDiffuse"].value = this.renderTargetMaskBuffer.texture;
      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.tempPulseColor1.copy(this.visibleEdgeColor);
      this.tempPulseColor2.copy(this.hiddenEdgeColor);
      if (this.pulsePeriod > 0) {
        const scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1 - 0.25) / 2;
        this.tempPulseColor1.multiplyScalar(scalar);
        this.tempPulseColor2.multiplyScalar(scalar);
      }
      this.fsQuad.material = this.edgeDetectionMaterial;
      this.edgeDetectionMaterial.uniforms["maskTexture"].value = this.renderTargetMaskDownSampleBuffer.texture;
      this.edgeDetectionMaterial.uniforms["texSize"].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);
      this.edgeDetectionMaterial.uniforms["visibleEdgeColor"].value = this.tempPulseColor1;
      this.edgeDetectionMaterial.uniforms["hiddenEdgeColor"].value = this.tempPulseColor2;
      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.fsQuad.material = this.separableBlurMaterial1;
      this.separableBlurMaterial1.uniforms["colorTexture"].value = this.renderTargetEdgeBuffer1.texture;
      this.separableBlurMaterial1.uniforms["direction"].value = this.BlurDirectionX;
      this.separableBlurMaterial1.uniforms["kernelRadius"].value = this.edgeThickness;
      renderer.setRenderTarget(this.renderTargetBlurBuffer1);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.separableBlurMaterial1.uniforms["colorTexture"].value = this.renderTargetBlurBuffer1.texture;
      this.separableBlurMaterial1.uniforms["direction"].value = this.BlurDirectionY;
      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.fsQuad.material = this.separableBlurMaterial2;
      this.separableBlurMaterial2.uniforms["colorTexture"].value = this.renderTargetEdgeBuffer1.texture;
      this.separableBlurMaterial2.uniforms["direction"].value = this.BlurDirectionX;
      renderer.setRenderTarget(this.renderTargetBlurBuffer2);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.separableBlurMaterial2.uniforms["colorTexture"].value = this.renderTargetBlurBuffer2.texture;
      this.separableBlurMaterial2.uniforms["direction"].value = this.BlurDirectionY;
      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.fsQuad.material = this.overlayMaterial;
      this.overlayMaterial.uniforms["maskTexture"].value = this.renderTargetMaskBuffer.texture;
      this.overlayMaterial.uniforms["edgeTexture1"].value = this.renderTargetEdgeBuffer1.texture;
      this.overlayMaterial.uniforms["edgeTexture2"].value = this.renderTargetEdgeBuffer2.texture;
      this.overlayMaterial.uniforms["patternTexture"].value = this.patternTexture;
      this.overlayMaterial.uniforms["edgeStrength"].value = this.edgeStrength;
      this.overlayMaterial.uniforms["edgeGlow"].value = this.edgeGlow;
      this.overlayMaterial.uniforms["usePatternTexture"].value = this.usePatternTexture;
      if (maskActive)
        renderer.state.buffers.stencil.setTest(true);
      renderer.setRenderTarget(readBuffer);
      this.fsQuad.render(renderer);
      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
      renderer.autoClear = oldAutoClear;
    }
    if (this.renderToScreen) {
      this.fsQuad.material = this.materialCopy;
      this.copyUniforms["tDiffuse"].value = readBuffer.texture;
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    }
  }
  getPrepareMaskMaterial() {
    return new ShaderMaterial({
      uniforms: {
        depthTexture: {
          value: null
        },
        cameraNearFar: {
          value: new Vector2(0.5, 0.5)
        },
        textureMatrix: {
          value: null
        }
      },
      vertexShader: `#include <morphtarget_pars_vertex>
				#include <skinning_pars_vertex>
				varying vec4 projTexCoord;
				varying vec4 vPosition;
				uniform mat4 textureMatrix;
				void main() {
					#include <skinbase_vertex>
					#include <begin_vertex>
					#include <morphtarget_vertex>
					#include <skinning_vertex>
					#include <project_vertex>
					vPosition = mvPosition;
					vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
					projTexCoord = textureMatrix * worldPosition;
				}`,
      fragmentShader: `#include <packing>
				varying vec4 vPosition;
				varying vec4 projTexCoord;
				uniform sampler2D depthTexture;
				uniform vec2 cameraNearFar;
				void main() {
					float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));
					float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );
					float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;
					gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);
				}`
    });
  }
  getEdgeDetectionMaterial() {
    return new ShaderMaterial({
      uniforms: {
        maskTexture: {
          value: null
        },
        texSize: {
          value: new Vector2(0.5, 0.5)
        },
        visibleEdgeColor: {
          value: new Vector3(1, 1, 1)
        },
        hiddenEdgeColor: {
          value: new Vector3(1, 1, 1)
        }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;
				uniform sampler2D maskTexture;
				uniform vec2 texSize;
				uniform vec3 visibleEdgeColor;
				uniform vec3 hiddenEdgeColor;
				void main() {
					vec2 invSize = 1.0 / texSize;
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);
					float diff1 = (c1.r - c2.r)*0.5;
					float diff2 = (c3.r - c4.r)*0.5;
					float d = length( vec2(diff1, diff2) );
					float a1 = min(c1.g, c2.g);
					float a2 = min(c3.g, c4.g);
					float visibilityFactor = min(a1, a2);
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);
				}`
    });
  }
  getSeperableBlurMaterial(maxRadius) {
    return new ShaderMaterial({
      defines: {
        MAX_RADIUS: maxRadius
      },
      uniforms: {
        colorTexture: {
          value: null
        },
        texSize: {
          value: new Vector2(0.5, 0.5)
        },
        direction: {
          value: new Vector2(0.5, 0.5)
        },
        kernelRadius: {
          value: 1
        }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;
				uniform float kernelRadius;
				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float weightSum = gaussianPdf(0.0, kernelRadius);
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);
					vec2 uvOffset = delta;
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {
						float w = gaussianPdf(uvOffset.x, kernelRadius);
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
						diffuseSum += ((sample1 + sample2) * w);
						weightSum += (2.0 * w);
						uvOffset += delta;
					}
					gl_FragColor = diffuseSum/weightSum;
				}`
    });
  }
  getOverlayMaterial() {
    return new ShaderMaterial({
      uniforms: {
        maskTexture: {
          value: null
        },
        edgeTexture1: {
          value: null
        },
        edgeTexture2: {
          value: null
        },
        patternTexture: {
          value: null
        },
        edgeStrength: {
          value: 1
        },
        edgeGlow: {
          value: 1
        },
        usePatternTexture: {
          value: 0
        }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;
				uniform sampler2D maskTexture;
				uniform sampler2D edgeTexture1;
				uniform sampler2D edgeTexture2;
				uniform sampler2D patternTexture;
				uniform float edgeStrength;
				uniform float edgeGlow;
				uniform bool usePatternTexture;
				void main() {
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);
					vec4 maskColor = texture2D(maskTexture, vUv);
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;
					if(usePatternTexture)
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);
					gl_FragColor = finalColor;
				}`,
      blending: AdditiveBlending,
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
  }
};

// node_modules/three-stdlib/shaders/SSAOShader.js
var SSAOShader = {
  defines: {
    PERSPECTIVE_CAMERA: 1,
    KERNEL_SIZE: 32
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    tNormal: {
      value: null
    },
    tDepth: {
      value: null
    },
    tNoise: {
      value: null
    },
    kernel: {
      value: null
    },
    cameraNear: {
      value: null
    },
    cameraFar: {
      value: null
    },
    resolution: {
      value: new Vector2()
    },
    cameraProjectionMatrix: {
      value: new Matrix4()
    },
    cameraInverseProjectionMatrix: {
      value: new Matrix4()
    },
    kernelRadius: {
      value: 8
    },
    minDistance: {
      value: 5e-3
    },
    maxDistance: {
      value: 0.05
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tNormal;",
    "uniform sampler2D tDepth;",
    "uniform sampler2D tNoise;",
    "uniform vec3 kernel[ KERNEL_SIZE ];",
    "uniform vec2 resolution;",
    "uniform float cameraNear;",
    "uniform float cameraFar;",
    "uniform mat4 cameraProjectionMatrix;",
    "uniform mat4 cameraInverseProjectionMatrix;",
    "uniform float kernelRadius;",
    "uniform float minDistance;",
    "uniform float maxDistance;",
    "varying vec2 vUv;",
    "#include <packing>",
    "float getDepth( const in vec2 screenPosition ) {",
    "	return texture2D( tDepth, screenPosition ).x;",
    "}",
    "float getLinearDepth( const in vec2 screenPosition ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "		float fragCoordZ = texture2D( tDepth, screenPosition ).x;",
    "		float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );",
    "		return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );",
    "	#else",
    "		return texture2D( tDepth, screenPosition ).x;",
    "	#endif",
    "}",
    "float getViewZ( const in float depth ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "		return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );",
    "	#else",
    "		return orthographicDepthToViewZ( depth, cameraNear, cameraFar );",
    "	#endif",
    "}",
    "vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {",
    "	float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];",
    "	vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );",
    "	clipPosition *= clipW; // unprojection.",
    "	return ( cameraInverseProjectionMatrix * clipPosition ).xyz;",
    "}",
    "vec3 getViewNormal( const in vec2 screenPosition ) {",
    "	return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );",
    "}",
    "void main() {",
    "	float depth = getDepth( vUv );",
    "	float viewZ = getViewZ( depth );",
    "	vec3 viewPosition = getViewPosition( vUv, depth, viewZ );",
    "	vec3 viewNormal = getViewNormal( vUv );",
    " vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );",
    "	vec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;",
    "	vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );",
    "	vec3 bitangent = cross( viewNormal, tangent );",
    "	mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );",
    " float occlusion = 0.0;",
    " for ( int i = 0; i < KERNEL_SIZE; i ++ ) {",
    "		vec3 sampleVector = kernelMatrix * kernel[ i ];",
    "		vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );",
    "		vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );",
    "		samplePointNDC /= samplePointNDC.w;",
    "		vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;",
    "		float realDepth = getLinearDepth( samplePointUv );",
    "		float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );",
    "		float delta = sampleDepth - realDepth;",
    "		if ( delta > minDistance && delta < maxDistance ) {",
    "			occlusion += 1.0;",
    "		}",
    "	}",
    "	occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );",
    "	gl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );",
    "}"
  ].join("\n")
};
var SSAODepthShader = {
  defines: {
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: {
      value: null
    },
    cameraNear: {
      value: null
    },
    cameraFar: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDepth;", "uniform float cameraNear;", "uniform float cameraFar;", "varying vec2 vUv;", "#include <packing>", "float getLinearDepth( const in vec2 screenPosition ) {", "	#if PERSPECTIVE_CAMERA == 1", "		float fragCoordZ = texture2D( tDepth, screenPosition ).x;", "		float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );", "		return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );", "	#else", "		return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "void main() {", "	float depth = getLinearDepth( vUv );", "	gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );", "}"].join("\n")
};
var SSAOBlurShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2()
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "varying vec2 vUv;", "void main() {", "	vec2 texelSize = ( 1.0 / resolution );", "	float result = 0.0;", "	for ( int i = - 2; i <= 2; i ++ ) {", "		for ( int j = - 2; j <= 2; j ++ ) {", "			vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;", "			result += texture2D( tDiffuse, vUv + offset ).r;", "		}", "	}", "	gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );", "}"].join("\n")
};

// node_modules/three-stdlib/postprocessing/SSAOPass.js
var SSAOPass = class extends Pass {
  constructor(scene, camera, width, height) {
    super();
    this.width = width !== void 0 ? width : 512;
    this.height = height !== void 0 ? height : 512;
    this.clear = true;
    this.camera = camera;
    this.scene = scene;
    this.kernelRadius = 8;
    this.kernelSize = 32;
    this.kernel = [];
    this.noiseTexture = null;
    this.output = 0;
    this.minDistance = 5e-3;
    this.maxDistance = 0.1;
    this._visibilityCache = /* @__PURE__ */ new Map();
    this.generateSampleKernel();
    this.generateRandomKernelRotations();
    const depthTexture = new DepthTexture();
    depthTexture.format = DepthStencilFormat;
    depthTexture.type = UnsignedInt248Type;
    this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height);
    this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthTexture
    });
    this.ssaoRenderTarget = new WebGLRenderTarget(this.width, this.height);
    this.blurRenderTarget = this.ssaoRenderTarget.clone();
    if (SSAOShader === void 0) {
      console.error("THREE.SSAOPass: The pass relies on SSAOShader.");
    }
    this.ssaoMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAOShader.defines),
      uniforms: UniformsUtils.clone(SSAOShader.uniforms),
      vertexShader: SSAOShader.vertexShader,
      fragmentShader: SSAOShader.fragmentShader,
      blending: NoBlending
    });
    this.ssaoMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
    this.ssaoMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
    this.ssaoMaterial.uniforms["tDepth"].value = this.normalRenderTarget.depthTexture;
    this.ssaoMaterial.uniforms["tNoise"].value = this.noiseTexture;
    this.ssaoMaterial.uniforms["kernel"].value = this.kernel;
    this.ssaoMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.ssaoMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.ssaoMaterial.uniforms["resolution"].value.set(this.width, this.height);
    this.ssaoMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssaoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.normalMaterial = new MeshNormalMaterial();
    this.normalMaterial.blending = NoBlending;
    this.blurMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAOBlurShader.defines),
      uniforms: UniformsUtils.clone(SSAOBlurShader.uniforms),
      vertexShader: SSAOBlurShader.vertexShader,
      fragmentShader: SSAOBlurShader.fragmentShader
    });
    this.blurMaterial.uniforms["tDiffuse"].value = this.ssaoRenderTarget.texture;
    this.blurMaterial.uniforms["resolution"].value.set(this.width, this.height);
    this.depthRenderMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAODepthShader.defines),
      uniforms: UniformsUtils.clone(SSAODepthShader.uniforms),
      vertexShader: SSAODepthShader.vertexShader,
      fragmentShader: SSAODepthShader.fragmentShader,
      blending: NoBlending
    });
    this.depthRenderMaterial.uniforms["tDepth"].value = this.normalRenderTarget.depthTexture;
    this.depthRenderMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.depthRenderMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.copyMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(CopyShader.uniforms),
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      transparent: true,
      depthTest: false,
      depthWrite: false,
      blendSrc: DstColorFactor,
      blendDst: ZeroFactor,
      blendEquation: AddEquation,
      blendSrcAlpha: DstAlphaFactor,
      blendDstAlpha: ZeroFactor,
      blendEquationAlpha: AddEquation
    });
    this.fsQuad = new FullScreenQuad(null);
    this.originalClearColor = new Color();
  }
  dispose() {
    this.beautyRenderTarget.dispose();
    this.normalRenderTarget.dispose();
    this.ssaoRenderTarget.dispose();
    this.blurRenderTarget.dispose();
    this.normalMaterial.dispose();
    this.blurMaterial.dispose();
    this.copyMaterial.dispose();
    this.depthRenderMaterial.dispose();
    this.fsQuad.dispose();
  }
  render(renderer, writeBuffer) {
    if (renderer.capabilities.isWebGL2 === false)
      this.noiseTexture.format = LuminanceFormat;
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    renderer.render(this.scene, this.camera);
    this.overrideVisibility();
    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 7829503, 1);
    this.restoreVisibility();
    this.ssaoMaterial.uniforms["kernelRadius"].value = this.kernelRadius;
    this.ssaoMaterial.uniforms["minDistance"].value = this.minDistance;
    this.ssaoMaterial.uniforms["maxDistance"].value = this.maxDistance;
    this.renderPass(renderer, this.ssaoMaterial, this.ssaoRenderTarget);
    this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);
    switch (this.output) {
      case SSAOPass.OUTPUT.SSAO:
        this.copyMaterial.uniforms["tDiffuse"].value = this.ssaoRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Blur:
        this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Beauty:
        this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Depth:
        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Normal:
        this.copyMaterial.uniforms["tDiffuse"].value = this.normalRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Default:
        this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
        this.copyMaterial.blending = CustomBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      default:
        console.warn("THREE.SSAOPass: Unknown output type.");
    }
  }
  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    this.beautyRenderTarget.setSize(width, height);
    this.ssaoRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.blurRenderTarget.setSize(width, height);
    this.ssaoMaterial.uniforms["resolution"].value.set(width, height);
    this.ssaoMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssaoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.blurMaterial.uniforms["resolution"].value.set(width, height);
  }
  generateSampleKernel() {
    const kernelSize = this.kernelSize;
    const kernel = this.kernel;
    for (let i2 = 0; i2 < kernelSize; i2++) {
      const sample = new Vector3();
      sample.x = Math.random() * 2 - 1;
      sample.y = Math.random() * 2 - 1;
      sample.z = Math.random();
      sample.normalize();
      let scale = i2 / kernelSize;
      scale = MathUtils.lerp(0.1, 1, scale * scale);
      sample.multiplyScalar(scale);
      kernel.push(sample);
    }
  }
  generateRandomKernelRotations() {
    const width = 4, height = 4;
    if (SimplexNoise === void 0) {
      console.error("THREE.SSAOPass: The pass relies on SimplexNoise.");
    }
    const simplex = new SimplexNoise();
    const size2 = width * height;
    const data = new Float32Array(size2);
    for (let i2 = 0; i2 < size2; i2++) {
      const x = Math.random() * 2 - 1;
      const y = Math.random() * 2 - 1;
      const z = 0;
      data[i2] = simplex.noise3d(x, y, z);
    }
    this.noiseTexture = new DataTexture(data, width, height, RedFormat, FloatType);
    this.noiseTexture.wrapS = RepeatWrapping;
    this.noiseTexture.wrapT = RepeatWrapping;
    this.noiseTexture.needsUpdate = true;
  }
  overrideVisibility() {
    const scene = this.scene;
    const cache = this._visibilityCache;
    scene.traverse(function(object) {
      cache.set(object, object.visible);
      if (object.isPoints || object.isLine)
        object.visible = false;
    });
  }
  restoreVisibility() {
    const scene = this.scene;
    const cache = this._visibilityCache;
    scene.traverse(function(object) {
      const visible = cache.get(object);
      object.visible = visible;
    });
    cache.clear();
  }
};
SSAOPass.OUTPUT = {
  Default: 0,
  SSAO: 1,
  Blur: 2,
  Beauty: 3,
  Depth: 4,
  Normal: 5
};

// node_modules/three-stdlib/postprocessing/SavePass.js
var SavePass = class extends Pass {
  constructor(renderTarget) {
    super();
    if (CopyShader === void 0)
      console.error("THREE.SavePass relies on CopyShader");
    const shader = CopyShader;
    this.textureID = "tDiffuse";
    this.uniforms = UniformsUtils.clone(shader.uniforms);
    this.material = new ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader
    });
    this.renderTarget = renderTarget;
    if (this.renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(window.innerWidth, window.innerHeight);
      this.renderTarget.texture.name = "SavePass.rt";
    }
    this.needsSwap = false;
    this.fsQuad = new FullScreenQuad(this.material);
  }
  render(renderer, writeBuffer, readBuffer) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }
    renderer.setRenderTarget(this.renderTarget);
    if (this.clear)
      renderer.clear();
    this.fsQuad.render(renderer);
  }
};

// node_modules/three-stdlib/shaders/BokehShader.js
var BokehShader = {
  defines: {
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tColor: {
      value: null
    },
    tDepth: {
      value: null
    },
    focus: {
      value: 1
    },
    aspect: {
      value: 1
    },
    aperture: {
      value: 0.025
    },
    maxblur: {
      value: 0.01
    },
    nearClip: {
      value: 1
    },
    farClip: {
      value: 1e3
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#include <common>",
    "varying vec2 vUv;",
    "uniform sampler2D tColor;",
    "uniform sampler2D tDepth;",
    "uniform float maxblur;",
    "uniform float aperture;",
    "uniform float nearClip;",
    "uniform float farClip;",
    "uniform float focus;",
    "uniform float aspect;",
    "#include <packing>",
    "float getDepth( const in vec2 screenPosition ) {",
    "	#if DEPTH_PACKING == 1",
    "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );",
    "	#else",
    "	return texture2D( tDepth, screenPosition ).x;",
    "	#endif",
    "}",
    "float getViewZ( const in float depth ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "	return perspectiveDepthToViewZ( depth, nearClip, farClip );",
    "	#else",
    "	return orthographicDepthToViewZ( depth, nearClip, farClip );",
    "	#endif",
    "}",
    "void main() {",
    "	vec2 aspectcorrect = vec2( 1.0, aspect );",
    "	float viewZ = getViewZ( getDepth( vUv ) );",
    "	float factor = ( focus + viewZ );",
    "	vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );",
    "	vec2 dofblur9 = dofblur * 0.9;",
    "	vec2 dofblur7 = dofblur * 0.7;",
    "	vec2 dofblur4 = dofblur * 0.4;",
    "	vec4 col = vec4( 0.0 );",
    "	col += texture2D( tColor, vUv.xy );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );",
    "	gl_FragColor = col / 41.0;",
    "	gl_FragColor.a = 1.0;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/postprocessing/BokehPass.js
var BokehPass = class extends Pass {
  constructor(scene, camera, params) {
    super();
    _defineProperty(this, "scene", void 0);
    _defineProperty(this, "camera", void 0);
    _defineProperty(this, "renderTargetDepth", void 0);
    _defineProperty(this, "materialDepth", void 0);
    _defineProperty(this, "materialBokeh", void 0);
    _defineProperty(this, "fsQuad", void 0);
    _defineProperty(this, "_oldClearColor", void 0);
    _defineProperty(this, "uniforms", void 0);
    this.scene = scene;
    this.camera = camera;
    const focus = params.focus !== void 0 ? params.focus : 1;
    const aspect = params.aspect !== void 0 ? params.aspect : camera.aspect;
    const aperture = params.aperture !== void 0 ? params.aperture : 0.025;
    const maxblur = params.maxblur !== void 0 ? params.maxblur : 1;
    const width = params.width || window.innerWidth || 1;
    const height = params.height || window.innerHeight || 1;
    this.renderTargetDepth = new WebGLRenderTarget(width, height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter
    });
    this.renderTargetDepth.texture.name = "BokehPass.depth";
    this.materialDepth = new MeshDepthMaterial();
    this.materialDepth.depthPacking = RGBADepthPacking;
    this.materialDepth.blending = NoBlending;
    if (BokehShader === void 0) {
      console.error("BokehPass relies on BokehShader");
    }
    const bokehShader = BokehShader;
    const bokehUniforms = UniformsUtils.clone(bokehShader.uniforms);
    bokehUniforms["tDepth"].value = this.renderTargetDepth.texture;
    bokehUniforms["focus"].value = focus;
    bokehUniforms["aspect"].value = aspect;
    bokehUniforms["aperture"].value = aperture;
    bokehUniforms["maxblur"].value = maxblur;
    bokehUniforms["nearClip"].value = camera.near;
    bokehUniforms["farClip"].value = camera.far;
    this.materialBokeh = new ShaderMaterial({
      defines: Object.assign({}, bokehShader.defines),
      uniforms: bokehUniforms,
      vertexShader: bokehShader.vertexShader,
      fragmentShader: bokehShader.fragmentShader
    });
    this.uniforms = bokehUniforms;
    this.needsSwap = false;
    this.fsQuad = new FullScreenQuad(this.materialBokeh);
    this._oldClearColor = new Color();
  }
  render(renderer, writeBuffer, readBuffer) {
    this.scene.overrideMaterial = this.materialDepth;
    renderer.getClearColor(this._oldClearColor);
    const oldClearAlpha = renderer.getClearAlpha();
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setClearColor(16777215);
    renderer.setClearAlpha(1);
    renderer.setRenderTarget(this.renderTargetDepth);
    renderer.clear();
    renderer.render(this.scene, this.camera);
    this.uniforms["tColor"].value = readBuffer.texture;
    this.uniforms["nearClip"].value = this.camera.near;
    this.uniforms["farClip"].value = this.camera.far;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      renderer.clear();
      this.fsQuad.render(renderer);
    }
    this.scene.overrideMaterial = null;
    renderer.setClearColor(this._oldClearColor);
    renderer.setClearAlpha(oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  }
};

// node_modules/three-stdlib/postprocessing/TexturePass.js
var TexturePass = function(map, opacity) {
  if (CopyShader === void 0)
    console.error("THREE.TexturePass relies on CopyShader");
  var shader = CopyShader;
  this.map = map;
  this.opacity = opacity !== void 0 ? opacity : 1;
  this.uniforms = UniformsUtils.clone(shader.uniforms);
  this.material = new ShaderMaterial({
    uniforms: this.uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader,
    depthTest: false,
    depthWrite: false
  });
  this.needsSwap = false;
  this.fsQuad = new FullScreenQuad(null);
};
TexturePass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: TexturePass,
  render: function(renderer, writeBuffer, readBuffer) {
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    this.fsQuad.material = this.material;
    this.uniforms["opacity"].value = this.opacity;
    this.uniforms["tDiffuse"].value = this.map;
    this.material.transparent = this.opacity < 1;
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear)
      renderer.clear();
    this.fsQuad.render(renderer);
    renderer.autoClear = oldAutoClear;
  }
});

// node_modules/three-stdlib/shaders/LuminosityShader.js
var LuminosityShader = {
  uniforms: {
    tDiffuse: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	float l = linearToRelativeLuminance( texel.rgb );", "	gl_FragColor = vec4( l, l, l, texel.w );", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/ToneMapShader.js
var ToneMapShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    averageLuminance: {
      value: 1
    },
    luminanceMap: {
      value: null
    },
    maxLuminance: {
      value: 16
    },
    minLuminance: {
      value: 0.01
    },
    middleGrey: {
      value: 0.6
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#include <common>",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "uniform float middleGrey;",
    "uniform float minLuminance;",
    "uniform float maxLuminance;",
    "#ifdef ADAPTED_LUMINANCE",
    "	uniform sampler2D luminanceMap;",
    "#else",
    "	uniform float averageLuminance;",
    "#endif",
    "vec3 ToneMap( vec3 vColor ) {",
    "	#ifdef ADAPTED_LUMINANCE",
    "		float fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;",
    "	#else",
    "		float fLumAvg = averageLuminance;",
    "	#endif",
    "	float fLumPixel = linearToRelativeLuminance( vColor );",
    "	float fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );",
    "	float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);",
    "	return fLumCompressed * vColor;",
    "}",
    "void main() {",
    "	vec4 texel = texture2D( tDiffuse, vUv );",
    "	gl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/postprocessing/AdaptiveToneMappingPass.js
var AdaptiveToneMappingPass = function(adaptive, resolution) {
  this.resolution = resolution !== void 0 ? resolution : 256;
  this.needsInit = true;
  this.adaptive = adaptive !== void 0 ? !!adaptive : true;
  this.luminanceRT = null;
  this.previousLuminanceRT = null;
  this.currentLuminanceRT = null;
  if (CopyShader === void 0)
    console.error("THREE.AdaptiveToneMappingPass relies on CopyShader");
  var copyShader = CopyShader;
  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
  this.materialCopy = new ShaderMaterial({
    uniforms: this.copyUniforms,
    vertexShader: copyShader.vertexShader,
    fragmentShader: copyShader.fragmentShader,
    blending: NoBlending,
    depthTest: false
  });
  if (LuminosityShader === void 0)
    console.error("THREE.AdaptiveToneMappingPass relies on LuminosityShader");
  this.materialLuminance = new ShaderMaterial({
    uniforms: UniformsUtils.clone(LuminosityShader.uniforms),
    vertexShader: LuminosityShader.vertexShader,
    fragmentShader: LuminosityShader.fragmentShader,
    blending: NoBlending
  });
  this.adaptLuminanceShader = {
    defines: {
      MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2)).toFixed(1)
    },
    uniforms: {
      lastLum: {
        value: null
      },
      currentLum: {
        value: null
      },
      minLuminance: {
        value: 0.01
      },
      delta: {
        value: 0.016
      },
      tau: {
        value: 1
      }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: [
      "varying vec2 vUv;",
      "uniform sampler2D lastLum;",
      "uniform sampler2D currentLum;",
      "uniform float minLuminance;",
      "uniform float delta;",
      "uniform float tau;",
      "void main() {",
      "	vec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );",
      "	vec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );",
      "	float fLastLum = max( minLuminance, lastLum.r );",
      "	float fCurrentLum = max( minLuminance, currentLum.r );",
      "	fCurrentLum *= fCurrentLum;",
      "	float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));",
      "	gl_FragColor.r = fAdaptedLum;",
      "}"
    ].join("\n")
  };
  this.materialAdaptiveLum = new ShaderMaterial({
    uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),
    vertexShader: this.adaptLuminanceShader.vertexShader,
    fragmentShader: this.adaptLuminanceShader.fragmentShader,
    defines: Object.assign({}, this.adaptLuminanceShader.defines),
    blending: NoBlending
  });
  if (ToneMapShader === void 0)
    console.error("THREE.AdaptiveToneMappingPass relies on ToneMapShader");
  this.materialToneMap = new ShaderMaterial({
    uniforms: UniformsUtils.clone(ToneMapShader.uniforms),
    vertexShader: ToneMapShader.vertexShader,
    fragmentShader: ToneMapShader.fragmentShader,
    blending: NoBlending
  });
  this.fsQuad = new FullScreenQuad(null);
};
AdaptiveToneMappingPass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: AdaptiveToneMappingPass,
  render: function(renderer, writeBuffer, readBuffer, deltaTime) {
    if (this.needsInit) {
      this.reset(renderer);
      this.luminanceRT.texture.type = readBuffer.texture.type;
      this.previousLuminanceRT.texture.type = readBuffer.texture.type;
      this.currentLuminanceRT.texture.type = readBuffer.texture.type;
      this.needsInit = false;
    }
    if (this.adaptive) {
      this.fsQuad.material = this.materialLuminance;
      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;
      renderer.setRenderTarget(this.currentLuminanceRT);
      this.fsQuad.render(renderer);
      this.fsQuad.material = this.materialAdaptiveLum;
      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;
      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;
      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;
      renderer.setRenderTarget(this.luminanceRT);
      this.fsQuad.render(renderer);
      this.fsQuad.material = this.materialCopy;
      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;
      renderer.setRenderTarget(this.previousLuminanceRT);
      this.fsQuad.render(renderer);
    }
    this.fsQuad.material = this.materialToneMap;
    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear();
      this.fsQuad.render(renderer);
    }
  },
  reset: function() {
    if (this.luminanceRT) {
      this.luminanceRT.dispose();
    }
    if (this.currentLuminanceRT) {
      this.currentLuminanceRT.dispose();
    }
    if (this.previousLuminanceRT) {
      this.previousLuminanceRT.dispose();
    }
    var pars = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat
    };
    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);
    this.luminanceRT.texture.name = "AdaptiveToneMappingPass.l";
    this.luminanceRT.texture.generateMipmaps = false;
    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);
    this.previousLuminanceRT.texture.name = "AdaptiveToneMappingPass.pl";
    this.previousLuminanceRT.texture.generateMipmaps = false;
    pars.minFilter = LinearMipmapLinearFilter;
    pars.generateMipmaps = true;
    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);
    this.currentLuminanceRT.texture.name = "AdaptiveToneMappingPass.cl";
    if (this.adaptive) {
      this.materialToneMap.defines["ADAPTED_LUMINANCE"] = "";
      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;
    }
    this.fsQuad.material = new MeshBasicMaterial({
      color: 7829367
    });
    this.materialLuminance.needsUpdate = true;
    this.materialAdaptiveLum.needsUpdate = true;
    this.materialToneMap.needsUpdate = true;
  },
  setAdaptive: function(adaptive) {
    if (adaptive) {
      this.adaptive = true;
      this.materialToneMap.defines["ADAPTED_LUMINANCE"] = "";
      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;
    } else {
      this.adaptive = false;
      delete this.materialToneMap.defines["ADAPTED_LUMINANCE"];
      this.materialToneMap.uniforms.luminanceMap.value = null;
    }
    this.materialToneMap.needsUpdate = true;
  },
  setAdaptionRate: function(rate) {
    if (rate) {
      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);
    }
  },
  setMinLuminance: function(minLum) {
    if (minLum) {
      this.materialToneMap.uniforms.minLuminance.value = minLum;
      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;
    }
  },
  setMaxLuminance: function(maxLum) {
    if (maxLum) {
      this.materialToneMap.uniforms.maxLuminance.value = maxLum;
    }
  },
  setAverageLuminance: function(avgLum) {
    if (avgLum) {
      this.materialToneMap.uniforms.averageLuminance.value = avgLum;
    }
  },
  setMiddleGrey: function(middleGrey) {
    if (middleGrey) {
      this.materialToneMap.uniforms.middleGrey.value = middleGrey;
    }
  },
  dispose: function() {
    if (this.luminanceRT) {
      this.luminanceRT.dispose();
    }
    if (this.previousLuminanceRT) {
      this.previousLuminanceRT.dispose();
    }
    if (this.currentLuminanceRT) {
      this.currentLuminanceRT.dispose();
    }
    if (this.materialLuminance) {
      this.materialLuminance.dispose();
    }
    if (this.materialAdaptiveLum) {
      this.materialAdaptiveLum.dispose();
    }
    if (this.materialCopy) {
      this.materialCopy.dispose();
    }
    if (this.materialToneMap) {
      this.materialToneMap.dispose();
    }
  }
});

// node_modules/three-stdlib/shaders/LuminosityHighPassShader.js
var LuminosityHighPassShader = {
  shaderID: "luminosityHighPass",
  uniforms: {
    tDiffuse: {
      value: null
    },
    luminosityThreshold: {
      value: 1
    },
    smoothWidth: {
      value: 1
    },
    defaultColor: {
      value: new Color(0)
    },
    defaultOpacity: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec3 defaultColor;", "uniform float defaultOpacity;", "uniform float luminosityThreshold;", "uniform float smoothWidth;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	vec3 luma = vec3( 0.299, 0.587, 0.114 );", "	float v = dot( texel.xyz, luma );", "	vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );", "	float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );", "	gl_FragColor = mix( outputColor, texel, alpha );", "}"].join("\n")
};

// node_modules/three-stdlib/postprocessing/UnrealBloomPass.js
var UnrealBloomPass = function(resolution, strength, radius, threshold) {
  this.strength = strength !== void 0 ? strength : 1;
  this.radius = radius;
  this.threshold = threshold;
  this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);
  this.clearColor = new Color(0, 0, 0);
  var pars = {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat
  };
  this.renderTargetsHorizontal = [];
  this.renderTargetsVertical = [];
  this.nMips = 5;
  var resx = Math.round(this.resolution.x / 2);
  var resy = Math.round(this.resolution.y / 2);
  this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);
  this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
  this.renderTargetBright.texture.generateMipmaps = false;
  for (let i2 = 0; i2 < this.nMips; i2++) {
    var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);
    renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i2;
    renderTargetHorizonal.texture.generateMipmaps = false;
    this.renderTargetsHorizontal.push(renderTargetHorizonal);
    var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);
    renderTargetVertical.texture.name = "UnrealBloomPass.v" + i2;
    renderTargetVertical.texture.generateMipmaps = false;
    this.renderTargetsVertical.push(renderTargetVertical);
    resx = Math.round(resx / 2);
    resy = Math.round(resy / 2);
  }
  if (LuminosityHighPassShader === void 0)
    console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
  var highPassShader = LuminosityHighPassShader;
  this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);
  this.highPassUniforms["luminosityThreshold"].value = threshold;
  this.highPassUniforms["smoothWidth"].value = 0.01;
  this.materialHighPassFilter = new ShaderMaterial({
    uniforms: this.highPassUniforms,
    vertexShader: highPassShader.vertexShader,
    fragmentShader: highPassShader.fragmentShader,
    defines: {}
  });
  this.separableBlurMaterials = [];
  var kernelSizeArray = [3, 5, 7, 9, 11];
  var resx = Math.round(this.resolution.x / 2);
  var resy = Math.round(this.resolution.y / 2);
  for (let i2 = 0; i2 < this.nMips; i2++) {
    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i2]));
    this.separableBlurMaterials[i2].uniforms["texSize"].value = new Vector2(resx, resy);
    resx = Math.round(resx / 2);
    resy = Math.round(resy / 2);
  }
  this.compositeMaterial = this.getCompositeMaterial(this.nMips);
  this.compositeMaterial.uniforms["blurTexture1"].value = this.renderTargetsVertical[0].texture;
  this.compositeMaterial.uniforms["blurTexture2"].value = this.renderTargetsVertical[1].texture;
  this.compositeMaterial.uniforms["blurTexture3"].value = this.renderTargetsVertical[2].texture;
  this.compositeMaterial.uniforms["blurTexture4"].value = this.renderTargetsVertical[3].texture;
  this.compositeMaterial.uniforms["blurTexture5"].value = this.renderTargetsVertical[4].texture;
  this.compositeMaterial.uniforms["bloomStrength"].value = strength;
  this.compositeMaterial.uniforms["bloomRadius"].value = 0.1;
  this.compositeMaterial.needsUpdate = true;
  var bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];
  this.compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
  this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];
  this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
  if (CopyShader === void 0) {
    console.error("THREE.UnrealBloomPass relies on CopyShader");
  }
  var copyShader = CopyShader;
  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
  this.copyUniforms["opacity"].value = 1;
  this.materialCopy = new ShaderMaterial({
    uniforms: this.copyUniforms,
    vertexShader: copyShader.vertexShader,
    fragmentShader: copyShader.fragmentShader,
    blending: AdditiveBlending,
    depthTest: false,
    depthWrite: false,
    transparent: true
  });
  this.enabled = true;
  this.needsSwap = false;
  this._oldClearColor = new Color();
  this.oldClearAlpha = 1;
  this.basic = new MeshBasicMaterial();
  this.fsQuad = new FullScreenQuad(null);
};
UnrealBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: UnrealBloomPass,
  dispose: function() {
    for (let i2 = 0; i2 < this.renderTargetsHorizontal.length; i2++) {
      this.renderTargetsHorizontal[i2].dispose();
    }
    for (let i2 = 0; i2 < this.renderTargetsVertical.length; i2++) {
      this.renderTargetsVertical[i2].dispose();
    }
    this.renderTargetBright.dispose();
  },
  setSize: function(width, height) {
    var resx = Math.round(width / 2);
    var resy = Math.round(height / 2);
    this.renderTargetBright.setSize(resx, resy);
    for (let i2 = 0; i2 < this.nMips; i2++) {
      this.renderTargetsHorizontal[i2].setSize(resx, resy);
      this.renderTargetsVertical[i2].setSize(resx, resy);
      this.separableBlurMaterials[i2].uniforms["texSize"].value = new Vector2(resx, resy);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
  },
  render: function(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    renderer.getClearColor(this._oldClearColor);
    this.oldClearAlpha = renderer.getClearAlpha();
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setClearColor(this.clearColor, 0);
    if (maskActive)
      renderer.state.buffers.stencil.setTest(false);
    if (this.renderToScreen) {
      this.fsQuad.material = this.basic;
      this.basic.map = readBuffer.texture;
      renderer.setRenderTarget(null);
      renderer.clear();
      this.fsQuad.render(renderer);
    }
    this.highPassUniforms["tDiffuse"].value = readBuffer.texture;
    this.highPassUniforms["luminosityThreshold"].value = this.threshold;
    this.fsQuad.material = this.materialHighPassFilter;
    renderer.setRenderTarget(this.renderTargetBright);
    renderer.clear();
    this.fsQuad.render(renderer);
    var inputRenderTarget = this.renderTargetBright;
    for (let i2 = 0; i2 < this.nMips; i2++) {
      this.fsQuad.material = this.separableBlurMaterials[i2];
      this.separableBlurMaterials[i2].uniforms["colorTexture"].value = inputRenderTarget.texture;
      this.separableBlurMaterials[i2].uniforms["direction"].value = UnrealBloomPass.BlurDirectionX;
      renderer.setRenderTarget(this.renderTargetsHorizontal[i2]);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.separableBlurMaterials[i2].uniforms["colorTexture"].value = this.renderTargetsHorizontal[i2].texture;
      this.separableBlurMaterials[i2].uniforms["direction"].value = UnrealBloomPass.BlurDirectionY;
      renderer.setRenderTarget(this.renderTargetsVertical[i2]);
      renderer.clear();
      this.fsQuad.render(renderer);
      inputRenderTarget = this.renderTargetsVertical[i2];
    }
    this.fsQuad.material = this.compositeMaterial;
    this.compositeMaterial.uniforms["bloomStrength"].value = this.strength;
    this.compositeMaterial.uniforms["bloomRadius"].value = this.radius;
    this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
    renderer.clear();
    this.fsQuad.render(renderer);
    this.fsQuad.material = this.materialCopy;
    this.copyUniforms["tDiffuse"].value = this.renderTargetsHorizontal[0].texture;
    if (maskActive)
      renderer.state.buffers.stencil.setTest(true);
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(readBuffer);
      this.fsQuad.render(renderer);
    }
    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  },
  getSeperableBlurMaterial: function(kernelRadius) {
    return new ShaderMaterial({
      defines: {
        KERNEL_RADIUS: kernelRadius,
        SIGMA: kernelRadius
      },
      uniforms: {
        colorTexture: {
          value: null
        },
        texSize: {
          value: new Vector2(0.5, 0.5)
        },
        direction: {
          value: new Vector2(0.5, 0.5)
        }
      },
      vertexShader: "varying vec2 vUv;\n				void main() {\n					vUv = uv;\n					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n				}",
      fragmentShader: "#include <common>				varying vec2 vUv;\n				uniform sampler2D colorTexture;\n				uniform vec2 texSize;				uniform vec2 direction;								float gaussianPdf(in float x, in float sigma) {					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;				}				void main() {\n					vec2 invSize = 1.0 / texSize;					float fSigma = float(SIGMA);					float weightSum = gaussianPdf(0.0, fSigma);					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {						float x = float(i);						float w = gaussianPdf(x, fSigma);						vec2 uvOffset = direction * invSize * x;						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;						diffuseSum += (sample1 + sample2) * w;						weightSum += 2.0 * w;					}					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n				}"
    });
  },
  getCompositeMaterial: function(nMips) {
    return new ShaderMaterial({
      defines: {
        NUM_MIPS: nMips
      },
      uniforms: {
        blurTexture1: {
          value: null
        },
        blurTexture2: {
          value: null
        },
        blurTexture3: {
          value: null
        },
        blurTexture4: {
          value: null
        },
        blurTexture5: {
          value: null
        },
        dirtTexture: {
          value: null
        },
        bloomStrength: {
          value: 1
        },
        bloomFactors: {
          value: null
        },
        bloomTintColors: {
          value: null
        },
        bloomRadius: {
          value: 0
        }
      },
      vertexShader: "varying vec2 vUv;\n				void main() {\n					vUv = uv;\n					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n				}",
      fragmentShader: "varying vec2 vUv;				uniform sampler2D blurTexture1;				uniform sampler2D blurTexture2;				uniform sampler2D blurTexture3;				uniform sampler2D blurTexture4;				uniform sampler2D blurTexture5;				uniform sampler2D dirtTexture;				uniform float bloomStrength;				uniform float bloomRadius;				uniform float bloomFactors[NUM_MIPS];				uniform vec3 bloomTintColors[NUM_MIPS];								float lerpBloomFactor(const in float factor) { 					float mirrorFactor = 1.2 - factor;					return mix(factor, mirrorFactor, bloomRadius);				}								void main() {					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + 													 lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + 													 lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + 													 lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + 													 lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );				}"
    });
  }
});
UnrealBloomPass.BlurDirectionX = new Vector2(1, 0);
UnrealBloomPass.BlurDirectionY = new Vector2(0, 1);

// node_modules/three-stdlib/postprocessing/CubeTexturePass.js
var CubeTexturePass = function(camera, envMap, opacity) {
  this.camera = camera;
  this.needsSwap = false;
  this.cubeShader = ShaderLib["cube"];
  this.cubeMesh = new Mesh(new BoxGeometry(10, 10, 10), new ShaderMaterial({
    uniforms: UniformsUtils.clone(this.cubeShader.uniforms),
    vertexShader: this.cubeShader.vertexShader,
    fragmentShader: this.cubeShader.fragmentShader,
    depthTest: false,
    depthWrite: false,
    side: BackSide
  }));
  Object.defineProperty(this.cubeMesh.material, "envMap", {
    get: function() {
      return this.uniforms.envMap.value;
    }
  });
  this.envMap = envMap;
  this.opacity = opacity !== void 0 ? opacity : 1;
  this.cubeScene = new Scene();
  this.cubeCamera = new PerspectiveCamera();
  this.cubeScene.add(this.cubeMesh);
};
CubeTexturePass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: CubeTexturePass,
  render: function(renderer, writeBuffer, readBuffer) {
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);
    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);
    this.cubeMesh.material.uniforms.envMap.value = this.envMap;
    this.cubeMesh.material.uniforms.flipEnvMap.value = this.envMap.isCubeTexture && this.envMap._needsFlipEnvMap ? -1 : 1;
    this.cubeMesh.material.uniforms.opacity.value = this.opacity;
    this.cubeMesh.material.transparent = this.opacity < 1;
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.cubeScene, this.cubeCamera);
    renderer.autoClear = oldAutoClear;
  }
});

// node_modules/three-stdlib/shaders/SAOShader.js
var SAOShader = {
  defines: {
    NUM_SAMPLES: 7,
    NUM_RINGS: 4,
    NORMAL_TEXTURE: 0,
    DIFFUSE_TEXTURE: 0,
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    tNormal: {
      value: null
    },
    size: {
      value: new Vector2(512, 512)
    },
    cameraNear: {
      value: 1
    },
    cameraFar: {
      value: 100
    },
    cameraProjectionMatrix: {
      value: new Matrix4()
    },
    cameraInverseProjectionMatrix: {
      value: new Matrix4()
    },
    scale: {
      value: 1
    },
    intensity: {
      value: 0.1
    },
    bias: {
      value: 0.5
    },
    minResolution: {
      value: 0
    },
    kernelRadius: {
      value: 100
    },
    randomSeed: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", "varying vec2 vUv;", "#if DIFFUSE_TEXTURE == 1", "uniform sampler2D tDiffuse;", "#endif", "uniform sampler2D tDepth;", "#if NORMAL_TEXTURE == 1", "uniform sampler2D tNormal;", "#endif", "uniform float cameraNear;", "uniform float cameraFar;", "uniform mat4 cameraProjectionMatrix;", "uniform mat4 cameraInverseProjectionMatrix;", "uniform float scale;", "uniform float intensity;", "uniform float bias;", "uniform float kernelRadius;", "uniform float minResolution;", "uniform vec2 size;", "uniform float randomSeed;", "// RGBA depth", "#include <packing>", "vec4 getDefaultColor( const in vec2 screenPosition ) {", "	#if DIFFUSE_TEXTURE == 1", "	return texture2D( tDiffuse, vUv );", "	#else", "	return vec4( 1.0 );", "	#endif", "}", "float getDepth( const in vec2 screenPosition ) {", "	#if DEPTH_PACKING == 1", "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );", "	#else", "	return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "float getViewZ( const in float depth ) {", "	#if PERSPECTIVE_CAMERA == 1", "	return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );", "	#else", "	return orthographicDepthToViewZ( depth, cameraNear, cameraFar );", "	#endif", "}", "vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {", "	float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];", "	vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );", "	clipPosition *= clipW; // unprojection.", "	return ( cameraInverseProjectionMatrix * clipPosition ).xyz;", "}", "vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {", "	#if NORMAL_TEXTURE == 1", "	return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );", "	#else", "	return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );", "	#endif", "}", "float scaleDividedByCameraFar;", "float minResolutionMultipliedByCameraFar;", "float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {", "	vec3 viewDelta = sampleViewPosition - centerViewPosition;", "	float viewDistance = length( viewDelta );", "	float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;", "	return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );", "}", "// moving costly divides into consts", "const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );", "const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );", "float getAmbientOcclusion( const in vec3 centerViewPosition ) {", "	// precompute some variables require in getOcclusion.", "	scaleDividedByCameraFar = scale / cameraFar;", "	minResolutionMultipliedByCameraFar = minResolution * cameraFar;", "	vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );", "	// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/", "	float angle = rand( vUv + randomSeed ) * PI2;", "	vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;", "	vec2 radiusStep = radius;", "	float occlusionSum = 0.0;", "	float weightSum = 0.0;", "	for( int i = 0; i < NUM_SAMPLES; i ++ ) {", "		vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;", "		radius += radiusStep;", "		angle += ANGLE_STEP;", "		float sampleDepth = getDepth( sampleUv );", "		if( sampleDepth >= ( 1.0 - EPSILON ) ) {", "			continue;", "		}", "		float sampleViewZ = getViewZ( sampleDepth );", "		vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );", "		occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );", "		weightSum += 1.0;", "	}", "	if( weightSum == 0.0 ) discard;", "	return occlusionSum * ( intensity / weightSum );", "}", "void main() {", "	float centerDepth = getDepth( vUv );", "	if( centerDepth >= ( 1.0 - EPSILON ) ) {", "		discard;", "	}", "	float centerViewZ = getViewZ( centerDepth );", "	vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );", "	float ambientOcclusion = getAmbientOcclusion( viewPosition );", "	gl_FragColor = getDefaultColor( vUv );", "	gl_FragColor.xyz *=  1.0 - ambientOcclusion;", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js
var DepthLimitedBlurShader = {
  defines: {
    KERNEL_RADIUS: 4,
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    size: {
      value: new Vector2(512, 512)
    },
    sampleUvOffsets: {
      value: [new Vector2(0, 0)]
    },
    sampleWeights: {
      value: [1]
    },
    tDepth: {
      value: null
    },
    cameraNear: {
      value: 10
    },
    cameraFar: {
      value: 1e3
    },
    depthCutoff: {
      value: 10
    }
  },
  vertexShader: ["#include <common>", "uniform vec2 size;", "varying vec2 vUv;", "varying vec2 vInvSize;", "void main() {", "	vUv = uv;", "	vInvSize = 1.0 / size;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", "#include <packing>", "uniform sampler2D tDiffuse;", "uniform sampler2D tDepth;", "uniform float cameraNear;", "uniform float cameraFar;", "uniform float depthCutoff;", "uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];", "uniform float sampleWeights[ KERNEL_RADIUS + 1 ];", "varying vec2 vUv;", "varying vec2 vInvSize;", "float getDepth( const in vec2 screenPosition ) {", "	#if DEPTH_PACKING == 1", "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );", "	#else", "	return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "float getViewZ( const in float depth ) {", "	#if PERSPECTIVE_CAMERA == 1", "	return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );", "	#else", "	return orthographicDepthToViewZ( depth, cameraNear, cameraFar );", "	#endif", "}", "void main() {", "	float depth = getDepth( vUv );", "	if( depth >= ( 1.0 - EPSILON ) ) {", "		discard;", "	}", "	float centerViewZ = -getViewZ( depth );", "	bool rBreak = false, lBreak = false;", "	float weightSum = sampleWeights[0];", "	vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;", "	for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {", "		float sampleWeight = sampleWeights[i];", "		vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;", "		vec2 sampleUv = vUv + sampleUvOffset;", "		float viewZ = -getViewZ( getDepth( sampleUv ) );", "		if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;", "		if( ! rBreak ) {", "			diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;", "			weightSum += sampleWeight;", "		}", "		sampleUv = vUv - sampleUvOffset;", "		viewZ = -getViewZ( getDepth( sampleUv ) );", "		if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;", "		if( ! lBreak ) {", "			diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;", "			weightSum += sampleWeight;", "		}", "	}", "	gl_FragColor = diffuseSum / weightSum;", "}"].join("\n")
};
var BlurShaderUtils = {
  createSampleWeights: (kernelRadius, stdDev) => {
    const gaussian = (x, stdDev2) => {
      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);
    };
    const weights = [];
    for (let i2 = 0; i2 <= kernelRadius; i2++) {
      weights.push(gaussian(i2, stdDev));
    }
    return weights;
  },
  createSampleOffsets: (kernelRadius, uvIncrement) => {
    const offsets = [];
    for (let i2 = 0; i2 <= kernelRadius; i2++) {
      offsets.push(uvIncrement.clone().multiplyScalar(i2));
    }
    return offsets;
  },
  configure: (shader, kernelRadius, stdDev, uvIncrement) => {
    shader.defines["KERNEL_RADIUS"] = kernelRadius;
    shader.uniforms["sampleUvOffsets"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);
    shader.uniforms["sampleWeights"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);
    shader.needsUpdate = true;
  }
};

// node_modules/three-stdlib/postprocessing/SAOPass.js
var SAOPass = function(scene, camera, depthTexture, useNormals, resolution) {
  this.scene = scene;
  this.camera = camera;
  this.clear = true;
  this.needsSwap = false;
  this.supportsDepthTextureExtension = depthTexture !== void 0 ? depthTexture : false;
  this.supportsNormalTexture = useNormals !== void 0 ? useNormals : false;
  this.originalClearColor = new Color();
  this._oldClearColor = new Color();
  this.oldClearAlpha = 1;
  this.params = {
    output: 0,
    saoBias: 0.5,
    saoIntensity: 0.18,
    saoScale: 1,
    saoKernelRadius: 100,
    saoMinResolution: 0,
    saoBlur: true,
    saoBlurRadius: 8,
    saoBlurStdDev: 4,
    saoBlurDepthCutoff: 0.01
  };
  this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);
  this.saoRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat
  });
  this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();
  this.beautyRenderTarget = this.saoRenderTarget.clone();
  this.normalRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {
    minFilter: NearestFilter,
    magFilter: NearestFilter,
    format: RGBAFormat
  });
  this.depthRenderTarget = this.normalRenderTarget.clone();
  if (this.supportsDepthTextureExtension) {
    var depthTexture = new DepthTexture();
    depthTexture.type = UnsignedShortType;
    this.beautyRenderTarget.depthTexture = depthTexture;
    this.beautyRenderTarget.depthBuffer = true;
  }
  this.depthMaterial = new MeshDepthMaterial();
  this.depthMaterial.depthPacking = RGBADepthPacking;
  this.depthMaterial.blending = NoBlending;
  this.normalMaterial = new MeshNormalMaterial();
  this.normalMaterial.blending = NoBlending;
  if (SAOShader === void 0) {
    console.error("THREE.SAOPass relies on SAOShader");
  }
  this.saoMaterial = new ShaderMaterial({
    defines: Object.assign({}, SAOShader.defines),
    fragmentShader: SAOShader.fragmentShader,
    vertexShader: SAOShader.vertexShader,
    uniforms: UniformsUtils.clone(SAOShader.uniforms)
  });
  this.saoMaterial.extensions.derivatives = true;
  this.saoMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
  this.saoMaterial.defines["NORMAL_TEXTURE"] = this.supportsNormalTexture ? 1 : 0;
  this.saoMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
  this.saoMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
  this.saoMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
  this.saoMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
  this.saoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
  this.saoMaterial.uniforms["cameraProjectionMatrix"].value = this.camera.projectionMatrix;
  this.saoMaterial.blending = NoBlending;
  if (DepthLimitedBlurShader === void 0) {
    console.error("THREE.SAOPass relies on DepthLimitedBlurShader");
  }
  this.vBlurMaterial = new ShaderMaterial({
    uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),
    defines: Object.assign({}, DepthLimitedBlurShader.defines),
    vertexShader: DepthLimitedBlurShader.vertexShader,
    fragmentShader: DepthLimitedBlurShader.fragmentShader
  });
  this.vBlurMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
  this.vBlurMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
  this.vBlurMaterial.uniforms["tDiffuse"].value = this.saoRenderTarget.texture;
  this.vBlurMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
  this.vBlurMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
  this.vBlurMaterial.blending = NoBlending;
  this.hBlurMaterial = new ShaderMaterial({
    uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),
    defines: Object.assign({}, DepthLimitedBlurShader.defines),
    vertexShader: DepthLimitedBlurShader.vertexShader,
    fragmentShader: DepthLimitedBlurShader.fragmentShader
  });
  this.hBlurMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
  this.hBlurMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
  this.hBlurMaterial.uniforms["tDiffuse"].value = this.blurIntermediateRenderTarget.texture;
  this.hBlurMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
  this.hBlurMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
  this.hBlurMaterial.blending = NoBlending;
  if (CopyShader === void 0) {
    console.error("THREE.SAOPass relies on CopyShader");
  }
  this.materialCopy = new ShaderMaterial({
    uniforms: UniformsUtils.clone(CopyShader.uniforms),
    vertexShader: CopyShader.vertexShader,
    fragmentShader: CopyShader.fragmentShader,
    blending: NoBlending
  });
  this.materialCopy.transparent = true;
  this.materialCopy.depthTest = false;
  this.materialCopy.depthWrite = false;
  this.materialCopy.blending = CustomBlending;
  this.materialCopy.blendSrc = DstColorFactor;
  this.materialCopy.blendDst = ZeroFactor;
  this.materialCopy.blendEquation = AddEquation;
  this.materialCopy.blendSrcAlpha = DstAlphaFactor;
  this.materialCopy.blendDstAlpha = ZeroFactor;
  this.materialCopy.blendEquationAlpha = AddEquation;
  if (UnpackDepthRGBAShader === void 0) {
    console.error("THREE.SAOPass relies on UnpackDepthRGBAShader");
  }
  this.depthCopy = new ShaderMaterial({
    uniforms: UniformsUtils.clone(UnpackDepthRGBAShader.uniforms),
    vertexShader: UnpackDepthRGBAShader.vertexShader,
    fragmentShader: UnpackDepthRGBAShader.fragmentShader,
    blending: NoBlending
  });
  this.fsQuad = new FullScreenQuad(null);
};
SAOPass.OUTPUT = {
  Beauty: 1,
  Default: 0,
  SAO: 2,
  Depth: 3,
  Normal: 4
};
SAOPass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: SAOPass,
  render: function(renderer, writeBuffer, readBuffer) {
    if (this.renderToScreen) {
      this.materialCopy.blending = NoBlending;
      this.materialCopy.uniforms["tDiffuse"].value = readBuffer.texture;
      this.materialCopy.needsUpdate = true;
      this.renderPass(renderer, this.materialCopy, null);
    }
    if (this.params.output === 1) {
      return;
    }
    renderer.getClearColor(this._oldClearColor);
    this.oldClearAlpha = renderer.getClearAlpha();
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setRenderTarget(this.depthRenderTarget);
    renderer.clear();
    this.saoMaterial.uniforms["bias"].value = this.params.saoBias;
    this.saoMaterial.uniforms["intensity"].value = this.params.saoIntensity;
    this.saoMaterial.uniforms["scale"].value = this.params.saoScale;
    this.saoMaterial.uniforms["kernelRadius"].value = this.params.saoKernelRadius;
    this.saoMaterial.uniforms["minResolution"].value = this.params.saoMinResolution;
    this.saoMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.saoMaterial.uniforms["cameraFar"].value = this.camera.far;
    var depthCutoff = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);
    this.vBlurMaterial.uniforms["depthCutoff"].value = depthCutoff;
    this.hBlurMaterial.uniforms["depthCutoff"].value = depthCutoff;
    this.vBlurMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.vBlurMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.hBlurMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.hBlurMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius);
    if (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) {
      BlurShaderUtils.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(0, 1));
      BlurShaderUtils.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(1, 0));
      this.prevStdDev = this.params.saoBlurStdDev;
      this.prevNumSamples = this.params.saoBlurRadius;
    }
    renderer.setClearColor(0);
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    renderer.render(this.scene, this.camera);
    if (!this.supportsDepthTextureExtension) {
      this.renderOverride(renderer, this.depthMaterial, this.depthRenderTarget, 0, 1);
    }
    if (this.supportsNormalTexture) {
      this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 7829503, 1);
    }
    this.renderPass(renderer, this.saoMaterial, this.saoRenderTarget, 16777215, 1);
    if (this.params.saoBlur) {
      this.renderPass(renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 16777215, 1);
      this.renderPass(renderer, this.hBlurMaterial, this.saoRenderTarget, 16777215, 1);
    }
    var outputMaterial = this.materialCopy;
    if (this.params.output === 3) {
      if (this.supportsDepthTextureExtension) {
        this.materialCopy.uniforms["tDiffuse"].value = this.beautyRenderTarget.depthTexture;
        this.materialCopy.needsUpdate = true;
      } else {
        this.depthCopy.uniforms["tDiffuse"].value = this.depthRenderTarget.texture;
        this.depthCopy.needsUpdate = true;
        outputMaterial = this.depthCopy;
      }
    } else if (this.params.output === 4) {
      this.materialCopy.uniforms["tDiffuse"].value = this.normalRenderTarget.texture;
      this.materialCopy.needsUpdate = true;
    } else {
      this.materialCopy.uniforms["tDiffuse"].value = this.saoRenderTarget.texture;
      this.materialCopy.needsUpdate = true;
    }
    if (this.params.output === 0) {
      outputMaterial.blending = CustomBlending;
    } else {
      outputMaterial.blending = NoBlending;
    }
    this.renderPass(renderer, outputMaterial, this.renderToScreen ? null : readBuffer);
    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  },
  renderPass: function(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    var originalClearAlpha = renderer.getClearAlpha();
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  renderOverride: function(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    var originalClearAlpha = renderer.getClearAlpha();
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  setSize: function(width, height) {
    this.beautyRenderTarget.setSize(width, height);
    this.saoRenderTarget.setSize(width, height);
    this.blurIntermediateRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.depthRenderTarget.setSize(width, height);
    this.saoMaterial.uniforms["size"].value.set(width, height);
    this.saoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.saoMaterial.uniforms["cameraProjectionMatrix"].value = this.camera.projectionMatrix;
    this.saoMaterial.needsUpdate = true;
    this.vBlurMaterial.uniforms["size"].value.set(width, height);
    this.vBlurMaterial.needsUpdate = true;
    this.hBlurMaterial.uniforms["size"].value.set(width, height);
    this.hBlurMaterial.needsUpdate = true;
  }
});

// node_modules/three-stdlib/shaders/AfterimageShader.js
var AfterimageShader = {
  uniforms: {
    damp: {
      value: 0.96
    },
    tOld: {
      value: null
    },
    tNew: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float damp;", "uniform sampler2D tOld;", "uniform sampler2D tNew;", "varying vec2 vUv;", "vec4 when_gt( vec4 x, float y ) {", "	return max( sign( x - y ), 0.0 );", "}", "void main() {", "	vec4 texelOld = texture2D( tOld, vUv );", "	vec4 texelNew = texture2D( tNew, vUv );", "	texelOld *= damp * when_gt( texelOld, 0.1 );", "	gl_FragColor = max(texelNew, texelOld);", "}"].join("\n")
};

// node_modules/three-stdlib/postprocessing/AfterimagePass.js
var AfterimagePass = class extends Pass {
  constructor(damp = 0.96, shader = AfterimageShader) {
    super();
    _defineProperty(this, "shader", void 0);
    _defineProperty(this, "uniforms", void 0);
    _defineProperty(this, "textureComp", void 0);
    _defineProperty(this, "textureOld", void 0);
    _defineProperty(this, "shaderMaterial", void 0);
    _defineProperty(this, "compFsQuad", void 0);
    _defineProperty(this, "copyFsQuad", void 0);
    this.shader = shader;
    this.uniforms = UniformsUtils.clone(shader.uniforms);
    this.uniforms["damp"].value = damp;
    this.textureComp = new WebGLRenderTarget(window.innerWidth, window.innerHeight, {
      minFilter: LinearFilter,
      magFilter: NearestFilter,
      format: RGBAFormat
    });
    this.textureOld = new WebGLRenderTarget(window.innerWidth, window.innerHeight, {
      minFilter: LinearFilter,
      magFilter: NearestFilter,
      format: RGBAFormat
    });
    this.shaderMaterial = new ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: this.shader.vertexShader,
      fragmentShader: this.shader.fragmentShader
    });
    this.compFsQuad = new FullScreenQuad(this.shaderMaterial);
    let material = new MeshBasicMaterial();
    this.copyFsQuad = new FullScreenQuad(material);
  }
  render(renderer, writeBuffer, readBuffer) {
    this.uniforms["tOld"].value = this.textureOld.texture;
    this.uniforms["tNew"].value = readBuffer.texture;
    renderer.setRenderTarget(this.textureComp);
    this.compFsQuad.render(renderer);
    this.copyFsQuad.material.map = this.textureComp.texture;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.copyFsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear();
      this.copyFsQuad.render(renderer);
    }
    let temp2 = this.textureOld;
    this.textureOld = this.textureComp;
    this.textureComp = temp2;
  }
  setSize(width, height) {
    this.textureComp.setSize(width, height);
    this.textureOld.setSize(width, height);
  }
};

// node_modules/three-stdlib/postprocessing/MaskPass.js
var MaskPass = class extends Pass {
  constructor(scene, camera) {
    super();
    _defineProperty(this, "scene", void 0);
    _defineProperty(this, "camera", void 0);
    _defineProperty(this, "inverse", void 0);
    this.scene = scene;
    this.camera = camera;
    this.clear = true;
    this.needsSwap = false;
    this.inverse = false;
  }
  render(renderer, writeBuffer, readBuffer) {
    const context = renderer.getContext();
    const state = renderer.state;
    state.buffers.color.setMask(false);
    state.buffers.depth.setMask(false);
    state.buffers.color.setLocked(true);
    state.buffers.depth.setLocked(true);
    let writeValue, clearValue;
    if (this.inverse) {
      writeValue = 0;
      clearValue = 1;
    } else {
      writeValue = 1;
      clearValue = 0;
    }
    state.buffers.stencil.setTest(true);
    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
    state.buffers.stencil.setClear(clearValue);
    state.buffers.stencil.setLocked(true);
    renderer.setRenderTarget(readBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(writeBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.scene, this.camera);
    state.buffers.color.setLocked(false);
    state.buffers.depth.setLocked(false);
    state.buffers.stencil.setLocked(false);
    state.buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    state.buffers.stencil.setLocked(true);
  }
};
var ClearMaskPass = class extends Pass {
  constructor() {
    super();
    this.needsSwap = false;
  }
  render(renderer) {
    renderer.state.buffers.stencil.setLocked(false);
    renderer.state.buffers.stencil.setTest(false);
  }
};

// node_modules/three-stdlib/postprocessing/EffectComposer.js
var EffectComposer = class {
  constructor(renderer, renderTarget) {
    _defineProperty(this, "renderer", void 0);
    _defineProperty(this, "_pixelRatio", void 0);
    _defineProperty(this, "_width", void 0);
    _defineProperty(this, "_height", void 0);
    _defineProperty(this, "renderTarget1", void 0);
    _defineProperty(this, "renderTarget2", void 0);
    _defineProperty(this, "writeBuffer", void 0);
    _defineProperty(this, "readBuffer", void 0);
    _defineProperty(this, "renderToScreen", void 0);
    _defineProperty(this, "passes", []);
    _defineProperty(this, "copyPass", void 0);
    _defineProperty(this, "clock", void 0);
    this.renderer = renderer;
    if (renderTarget === void 0) {
      const parameters = {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat
      };
      const size2 = renderer.getSize(new Vector2());
      this._pixelRatio = renderer.getPixelRatio();
      this._width = size2.width;
      this._height = size2.height;
      renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);
      renderTarget.texture.name = "EffectComposer.rt1";
    } else {
      this._pixelRatio = 1;
      this._width = renderTarget.width;
      this._height = renderTarget.height;
    }
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.renderTarget2.texture.name = "EffectComposer.rt2";
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.renderToScreen = true;
    if (CopyShader === void 0) {
      console.error("THREE.EffectComposer relies on CopyShader");
    }
    if (ShaderPass === void 0) {
      console.error("THREE.EffectComposer relies on ShaderPass");
    }
    this.copyPass = new ShaderPass(CopyShader);
    this.clock = new Clock();
  }
  swapBuffers() {
    const tmp = this.readBuffer;
    this.readBuffer = this.writeBuffer;
    this.writeBuffer = tmp;
  }
  addPass(pass) {
    this.passes.push(pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(pass, index) {
    this.passes.splice(index, 0, pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(pass) {
    const index = this.passes.indexOf(pass);
    if (index !== -1) {
      this.passes.splice(index, 1);
    }
  }
  isLastEnabledPass(passIndex) {
    for (let i2 = passIndex + 1; i2 < this.passes.length; i2++) {
      if (this.passes[i2].enabled) {
        return false;
      }
    }
    return true;
  }
  render(deltaTime) {
    if (deltaTime === void 0) {
      deltaTime = this.clock.getDelta();
    }
    const currentRenderTarget = this.renderer.getRenderTarget();
    let maskActive = false;
    const il = this.passes.length;
    for (let i2 = 0; i2 < il; i2++) {
      const pass = this.passes[i2];
      if (pass.enabled === false)
        continue;
      pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i2);
      pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
      if (pass.needsSwap) {
        if (maskActive) {
          const context = this.renderer.getContext();
          const stencil = this.renderer.state.buffers.stencil;
          stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
          stencil.setFunc(context.EQUAL, 1, 4294967295);
        }
        this.swapBuffers();
      }
      if (MaskPass !== void 0) {
        if (pass instanceof MaskPass) {
          maskActive = true;
        } else if (pass instanceof ClearMaskPass) {
          maskActive = false;
        }
      }
    }
    this.renderer.setRenderTarget(currentRenderTarget);
  }
  reset(renderTarget) {
    if (renderTarget === void 0) {
      const size2 = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio();
      this._width = size2.width;
      this._height = size2.height;
      renderTarget = this.renderTarget1.clone();
      renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = this._width * this._pixelRatio;
    const effectiveHeight = this._height * this._pixelRatio;
    this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
    this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
    for (let i2 = 0; i2 < this.passes.length; i2++) {
      this.passes[i2].setSize(effectiveWidth, effectiveHeight);
    }
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
};

// node_modules/three-stdlib/shaders/DotScreenShader.js
var DotScreenShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    tSize: {
      value: new Vector2(256, 256)
    },
    center: {
      value: new Vector2(0.5, 0.5)
    },
    angle: {
      value: 1.57
    },
    scale: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform vec2 center;", "uniform float angle;", "uniform float scale;", "uniform vec2 tSize;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "float pattern() {", "	float s = sin( angle ), c = cos( angle );", "	vec2 tex = vUv * tSize - center;", "	vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;", "	return ( sin( point.x ) * sin( point.y ) ) * 4.0;", "}", "void main() {", "	vec4 color = texture2D( tDiffuse, vUv );", "	float average = ( color.r + color.g + color.b ) / 3.0;", "	gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );", "}"].join("\n")
};

// node_modules/three-stdlib/postprocessing/DotScreenPass.js
var DotScreenPass = class extends Pass {
  constructor(center, angle, scale) {
    super();
    _defineProperty(this, "material", void 0);
    _defineProperty(this, "fsQuad", void 0);
    _defineProperty(this, "uniforms", void 0);
    if (DotScreenShader === void 0)
      console.error("THREE.DotScreenPass relies on THREE.DotScreenShader");
    const shader = DotScreenShader;
    this.uniforms = UniformsUtils.clone(shader.uniforms);
    if (center !== void 0)
      this.uniforms["center"].value.copy(center);
    if (angle !== void 0)
      this.uniforms["angle"].value = angle;
    if (scale !== void 0)
      this.uniforms["scale"].value = scale;
    this.material = new ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader
    });
    this.fsQuad = new FullScreenQuad(this.material);
  }
  render(renderer, writeBuffer, readBuffer) {
    this.uniforms["tDiffuse"].value = readBuffer.texture;
    this.uniforms["tSize"].value.set(readBuffer.width, readBuffer.height);
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear();
      this.fsQuad.render(renderer);
    }
  }
};

// node_modules/three-stdlib/shaders/SSRShader.js
var SSRShader = {
  defines: {
    MAX_STEP: 0,
    isPerspectiveCamera: true,
    isDistanceAttenuation: true,
    isFresnel: true,
    isInfiniteThick: false,
    isSelective: false
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    tNormal: {
      value: null
    },
    tMetalness: {
      value: null
    },
    tDepth: {
      value: null
    },
    cameraNear: {
      value: null
    },
    cameraFar: {
      value: null
    },
    resolution: {
      value: new Vector2()
    },
    cameraProjectionMatrix: {
      value: new Matrix4()
    },
    cameraInverseProjectionMatrix: {
      value: new Matrix4()
    },
    opacity: {
      value: 0.5
    },
    maxDistance: {
      value: 180
    },
    cameraRange: {
      value: 0
    },
    surfDist: {
      value: 7e-3
    },
    thickTolerance: {
      value: 0.03
    }
  },
  vertexShader: `

    varying vec2 vUv;

    void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `,
  fragmentShader: `
		// precision highp float;
		precision highp sampler2D;
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
		uniform sampler2D tMetalness;
		uniform sampler2D tDiffuse;
		uniform float cameraRange;
		uniform vec2 resolution;
		uniform float opacity;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float maxDistance;
		uniform float surfDist;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		uniform float thickTolerance;
		#include <packing>
		float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
			//x0: point, x1: linePointA, x2: linePointB
			//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
			return length(cross(x0-x1,x0-x2))/length(x2-x1);
		}
		float pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){
			// https://mathworld.wolfram.com/Point-PlaneDistance.html
			//// https://en.wikipedia.org/wiki/Plane_(geometry)
			//// http://paulbourke.net/geometry/pointlineplane/
			float a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;
			float x0=point.x,y0=point.y,z0=point.z;
			float x=planePoint.x,y=planePoint.y,z=planePoint.z;
			float d=-(a*x+b*y+c*z);
			float distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);
			return distance;
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			#ifdef isPerspectiveCamera
				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view
		}
		vec3 getViewNormal( const in vec2 uv ) {
			return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );
		}
		vec2 viewPositionToXY(vec3 viewPosition){
			vec2 xy;
			vec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);
			xy=clip.xy;//clip
			float clipW=clip.w;
			xy/=clipW;//NDC
			xy=(xy+1.)/2.;//uv
			xy*=resolution;//screen
			return xy;
		}
		void main(){
			#ifdef isSelective
				float metalness=texture2D(tMetalness,vUv).r;
				if(metalness==0.) return;
			#endif

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );
			if(-viewZ>=cameraFar) return;

			float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];
			vec3 viewPosition=getViewPosition( vUv, depth, clipW );

			vec2 d0=gl_FragCoord.xy;
			vec2 d1;

			vec3 viewNormal=getViewNormal( vUv );

			#ifdef isPerspectiveCamera
				vec3 viewIncidenceDir=normalize(viewPosition);
				vec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);
			#else
				vec3 viewIncidenceDir=vec3(0,0,-1);
				vec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);
			#endif

			float maxReflectRayLen=maxDistance/dot(-viewIncidenceDir,viewNormal);
			// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
			// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
			// maxDistance/maxReflectRayLen=cos(theta)
			// maxDistance/maxReflectRayLen==dot(a,b)
			// maxReflectRayLen==maxDistance/dot(a,b)

			vec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;
			#ifdef isPerspectiveCamera
				if(d1viewPosition.z>-cameraNear){
					//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
					float t=(-cameraNear-viewPosition.z)/viewReflectDir.z;
					d1viewPosition=viewPosition+viewReflectDir*t;
				}
			#endif
			d1=viewPositionToXY(d1viewPosition);

			float totalLen=length(d1-d0);
			float xLen=d1.x-d0.x;
			float yLen=d1.y-d0.y;
			float totalStep=max(abs(xLen),abs(yLen));
			float xSpan=xLen/totalStep;
			float ySpan=yLen/totalStep;
			for(float i=0.;i<MAX_STEP;i++){
				if(i>=totalStep) break;
				vec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);
				if(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;
				float s=length(xy-d0)/totalLen;
				vec2 uv=xy/resolution;

				float d = getDepth(uv);
				float vZ = getViewZ( d );
				if(-vZ>=cameraFar) continue;
				float cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];
				vec3 vP=getViewPosition( uv, d, cW );

				#ifdef isPerspectiveCamera
					// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
					float recipVPZ=1./viewPosition.z;
					float viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));
					float sD=surfDist*cW;
				#else
					float viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);
					float sD=surfDist;
				#endif
				if(viewReflectRayZ-sD>vZ) continue;

				#ifdef isInfiniteThick
					if(viewReflectRayZ+thickTolerance*clipW<vP.z) break;
				#endif
				float away=pointToLineDistance(vP,viewPosition,d1viewPosition);

				float op=opacity;

				if(away<sD){
					vec3 vN=getViewNormal( uv );
					if(dot(viewReflectDir,vN)>=0.) continue;
					float distance=pointPlaneDistance(vP,viewPosition,viewNormal);
					if(distance>maxDistance) break;
					#ifdef isDistanceAttenuation
						float ratio=1.-(distance/maxDistance);
						float attenuation=ratio*ratio;
						op=opacity*attenuation;
					#endif
					#ifdef isFresnel
						float fresnel=(dot(viewIncidenceDir,viewReflectDir)+1.)/2.;
						op*=fresnel;
					#endif
					vec4 reflectColor=texture2D(tDiffuse,uv);
					gl_FragColor.xyz=reflectColor.xyz;
					gl_FragColor.a=op;
					break;
				}
			}
		}
	`
};
var SSRDepthShader = {
  defines: {
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: {
      value: null
    },
    cameraNear: {
      value: null
    },
    cameraFar: {
      value: null
    }
  },
  vertexShader: `

    varying vec2 vUv;

    void main() {

    	vUv = uv;
    	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `,
  fragmentShader: `

    uniform sampler2D tDepth;

    uniform float cameraNear;
    uniform float cameraFar;

    varying vec2 vUv;

    #include <packing>

		float getLinearDepth( const in vec2 uv ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, uv ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, uv ).x;

			#endif

		}

    void main() {

    	float depth = getLinearDepth( vUv );
			float d = 1.0 - depth;
			// d=(d-.999)*1000.;
    	gl_FragColor = vec4( vec3( d ), 1.0 );

    }

  `
};
var SSRBlurShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2()
    },
    opacity: {
      value: 0.5
    }
  },
  vertexShader: `

    varying vec2 vUv;

    void main() {

    	vUv = uv;
    	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `,
  fragmentShader: `

    uniform sampler2D tDiffuse;
    uniform vec2 resolution;
    varying vec2 vUv;
    void main() {
			//reverse engineering from PhotoShop blur filter, then change coefficient

    	vec2 texelSize = ( 1.0 / resolution );

			vec4 c=texture2D(tDiffuse,vUv);

			vec2 offset;

			offset=(vec2(-1,0))*texelSize;
			vec4 cl=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(1,0))*texelSize;
			vec4 cr=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,-1))*texelSize;
			vec4 cb=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,1))*texelSize;
			vec4 ct=texture2D(tDiffuse,vUv+offset);

			// float coeCenter=.5;
			// float coeSide=.125;
			float coeCenter=.2;
			float coeSide=.2;
			float a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;
			vec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;
			gl_FragColor=vec4(rgb,a);

		}
	`
};

// node_modules/three-stdlib/postprocessing/SSRPass.js
var SSRPass = function({
  renderer,
  scene,
  camera,
  width,
  height,
  selects,
  encoding,
  isPerspectiveCamera = true,
  isBouncing = false,
  morphTargets = false,
  groundReflector
}) {
  this.width = width !== void 0 ? width : 512;
  this.height = height !== void 0 ? height : 512;
  this.clear = true;
  this.renderer = renderer;
  this.scene = scene;
  this.camera = camera;
  this.groundReflector = groundReflector;
  this.opacity = SSRShader.uniforms.opacity.value;
  this.output = 0;
  this.maxDistance = SSRShader.uniforms.maxDistance.value;
  this.surfDist = SSRShader.uniforms.surfDist.value;
  this.encoding = encoding;
  this.tempColor = new Color();
  this._selects = selects;
  this.isSelective = Array.isArray(this._selects);
  Object.defineProperty(this, "selects", {
    get() {
      return this._selects;
    },
    set(val) {
      if (this._selects === val)
        return;
      this._selects = val;
      if (Array.isArray(val)) {
        this.isSelective = true;
        this.ssrMaterial.defines.isSelective = true;
        this.ssrMaterial.needsUpdate = true;
      } else {
        this.isSelective = false;
        this.ssrMaterial.defines.isSelective = false;
        this.ssrMaterial.needsUpdate = true;
      }
    }
  });
  this._isBouncing = isBouncing;
  Object.defineProperty(this, "isBouncing", {
    get() {
      return this._isBouncing;
    },
    set(val) {
      if (this._isBouncing === val)
        return;
      this._isBouncing = val;
      if (val) {
        this.ssrMaterial.uniforms["tDiffuse"].value = this.prevRenderTarget.texture;
      } else {
        this.ssrMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
      }
    }
  });
  this.isBlur = true;
  this._isDistanceAttenuation = SSRShader.defines.isDistanceAttenuation;
  Object.defineProperty(this, "isDistanceAttenuation", {
    get() {
      return this._isDistanceAttenuation;
    },
    set(val) {
      if (this._isDistanceAttenuation === val)
        return;
      this._isDistanceAttenuation = val;
      this.ssrMaterial.defines.isDistanceAttenuation = val;
      this.ssrMaterial.needsUpdate = true;
    }
  });
  this._isFresnel = SSRShader.defines.isFresnel;
  Object.defineProperty(this, "isFresnel", {
    get() {
      return this._isFresnel;
    },
    set(val) {
      if (this._isFresnel === val)
        return;
      this._isFresnel = val;
      this.ssrMaterial.defines.isFresnel = val;
      this.ssrMaterial.needsUpdate = true;
    }
  });
  this._isInfiniteThick = SSRShader.defines.isInfiniteThick;
  Object.defineProperty(this, "isInfiniteThick", {
    get() {
      return this._isInfiniteThick;
    },
    set(val) {
      if (this._isInfiniteThick === val)
        return;
      this._isInfiniteThick = val;
      this.ssrMaterial.defines.isInfiniteThick = val;
      this.ssrMaterial.needsUpdate = true;
    }
  });
  this.thickTolerance = SSRShader.uniforms.thickTolerance.value;
  var depthTexture = new DepthTexture();
  depthTexture.type = UnsignedShortType;
  depthTexture.minFilter = NearestFilter;
  depthTexture.maxFilter = NearestFilter;
  this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat,
    depthTexture,
    depthBuffer: true
  });
  this.prevRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat
  });
  this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: NearestFilter,
    magFilter: NearestFilter,
    format: RGBAFormat,
    type: HalfFloatType
  });
  this.metalnessRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: NearestFilter,
    magFilter: NearestFilter,
    format: RGBAFormat
  });
  this.ssrRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat
  });
  this.blurRenderTarget = this.ssrRenderTarget.clone();
  this.blurRenderTarget2 = this.ssrRenderTarget.clone();
  if (SSRShader === void 0) {
    console.error("THREE.SSRPass: The pass relies on SSRShader.");
  }
  this.ssrMaterial = new ShaderMaterial({
    defines: Object.assign({
      MAX_STEP: Math.sqrt(window.innerWidth * window.innerWidth + window.innerHeight * window.innerHeight)
    }, SSRShader.defines),
    uniforms: UniformsUtils.clone(SSRShader.uniforms),
    vertexShader: SSRShader.vertexShader,
    fragmentShader: SSRShader.fragmentShader,
    blending: NoBlending
  });
  if (!isPerspectiveCamera) {
    this.ssrMaterial.defines.isPerspectiveCamera = isPerspectiveCamera;
    this.ssrMaterial.needsUpdate = true;
  }
  this.ssrMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
  this.ssrMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
  this.ssrMaterial.defines.isSelective = this.isSelective;
  this.ssrMaterial.needsUpdate = true;
  this.ssrMaterial.uniforms["tMetalness"].value = this.metalnessRenderTarget.texture;
  this.ssrMaterial.uniforms["tDepth"].value = this.beautyRenderTarget.depthTexture;
  this.ssrMaterial.uniforms["cameraNear"].value = this.camera.near;
  this.ssrMaterial.uniforms["cameraFar"].value = this.camera.far;
  this.ssrMaterial.uniforms["surfDist"].value = this.surfDist;
  this.ssrMaterial.uniforms["resolution"].value.set(this.width, this.height);
  this.ssrMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
  this.ssrMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
  this.normalMaterial = new MeshNormalMaterial({
    morphTargets
  });
  this.normalMaterial.blending = NoBlending;
  this.metalnessOnMaterial = new MeshBasicMaterial({
    color: "white"
  });
  this.metalnessOffMaterial = new MeshBasicMaterial({
    color: "black"
  });
  this.blurMaterial = new ShaderMaterial({
    defines: Object.assign({}, SSRBlurShader.defines),
    uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),
    vertexShader: SSRBlurShader.vertexShader,
    fragmentShader: SSRBlurShader.fragmentShader
  });
  this.blurMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
  this.blurMaterial.uniforms["resolution"].value.set(this.width, this.height);
  this.blurMaterial2 = new ShaderMaterial({
    defines: Object.assign({}, SSRBlurShader.defines),
    uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),
    vertexShader: SSRBlurShader.vertexShader,
    fragmentShader: SSRBlurShader.fragmentShader
  });
  this.blurMaterial2.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
  this.blurMaterial2.uniforms["resolution"].value.set(this.width, this.height);
  this.depthRenderMaterial = new ShaderMaterial({
    defines: Object.assign({}, SSRDepthShader.defines),
    uniforms: UniformsUtils.clone(SSRDepthShader.uniforms),
    vertexShader: SSRDepthShader.vertexShader,
    fragmentShader: SSRDepthShader.fragmentShader,
    blending: NoBlending
  });
  this.depthRenderMaterial.uniforms["tDepth"].value = this.beautyRenderTarget.depthTexture;
  this.depthRenderMaterial.uniforms["cameraNear"].value = this.camera.near;
  this.depthRenderMaterial.uniforms["cameraFar"].value = this.camera.far;
  this.copyMaterial = new ShaderMaterial({
    uniforms: UniformsUtils.clone(CopyShader.uniforms),
    vertexShader: CopyShader.vertexShader,
    fragmentShader: CopyShader.fragmentShader,
    transparent: true,
    depthTest: false,
    depthWrite: false,
    blendSrc: SrcAlphaFactor,
    blendDst: OneMinusSrcAlphaFactor,
    blendEquation: AddEquation,
    blendSrcAlpha: SrcAlphaFactor,
    blendDstAlpha: OneMinusSrcAlphaFactor,
    blendEquationAlpha: AddEquation
  });
  this.fsQuad = new FullScreenQuad(null);
  this.originalClearColor = new Color();
};
SSRPass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: SSRPass,
  dispose: function() {
    this.beautyRenderTarget.dispose();
    this.prevRenderTarget.dispose();
    this.normalRenderTarget.dispose();
    this.metalnessRenderTarget.dispose();
    this.ssrRenderTarget.dispose();
    this.blurRenderTarget.dispose();
    this.blurRenderTarget2.dispose();
    this.normalMaterial.dispose();
    this.metalnessOnMaterial.dispose();
    this.metalnessOffMaterial.dispose();
    this.blurMaterial.dispose();
    this.blurMaterial2.dispose();
    this.copyMaterial.dispose();
    this.depthRenderMaterial.dispose();
    this.fsQuad.dispose();
  },
  render: function(renderer, writeBuffer) {
    if (this.encoding)
      this.beautyRenderTarget.texture.encoding = this.encoding;
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    if (this.groundReflector) {
      this.groundReflector.doRender(this.renderer, this.scene, this.camera);
      this.groundReflector.visible = true;
    }
    renderer.render(this.scene, this.camera);
    if (this.groundReflector)
      this.groundReflector.visible = false;
    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0, 0);
    if (this.isSelective) {
      this.renderMetalness(renderer, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0);
    }
    this.ssrMaterial.uniforms["opacity"].value = this.opacity;
    this.ssrMaterial.uniforms["maxDistance"].value = this.maxDistance;
    this.ssrMaterial.uniforms["surfDist"].value = this.surfDist;
    this.ssrMaterial.uniforms["thickTolerance"].value = this.thickTolerance;
    this.renderPass(renderer, this.ssrMaterial, this.ssrRenderTarget);
    if (this.isBlur) {
      this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);
      this.renderPass(renderer, this.blurMaterial2, this.blurRenderTarget2);
    }
    switch (this.output) {
      case SSRPass.OUTPUT.Default:
        if (this.isBouncing) {
          this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          if (this.isBlur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          this.copyMaterial.uniforms["tDiffuse"].value = this.prevRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        } else {
          this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
          if (this.isBlur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        }
        break;
      case SSRPass.OUTPUT.SSR:
        if (this.isBlur)
          this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
        else
          this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        if (this.isBouncing) {
          if (this.isBlur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
        }
        break;
      case SSRPass.OUTPUT.Beauty:
        this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSRPass.OUTPUT.Depth:
        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSRPass.OUTPUT.Normal:
        this.copyMaterial.uniforms["tDiffuse"].value = this.normalRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSRPass.OUTPUT.Metalness:
        this.copyMaterial.uniforms["tDiffuse"].value = this.metalnessRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      default:
        console.warn("THREE.SSRPass: Unknown output type.");
    }
  },
  renderPass: function(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  renderOverride: function(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  renderMetalness: function(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.traverseVisible((child) => {
      child._SSRPassMaterialBack = child.material;
      if (this._selects.includes(child)) {
        child.material = this.metalnessOnMaterial;
      } else {
        child.material = this.metalnessOffMaterial;
      }
    });
    renderer.render(this.scene, this.camera);
    this.scene.traverseVisible((child) => {
      child.material = child._SSRPassMaterialBack;
    });
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  setSize: function(width, height) {
    this.width = width;
    this.height = height;
    this.ssrMaterial.defines.MAX_STEP = Math.sqrt(width * width + height * height);
    this.ssrMaterial.needsUpdate = true;
    this.beautyRenderTarget.setSize(width, height);
    this.prevRenderTarget.setSize(width, height);
    this.ssrRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.metalnessRenderTarget.setSize(width, height);
    this.blurRenderTarget.setSize(width, height);
    this.blurRenderTarget2.setSize(width, height);
    this.ssrMaterial.uniforms["resolution"].value.set(width, height);
    this.ssrMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssrMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.blurMaterial.uniforms["resolution"].value.set(width, height);
    this.blurMaterial2.uniforms["resolution"].value.set(width, height);
  }
});
SSRPass.OUTPUT = {
  Default: 0,
  SSR: 1,
  Beauty: 3,
  Depth: 4,
  Normal: 5,
  Metalness: 7
};

// node_modules/three-stdlib/postprocessing/SSAARenderPass.js
var SSAARenderPass = function(scene, camera, clearColor, clearAlpha) {
  this.scene = scene;
  this.camera = camera;
  this.sampleLevel = 4;
  this.unbiased = true;
  this.clearColor = clearColor !== void 0 ? clearColor : 0;
  this.clearAlpha = clearAlpha !== void 0 ? clearAlpha : 0;
  this._oldClearColor = new Color();
  if (CopyShader === void 0)
    console.error("THREE.SSAARenderPass relies on CopyShader");
  var copyShader = CopyShader;
  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
  this.copyMaterial = new ShaderMaterial({
    uniforms: this.copyUniforms,
    vertexShader: copyShader.vertexShader,
    fragmentShader: copyShader.fragmentShader,
    premultipliedAlpha: true,
    transparent: true,
    blending: AdditiveBlending,
    depthTest: false,
    depthWrite: false
  });
  this.fsQuad = new FullScreenQuad(this.copyMaterial);
};
SSAARenderPass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: SSAARenderPass,
  dispose: function() {
    if (this.sampleRenderTarget) {
      this.sampleRenderTarget.dispose();
      this.sampleRenderTarget = null;
    }
  },
  setSize: function(width, height) {
    if (this.sampleRenderTarget)
      this.sampleRenderTarget.setSize(width, height);
  },
  render: function(renderer, writeBuffer, readBuffer) {
    if (!this.sampleRenderTarget) {
      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat
      });
      this.sampleRenderTarget.texture.name = "SSAARenderPass.sample";
    }
    var jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];
    var autoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.getClearColor(this._oldClearColor);
    var oldClearAlpha = renderer.getClearAlpha();
    var baseSampleWeight = 1 / jitterOffsets.length;
    var roundingRange = 1 / 32;
    this.copyUniforms["tDiffuse"].value = this.sampleRenderTarget.texture;
    var width = readBuffer.width, height = readBuffer.height;
    for (let i2 = 0; i2 < jitterOffsets.length; i2++) {
      var jitterOffset = jitterOffsets[i2];
      if (this.camera.setViewOffset) {
        this.camera.setViewOffset(
          width,
          height,
          jitterOffset[0] * 0.0625,
          jitterOffset[1] * 0.0625,
          width,
          height
        );
      }
      var sampleWeight = baseSampleWeight;
      if (this.unbiased) {
        var uniformCenteredDistribution = -0.5 + (i2 + 0.5) / jitterOffsets.length;
        sampleWeight += roundingRange * uniformCenteredDistribution;
      }
      this.copyUniforms["opacity"].value = sampleWeight;
      renderer.setClearColor(this.clearColor, this.clearAlpha);
      renderer.setRenderTarget(this.sampleRenderTarget);
      renderer.clear();
      renderer.render(this.scene, this.camera);
      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
      if (i2 === 0) {
        renderer.setClearColor(0, 0);
        renderer.clear();
      }
      this.fsQuad.render(renderer);
    }
    if (this.camera.clearViewOffset)
      this.camera.clearViewOffset();
    renderer.autoClear = autoClear;
    renderer.setClearColor(this._oldClearColor, oldClearAlpha);
  }
});
SSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];

// node_modules/three-stdlib/postprocessing/TAARenderPass.js
var TAARenderPass = function(scene, camera, clearColor, clearAlpha) {
  if (SSAARenderPass === void 0) {
    console.error("THREE.TAARenderPass relies on SSAARenderPass");
  }
  SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);
  this.sampleLevel = 0;
  this.accumulate = false;
};
TAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;
TAARenderPass.prototype = Object.assign(Object.create(SSAARenderPass.prototype), {
  constructor: TAARenderPass,
  render: function(renderer, writeBuffer, readBuffer, deltaTime) {
    if (!this.accumulate) {
      SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);
      this.accumulateIndex = -1;
      return;
    }
    var jitterOffsets = TAARenderPass.JitterVectors[5];
    if (!this.sampleRenderTarget) {
      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);
      this.sampleRenderTarget.texture.name = "TAARenderPass.sample";
    }
    if (!this.holdRenderTarget) {
      this.holdRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);
      this.holdRenderTarget.texture.name = "TAARenderPass.hold";
    }
    if (this.accumulate && this.accumulateIndex === -1) {
      SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);
      this.accumulateIndex = 0;
    }
    var autoClear = renderer.autoClear;
    renderer.autoClear = false;
    var sampleWeight = 1 / jitterOffsets.length;
    if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {
      this.copyUniforms["opacity"].value = sampleWeight;
      this.copyUniforms["tDiffuse"].value = writeBuffer.texture;
      var numSamplesPerFrame = Math.pow(2, this.sampleLevel);
      for (let i2 = 0; i2 < numSamplesPerFrame; i2++) {
        var j2 = this.accumulateIndex;
        var jitterOffset = jitterOffsets[j2];
        if (this.camera.setViewOffset) {
          this.camera.setViewOffset(
            readBuffer.width,
            readBuffer.height,
            jitterOffset[0] * 0.0625,
            jitterOffset[1] * 0.0625,
            readBuffer.width,
            readBuffer.height
          );
        }
        renderer.setRenderTarget(writeBuffer);
        renderer.clear();
        renderer.render(this.scene, this.camera);
        renderer.setRenderTarget(this.sampleRenderTarget);
        if (this.accumulateIndex === 0)
          renderer.clear();
        this.fsQuad.render(renderer);
        this.accumulateIndex++;
        if (this.accumulateIndex >= jitterOffsets.length)
          break;
      }
      if (this.camera.clearViewOffset)
        this.camera.clearViewOffset();
    }
    var accumulationWeight = this.accumulateIndex * sampleWeight;
    if (accumulationWeight > 0) {
      this.copyUniforms["opacity"].value = 1;
      this.copyUniforms["tDiffuse"].value = this.sampleRenderTarget.texture;
      renderer.setRenderTarget(writeBuffer);
      renderer.clear();
      this.fsQuad.render(renderer);
    }
    if (accumulationWeight < 1) {
      this.copyUniforms["opacity"].value = 1 - accumulationWeight;
      this.copyUniforms["tDiffuse"].value = this.holdRenderTarget.texture;
      renderer.setRenderTarget(writeBuffer);
      if (accumulationWeight === 0)
        renderer.clear();
      this.fsQuad.render(renderer);
    }
    renderer.autoClear = autoClear;
  }
});

// node_modules/three-stdlib/postprocessing/RenderPass.js
var RenderPass = class extends Pass {
  constructor(scene, camera, overrideMaterial, clearColor, clearAlpha = 0) {
    super();
    _defineProperty(this, "scene", void 0);
    _defineProperty(this, "camera", void 0);
    _defineProperty(this, "overrideMaterial", void 0);
    _defineProperty(this, "clearColor", void 0);
    _defineProperty(this, "clearAlpha", void 0);
    _defineProperty(this, "clearDepth", false);
    _defineProperty(this, "_oldClearColor", new Color());
    this.scene = scene;
    this.camera = camera;
    this.overrideMaterial = overrideMaterial;
    this.clearColor = clearColor;
    this.clearAlpha = clearAlpha;
    this.clear = true;
    this.needsSwap = false;
  }
  render(renderer, writeBuffer, readBuffer) {
    let oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    let oldClearAlpha;
    let oldOverrideMaterial = null;
    if (this.overrideMaterial !== void 0) {
      oldOverrideMaterial = this.scene.overrideMaterial;
      this.scene.overrideMaterial = this.overrideMaterial;
    }
    if (this.clearColor) {
      renderer.getClearColor(this._oldClearColor);
      oldClearAlpha = renderer.getClearAlpha();
      renderer.setClearColor(this.clearColor, this.clearAlpha);
    }
    if (this.clearDepth) {
      renderer.clearDepth();
    }
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear)
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    renderer.render(this.scene, this.camera);
    if (this.clearColor) {
      renderer.setClearColor(this._oldClearColor, oldClearAlpha);
    }
    if (this.overrideMaterial !== void 0) {
      this.scene.overrideMaterial = oldOverrideMaterial;
    }
    renderer.autoClear = oldAutoClear;
  }
};

// node_modules/three-stdlib/postprocessing/RenderPixelatedPass.js
var RenderPixelatedPass = class extends Pass {
  constructor(resolution, pixelSize, scene, camera, options = {}) {
    var _options$normalEdgeSt, _options$depthEdgeStr;
    super();
    this.pixelSize = pixelSize;
    this.resolution = new Vector2();
    this.renderResolution = new Vector2();
    this.setSize(resolution.x, resolution.y);
    this.fsQuad = new FullScreenQuad(this.material());
    this.scene = scene;
    this.camera = camera;
    this.normalEdgeStrength = (_options$normalEdgeSt = options.normalEdgeStrength) != null ? _options$normalEdgeSt : 0.3;
    this.depthEdgeStrength = (_options$depthEdgeStr = options.depthEdgeStrength) != null ? _options$depthEdgeStr : 0.4;
    this.rgbRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, true);
    this.normalRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, false);
    this.normalMaterial = new MeshNormalMaterial();
  }
  dispose() {
    this.rgbRenderTarget.dispose();
    this.normalRenderTarget.dispose();
    this.fsQuad.dispose();
  }
  setSize(width, height) {
    var _this$rgbRenderTarget, _this$normalRenderTar, _this$fsQuad;
    this.resolution.set(width, height);
    this.renderResolution.set(width / this.pixelSize | 0, height / this.pixelSize | 0);
    const {
      x,
      y
    } = this.renderResolution;
    (_this$rgbRenderTarget = this.rgbRenderTarget) === null || _this$rgbRenderTarget === void 0 ? void 0 : _this$rgbRenderTarget.setSize(x, y);
    (_this$normalRenderTar = this.normalRenderTarget) === null || _this$normalRenderTar === void 0 ? void 0 : _this$normalRenderTar.setSize(x, y);
    (_this$fsQuad = this.fsQuad) === null || _this$fsQuad === void 0 ? void 0 : _this$fsQuad.material.uniforms.resolution.value.set(x, y, 1 / x, 1 / y);
  }
  setPixelSize(pixelSize) {
    this.pixelSize = pixelSize;
    this.setSize(this.resolution.x, this.resolution.y);
  }
  render(renderer, writeBuffer) {
    const uniforms = this.fsQuad.material.uniforms;
    uniforms.normalEdgeStrength.value = this.normalEdgeStrength;
    uniforms.depthEdgeStrength.value = this.depthEdgeStrength;
    renderer.setRenderTarget(this.rgbRenderTarget);
    renderer.render(this.scene, this.camera);
    const overrideMaterial_old = this.scene.overrideMaterial;
    renderer.setRenderTarget(this.normalRenderTarget);
    this.scene.overrideMaterial = this.normalMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = overrideMaterial_old;
    uniforms.tDiffuse.value = this.rgbRenderTarget.texture;
    uniforms.tDepth.value = this.rgbRenderTarget.depthTexture;
    uniforms.tNormal.value = this.normalRenderTarget.texture;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear();
    }
    this.fsQuad.render(renderer);
  }
  material() {
    return new ShaderMaterial({
      uniforms: {
        tDiffuse: {
          value: null
        },
        tDepth: {
          value: null
        },
        tNormal: {
          value: null
        },
        resolution: {
          value: new Vector4(this.renderResolution.x, this.renderResolution.y, 1 / this.renderResolution.x, 1 / this.renderResolution.y)
        },
        normalEdgeStrength: {
          value: 0
        },
        depthEdgeStrength: {
          value: 0
        }
      },
      vertexShader: `
				varying vec2 vUv;

				void main() {

					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

				}
				`,
      fragmentShader: `
				uniform sampler2D tDiffuse;
				uniform sampler2D tDepth;
				uniform sampler2D tNormal;
				uniform vec4 resolution;
				uniform float normalEdgeStrength;
				uniform float depthEdgeStrength;
				varying vec2 vUv;

				float getDepth(int x, int y) {

					return texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;

				}

				vec3 getNormal(int x, int y) {

					return texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;

				}

				float depthEdgeIndicator(float depth, vec3 normal) {

					float diff = 0.0;
					diff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);
					diff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);
					diff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);
					diff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);
					return floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;

				}

				float neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {

					float depthDiff = getDepth(x, y) - depth;
					vec3 neighborNormal = getNormal(x, y);
					
					// Edge pixels should yield to faces who's normals are closer to the bias normal.
					vec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.
					float normalDiff = dot(normal - neighborNormal, normalEdgeBias);
					float normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);
					
					// Only the shallower pixel should detect the normal edge.
					float depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);

					return (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;

				}

				float normalEdgeIndicator(float depth, vec3 normal) {
					
					float indicator = 0.0;

					indicator += neighborNormalEdgeIndicator(0, -1, depth, normal);
					indicator += neighborNormalEdgeIndicator(0, 1, depth, normal);
					indicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);
					indicator += neighborNormalEdgeIndicator(1, 0, depth, normal);

					return step(0.1, indicator);

				}

				void main() {

					vec4 texel = texture2D( tDiffuse, vUv );

					float depth = 0.0;
					vec3 normal = vec3(0.0);

					if (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {

						depth = getDepth(0, 0);
						normal = getNormal(0, 0);

					}

					float dei = 0.0;
					if (depthEdgeStrength > 0.0) 
						dei = depthEdgeIndicator(depth, normal);

					float nei = 0.0; 
					if (normalEdgeStrength > 0.0) 
						nei = normalEdgeIndicator(depth, normal);

					float Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);

					gl_FragColor = texel * Strength;

				}
				`
    });
  }
};
function pixelRenderTarget(resolution, pixelFormat, useDepthTexture) {
  const renderTarget = new WebGLRenderTarget(resolution.x, resolution.y, !useDepthTexture ? void 0 : {
    depthTexture: new DepthTexture(resolution.x, resolution.y),
    depthBuffer: true
  });
  renderTarget.texture.format = pixelFormat;
  renderTarget.texture.minFilter = NearestFilter;
  renderTarget.texture.magFilter = NearestFilter;
  renderTarget.texture.generateMipmaps = false;
  renderTarget.stencilBuffer = false;
  return renderTarget;
}

// node_modules/three-stdlib/shaders/ConvolutionShader.js
var ConvolutionShader = {
  defines: {
    KERNEL_SIZE_FLOAT: "25.0",
    KERNEL_SIZE_INT: "25"
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    uImageIncrement: {
      value: new Vector2(1953125e-9, 0)
    },
    cKernel: {
      value: []
    }
  },
  vertexShader: ["uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "	vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float cKernel[ KERNEL_SIZE_INT ];", "uniform sampler2D tDiffuse;", "uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "	vec2 imageCoord = vUv;", "	vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );", "	for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {", "		sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];", "		imageCoord += uImageIncrement;", "	}", "	gl_FragColor = sum;", "}"].join("\n"),
  buildKernel: function(sigma) {
    function gauss(x, sigma2) {
      return Math.exp(-(x * x) / (2 * sigma2 * sigma2));
    }
    const kMaxKernelSize = 25;
    const kernelSize = Math.min(2 * Math.ceil(sigma * 3) + 1, kMaxKernelSize);
    const halfWidth = (kernelSize - 1) * 0.5;
    const values = new Array(kernelSize);
    let sum = 0;
    for (let i2 = 0; i2 < kernelSize; ++i2) {
      values[i2] = gauss(i2 - halfWidth, sigma);
      sum += values[i2];
    }
    for (let i2 = 0; i2 < kernelSize; ++i2)
      values[i2] /= sum;
    return values;
  }
};

// node_modules/three-stdlib/postprocessing/BloomPass.js
var BloomPass = class extends Pass {
  constructor(strength = 1, kernelSize = 25, sigma = 4, resolution = 256) {
    super();
    _defineProperty(this, "renderTargetX", void 0);
    _defineProperty(this, "renderTargetY", void 0);
    _defineProperty(this, "materialCombine", void 0);
    _defineProperty(this, "materialConvolution", void 0);
    _defineProperty(this, "fsQuad", void 0);
    _defineProperty(this, "combineUniforms", void 0);
    _defineProperty(this, "convolutionUniforms", void 0);
    _defineProperty(this, "blurX", new Vector2(1953125e-9, 0));
    _defineProperty(this, "blurY", new Vector2(0, 1953125e-9));
    this.renderTargetX = new WebGLRenderTarget(resolution, resolution);
    this.renderTargetX.texture.name = "BloomPass.x";
    this.renderTargetY = new WebGLRenderTarget(resolution, resolution);
    this.renderTargetY.texture.name = "BloomPass.y";
    this.combineUniforms = UniformsUtils.clone(CombineShader.uniforms);
    this.combineUniforms["strength"].value = strength;
    this.materialCombine = new ShaderMaterial({
      uniforms: this.combineUniforms,
      vertexShader: CombineShader.vertexShader,
      fragmentShader: CombineShader.fragmentShader,
      blending: AdditiveBlending,
      transparent: true
    });
    if (ConvolutionShader === void 0)
      console.error("BloomPass relies on ConvolutionShader");
    const convolutionShader = ConvolutionShader;
    this.convolutionUniforms = UniformsUtils.clone(convolutionShader.uniforms);
    this.convolutionUniforms["uImageIncrement"].value = this.blurX;
    this.convolutionUniforms["cKernel"].value = ConvolutionShader.buildKernel(sigma);
    this.materialConvolution = new ShaderMaterial({
      uniforms: this.convolutionUniforms,
      vertexShader: convolutionShader.vertexShader,
      fragmentShader: convolutionShader.fragmentShader,
      defines: {
        KERNEL_SIZE_FLOAT: kernelSize.toFixed(1),
        KERNEL_SIZE_INT: kernelSize.toFixed(0)
      }
    });
    this.needsSwap = false;
    this.fsQuad = new FullScreenQuad(this.materialConvolution);
  }
  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    if (maskActive)
      renderer.state.buffers.stencil.setTest(false);
    this.fsQuad.material = this.materialConvolution;
    this.convolutionUniforms["tDiffuse"].value = readBuffer.texture;
    this.convolutionUniforms["uImageIncrement"].value = this.blurX;
    renderer.setRenderTarget(this.renderTargetX);
    renderer.clear();
    this.fsQuad.render(renderer);
    this.convolutionUniforms["tDiffuse"].value = this.renderTargetX.texture;
    this.convolutionUniforms["uImageIncrement"].value = this.blurY;
    renderer.setRenderTarget(this.renderTargetY);
    renderer.clear();
    this.fsQuad.render(renderer);
    this.fsQuad.material = this.materialCombine;
    this.combineUniforms["tDiffuse"].value = this.renderTargetY.texture;
    if (maskActive)
      renderer.state.buffers.stencil.setTest(true);
    renderer.setRenderTarget(readBuffer);
    if (this.clear)
      renderer.clear();
    this.fsQuad.render(renderer);
  }
};
var CombineShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    strength: {
      value: 1
    }
  },
  vertexShader: `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  }`,
  fragmentShader: `
  uniform float strength;
  uniform sampler2D tDiffuse;
  varying vec2 vUv;
  void main() {
    vec4 texel = texture2D( tDiffuse, vUv );
    gl_FragColor = strength * texel;
  }`
};

// node_modules/three-stdlib/webxr/ARButton.js
var ARButton = class {
  static createButton(renderer, sessionInit = {}) {
    const button = document.createElement("button");
    function showStartAR() {
      if (sessionInit.domOverlay === void 0) {
        const overlay = document.createElement("div");
        overlay.style.display = "none";
        document.body.appendChild(overlay);
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", "38px");
        svg.setAttribute("height", "38px");
        svg.style.position = "absolute";
        svg.style.right = "20px";
        svg.style.top = "20px";
        svg.addEventListener("click", function() {
          var _currentSession;
          (_currentSession = currentSession) === null || _currentSession === void 0 ? void 0 : _currentSession.end();
        });
        overlay.appendChild(svg);
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28");
        path.setAttribute("stroke", "#fff");
        path.setAttribute("stroke-width", "2px");
        svg.appendChild(path);
        if (sessionInit.optionalFeatures === void 0) {
          sessionInit.optionalFeatures = [];
        }
        sessionInit.optionalFeatures.push("dom-overlay");
        sessionInit.domOverlay = {
          root: overlay
        };
      }
      let currentSession = null;
      async function onSessionStarted(session) {
        session.addEventListener("end", onSessionEnded);
        renderer.xr.setReferenceSpaceType("local");
        await renderer.xr.setSession(session);
        button.textContent = "STOP AR";
        sessionInit.domOverlay.root.style.display = "";
        currentSession = session;
      }
      function onSessionEnded() {
        currentSession.removeEventListener("end", onSessionEnded);
        button.textContent = "START AR";
        sessionInit.domOverlay.root.style.display = "none";
        currentSession = null;
      }
      button.style.display = "";
      button.style.cursor = "pointer";
      button.style.left = "calc(50% - 50px)";
      button.style.width = "100px";
      button.textContent = "START AR";
      button.onmouseenter = () => {
        button.style.opacity = "1.0";
      };
      button.onmouseleave = () => {
        button.style.opacity = "0.5";
      };
      button.onclick = () => {
        if (currentSession === null) {
          navigator.xr.requestSession("immersive-ar", sessionInit).then(onSessionStarted);
        } else {
          currentSession.end();
        }
      };
    }
    function disableButton() {
      button.style.display = "";
      button.style.cursor = "auto";
      button.style.left = "calc(50% - 75px)";
      button.style.width = "150px";
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }
    function showARNotSupported() {
      disableButton();
      button.textContent = "AR NOT SUPPORTED";
    }
    function stylizeElement(element2) {
      element2.style.position = "absolute";
      element2.style.bottom = "20px";
      element2.style.padding = "12px 6px";
      element2.style.border = "1px solid #fff";
      element2.style.borderRadius = "4px";
      element2.style.background = "rgba(0,0,0,0.1)";
      element2.style.color = "#fff";
      element2.style.font = "normal 13px sans-serif";
      element2.style.textAlign = "center";
      element2.style.opacity = "0.5";
      element2.style.outline = "none";
      element2.style.zIndex = "999";
    }
    if ("xr" in navigator) {
      button.id = "ARButton";
      button.style.display = "none";
      stylizeElement(button);
      navigator.xr.isSessionSupported("immersive-ar").then(function(supported) {
        supported ? showStartAR() : showARNotSupported();
      }).catch(showARNotSupported);
      return button;
    } else {
      const message = document.createElement("a");
      if (window.isSecureContext === false) {
        message.href = document.location.href.replace(/^http:/, "https:");
        message.innerHTML = "WEBXR NEEDS HTTPS";
      } else {
        message.href = "https://immersiveweb.dev/";
        message.innerHTML = "WEBXR NOT AVAILABLE";
      }
      message.style.left = "calc(50% - 90px)";
      message.style.width = "180px";
      message.style.textDecoration = "none";
      stylizeElement(message);
      return message;
    }
  }
};

// node_modules/three-stdlib/loaders/GLTFLoader.js
var GLTFLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsEmissiveStrengthExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIridescenceExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      resourcePath = this.path;
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
      scope2.manager.itemError(url);
      scope2.manager.itemEnd(url);
    };
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(data) {
      try {
        scope2.parse(data, resourcePath, function(gltf) {
          onLoad(gltf);
          scope2.manager.itemEnd(url);
        }, _onError);
      } catch (e) {
        _onError(e);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad, onError) {
    let content;
    const extensions = {};
    const plugins = {};
    if (typeof data === "string") {
      content = data;
    } else {
      const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError)
            onError(error);
          return;
        }
        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
      } else {
        content = LoaderUtils.decodeText(new Uint8Array(data));
      }
    }
    const json = JSON.parse(content);
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError)
        onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i2 = 0; i2 < this.pluginCallbacks.length; i2++) {
      const plugin = this.pluginCallbacks[i2](parser);
      plugins[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i2 = 0; i2 < json.extensionsUsed.length; ++i2) {
        const extensionName = json.extensionsUsed[i2];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension2();
            break;
          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
  parseAsync(data, path) {
    const scope2 = this;
    return new Promise(function(resolve, reject) {
      scope2.parse(data, path, resolve, reject);
    });
  }
};
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object) {
      objects[key] = object;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
var EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
var GLTFLightsExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = {
      refs: {},
      uses: {}
    };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency)
      return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color2 = new Color(16777215);
    if (lightDef.color !== void 0)
      color2.fromArray(lightDef.color);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color2);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color2);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color2);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    if (lightDef.intensity !== void 0)
      lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0)
      return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
};
var GLTFMaterialsUnlitExtension2 = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, sRGBEncoding));
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsEmissiveStrengthExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
    if (emissiveStrength !== void 0) {
      materialParams.emissiveIntensity = emissiveStrength;
    }
    return Promise.resolve();
  }
};
var GLTFMaterialsClearcoatExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, scale);
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsIridescenceExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.iridescenceFactor !== void 0) {
      materialParams.iridescence = extension.iridescenceFactor;
    }
    if (extension.iridescenceTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
    }
    if (extension.iridescenceIor !== void 0) {
      materialParams.iridescenceIOR = extension.iridescenceIor;
    }
    if (materialParams.iridescenceThicknessRange === void 0) {
      materialParams.iridescenceThicknessRange = [100, 400];
    }
    if (extension.iridescenceThicknessMinimum !== void 0) {
      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
    }
    if (extension.iridescenceThicknessMaximum !== void 0) {
      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
    }
    if (extension.iridescenceThicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsSheenExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      materialParams.sheenColor.fromArray(extension.sheenColorFactor);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, sRGBEncoding));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsTransmissionExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsVolumeExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
    return Promise.all(pending);
  }
};
var GLTFMaterialsIorExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
};
var GLTFMaterialsSpecularExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, sRGBEncoding));
    }
    return Promise.all(pending);
  }
};
var GLTFTextureBasisUExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader);
  }
};
var GLTFTextureWebPExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFMeshoptCompression = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer2 = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return buffer2.then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const source = new Uint8Array(res, byteOffset, byteLength);
        if (decoder.decodeGltfBufferAsync) {
          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
            return res2.buffer;
          });
        } else {
          return decoder.ready.then(function() {
            const result = new ArrayBuffer(count * stride);
            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
            return result;
          });
        }
      });
    } else {
      return null;
    }
  }
};
var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = {
  JSON: 1313821514,
  BIN: 5130562
};
var GLTFBinaryExtension = class {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = LoaderUtils.decodeText(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
};
var GLTFDracoMeshCompressionExtension = class {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType.name;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute2 = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0)
              attribute2.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap);
      });
    });
  }
};
var GLTFTextureTransformExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture2, transform) {
    if (transform.texCoord !== void 0) {
      console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
    }
    if (transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
      return texture2;
    }
    texture2 = texture2.clone();
    if (transform.offset !== void 0) {
      texture2.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== void 0) {
      texture2.rotation = transform.rotation;
    }
    if (transform.scale !== void 0) {
      texture2.repeat.fromArray(transform.scale);
    }
    texture2.needsUpdate = true;
    return texture2;
  }
};
var GLTFMeshStandardSGMaterial = class extends MeshStandardMaterial {
  constructor(params) {
    super();
    this.isGLTFSpecularGlossinessMaterial = true;
    const specularMapParsFragmentChunk = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join("\n");
    const glossinessMapParsFragmentChunk = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join("\n");
    const specularMapFragmentChunk = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join("\n");
    const glossinessMapFragmentChunk = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join("\n");
    const lightPhysicalFragmentChunk = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n");
    const uniforms = {
      specular: {
        value: new Color().setHex(16777215)
      },
      glossiness: {
        value: 1
      },
      specularMap: {
        value: null
      },
      glossinessMap: {
        value: null
      }
    };
    this._extraUniforms = uniforms;
    this.onBeforeCompile = function(shader) {
      for (const uniformName in uniforms) {
        shader.uniforms[uniformName] = uniforms[uniformName];
      }
      shader.fragmentShader = shader.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", specularMapParsFragmentChunk).replace("#include <metalnessmap_pars_fragment>", glossinessMapParsFragmentChunk).replace("#include <roughnessmap_fragment>", specularMapFragmentChunk).replace("#include <metalnessmap_fragment>", glossinessMapFragmentChunk).replace("#include <lights_physical_fragment>", lightPhysicalFragmentChunk);
    };
    Object.defineProperties(this, {
      specular: {
        get: function() {
          return uniforms.specular.value;
        },
        set: function(v) {
          uniforms.specular.value = v;
        }
      },
      specularMap: {
        get: function() {
          return uniforms.specularMap.value;
        },
        set: function(v) {
          uniforms.specularMap.value = v;
          if (v) {
            this.defines.USE_SPECULARMAP = "";
          } else {
            delete this.defines.USE_SPECULARMAP;
          }
        }
      },
      glossiness: {
        get: function() {
          return uniforms.glossiness.value;
        },
        set: function(v) {
          uniforms.glossiness.value = v;
        }
      },
      glossinessMap: {
        get: function() {
          return uniforms.glossinessMap.value;
        },
        set: function(v) {
          uniforms.glossinessMap.value = v;
          if (v) {
            this.defines.USE_GLOSSINESSMAP = "";
            this.defines.USE_UV = "";
          } else {
            delete this.defines.USE_GLOSSINESSMAP;
            delete this.defines.USE_UV;
          }
        }
      }
    });
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    this.setValues(params);
  }
  copy(source) {
    super.copy(source);
    this.specularMap = source.specularMap;
    this.specular.copy(source.specular);
    this.glossinessMap = source.glossinessMap;
    this.glossiness = source.glossiness;
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    return this;
  }
};
var GLTFMaterialsPbrSpecularGlossinessExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
    this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"];
  }
  getMaterialType() {
    return GLTFMeshStandardSGMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pbrSpecularGlossiness = materialDef.extensions[this.name];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const pending = [];
    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
      const array = pbrSpecularGlossiness.diffuseFactor;
      materialParams.color.fromArray(array);
      materialParams.opacity = array[3];
    }
    if (pbrSpecularGlossiness.diffuseTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "map", pbrSpecularGlossiness.diffuseTexture, sRGBEncoding));
    }
    materialParams.emissive = new Color(0, 0, 0);
    materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== void 0 ? pbrSpecularGlossiness.glossinessFactor : 1;
    materialParams.specular = new Color(1, 1, 1);
    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
    }
    if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {
      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
      pending.push(parser.assignTexture(materialParams, "glossinessMap", specGlossMapDef));
      pending.push(parser.assignTexture(materialParams, "specularMap", specGlossMapDef, sRGBEncoding));
    }
    return Promise.all(pending);
  }
  createMaterial(materialParams) {
    const material = new GLTFMeshStandardSGMaterial(materialParams);
    material.fog = true;
    material.color = materialParams.color;
    material.map = materialParams.map === void 0 ? null : materialParams.map;
    material.lightMap = null;
    material.lightMapIntensity = 1;
    material.aoMap = materialParams.aoMap === void 0 ? null : materialParams.aoMap;
    material.aoMapIntensity = 1;
    material.emissive = materialParams.emissive;
    material.emissiveIntensity = materialParams.emissiveIntensity === void 0 ? 1 : materialParams.emissiveIntensity;
    material.emissiveMap = materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap;
    material.bumpMap = materialParams.bumpMap === void 0 ? null : materialParams.bumpMap;
    material.bumpScale = 1;
    material.normalMap = materialParams.normalMap === void 0 ? null : materialParams.normalMap;
    material.normalMapType = TangentSpaceNormalMap;
    if (materialParams.normalScale)
      material.normalScale = materialParams.normalScale;
    material.displacementMap = null;
    material.displacementScale = 1;
    material.displacementBias = 0;
    material.specularMap = materialParams.specularMap === void 0 ? null : materialParams.specularMap;
    material.specular = materialParams.specular;
    material.glossinessMap = materialParams.glossinessMap === void 0 ? null : materialParams.glossinessMap;
    material.glossiness = materialParams.glossiness;
    material.alphaMap = null;
    material.envMap = materialParams.envMap === void 0 ? null : materialParams.envMap;
    material.envMapIntensity = 1;
    material.refractionRatio = 0.98;
    return material;
  }
};
var GLTFMeshQuantizationExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
};
var GLTFCubicSplineInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i2 = 0; i2 !== valueSize; i2++) {
      result[i2] = values[offset + i2];
    }
    return result;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const stride2 = stride * 2;
    const stride3 = stride * 3;
    const td2 = t1 - t0;
    const p = (t2 - t0) / td2;
    const pp = p * p;
    const ppp = pp * p;
    const offset1 = i1 * stride3;
    const offset0 = offset1 - stride3;
    const s2 = -2 * ppp + 3 * pp;
    const s3 = ppp - pp;
    const s0 = 1 - s2;
    const s1 = s3 - pp + p;
    for (let i2 = 0; i2 !== stride; i2++) {
      const p0 = values[offset0 + i2 + stride];
      const m0 = values[offset0 + i2 + stride2] * td2;
      const p1 = values[offset1 + i2 + stride];
      const m1 = values[offset1 + i2] * td2;
      result[i2] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  }
};
var _q = new Quaternion();
var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t2, t1) {
    const result = super.interpolate_(i1, t0, t2, t1);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
};
var WEBGL_CONSTANTS2 = {
  FLOAT: 5126,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv2",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var PATH_PROPERTIES2 = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var INTERPOLATION = {
  CUBICSPLINE: void 0,
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
  if (cache["DefaultMaterial"] === void 0) {
    cache["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  let hasMorphColor = false;
  for (let i2 = 0, il = targets.length; i2 < il; i2++) {
    const target = targets[i2];
    if (target.POSITION !== void 0)
      hasMorphPosition = true;
    if (target.NORMAL !== void 0)
      hasMorphNormal = true;
    if (target.COLOR_0 !== void 0)
      hasMorphColor = true;
    if (hasMorphPosition && hasMorphNormal && hasMorphColor)
      break;
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)
    return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  const pendingColorAccessors = [];
  for (let i2 = 0, il = targets.length; i2 < il; i2++) {
    const target = targets[i2];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
    if (hasMorphColor) {
      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
      pendingColorAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors), Promise.all(pendingColorAccessors)]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    const morphColors = accessors[2];
    if (hasMorphPosition)
      geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal)
      geometry.morphAttributes.normal = morphNormals;
    if (hasMorphColor)
      geometry.morphAttributes.color = morphColors;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i2 = 0, il = meshDef.weights.length; i2 < il; i2++) {
      mesh.morphTargetInfluences[i2] = meshDef.weights[i2];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i2 = 0, il = targetNames.length; i2 < il; i2++) {
        mesh.morphTargetDictionary[targetNames[i2]] = i2;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  let geometryKey;
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i2 = 0, il = keys.length; i2 < il; i2++) {
    attributesKey += keys[i2] + ":" + attributes[keys[i2]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(uri) {
  if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0)
    return "image/jpeg";
  if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0)
    return "image/webp";
  return "image/png";
}
var GLTFParser = class {
  constructor(json = {}, options = {}) {
    var _navigator$userAgent, _navigator$userAgent2;
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.meshCache = {
      refs: {},
      uses: {}
    };
    this.cameraCache = {
      refs: {},
      uses: {}
    };
    this.lightCache = {
      refs: {},
      uses: {}
    };
    this.sourceCache = {};
    this.textureCache = {};
    this.nodeNamesUsed = {};
    const isSafari = typeof navigator !== "undefined" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;
    const isFirefox = typeof navigator !== "undefined" && ((_navigator$userAgent = navigator.userAgent) === null || _navigator$userAgent === void 0 ? void 0 : _navigator$userAgent.indexOf("Firefox")) > -1;
    const firefoxVersion = typeof navigator !== "undefined" && isFirefox ? (_navigator$userAgent2 = navigator.userAgent) === null || _navigator$userAgent2 === void 0 ? void 0 : _navigator$userAgent2.match(/Firefox\/([0-9]+)\./)[1] : -1;
    if (typeof createImageBitmap === "undefined" || isSafari || isFirefox && firefoxVersion < 98) {
      this.textureLoader = new TextureLoader(this.options.manager);
    } else {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader2(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([parser.getDependencies("scene"), parser.getDependencies("animation"), parser.getDependencies("camera")]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        onLoad(result);
      });
    }).catch(onError);
  }
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i2 = 0, il = joints.length; i2 < il; i2++) {
        nodeDefs[joints[i2]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  _addNodeRef(cache, index) {
    if (index === void 0)
      return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  }
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1)
      return object;
    const ref = object.clone();
    const updateMappings = (original, clone) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone, mappings);
      }
      for (const [i2, child] of original.children.entries()) {
        updateMappings(child, clone.children[i2]);
      }
    };
    updateMappings(object, ref);
    ref.name += "_instance_" + cache.uses[index]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i2 = 0; i2 < extensions.length; i2++) {
      const result = func(extensions[i2]);
      if (result)
        return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i2 = 0; i2 < extensions.length; i2++) {
      const result = func(extensions[i2]);
      if (result)
        pending.push(result);
    }
    return pending;
  }
  getDependency(type2, index) {
    const cacheKey = type2 + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type2) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this.loadNode(index);
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this._invokeOne(function(ext) {
            return ext.loadAnimation && ext.loadAnimation(index);
          });
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          throw new Error("Unknown type: " + type2);
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  getDependencies(type2) {
    let dependencies = this.cache.get(type2);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type2 + (type2 === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index) {
        return parser.getDependency(type2, index);
      }));
      this.cache.add(type2, dependencies);
    }
    return dependencies;
  }
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer2) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer2.slice(byteOffset, byteOffset + byteLength);
    });
  }
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      return Promise.resolve(null);
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        for (let i2 = 0, il = sparseIndices.length; i2 < il; i2++) {
          const index = sparseIndices[i2];
          bufferAttribute.setX(index, sparseValues[i2 * itemSize]);
          if (itemSize >= 2)
            bufferAttribute.setY(index, sparseValues[i2 * itemSize + 1]);
          if (itemSize >= 3)
            bufferAttribute.setZ(index, sparseValues[i2 * itemSize + 2]);
          if (itemSize >= 4)
            bufferAttribute.setW(index, sparseValues[i2 * itemSize + 3]);
          if (itemSize >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return bufferAttribute;
    });
  }
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const sourceIndex = textureDef.source;
    const sourceDef = json.images[sourceIndex];
    let loader = this.textureLoader;
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader);
  }
  loadTextureImage(textureIndex, sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const textureDef = json.textures[textureIndex];
    const sourceDef = json.images[sourceIndex];
    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture2) {
      texture2.flipY = false;
      if (textureDef.name)
        texture2.name = textureDef.name;
      const samplers = json.samplers || {};
      const sampler2 = samplers[textureDef.sampler] || {};
      texture2.magFilter = WEBGL_FILTERS[sampler2.magFilter] || LinearFilter;
      texture2.minFilter = WEBGL_FILTERS[sampler2.minFilter] || LinearMipmapLinearFilter;
      texture2.wrapS = WEBGL_WRAPPINGS[sampler2.wrapS] || RepeatWrapping;
      texture2.wrapT = WEBGL_WRAPPINGS[sampler2.wrapT] || RepeatWrapping;
      parser.associations.set(texture2, {
        textures: textureIndex
      });
      return texture2;
    }).catch(function() {
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  loadImageSource(sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then((texture2) => texture2.clone());
    }
    const sourceDef = json.images[sourceIndex];
    const URL2 = self.URL || self.webkitURL;
    let sourceURI = sourceDef.uri || "";
    let isObjectURL = false;
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], {
          type: sourceDef.mimeType
        });
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (sourceDef.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture2 = new Texture(imageBitmap);
            texture2.needsUpdate = true;
            resolve(texture2);
          };
        }
        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture2) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      texture2.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
      return texture2;
    }).catch(function(error) {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      throw error;
    });
    this.sourceCache[sourceIndex] = promise;
    return promise;
  }
  assignTexture(materialParams, mapName, mapDef, encoding) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture2) {
      if (mapDef.texCoord !== void 0 && mapDef.texCoord != 0 && !(mapName === "aoMap" && mapDef.texCoord == 1)) {
        console.warn("THREE.GLTFLoader: Custom UV set " + mapDef.texCoord + " for texture " + mapName + " not yet supported.");
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform) {
          const gltfReference = parser.associations.get(texture2);
          texture2 = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture2, transform);
          parser.associations.set(texture2, gltfReference);
        }
      }
      if (encoding !== void 0) {
        texture2.encoding = encoding;
      }
      materialParams[mapName] = texture2;
      return texture2;
    });
  }
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (material.isGLTFSpecularGlossinessMaterial)
        cacheKey += "specular-glossiness:";
      if (useDerivativeTangents)
        cacheKey += "derivative-tangents:";
      if (useVertexColors)
        cacheKey += "vertex-colors:";
      if (useFlatShading)
        cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors)
          cachedMaterial.vertexColors = true;
        if (useFlatShading)
          cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale)
            cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale)
            cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    if (material.aoMap && geometry.attributes.uv2 === void 0 && geometry.attributes.uv !== void 0) {
      geometry.setAttribute("uv2", geometry.attributes.uv);
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      materialType = sgExtension.getMaterialType();
      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, sRGBEncoding));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale, scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, sRGBEncoding));
    }
    return Promise.all(pending).then(function() {
      let material;
      if (materialType === GLTFMeshStandardSGMaterial) {
        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
      } else {
        material = new materialType(materialParams);
      }
      if (materialDef.name)
        material.name = materialDef.name;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, {
        materials: materialIndex
      });
      if (materialDef.extensions)
        addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    let name = sanitizedName;
    for (let i2 = 1; this.nodeNamesUsed[name]; ++i2) {
      name = sanitizedName + "_" + i2;
    }
    this.nodeNamesUsed[name] = true;
    return name;
  }
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i2 = 0, il = primitives.length; i2 < il; i2++) {
      const primitive = primitives[i2];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = {
          primitive,
          promise: geometryPromise
        };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i2 = 0, il = primitives.length; i2 < il; i2++) {
      const material = primitives[i2].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i2].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i2 = 0, il = geometries.length; i2 < il; i2++) {
        const geometry = geometries[i2];
        const primitive = primitives[i2];
        let mesh;
        const material = materials[i2];
        if (primitive.mode === WEBGL_CONSTANTS2.TRIANGLES || primitive.mode === WEBGL_CONSTANTS2.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS2.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS2.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode2(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS2.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode2(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS2.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS2.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS2.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS2.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions)
          addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
        parser.associations.set(meshes[i2], {
          meshes: meshIndex,
          primitives: i2
        });
      }
      if (meshes.length === 1) {
        return meshes[0];
      }
      const group = new Group();
      parser.associations.set(group, {
        meshes: meshIndex
      });
      for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
        group.add(meshes[i2]);
      }
      return group;
    });
  }
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name)
      camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const skinEntry = {
      joints: skinDef.joints
    };
    if (skinDef.inverseBindMatrices === void 0) {
      return Promise.resolve(skinEntry);
    }
    return this.getDependency("accessor", skinDef.inverseBindMatrices).then(function(accessor) {
      skinEntry.inverseBindMatrices = accessor;
      return skinEntry;
    });
  }
  loadAnimation(animationIndex) {
    const json = this.json;
    const animationDef = json.animations[animationIndex];
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i2 = 0, il = animationDef.channels.length; i2 < il; i2++) {
      const channel = animationDef.channels[i2];
      const sampler2 = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler2.input] : sampler2.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler2.output] : sampler2.output;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler2);
      pendingTargets.push(target);
    }
    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i2 = 0, il = nodes.length; i2 < il; i2++) {
        const node = nodes[i2];
        const inputAccessor = inputAccessors[i2];
        const outputAccessor = outputAccessors[i2];
        const sampler2 = samplers[i2];
        const target = targets[i2];
        if (node === void 0)
          continue;
        node.updateMatrix();
        let TypedKeyframeTrack;
        switch (PATH_PROPERTIES2[target.path]) {
          case PATH_PROPERTIES2.weights:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES2.rotation:
            TypedKeyframeTrack = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES2.position:
          case PATH_PROPERTIES2.scale:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        const targetName = node.name ? node.name : node.uuid;
        const interpolation = sampler2.interpolation !== void 0 ? INTERPOLATION[sampler2.interpolation] : InterpolateLinear;
        const targetNames = [];
        if (PATH_PROPERTIES2[target.path] === PATH_PROPERTIES2.weights) {
          node.traverse(function(object) {
            if (object.morphTargetInfluences) {
              targetNames.push(object.name ? object.name : object.uuid);
            }
          });
        } else {
          targetNames.push(targetName);
        }
        let outputArray = outputAccessor.array;
        if (outputAccessor.normalized) {
          const scale = getNormalizedComponentScale(outputArray.constructor);
          const scaled = new Float32Array(outputArray.length);
          for (let j2 = 0, jl2 = outputArray.length; j2 < jl2; j2++) {
            scaled[j2] = outputArray[j2] * scale;
          }
          outputArray = scaled;
        }
        for (let j2 = 0, jl2 = targetNames.length; j2 < jl2; j2++) {
          const track = new TypedKeyframeTrack(targetNames[j2] + "." + PATH_PROPERTIES2[target.path], inputAccessor.array, outputArray, interpolation);
          if (sampler2.interpolation === "CUBICSPLINE") {
            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
              const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
            };
            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
          }
          tracks.push(track);
        }
      }
      const name = animationDef.name ? animationDef.name : "animation_" + animationIndex;
      return new AnimationClip(name, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0)
      return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o) {
          if (!o.isMesh)
            return;
          for (let i2 = 0, il = nodeDef.weights.length; i2 < il; i2++) {
            o.morphTargetInfluences[i2] = nodeDef.weights[i2];
          }
        });
      }
      return node;
    });
  }
  loadNode(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    return function() {
      const pending = [];
      const meshPromise = parser._invokeOne(function(ext) {
        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
      });
      if (meshPromise) {
        pending.push(meshPromise);
      }
      if (nodeDef.camera !== void 0) {
        pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
        }));
      }
      parser._invokeAll(function(ext) {
        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
      }).forEach(function(promise) {
        pending.push(promise);
      });
      return Promise.all(pending);
    }().then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i2 = 0, il = objects.length; i2 < il; i2++) {
          node.add(objects[i2]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions)
        addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix3 = new Matrix4();
        matrix3.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix3);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
  }
  loadScene(sceneIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene = new Group();
    if (sceneDef.name)
      scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions)
      addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i2 = 0, il = nodeIds.length; i2 < il; i2++) {
      pending.push(buildNodeHierarchy(nodeIds[i2], scene, json, parser));
    }
    return Promise.all(pending).then(function() {
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene);
      return scene;
    });
  }
};
function buildNodeHierarchy(nodeId, parentObject, json, parser) {
  const nodeDef = json.nodes[nodeId];
  return parser.getDependency("node", nodeId).then(function(node) {
    if (nodeDef.skin === void 0)
      return node;
    let skinEntry;
    return parser.getDependency("skin", nodeDef.skin).then(function(skin) {
      skinEntry = skin;
      const pendingJoints = [];
      for (let i2 = 0, il = skinEntry.joints.length; i2 < il; i2++) {
        pendingJoints.push(parser.getDependency("node", skinEntry.joints[i2]));
      }
      return Promise.all(pendingJoints);
    }).then(function(jointNodes) {
      node.traverse(function(mesh) {
        if (!mesh.isMesh)
          return;
        const bones = [];
        const boneInverses = [];
        for (let j2 = 0, jl2 = jointNodes.length; j2 < jl2; j2++) {
          const jointNode = jointNodes[j2];
          if (jointNode) {
            bones.push(jointNode);
            const mat = new Matrix4();
            if (skinEntry.inverseBindMatrices !== void 0) {
              mat.fromArray(skinEntry.inverseBindMatrices.array, j2 * 16);
            }
            boneInverses.push(mat);
          } else {
            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j2]);
          }
        }
        mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
      });
      return node;
    });
  }).then(function(node) {
    parentObject.add(node);
    const pending = [];
    if (nodeDef.children) {
      const children = nodeDef.children;
      for (let i2 = 0, il = children.length; i2 < il; i2++) {
        const child = children[i2];
        pending.push(buildNodeHierarchy(child, node, json, parser));
      }
    }
    return Promise.all(pending);
  });
}
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min2 = accessor.min;
    const max3 = accessor.max;
    if (min2 !== void 0 && max3 !== void 0) {
      box.set(new Vector3(min2[0], min2[1], min2[2]), new Vector3(max3[0], max3[1], max3[2]));
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector2 = new Vector3();
    for (let i2 = 0, il = targets.length; i2 < il; i2++) {
      const target = targets[i2];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min2 = accessor.min;
        const max3 = accessor.max;
        if (min2 !== void 0 && max3 !== void 0) {
          vector2.setX(Math.max(Math.abs(min2[0]), Math.abs(max3[0])));
          vector2.setY(Math.max(Math.abs(min2[1]), Math.abs(max3[1])));
          vector2.setZ(Math.max(Math.abs(min2[2]), Math.abs(max3[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector2.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector2);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere = new Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes)
      continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}
function toTrianglesDrawMode2(geometry, drawMode) {
  let index = geometry.getIndex();
  if (index === null) {
    const indices = [];
    const position = geometry.getAttribute("position");
    if (position !== void 0) {
      for (let i2 = 0; i2 < position.count; i2++) {
        indices.push(i2);
      }
      geometry.setIndex(indices);
      index = geometry.getIndex();
    } else {
      console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
      return geometry;
    }
  }
  const numberOfTriangles = index.count - 2;
  const newIndices = [];
  if (drawMode === TriangleFanDrawMode) {
    for (let i2 = 1; i2 <= numberOfTriangles; i2++) {
      newIndices.push(index.getX(0));
      newIndices.push(index.getX(i2));
      newIndices.push(index.getX(i2 + 1));
    }
  } else {
    for (let i2 = 0; i2 < numberOfTriangles; i2++) {
      if (i2 % 2 === 0) {
        newIndices.push(index.getX(i2));
        newIndices.push(index.getX(i2 + 1));
        newIndices.push(index.getX(i2 + 2));
      } else {
        newIndices.push(index.getX(i2 + 2));
        newIndices.push(index.getX(i2 + 1));
        newIndices.push(index.getX(i2));
      }
    }
  }
  if (newIndices.length / 3 !== numberOfTriangles) {
    console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
  }
  const newGeometry = geometry.clone();
  newGeometry.setIndex(newIndices);
  return newGeometry;
}

// node_modules/three-stdlib/webxr/XRHandMeshModel.js
var DEFAULT_HAND_PROFILE_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/";
var XRHandMeshModel = class {
  constructor(handModel, controller, path = DEFAULT_HAND_PROFILE_PATH, handedness, customModelPath) {
    _defineProperty(this, "controller", void 0);
    _defineProperty(this, "handModel", void 0);
    _defineProperty(this, "bones", void 0);
    this.controller = controller;
    this.handModel = handModel;
    this.bones = [];
    const loader = new GLTFLoader();
    if (!customModelPath)
      loader.setPath(path);
    loader.load(customModelPath != null ? customModelPath : `${handedness}.glb`, (gltf) => {
      const object = gltf.scene.children[0];
      this.handModel.add(object);
      const mesh = object.getObjectByProperty("type", "SkinnedMesh");
      mesh.frustumCulled = false;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      const joints = ["wrist", "thumb-metacarpal", "thumb-phalanx-proximal", "thumb-phalanx-distal", "thumb-tip", "index-finger-metacarpal", "index-finger-phalanx-proximal", "index-finger-phalanx-intermediate", "index-finger-phalanx-distal", "index-finger-tip", "middle-finger-metacarpal", "middle-finger-phalanx-proximal", "middle-finger-phalanx-intermediate", "middle-finger-phalanx-distal", "middle-finger-tip", "ring-finger-metacarpal", "ring-finger-phalanx-proximal", "ring-finger-phalanx-intermediate", "ring-finger-phalanx-distal", "ring-finger-tip", "pinky-finger-metacarpal", "pinky-finger-phalanx-proximal", "pinky-finger-phalanx-intermediate", "pinky-finger-phalanx-distal", "pinky-finger-tip"];
      joints.forEach((jointName) => {
        const bone = object.getObjectByName(jointName);
        if (bone !== void 0) {
          bone.jointName = jointName;
        } else {
          console.warn(`Couldn't find ${jointName} in ${handedness} hand mesh`);
        }
        this.bones.push(bone);
      });
    });
  }
  updateMesh() {
    const XRJoints = this.controller.joints;
    for (let i2 = 0; i2 < this.bones.length; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        const XRJoint = XRJoints[bone.jointName];
        if (XRJoint.visible) {
          const position = XRJoint.position;
          bone.position.copy(position);
          bone.quaternion.copy(XRJoint.quaternion);
        }
      }
    }
  }
};

// node_modules/three-stdlib/webxr/OculusHandModel.js
var TOUCH_RADIUS = 0.01;
var POINTING_JOINT = "index-finger-tip";
var OculusHandModel = class extends Object3D {
  constructor(controller, leftModelPath, rightModelPath) {
    super();
    _defineProperty(this, "controller", void 0);
    _defineProperty(this, "motionController", void 0);
    _defineProperty(this, "envMap", void 0);
    _defineProperty(this, "mesh", void 0);
    _defineProperty(this, "xrInputSource", void 0);
    this.controller = controller;
    this.motionController = null;
    this.envMap = null;
    this.mesh = null;
    this.xrInputSource = null;
    controller.addEventListener("connected", (event) => {
      const xrInputSource = event.data;
      if (xrInputSource.hand && !this.motionController) {
        this.xrInputSource = xrInputSource;
        this.motionController = new XRHandMeshModel(this, controller, void 0, xrInputSource.handedness, xrInputSource.handedness === "left" ? leftModelPath : rightModelPath);
      }
    });
    controller.addEventListener("disconnected", () => {
      this.dispose();
    });
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.motionController) {
      this.motionController.updateMesh();
    }
  }
  getPointerPosition() {
    const indexFingerTip = this.controller.joints[POINTING_JOINT];
    if (indexFingerTip) {
      return indexFingerTip.position;
    } else {
      return null;
    }
  }
  intersectBoxObject(boxObject) {
    const pointerPosition = this.getPointerPosition();
    if (pointerPosition) {
      const indexSphere = new Sphere(pointerPosition, TOUCH_RADIUS);
      const box = new Box3().setFromObject(boxObject);
      return indexSphere.intersectsBox(box);
    } else {
      return false;
    }
  }
  checkButton(button) {
    if (this.intersectBoxObject(button)) {
      button.onPress();
    } else {
      button.onClear();
    }
    if (button.isPressed()) {
      button.whilePressed();
    }
  }
  dispose() {
    this.clear();
    this.motionController = null;
  }
};

// node_modules/three-stdlib/webxr/OculusHandPointerModel.js
var PINCH_MAX = 0.05;
var PINCH_THRESHOLD = 0.02;
var PINCH_MIN = 0.01;
var POINTER_ADVANCE_MAX = 0.02;
var POINTER_OPACITY_MAX = 1;
var POINTER_OPACITY_MIN = 0.4;
var POINTER_FRONT_RADIUS = 2e-3;
var POINTER_REAR_RADIUS = 0.01;
var POINTER_REAR_RADIUS_MIN = 3e-3;
var POINTER_LENGTH = 0.035;
var POINTER_SEGMENTS = 16;
var POINTER_RINGS = 12;
var POINTER_HEMISPHERE_ANGLE = 110;
var YAXIS = new Vector3(0, 1, 0);
var ZAXIS = new Vector3(0, 0, 1);
var CURSOR_RADIUS = 0.02;
var CURSOR_MAX_DISTANCE = 1.5;
var OculusHandPointerModel = class extends Object3D {
  constructor(hand, controller) {
    super();
    this.hand = hand;
    this.controller = controller;
    this.motionController = null;
    this.envMap = null;
    this.mesh = null;
    this.pointerGeometry = null;
    this.pointerMesh = null;
    this.pointerObject = null;
    this.pinched = false;
    this.attached = false;
    this.cursorObject = null;
    this.raycaster = null;
    hand.addEventListener("connected", (event) => {
      const xrInputSource = event.data;
      if (xrInputSource.hand) {
        this.visible = true;
        this.xrInputSource = xrInputSource;
        this.createPointer();
      }
    });
  }
  _drawVerticesRing(vertices, baseVector, ringIndex) {
    const segmentVector = baseVector.clone();
    for (var i2 = 0; i2 < POINTER_SEGMENTS; i2++) {
      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);
      const vid = ringIndex * POINTER_SEGMENTS + i2;
      vertices[3 * vid] = segmentVector.x;
      vertices[3 * vid + 1] = segmentVector.y;
      vertices[3 * vid + 2] = segmentVector.z;
    }
  }
  _updatePointerVertices(rearRadius) {
    const vertices = this.pointerGeometry.attributes.position.array;
    const frontFaceBase = new Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));
    this._drawVerticesRing(vertices, frontFaceBase, 0);
    const rearBase = new Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);
    for (var i2 = 0; i2 < POINTER_RINGS; i2++) {
      this._drawVerticesRing(vertices, rearBase, i2 + 1);
      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));
    }
    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);
    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;
    const frontCenter = new Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));
    vertices[frontCenterIndex * 3] = frontCenter.x;
    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;
    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;
    const rearCenter = new Vector3(0, 0, rearRadius);
    vertices[rearCenterIndex * 3] = rearCenter.x;
    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;
    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;
    this.pointerGeometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  }
  createPointer() {
    var i2, j2;
    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0);
    const indices = [];
    this.pointerGeometry = new BufferGeometry();
    this.pointerGeometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this._updatePointerVertices(POINTER_REAR_RADIUS);
    for (i2 = 0; i2 < POINTER_RINGS; i2++) {
      for (j2 = 0; j2 < POINTER_SEGMENTS - 1; j2++) {
        indices.push(i2 * POINTER_SEGMENTS + j2, i2 * POINTER_SEGMENTS + j2 + 1, (i2 + 1) * POINTER_SEGMENTS + j2);
        indices.push(i2 * POINTER_SEGMENTS + j2 + 1, (i2 + 1) * POINTER_SEGMENTS + j2 + 1, (i2 + 1) * POINTER_SEGMENTS + j2);
      }
      indices.push((i2 + 1) * POINTER_SEGMENTS - 1, i2 * POINTER_SEGMENTS, (i2 + 2) * POINTER_SEGMENTS - 1);
      indices.push(i2 * POINTER_SEGMENTS, (i2 + 1) * POINTER_SEGMENTS, (i2 + 2) * POINTER_SEGMENTS - 1);
    }
    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);
    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;
    for (i2 = 0; i2 < POINTER_SEGMENTS - 1; i2++) {
      indices.push(frontCenterIndex, i2 + 1, i2);
      indices.push(rearCenterIndex, i2 + POINTER_SEGMENTS * POINTER_RINGS, i2 + POINTER_SEGMENTS * POINTER_RINGS + 1);
    }
    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);
    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);
    const material = new MeshBasicMaterial();
    material.transparent = true;
    material.opacity = POINTER_OPACITY_MIN;
    this.pointerGeometry.setIndex(indices);
    this.pointerMesh = new Mesh(this.pointerGeometry, material);
    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);
    this.pointerObject = new Object3D();
    this.pointerObject.add(this.pointerMesh);
    this.raycaster = new Raycaster();
    const cursorGeometry = new SphereGeometry(CURSOR_RADIUS, 10, 10);
    const cursorMaterial = new MeshBasicMaterial();
    cursorMaterial.transparent = true;
    cursorMaterial.opacity = POINTER_OPACITY_MIN;
    this.cursorObject = new Mesh(cursorGeometry, cursorMaterial);
    this.pointerObject.add(this.cursorObject);
    this.add(this.pointerObject);
  }
  _updateRaycaster() {
    if (this.raycaster) {
      const pointerMatrix = this.pointerObject.matrixWorld;
      const tempMatrix = new Matrix4();
      tempMatrix.identity().extractRotation(pointerMatrix);
      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);
      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
    }
  }
  _updatePointer() {
    this.pointerObject.visible = this.controller.visible;
    const indexTip = this.hand.joints["index-finger-tip"];
    const thumbTip = this.hand.joints["thumb-tip"];
    const distance2 = indexTip.position.distanceTo(thumbTip.position);
    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);
    this.pointerObject.position.copy(position);
    this.pointerObject.quaternion.copy(this.controller.quaternion);
    this.pinched = distance2 <= PINCH_THRESHOLD;
    const pinchScale = (distance2 - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);
    const focusScale = (distance2 - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);
    if (pinchScale > 1) {
      this._updatePointerVertices(POINTER_REAR_RADIUS);
      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);
      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;
    } else if (pinchScale > 0) {
      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;
      this._updatePointerVertices(rearRadius);
      if (focusScale < 1) {
        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);
        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);
      } else {
        this.pointerMesh.position.set(0, 0, -1 * rearRadius);
        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;
      }
    } else {
      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);
      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);
      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;
    }
    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.pointerGeometry) {
      this._updatePointer();
      this._updateRaycaster();
    }
  }
  isPinched() {
    return this.pinched;
  }
  setAttached(attached) {
    this.attached = attached;
  }
  isAttached() {
    return this.attached;
  }
  intersectObject(object, recursive = true) {
    if (this.raycaster) {
      return this.raycaster.intersectObject(object, recursive);
    }
  }
  intersectObjects(objects, recursive = true) {
    if (this.raycaster) {
      return this.raycaster.intersectObjects(objects, recursive);
    }
  }
  checkIntersections(objects, recursive = false) {
    if (this.raycaster && !this.attached) {
      const intersections = this.raycaster.intersectObjects(objects, recursive);
      const direction = new Vector3(0, 0, -1);
      if (intersections.length > 0) {
        const intersection = intersections[0];
        const distance2 = intersection.distance;
        this.cursorObject.position.copy(direction.multiplyScalar(distance2));
      } else {
        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));
      }
    }
  }
  setCursor(distance2) {
    const direction = new Vector3(0, 0, -1);
    if (this.raycaster && !this.attached) {
      this.cursorObject.position.copy(direction.multiplyScalar(distance2));
    }
  }
};

// node_modules/three-stdlib/webxr/Text2D.js
function createText(message, height) {
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  let metrics = null;
  const textHeight = 100;
  context.font = "normal " + textHeight + "px Arial";
  metrics = context.measureText(message);
  const textWidth = metrics.width;
  canvas.width = textWidth;
  canvas.height = textHeight;
  context.font = "normal " + textHeight + "px Arial";
  context.textAlign = "center";
  context.textBaseline = "middle";
  context.fillStyle = "#ffffff";
  context.fillText(message, textWidth / 2, textHeight / 2);
  const texture2 = new Texture(canvas);
  texture2.needsUpdate = true;
  const material = new MeshBasicMaterial({
    color: 16777215,
    side: DoubleSide,
    map: texture2,
    transparent: true
  });
  const geometry = new PlaneGeometry(height * textWidth / textHeight, height);
  const plane = new Mesh(geometry, material);
  return plane;
}

// node_modules/three-stdlib/webxr/VRButton.js
var VRButton = class {
  static createButton(renderer, sessionInit = {}) {
    const button = document.createElement("button");
    function showEnterVR() {
      let currentSession = null;
      async function onSessionStarted(session) {
        session.addEventListener("end", onSessionEnded);
        await renderer.xr.setSession(session);
        button.textContent = "EXIT VR";
        currentSession = session;
      }
      function onSessionEnded() {
        currentSession.removeEventListener("end", onSessionEnded);
        button.textContent = "ENTER VR";
        currentSession = null;
      }
      button.style.display = "";
      button.style.cursor = "pointer";
      button.style.left = "calc(50% - 50px)";
      button.style.width = "100px";
      button.textContent = "ENTER VR";
      button.onmouseenter = () => {
        button.style.opacity = "1.0";
      };
      button.onmouseleave = () => {
        button.style.opacity = "0.5";
      };
      button.onclick = () => {
        if (currentSession === null) {
          var _xr;
          const optionalFeatures = [sessionInit.optionalFeatures, "local-floor", "bounded-floor", "hand-tracking"].flat().filter(Boolean);
          (_xr = navigator.xr) === null || _xr === void 0 ? void 0 : _xr.requestSession("immersive-vr", {
            ...sessionInit,
            optionalFeatures
          }).then(onSessionStarted);
        } else {
          currentSession.end();
        }
      };
    }
    function disableButton() {
      button.style.display = "";
      button.style.cursor = "auto";
      button.style.left = "calc(50% - 75px)";
      button.style.width = "150px";
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }
    function showWebXRNotFound() {
      disableButton();
      button.textContent = "VR NOT SUPPORTED";
    }
    function stylizeElement(element2) {
      element2.style.position = "absolute";
      element2.style.bottom = "20px";
      element2.style.padding = "12px 6px";
      element2.style.border = "1px solid #fff";
      element2.style.borderRadius = "4px";
      element2.style.background = "rgba(0,0,0,0.1)";
      element2.style.color = "#fff";
      element2.style.font = "normal 13px sans-serif";
      element2.style.textAlign = "center";
      element2.style.opacity = "0.5";
      element2.style.outline = "none";
      element2.style.zIndex = "999";
    }
    if ("xr" in navigator) {
      stylizeElement(button);
      button.id = "VRButton";
      button.style.display = "none";
      navigator.xr.isSessionSupported("immersive-vr").then((supported) => {
        supported ? showEnterVR() : showWebXRNotFound();
        if (supported && VRButton.xrSessionIsGranted) {
          button.click();
        }
      });
      return button;
    } else {
      const message = document.createElement("a");
      if (window.isSecureContext === false) {
        message.href = document.location.href.replace(/^http:/, "https:");
        message.innerHTML = "WEBXR NEEDS HTTPS";
      } else {
        message.href = "https://immersiveweb.dev/";
        message.innerHTML = "WEBXR NOT AVAILABLE";
      }
      message.style.left = "calc(50% - 90px)";
      message.style.width = "180px";
      message.style.textDecoration = "none";
      stylizeElement(message);
      return message;
    }
  }
  static registerSessionGrantedListener() {
    if ("xr" in navigator) {
      navigator.xr.addEventListener("sessiongranted", () => {
        VRButton.xrSessionIsGranted = true;
      });
    }
  }
};
_defineProperty(VRButton, "xrSessionIsGranted", false);

// node_modules/three-stdlib/libs/MotionControllers.js
var MotionControllerConstants = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function fetchJsonFile(path) {
  const response = await fetch(path);
  if (!response.ok) {
    throw new Error(response.statusText);
  } else {
    return response.json();
  }
}
async function fetchProfilesList(basePath) {
  if (!basePath) {
    throw new Error("No basePath supplied");
  }
  const profileListFileName = "profilesList.json";
  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);
  return profilesList;
}
async function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {
  if (!xrInputSource) {
    throw new Error("No xrInputSource supplied");
  }
  if (!basePath) {
    throw new Error("No basePath supplied");
  }
  const supportedProfilesList = await fetchProfilesList(basePath);
  let match;
  xrInputSource.profiles.some((profileId) => {
    const supportedProfile = supportedProfilesList[profileId];
    if (supportedProfile) {
      match = {
        profileId,
        profilePath: `${basePath}/${supportedProfile.path}`,
        deprecated: !!supportedProfile.deprecated
      };
    }
    return !!match;
  });
  if (!match) {
    if (!defaultProfile) {
      throw new Error("No matching profile name found");
    }
    const supportedProfile = supportedProfilesList[defaultProfile];
    if (!supportedProfile) {
      throw new Error(`No matching profile name found and default profile "${defaultProfile}" missing.`);
    }
    match = {
      profileId: defaultProfile,
      profilePath: `${basePath}/${supportedProfile.path}`,
      deprecated: !!supportedProfile.deprecated
    };
  }
  const profile = await fetchJsonFile(match.profilePath);
  let assetPath;
  if (getAssetPath) {
    let layout;
    if (xrInputSource.handedness === "any") {
      layout = profile.layouts[Object.keys(profile.layouts)[0]];
    } else {
      layout = profile.layouts[xrInputSource.handedness];
    }
    if (!layout) {
      throw new Error(`No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`);
    }
    if (layout.assetPath) {
      assetPath = match.profilePath.replace("profile.json", layout.assetPath);
    }
  }
  return {
    profile,
    assetPath
  };
}
var defaultComponentValues = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: MotionControllerConstants.ComponentState.DEFAULT
};
function normalizeAxes(x = 0, y = 0) {
  let xAxis2 = x;
  let yAxis2 = y;
  const hypotenuse = Math.sqrt(x * x + y * y);
  if (hypotenuse > 1) {
    const theta = Math.atan2(y, x);
    xAxis2 = Math.cos(theta);
    yAxis2 = Math.sin(theta);
  }
  const result = {
    normalizedXAxis: xAxis2 * 0.5 + 0.5,
    normalizedYAxis: yAxis2 * 0.5 + 0.5
  };
  return result;
}
var VisualResponse = class {
  constructor(visualResponseDescription) {
    this.componentProperty = visualResponseDescription.componentProperty;
    this.states = visualResponseDescription.states;
    this.valueNodeName = visualResponseDescription.valueNodeName;
    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;
    if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM) {
      this.minNodeName = visualResponseDescription.minNodeName;
      this.maxNodeName = visualResponseDescription.maxNodeName;
    }
    this.value = 0;
    this.updateFromComponent(defaultComponentValues);
  }
  updateFromComponent({
    xAxis: xAxis2,
    yAxis: yAxis2,
    button,
    state
  }) {
    const {
      normalizedXAxis,
      normalizedYAxis
    } = normalizeAxes(xAxis2, yAxis2);
    switch (this.componentProperty) {
      case MotionControllerConstants.ComponentProperty.X_AXIS:
        this.value = this.states.includes(state) ? normalizedXAxis : 0.5;
        break;
      case MotionControllerConstants.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(state) ? normalizedYAxis : 0.5;
        break;
      case MotionControllerConstants.ComponentProperty.BUTTON:
        this.value = this.states.includes(state) ? button : 0;
        break;
      case MotionControllerConstants.ComponentProperty.STATE:
        if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY) {
          this.value = this.states.includes(state);
        } else {
          this.value = this.states.includes(state) ? 1 : 0;
        }
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
};
var Component = class {
  constructor(componentId, componentDescription) {
    if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {
      throw new Error("Invalid arguments supplied");
    }
    this.id = componentId;
    this.type = componentDescription.type;
    this.rootNodeName = componentDescription.rootNodeName;
    this.touchPointNodeName = componentDescription.touchPointNodeName;
    this.visualResponses = {};
    Object.keys(componentDescription.visualResponses).forEach((responseName) => {
      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);
      this.visualResponses[responseName] = visualResponse;
    });
    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);
    this.values = {
      state: MotionControllerConstants.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    const data = {
      id: this.id,
      ...this.values
    };
    return data;
  }
  updateFromGamepad(gamepad) {
    this.values.state = MotionControllerConstants.ComponentState.DEFAULT;
    if (this.gamepadIndices.button !== void 0 && gamepad.buttons.length > this.gamepadIndices.button) {
      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];
      this.values.button = gamepadButton.value;
      this.values.button = this.values.button < 0 ? 0 : this.values.button;
      this.values.button = this.values.button > 1 ? 1 : this.values.button;
      if (gamepadButton.pressed || this.values.button === 1) {
        this.values.state = MotionControllerConstants.ComponentState.PRESSED;
      } else if (gamepadButton.touched || this.values.button > MotionControllerConstants.ButtonTouchThreshold) {
        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;
      }
    }
    if (this.gamepadIndices.xAxis !== void 0 && gamepad.axes.length > this.gamepadIndices.xAxis) {
      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];
      this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;
      this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis;
      if (this.values.state === MotionControllerConstants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > MotionControllerConstants.AxisTouchThreshold) {
        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;
      }
    }
    if (this.gamepadIndices.yAxis !== void 0 && gamepad.axes.length > this.gamepadIndices.yAxis) {
      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];
      this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;
      this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis;
      if (this.values.state === MotionControllerConstants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > MotionControllerConstants.AxisTouchThreshold) {
        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;
      }
    }
    Object.values(this.visualResponses).forEach((visualResponse) => {
      visualResponse.updateFromComponent(this.values);
    });
  }
};
var MotionController = class {
  constructor(xrInputSource, profile, assetUrl) {
    if (!xrInputSource) {
      throw new Error("No xrInputSource supplied");
    }
    if (!profile) {
      throw new Error("No profile supplied");
    }
    this.xrInputSource = xrInputSource;
    this.assetUrl = assetUrl;
    this.id = profile.profileId;
    this.layoutDescription = profile.layouts[xrInputSource.handedness];
    this.components = {};
    Object.keys(this.layoutDescription.components).forEach((componentId) => {
      const componentDescription = this.layoutDescription.components[componentId];
      this.components[componentId] = new Component(componentId, componentDescription);
    });
    this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  get data() {
    const data = [];
    Object.values(this.components).forEach((component) => {
      data.push(component.data);
    });
    return data;
  }
  updateFromGamepad() {
    Object.values(this.components).forEach((component) => {
      component.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
};

// node_modules/three-stdlib/webxr/XRControllerModelFactory.js
var DEFAULT_PROFILES_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles";
var DEFAULT_PROFILE = "generic-trigger";
var XRControllerModel = class extends Object3D {
  constructor() {
    super();
    this.motionController = null;
    this.envMap = null;
  }
  setEnvironmentMap(envMap) {
    if (this.envMap == envMap) {
      return this;
    }
    this.envMap = envMap;
    this.traverse((child) => {
      if (child.isMesh) {
        child.material.envMap = this.envMap;
        child.material.needsUpdate = true;
      }
    });
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (!this.motionController)
      return;
    this.motionController.updateFromGamepad();
    Object.values(this.motionController.components).forEach((component) => {
      Object.values(component.visualResponses).forEach((visualResponse) => {
        const {
          valueNode,
          minNode,
          maxNode,
          value,
          valueNodeProperty
        } = visualResponse;
        if (!valueNode)
          return;
        if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY) {
          valueNode.visible = value;
        } else if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM) {
          valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);
          valueNode.position.lerpVectors(minNode.position, maxNode.position, value);
        }
      });
    });
  }
};
function findNodes(motionController, scene) {
  Object.values(motionController.components).forEach((component) => {
    const {
      type: type2,
      touchPointNodeName,
      visualResponses
    } = component;
    if (type2 === MotionControllerConstants.ComponentType.TOUCHPAD) {
      component.touchPointNode = scene.getObjectByName(touchPointNodeName);
      if (component.touchPointNode) {
        const sphereGeometry = new SphereGeometry(1e-3);
        const material = new MeshBasicMaterial({
          color: 255
        });
        const sphere = new Mesh(sphereGeometry, material);
        component.touchPointNode.add(sphere);
      } else {
        console.warn(`Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}`);
      }
    }
    Object.values(visualResponses).forEach((visualResponse) => {
      const {
        valueNodeName,
        minNodeName,
        maxNodeName,
        valueNodeProperty
      } = visualResponse;
      if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM) {
        visualResponse.minNode = scene.getObjectByName(minNodeName);
        visualResponse.maxNode = scene.getObjectByName(maxNodeName);
        if (!visualResponse.minNode) {
          console.warn(`Could not find ${minNodeName} in the model`);
          return;
        }
        if (!visualResponse.maxNode) {
          console.warn(`Could not find ${maxNodeName} in the model`);
          return;
        }
      }
      visualResponse.valueNode = scene.getObjectByName(valueNodeName);
      if (!visualResponse.valueNode) {
        console.warn(`Could not find ${valueNodeName} in the model`);
      }
    });
  });
}
function addAssetSceneToControllerModel(controllerModel, scene) {
  findNodes(controllerModel.motionController, scene);
  if (controllerModel.envMap) {
    scene.traverse((child) => {
      if (child.isMesh) {
        child.material.envMap = controllerModel.envMap;
        child.material.needsUpdate = true;
      }
    });
  }
  controllerModel.add(scene);
}
var XRControllerModelFactory = class {
  constructor(gltfLoader = null) {
    this.gltfLoader = gltfLoader;
    this.path = DEFAULT_PROFILES_PATH;
    this._assetCache = {};
    if (!this.gltfLoader) {
      this.gltfLoader = new GLTFLoader();
    }
  }
  createControllerModel(controller) {
    const controllerModel = new XRControllerModel();
    let scene = null;
    controller.addEventListener("connected", (event) => {
      const xrInputSource = event.data;
      if (xrInputSource.targetRayMode !== "tracked-pointer" || !xrInputSource.gamepad)
        return;
      fetchProfile(xrInputSource, this.path, DEFAULT_PROFILE).then(({
        profile,
        assetPath
      }) => {
        controllerModel.motionController = new MotionController(xrInputSource, profile, assetPath);
        const cachedAsset = this._assetCache[controllerModel.motionController.assetUrl];
        if (cachedAsset) {
          scene = cachedAsset.scene.clone();
          addAssetSceneToControllerModel(controllerModel, scene);
        } else {
          if (!this.gltfLoader) {
            throw new Error("GLTFLoader not set.");
          }
          this.gltfLoader.setPath("");
          this.gltfLoader.load(controllerModel.motionController.assetUrl, (asset) => {
            this._assetCache[controllerModel.motionController.assetUrl] = asset;
            scene = asset.scene.clone();
            addAssetSceneToControllerModel(controllerModel, scene);
          }, null, () => {
            throw new Error(`Asset ${controllerModel.motionController.assetUrl} missing or malformed.`);
          });
        }
      }).catch((err) => {
        console.warn(err);
      });
    });
    controller.addEventListener("disconnected", () => {
      controllerModel.motionController = null;
      controllerModel.remove(scene);
      scene = null;
    });
    return controllerModel;
  }
};

// node_modules/three-stdlib/webxr/XREstimatedLight.js
var SessionLightProbe = class {
  constructor(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {
    this.xrLight = xrLight;
    this.renderer = renderer;
    this.lightProbe = lightProbe;
    this.xrWebGLBinding = null;
    this.estimationStartCallback = estimationStartCallback;
    this.frameCallback = this.onXRFrame.bind(this);
    const session = renderer.xr.getSession();
    if (environmentEstimation && "XRWebGLBinding" in window) {
      const cubeRenderTarget = new WebGLCubeRenderTarget(16);
      xrLight.environment = cubeRenderTarget.texture;
      const gl = renderer.getContext();
      switch (session.preferredReflectionFormat) {
        case "srgba8":
          gl.getExtension("EXT_sRGB");
          break;
        case "rgba16f":
          gl.getExtension("OES_texture_half_float");
          break;
      }
      this.xrWebGLBinding = new XRWebGLBinding(session, gl);
      this.lightProbe.addEventListener("reflectionchange", () => {
        this.updateReflection();
      });
    }
    session.requestAnimationFrame(this.frameCallback);
  }
  updateReflection() {
    const textureProperties = this.renderer.properties.get(this.xrLight.environment);
    if (textureProperties) {
      const cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);
      if (cubeMap) {
        textureProperties.__webglTexture = cubeMap;
        this.xrLight.environment.needsPMREMUpdate = true;
      }
    }
  }
  onXRFrame(time, xrFrame) {
    if (!this.xrLight) {
      return;
    }
    const session = xrFrame.session;
    session.requestAnimationFrame(this.frameCallback);
    const lightEstimate = xrFrame.getLightEstimate(this.lightProbe);
    if (lightEstimate) {
      this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients);
      this.xrLight.lightProbe.intensity = 1;
      const intensityScalar = Math.max(1, Math.max(lightEstimate.primaryLightIntensity.x, Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z)));
      this.xrLight.directionalLight.color.setRGB(lightEstimate.primaryLightIntensity.x / intensityScalar, lightEstimate.primaryLightIntensity.y / intensityScalar, lightEstimate.primaryLightIntensity.z / intensityScalar);
      this.xrLight.directionalLight.intensity = intensityScalar;
      this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection);
      if (this.estimationStartCallback) {
        this.estimationStartCallback();
        this.estimationStartCallback = null;
      }
    }
  }
  dispose() {
    this.xrLight = null;
    this.renderer = null;
    this.lightProbe = null;
    this.xrWebGLBinding = null;
  }
};
var XREstimatedLight = class extends Group {
  constructor(renderer, environmentEstimation = true) {
    super();
    this.lightProbe = new LightProbe();
    this.lightProbe.intensity = 0;
    this.add(this.lightProbe);
    this.directionalLight = new DirectionalLight();
    this.directionalLight.intensity = 0;
    this.add(this.directionalLight);
    this.environment = null;
    let sessionLightProbe = null;
    let estimationStarted = false;
    renderer.xr.addEventListener("sessionstart", () => {
      const session = renderer.xr.getSession();
      if ("requestLightProbe" in session) {
        session.requestLightProbe({
          reflectionFormat: session.preferredReflectionFormat
        }).then((probe) => {
          sessionLightProbe = new SessionLightProbe(this, renderer, probe, environmentEstimation, () => {
            estimationStarted = true;
            this.dispatchEvent({
              type: "estimationstart"
            });
          });
        });
      }
    });
    renderer.xr.addEventListener("sessionend", () => {
      if (sessionLightProbe) {
        sessionLightProbe.dispose();
        sessionLightProbe = null;
      }
      if (estimationStarted) {
        this.dispatchEvent({
          type: "estimationend"
        });
      }
    });
    this.dispose = () => {
      if (sessionLightProbe) {
        sessionLightProbe.dispose();
        sessionLightProbe = null;
      }
      this.remove(this.lightProbe);
      this.lightProbe = null;
      this.remove(this.directionalLight);
      this.directionalLight = null;
      this.environment = null;
    };
  }
};

// node_modules/three-stdlib/webxr/XRHandPrimitiveModel.js
var _matrix = new Matrix4();
var _vector = new Vector3();
var XRHandPrimitiveModel = class {
  constructor(handModel, controller, path, handedness, options) {
    this.controller = controller;
    this.handModel = handModel;
    this.envMap = null;
    let geometry;
    if (!options || !options.primitive || options.primitive === "sphere") {
      geometry = new SphereGeometry(1, 10, 10);
    } else if (options.primitive === "box") {
      geometry = new BoxGeometry(1, 1, 1);
    }
    const material = new MeshStandardMaterial();
    this.handMesh = new InstancedMesh(geometry, material, 30);
    this.handMesh.instanceMatrix.setUsage(DynamicDrawUsage);
    this.handMesh.castShadow = true;
    this.handMesh.receiveShadow = true;
    this.handModel.add(this.handMesh);
    this.joints = ["wrist", "thumb-metacarpal", "thumb-phalanx-proximal", "thumb-phalanx-distal", "thumb-tip", "index-finger-metacarpal", "index-finger-phalanx-proximal", "index-finger-phalanx-intermediate", "index-finger-phalanx-distal", "index-finger-tip", "middle-finger-metacarpal", "middle-finger-phalanx-proximal", "middle-finger-phalanx-intermediate", "middle-finger-phalanx-distal", "middle-finger-tip", "ring-finger-metacarpal", "ring-finger-phalanx-proximal", "ring-finger-phalanx-intermediate", "ring-finger-phalanx-distal", "ring-finger-tip", "pinky-finger-metacarpal", "pinky-finger-phalanx-proximal", "pinky-finger-phalanx-intermediate", "pinky-finger-phalanx-distal", "pinky-finger-tip"];
  }
  updateMesh() {
    const defaultRadius = 8e-3;
    const joints = this.controller.joints;
    let count = 0;
    for (let i2 = 0; i2 < this.joints.length; i2++) {
      const joint = joints[this.joints[i2]];
      if (joint.visible) {
        _vector.setScalar(joint.jointRadius || defaultRadius);
        _matrix.compose(joint.position, joint.quaternion, _vector);
        this.handMesh.setMatrixAt(i2, _matrix);
        count++;
      }
    }
    this.handMesh.count = count;
    this.handMesh.instanceMatrix.needsUpdate = true;
  }
};

// node_modules/three-stdlib/webxr/XRHandModelFactory.js
var XRHandModel = class extends Object3D {
  constructor(controller) {
    super();
    this.controller = controller;
    this.motionController = null;
    this.envMap = null;
    this.mesh = null;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.motionController) {
      this.motionController.updateMesh();
    }
  }
};
var XRHandModelFactory = class {
  constructor() {
    this.path = null;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  createHandModel(controller, profile) {
    const handModel = new XRHandModel(controller);
    controller.addEventListener("connected", (event) => {
      const xrInputSource = event.data;
      if (xrInputSource.hand && !handModel.motionController) {
        handModel.xrInputSource = xrInputSource;
        if (profile === void 0 || profile === "spheres") {
          handModel.motionController = new XRHandPrimitiveModel(handModel, controller, this.path, xrInputSource.handedness, {
            primitive: "sphere"
          });
        } else if (profile === "boxes") {
          handModel.motionController = new XRHandPrimitiveModel(handModel, controller, this.path, xrInputSource.handedness, {
            primitive: "box"
          });
        } else if (profile === "mesh") {
          handModel.motionController = new XRHandMeshModel(handModel, controller, this.path, xrInputSource.handedness);
        }
      }
    });
    controller.addEventListener("disconnected", () => {
    });
    return handModel;
  }
};

// node_modules/three-stdlib/geometries/ParametricGeometry.js
var ParametricGeometry = class extends BufferGeometry {
  constructor(func = (u, v, target) => target.set(u, v, Math.cos(u) * Math.sin(v)), slices = 8, stacks = 8) {
    super();
    this.type = "ParametricGeometry";
    this.parameters = {
      func,
      slices,
      stacks
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const EPS = 1e-5;
    const normal = new Vector3();
    const p0 = new Vector3(), p1 = new Vector3();
    const pu = new Vector3(), pv = new Vector3();
    const sliceCount = slices + 1;
    for (let i2 = 0; i2 <= stacks; i2++) {
      const v = i2 / stacks;
      for (let j2 = 0; j2 <= slices; j2++) {
        const u = j2 / slices;
        func(u, v, p0);
        vertices.push(p0.x, p0.y, p0.z);
        if (u - EPS >= 0) {
          func(u - EPS, v, p1);
          pu.subVectors(p0, p1);
        } else {
          func(u + EPS, v, p1);
          pu.subVectors(p1, p0);
        }
        if (v - EPS >= 0) {
          func(u, v - EPS, p1);
          pv.subVectors(p0, p1);
        } else {
          func(u, v + EPS, p1);
          pv.subVectors(p1, p0);
        }
        normal.crossVectors(pu, pv).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u, v);
      }
    }
    for (let i2 = 0; i2 < stacks; i2++) {
      for (let j2 = 0; j2 < slices; j2++) {
        const a2 = i2 * sliceCount + j2;
        const b3 = i2 * sliceCount + j2 + 1;
        const c = (i2 + 1) * sliceCount + j2 + 1;
        const d = (i2 + 1) * sliceCount + j2;
        indices.push(a2, b3, d);
        indices.push(b3, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};

// node_modules/three-stdlib/geometries/ParametricGeometries.js
var ParametricGeometries = {
  klein: function(v, u, target) {
    u *= Math.PI;
    v *= 2 * Math.PI;
    u = u * 2;
    let x, z;
    if (u < Math.PI) {
      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(u) * Math.cos(v);
      z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);
    } else {
      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI);
      z = -8 * Math.sin(u);
    }
    const y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);
    target.set(x, y, z);
  },
  plane: function(width, height) {
    return function(u, v, target) {
      const x = u * width;
      const y = 0;
      const z = v * height;
      target.set(x, y, z);
    };
  },
  mobius: function(u, t2, target) {
    u = u - 0.5;
    const v = 2 * Math.PI * t2;
    const a2 = 2;
    const x = Math.cos(v) * (a2 + u * Math.cos(v / 2));
    const y = Math.sin(v) * (a2 + u * Math.cos(v / 2));
    const z = u * Math.sin(v / 2);
    target.set(x, y, z);
  },
  mobius3d: function(u, t2, target) {
    u *= Math.PI;
    t2 *= 2 * Math.PI;
    u = u * 2;
    const phi = u / 2;
    const major = 2.25, a2 = 0.125, b3 = 0.65;
    let x = a2 * Math.cos(t2) * Math.cos(phi) - b3 * Math.sin(t2) * Math.sin(phi);
    const z = a2 * Math.cos(t2) * Math.sin(phi) + b3 * Math.sin(t2) * Math.cos(phi);
    const y = (major + x) * Math.sin(u);
    x = (major + x) * Math.cos(u);
    target.set(x, y, z);
  }
};
ParametricGeometries.TubeGeometry = class TubeGeometry extends ParametricGeometry {
  constructor(path, segments = 64, radius = 1, segmentsRadius = 8, closed = false) {
    const numpoints = segments + 1;
    const frames = path.computeFrenetFrames(segments, closed), tangents = frames.tangents, normals = frames.normals, binormals = frames.binormals;
    const position = new Vector3();
    function ParametricTube(u, v, target) {
      v *= 2 * Math.PI;
      const i2 = Math.floor(u * (numpoints - 1));
      path.getPointAt(u, position);
      const normal = normals[i2];
      const binormal = binormals[i2];
      const cx = -radius * Math.cos(v);
      const cy = radius * Math.sin(v);
      position.x += cx * normal.x + cy * binormal.x;
      position.y += cx * normal.y + cy * binormal.y;
      position.z += cx * normal.z + cy * binormal.z;
      target.copy(position);
    }
    super(ParametricTube, segments, segmentsRadius);
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;
    this.path = path;
    this.segments = segments;
    this.radius = radius;
    this.segmentsRadius = segmentsRadius;
    this.closed = closed;
  }
};
ParametricGeometries.TorusKnotGeometry = class TorusKnotGeometry extends ParametricGeometries.TubeGeometry {
  constructor(radius = 200, tube = 40, segmentsT = 64, segmentsR = 8, p = 2, q = 3) {
    class TorusKnotCurve extends Curve {
      getPoint(t2, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        t2 *= Math.PI * 2;
        const r = 0.5;
        const x = (1 + r * Math.cos(q * t2)) * Math.cos(p * t2);
        const y = (1 + r * Math.cos(q * t2)) * Math.sin(p * t2);
        const z = r * Math.sin(q * t2);
        return point.set(x, y, z).multiplyScalar(radius);
      }
    }
    const segments = segmentsT;
    const radiusSegments = segmentsR;
    const extrudePath = new TorusKnotCurve();
    super(extrudePath, segments, tube, radiusSegments, true, false);
    this.radius = radius;
    this.tube = tube;
    this.segmentsT = segmentsT;
    this.segmentsR = segmentsR;
    this.p = p;
    this.q = q;
  }
};
ParametricGeometries.SphereGeometry = class SphereGeometry2 extends ParametricGeometry {
  constructor(size2, u, v) {
    function sphere(u2, v2, target) {
      u2 *= Math.PI;
      v2 *= 2 * Math.PI;
      const x = size2 * Math.sin(u2) * Math.cos(v2);
      const y = size2 * Math.sin(u2) * Math.sin(v2);
      const z = size2 * Math.cos(u2);
      target.set(x, y, z);
    }
    super(sphere, u, v);
  }
};
ParametricGeometries.PlaneGeometry = class PlaneGeometry2 extends ParametricGeometry {
  constructor(width, depth, segmentsWidth, segmentsDepth) {
    function plane(u, v, target) {
      const x = u * width;
      const y = 0;
      const z = v * depth;
      target.set(x, y, z);
    }
    super(plane, segmentsWidth, segmentsDepth);
  }
};

// node_modules/three-stdlib/geometries/RoundedBoxGeometry.js
var tempNormal = new Vector3();
function getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {
  const totArcLength = 2 * Math.PI * radius / 4;
  const centerLength = Math.max(sideLength - 2 * radius, 0);
  const halfArc = Math.PI / 4;
  tempNormal.copy(normal);
  tempNormal[projectionAxis] = 0;
  tempNormal.normalize();
  const arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength);
  const arcAngleRatio = 1 - tempNormal.angleTo(faceDirVector) / halfArc;
  if (Math.sign(tempNormal[uvAxis]) === 1) {
    return arcAngleRatio * arcUvRatio;
  } else {
    const lenUv = centerLength / (totArcLength + centerLength);
    return lenUv + arcUvRatio + arcUvRatio * (1 - arcAngleRatio);
  }
}
var RoundedBoxGeometry = class extends BoxGeometry {
  constructor(width = 1, height = 1, depth = 1, segments = 2, radius = 0.1) {
    segments = segments * 2 + 1;
    radius = Math.min(width / 2, height / 2, depth / 2, radius);
    super(1, 1, 1, segments, segments, segments);
    if (segments === 1)
      return;
    const geometry2 = this.toNonIndexed();
    this.index = null;
    this.attributes.position = geometry2.attributes.position;
    this.attributes.normal = geometry2.attributes.normal;
    this.attributes.uv = geometry2.attributes.uv;
    const position = new Vector3();
    const normal = new Vector3();
    const box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius);
    const positions = this.attributes.position.array;
    const normals = this.attributes.normal.array;
    const uvs = this.attributes.uv.array;
    const faceTris = positions.length / 6;
    const faceDirVector = new Vector3();
    const halfSegmentSize = 0.5 / segments;
    for (let i2 = 0, j2 = 0; i2 < positions.length; i2 += 3, j2 += 2) {
      position.fromArray(positions, i2);
      normal.copy(position);
      normal.x -= Math.sign(normal.x) * halfSegmentSize;
      normal.y -= Math.sign(normal.y) * halfSegmentSize;
      normal.z -= Math.sign(normal.z) * halfSegmentSize;
      normal.normalize();
      positions[i2 + 0] = box.x * Math.sign(position.x) + normal.x * radius;
      positions[i2 + 1] = box.y * Math.sign(position.y) + normal.y * radius;
      positions[i2 + 2] = box.z * Math.sign(position.z) + normal.z * radius;
      normals[i2 + 0] = normal.x;
      normals[i2 + 1] = normal.y;
      normals[i2 + 2] = normal.z;
      const side = Math.floor(i2 / faceTris);
      switch (side) {
        case 0:
          faceDirVector.set(1, 0, 0);
          uvs[j2 + 0] = getUv(faceDirVector, normal, "z", "y", radius, depth);
          uvs[j2 + 1] = 1 - getUv(faceDirVector, normal, "y", "z", radius, height);
          break;
        case 1:
          faceDirVector.set(-1, 0, 0);
          uvs[j2 + 0] = 1 - getUv(faceDirVector, normal, "z", "y", radius, depth);
          uvs[j2 + 1] = 1 - getUv(faceDirVector, normal, "y", "z", radius, height);
          break;
        case 2:
          faceDirVector.set(0, 1, 0);
          uvs[j2 + 0] = 1 - getUv(faceDirVector, normal, "x", "z", radius, width);
          uvs[j2 + 1] = getUv(faceDirVector, normal, "z", "x", radius, depth);
          break;
        case 3:
          faceDirVector.set(0, -1, 0);
          uvs[j2 + 0] = 1 - getUv(faceDirVector, normal, "x", "z", radius, width);
          uvs[j2 + 1] = 1 - getUv(faceDirVector, normal, "z", "x", radius, depth);
          break;
        case 4:
          faceDirVector.set(0, 0, 1);
          uvs[j2 + 0] = 1 - getUv(faceDirVector, normal, "x", "y", radius, width);
          uvs[j2 + 1] = 1 - getUv(faceDirVector, normal, "y", "x", radius, height);
          break;
        case 5:
          faceDirVector.set(0, 0, -1);
          uvs[j2 + 0] = getUv(faceDirVector, normal, "x", "y", radius, width);
          uvs[j2 + 1] = 1 - getUv(faceDirVector, normal, "y", "x", radius, height);
          break;
      }
    }
  }
};

// node_modules/three-stdlib/geometries/BoxLineGeometry.js
var BoxLineGeometry = class extends BufferGeometry {
  constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
    super();
    width = width || 1;
    height = height || 1;
    depth = depth || 1;
    widthSegments = Math.floor(widthSegments) || 1;
    heightSegments = Math.floor(heightSegments) || 1;
    depthSegments = Math.floor(depthSegments) || 1;
    const widthHalf = width / 2;
    const heightHalf = height / 2;
    const depthHalf = depth / 2;
    const segmentWidth = width / widthSegments;
    const segmentHeight = height / heightSegments;
    const segmentDepth = depth / depthSegments;
    const vertices = [];
    let x = -widthHalf, y = -heightHalf, z = -depthHalf;
    for (let i2 = 0; i2 <= widthSegments; i2++) {
      vertices.push(x, -heightHalf, -depthHalf, x, heightHalf, -depthHalf);
      vertices.push(x, heightHalf, -depthHalf, x, heightHalf, depthHalf);
      vertices.push(x, heightHalf, depthHalf, x, -heightHalf, depthHalf);
      vertices.push(x, -heightHalf, depthHalf, x, -heightHalf, -depthHalf);
      x += segmentWidth;
    }
    for (let i2 = 0; i2 <= heightSegments; i2++) {
      vertices.push(-widthHalf, y, -depthHalf, widthHalf, y, -depthHalf);
      vertices.push(widthHalf, y, -depthHalf, widthHalf, y, depthHalf);
      vertices.push(widthHalf, y, depthHalf, -widthHalf, y, depthHalf);
      vertices.push(-widthHalf, y, depthHalf, -widthHalf, y, -depthHalf);
      y += segmentHeight;
    }
    for (let i2 = 0; i2 <= depthSegments; i2++) {
      vertices.push(-widthHalf, -heightHalf, z, -widthHalf, heightHalf, z);
      vertices.push(-widthHalf, heightHalf, z, widthHalf, heightHalf, z);
      vertices.push(widthHalf, heightHalf, z, widthHalf, -heightHalf, z);
      vertices.push(widthHalf, -heightHalf, z, -widthHalf, -heightHalf, z);
      z += segmentDepth;
    }
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  }
};

// node_modules/three-stdlib/geometries/DecalGeometry.js
var DecalGeometry = class extends BufferGeometry {
  constructor(mesh, position, orientation, size2) {
    super();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const plane = new Vector3();
    const projectorMatrix = new Matrix4();
    projectorMatrix.makeRotationFromEuler(orientation);
    projectorMatrix.setPosition(position);
    const projectorMatrixInverse = new Matrix4();
    projectorMatrixInverse.copy(projectorMatrix).invert();
    generate();
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generate() {
      let i2;
      let decalVertices = [];
      const vertex = new Vector3();
      const normal = new Vector3();
      if (mesh.geometry.isGeometry === true) {
        console.error("THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.");
        return;
      }
      const geometry = mesh.geometry;
      const positionAttribute = geometry.attributes.position;
      const normalAttribute = geometry.attributes.normal;
      if (geometry.index !== null) {
        const index = geometry.index;
        for (i2 = 0; i2 < index.count; i2++) {
          vertex.fromBufferAttribute(positionAttribute, index.getX(i2));
          normal.fromBufferAttribute(normalAttribute, index.getX(i2));
          pushDecalVertex(decalVertices, vertex, normal);
        }
      } else {
        for (i2 = 0; i2 < positionAttribute.count; i2++) {
          vertex.fromBufferAttribute(positionAttribute, i2);
          normal.fromBufferAttribute(normalAttribute, i2);
          pushDecalVertex(decalVertices, vertex, normal);
        }
      }
      decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0));
      decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0));
      decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0));
      decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0));
      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1));
      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1));
      for (i2 = 0; i2 < decalVertices.length; i2++) {
        const decalVertex = decalVertices[i2];
        uvs.push(0.5 + decalVertex.position.x / size2.x, 0.5 + decalVertex.position.y / size2.y);
        decalVertex.position.applyMatrix4(projectorMatrix);
        vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z);
        normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z);
      }
    }
    function pushDecalVertex(decalVertices, vertex, normal) {
      vertex.applyMatrix4(mesh.matrixWorld);
      vertex.applyMatrix4(projectorMatrixInverse);
      normal.transformDirection(mesh.matrixWorld);
      decalVertices.push(new DecalVertex(vertex.clone(), normal.clone()));
    }
    function clipGeometry(inVertices, plane2) {
      const outVertices = [];
      const s = 0.5 * Math.abs(size2.dot(plane2));
      for (let i2 = 0; i2 < inVertices.length; i2 += 3) {
        let v1Out, v2Out, v3Out, total = 0;
        let nV1, nV2, nV3, nV4;
        const d1 = inVertices[i2 + 0].position.dot(plane2) - s;
        const d2 = inVertices[i2 + 1].position.dot(plane2) - s;
        const d3 = inVertices[i2 + 2].position.dot(plane2) - s;
        v1Out = d1 > 0;
        v2Out = d2 > 0;
        v3Out = d3 > 0;
        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);
        switch (total) {
          case 0: {
            outVertices.push(inVertices[i2]);
            outVertices.push(inVertices[i2 + 1]);
            outVertices.push(inVertices[i2 + 2]);
            break;
          }
          case 1: {
            if (v1Out) {
              nV1 = inVertices[i2 + 1];
              nV2 = inVertices[i2 + 2];
              nV3 = clip(inVertices[i2], nV1, plane2, s);
              nV4 = clip(inVertices[i2], nV2, plane2, s);
            }
            if (v2Out) {
              nV1 = inVertices[i2];
              nV2 = inVertices[i2 + 2];
              nV3 = clip(inVertices[i2 + 1], nV1, plane2, s);
              nV4 = clip(inVertices[i2 + 1], nV2, plane2, s);
              outVertices.push(nV3);
              outVertices.push(nV2.clone());
              outVertices.push(nV1.clone());
              outVertices.push(nV2.clone());
              outVertices.push(nV3.clone());
              outVertices.push(nV4);
              break;
            }
            if (v3Out) {
              nV1 = inVertices[i2];
              nV2 = inVertices[i2 + 1];
              nV3 = clip(inVertices[i2 + 2], nV1, plane2, s);
              nV4 = clip(inVertices[i2 + 2], nV2, plane2, s);
            }
            outVertices.push(nV1.clone());
            outVertices.push(nV2.clone());
            outVertices.push(nV3);
            outVertices.push(nV4);
            outVertices.push(nV3.clone());
            outVertices.push(nV2.clone());
            break;
          }
          case 2: {
            if (!v1Out) {
              nV1 = inVertices[i2].clone();
              nV2 = clip(nV1, inVertices[i2 + 1], plane2, s);
              nV3 = clip(nV1, inVertices[i2 + 2], plane2, s);
              outVertices.push(nV1);
              outVertices.push(nV2);
              outVertices.push(nV3);
            }
            if (!v2Out) {
              nV1 = inVertices[i2 + 1].clone();
              nV2 = clip(nV1, inVertices[i2 + 2], plane2, s);
              nV3 = clip(nV1, inVertices[i2], plane2, s);
              outVertices.push(nV1);
              outVertices.push(nV2);
              outVertices.push(nV3);
            }
            if (!v3Out) {
              nV1 = inVertices[i2 + 2].clone();
              nV2 = clip(nV1, inVertices[i2], plane2, s);
              nV3 = clip(nV1, inVertices[i2 + 1], plane2, s);
              outVertices.push(nV1);
              outVertices.push(nV2);
              outVertices.push(nV3);
            }
            break;
          }
        }
      }
      return outVertices;
    }
    function clip(v0, v12, p, s) {
      const d0 = v0.position.dot(p) - s;
      const d1 = v12.position.dot(p) - s;
      const s0 = d0 / (d0 - d1);
      const v = new DecalVertex(new Vector3(v0.position.x + s0 * (v12.position.x - v0.position.x), v0.position.y + s0 * (v12.position.y - v0.position.y), v0.position.z + s0 * (v12.position.z - v0.position.z)), new Vector3(v0.normal.x + s0 * (v12.normal.x - v0.normal.x), v0.normal.y + s0 * (v12.normal.y - v0.normal.y), v0.normal.z + s0 * (v12.normal.z - v0.normal.z)));
      return v;
    }
  }
};
var DecalVertex = class {
  constructor(position, normal) {
    this.position = position;
    this.normal = normal;
  }
  clone() {
    return new this.constructor(this.position.clone(), this.normal.clone());
  }
};

// node_modules/three-stdlib/geometries/TeapotGeometry.js
var TeapotGeometry = class extends BufferGeometry {
  constructor(size2, segments, bottom, lid, body, fitLid, blinn) {
    const teapotPatches = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      3,
      16,
      17,
      18,
      7,
      19,
      20,
      21,
      11,
      22,
      23,
      24,
      15,
      25,
      26,
      27,
      18,
      28,
      29,
      30,
      21,
      31,
      32,
      33,
      24,
      34,
      35,
      36,
      27,
      37,
      38,
      39,
      30,
      40,
      41,
      0,
      33,
      42,
      43,
      4,
      36,
      44,
      45,
      8,
      39,
      46,
      47,
      12,
      12,
      13,
      14,
      15,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      15,
      25,
      26,
      27,
      51,
      60,
      61,
      62,
      55,
      63,
      64,
      65,
      59,
      66,
      67,
      68,
      27,
      37,
      38,
      39,
      62,
      69,
      70,
      71,
      65,
      72,
      73,
      74,
      68,
      75,
      76,
      77,
      39,
      46,
      47,
      12,
      71,
      78,
      79,
      48,
      74,
      80,
      81,
      52,
      77,
      82,
      83,
      56,
      56,
      57,
      58,
      59,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      93,
      94,
      95,
      59,
      66,
      67,
      68,
      87,
      96,
      97,
      98,
      91,
      99,
      100,
      101,
      95,
      102,
      103,
      104,
      68,
      75,
      76,
      77,
      98,
      105,
      106,
      107,
      101,
      108,
      109,
      110,
      104,
      111,
      112,
      113,
      77,
      82,
      83,
      56,
      107,
      114,
      115,
      84,
      110,
      116,
      117,
      88,
      113,
      118,
      119,
      92,
      120,
      121,
      122,
      123,
      124,
      125,
      126,
      127,
      128,
      129,
      130,
      131,
      132,
      133,
      134,
      135,
      123,
      136,
      137,
      120,
      127,
      138,
      139,
      124,
      131,
      140,
      141,
      128,
      135,
      142,
      143,
      132,
      132,
      133,
      134,
      135,
      144,
      145,
      146,
      147,
      148,
      149,
      150,
      151,
      68,
      152,
      153,
      154,
      135,
      142,
      143,
      132,
      147,
      155,
      156,
      144,
      151,
      157,
      158,
      148,
      154,
      159,
      160,
      68,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      164,
      177,
      178,
      161,
      168,
      179,
      180,
      165,
      172,
      181,
      182,
      169,
      176,
      183,
      184,
      173,
      173,
      174,
      175,
      176,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      176,
      183,
      184,
      173,
      188,
      197,
      198,
      185,
      192,
      199,
      200,
      189,
      196,
      201,
      202,
      193,
      203,
      203,
      203,
      203,
      204,
      205,
      206,
      207,
      208,
      208,
      208,
      208,
      209,
      210,
      211,
      212,
      203,
      203,
      203,
      203,
      207,
      213,
      214,
      215,
      208,
      208,
      208,
      208,
      212,
      216,
      217,
      218,
      203,
      203,
      203,
      203,
      215,
      219,
      220,
      221,
      208,
      208,
      208,
      208,
      218,
      222,
      223,
      224,
      203,
      203,
      203,
      203,
      221,
      225,
      226,
      204,
      208,
      208,
      208,
      208,
      224,
      227,
      228,
      209,
      209,
      210,
      211,
      212,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      238,
      239,
      240,
      212,
      216,
      217,
      218,
      232,
      241,
      242,
      243,
      236,
      244,
      245,
      246,
      240,
      247,
      248,
      249,
      218,
      222,
      223,
      224,
      243,
      250,
      251,
      252,
      246,
      253,
      254,
      255,
      249,
      256,
      257,
      258,
      224,
      227,
      228,
      209,
      252,
      259,
      260,
      229,
      255,
      261,
      262,
      233,
      258,
      263,
      264,
      237,
      265,
      265,
      265,
      265,
      266,
      267,
      268,
      269,
      270,
      271,
      272,
      273,
      92,
      119,
      118,
      113,
      265,
      265,
      265,
      265,
      269,
      274,
      275,
      276,
      273,
      277,
      278,
      279,
      113,
      112,
      111,
      104,
      265,
      265,
      265,
      265,
      276,
      280,
      281,
      282,
      279,
      283,
      284,
      285,
      104,
      103,
      102,
      95,
      265,
      265,
      265,
      265,
      282,
      286,
      287,
      266,
      285,
      288,
      289,
      270,
      95,
      94,
      93,
      92
    ];
    const teapotVertices = [1.4, 0, 2.4, 1.4, -0.784, 2.4, 0.784, -1.4, 2.4, 0, -1.4, 2.4, 1.3375, 0, 2.53125, 1.3375, -0.749, 2.53125, 0.749, -1.3375, 2.53125, 0, -1.3375, 2.53125, 1.4375, 0, 2.53125, 1.4375, -0.805, 2.53125, 0.805, -1.4375, 2.53125, 0, -1.4375, 2.53125, 1.5, 0, 2.4, 1.5, -0.84, 2.4, 0.84, -1.5, 2.4, 0, -1.5, 2.4, -0.784, -1.4, 2.4, -1.4, -0.784, 2.4, -1.4, 0, 2.4, -0.749, -1.3375, 2.53125, -1.3375, -0.749, 2.53125, -1.3375, 0, 2.53125, -0.805, -1.4375, 2.53125, -1.4375, -0.805, 2.53125, -1.4375, 0, 2.53125, -0.84, -1.5, 2.4, -1.5, -0.84, 2.4, -1.5, 0, 2.4, -1.4, 0.784, 2.4, -0.784, 1.4, 2.4, 0, 1.4, 2.4, -1.3375, 0.749, 2.53125, -0.749, 1.3375, 2.53125, 0, 1.3375, 2.53125, -1.4375, 0.805, 2.53125, -0.805, 1.4375, 2.53125, 0, 1.4375, 2.53125, -1.5, 0.84, 2.4, -0.84, 1.5, 2.4, 0, 1.5, 2.4, 0.784, 1.4, 2.4, 1.4, 0.784, 2.4, 0.749, 1.3375, 2.53125, 1.3375, 0.749, 2.53125, 0.805, 1.4375, 2.53125, 1.4375, 0.805, 2.53125, 0.84, 1.5, 2.4, 1.5, 0.84, 2.4, 1.75, 0, 1.875, 1.75, -0.98, 1.875, 0.98, -1.75, 1.875, 0, -1.75, 1.875, 2, 0, 1.35, 2, -1.12, 1.35, 1.12, -2, 1.35, 0, -2, 1.35, 2, 0, 0.9, 2, -1.12, 0.9, 1.12, -2, 0.9, 0, -2, 0.9, -0.98, -1.75, 1.875, -1.75, -0.98, 1.875, -1.75, 0, 1.875, -1.12, -2, 1.35, -2, -1.12, 1.35, -2, 0, 1.35, -1.12, -2, 0.9, -2, -1.12, 0.9, -2, 0, 0.9, -1.75, 0.98, 1.875, -0.98, 1.75, 1.875, 0, 1.75, 1.875, -2, 1.12, 1.35, -1.12, 2, 1.35, 0, 2, 1.35, -2, 1.12, 0.9, -1.12, 2, 0.9, 0, 2, 0.9, 0.98, 1.75, 1.875, 1.75, 0.98, 1.875, 1.12, 2, 1.35, 2, 1.12, 1.35, 1.12, 2, 0.9, 2, 1.12, 0.9, 2, 0, 0.45, 2, -1.12, 0.45, 1.12, -2, 0.45, 0, -2, 0.45, 1.5, 0, 0.225, 1.5, -0.84, 0.225, 0.84, -1.5, 0.225, 0, -1.5, 0.225, 1.5, 0, 0.15, 1.5, -0.84, 0.15, 0.84, -1.5, 0.15, 0, -1.5, 0.15, -1.12, -2, 0.45, -2, -1.12, 0.45, -2, 0, 0.45, -0.84, -1.5, 0.225, -1.5, -0.84, 0.225, -1.5, 0, 0.225, -0.84, -1.5, 0.15, -1.5, -0.84, 0.15, -1.5, 0, 0.15, -2, 1.12, 0.45, -1.12, 2, 0.45, 0, 2, 0.45, -1.5, 0.84, 0.225, -0.84, 1.5, 0.225, 0, 1.5, 0.225, -1.5, 0.84, 0.15, -0.84, 1.5, 0.15, 0, 1.5, 0.15, 1.12, 2, 0.45, 2, 1.12, 0.45, 0.84, 1.5, 0.225, 1.5, 0.84, 0.225, 0.84, 1.5, 0.15, 1.5, 0.84, 0.15, -1.6, 0, 2.025, -1.6, -0.3, 2.025, -1.5, -0.3, 2.25, -1.5, 0, 2.25, -2.3, 0, 2.025, -2.3, -0.3, 2.025, -2.5, -0.3, 2.25, -2.5, 0, 2.25, -2.7, 0, 2.025, -2.7, -0.3, 2.025, -3, -0.3, 2.25, -3, 0, 2.25, -2.7, 0, 1.8, -2.7, -0.3, 1.8, -3, -0.3, 1.8, -3, 0, 1.8, -1.5, 0.3, 2.25, -1.6, 0.3, 2.025, -2.5, 0.3, 2.25, -2.3, 0.3, 2.025, -3, 0.3, 2.25, -2.7, 0.3, 2.025, -3, 0.3, 1.8, -2.7, 0.3, 1.8, -2.7, 0, 1.575, -2.7, -0.3, 1.575, -3, -0.3, 1.35, -3, 0, 1.35, -2.5, 0, 1.125, -2.5, -0.3, 1.125, -2.65, -0.3, 0.9375, -2.65, 0, 0.9375, -2, -0.3, 0.9, -1.9, -0.3, 0.6, -1.9, 0, 0.6, -3, 0.3, 1.35, -2.7, 0.3, 1.575, -2.65, 0.3, 0.9375, -2.5, 0.3, 1.125, -1.9, 0.3, 0.6, -2, 0.3, 0.9, 1.7, 0, 1.425, 1.7, -0.66, 1.425, 1.7, -0.66, 0.6, 1.7, 0, 0.6, 2.6, 0, 1.425, 2.6, -0.66, 1.425, 3.1, -0.66, 0.825, 3.1, 0, 0.825, 2.3, 0, 2.1, 2.3, -0.25, 2.1, 2.4, -0.25, 2.025, 2.4, 0, 2.025, 2.7, 0, 2.4, 2.7, -0.25, 2.4, 3.3, -0.25, 2.4, 3.3, 0, 2.4, 1.7, 0.66, 0.6, 1.7, 0.66, 1.425, 3.1, 0.66, 0.825, 2.6, 0.66, 1.425, 2.4, 0.25, 2.025, 2.3, 0.25, 2.1, 3.3, 0.25, 2.4, 2.7, 0.25, 2.4, 2.8, 0, 2.475, 2.8, -0.25, 2.475, 3.525, -0.25, 2.49375, 3.525, 0, 2.49375, 2.9, 0, 2.475, 2.9, -0.15, 2.475, 3.45, -0.15, 2.5125, 3.45, 0, 2.5125, 2.8, 0, 2.4, 2.8, -0.15, 2.4, 3.2, -0.15, 2.4, 3.2, 0, 2.4, 3.525, 0.25, 2.49375, 2.8, 0.25, 2.475, 3.45, 0.15, 2.5125, 2.9, 0.15, 2.475, 3.2, 0.15, 2.4, 2.8, 0.15, 2.4, 0, 0, 3.15, 0.8, 0, 3.15, 0.8, -0.45, 3.15, 0.45, -0.8, 3.15, 0, -0.8, 3.15, 0, 0, 2.85, 0.2, 0, 2.7, 0.2, -0.112, 2.7, 0.112, -0.2, 2.7, 0, -0.2, 2.7, -0.45, -0.8, 3.15, -0.8, -0.45, 3.15, -0.8, 0, 3.15, -0.112, -0.2, 2.7, -0.2, -0.112, 2.7, -0.2, 0, 2.7, -0.8, 0.45, 3.15, -0.45, 0.8, 3.15, 0, 0.8, 3.15, -0.2, 0.112, 2.7, -0.112, 0.2, 2.7, 0, 0.2, 2.7, 0.45, 0.8, 3.15, 0.8, 0.45, 3.15, 0.112, 0.2, 2.7, 0.2, 0.112, 2.7, 0.4, 0, 2.55, 0.4, -0.224, 2.55, 0.224, -0.4, 2.55, 0, -0.4, 2.55, 1.3, 0, 2.55, 1.3, -0.728, 2.55, 0.728, -1.3, 2.55, 0, -1.3, 2.55, 1.3, 0, 2.4, 1.3, -0.728, 2.4, 0.728, -1.3, 2.4, 0, -1.3, 2.4, -0.224, -0.4, 2.55, -0.4, -0.224, 2.55, -0.4, 0, 2.55, -0.728, -1.3, 2.55, -1.3, -0.728, 2.55, -1.3, 0, 2.55, -0.728, -1.3, 2.4, -1.3, -0.728, 2.4, -1.3, 0, 2.4, -0.4, 0.224, 2.55, -0.224, 0.4, 2.55, 0, 0.4, 2.55, -1.3, 0.728, 2.55, -0.728, 1.3, 2.55, 0, 1.3, 2.55, -1.3, 0.728, 2.4, -0.728, 1.3, 2.4, 0, 1.3, 2.4, 0.224, 0.4, 2.55, 0.4, 0.224, 2.55, 0.728, 1.3, 2.55, 1.3, 0.728, 2.55, 0.728, 1.3, 2.4, 1.3, 0.728, 2.4, 0, 0, 0, 1.425, 0, 0, 1.425, 0.798, 0, 0.798, 1.425, 0, 0, 1.425, 0, 1.5, 0, 0.075, 1.5, 0.84, 0.075, 0.84, 1.5, 0.075, 0, 1.5, 0.075, -0.798, 1.425, 0, -1.425, 0.798, 0, -1.425, 0, 0, -0.84, 1.5, 0.075, -1.5, 0.84, 0.075, -1.5, 0, 0.075, -1.425, -0.798, 0, -0.798, -1.425, 0, 0, -1.425, 0, -1.5, -0.84, 0.075, -0.84, -1.5, 0.075, 0, -1.5, 0.075, 0.798, -1.425, 0, 1.425, -0.798, 0, 0.84, -1.5, 0.075, 1.5, -0.84, 0.075];
    super();
    size2 = size2 || 50;
    segments = segments !== void 0 ? Math.max(2, Math.floor(segments) || 10) : 10;
    bottom = bottom === void 0 ? true : bottom;
    lid = lid === void 0 ? true : lid;
    body = body === void 0 ? true : body;
    fitLid = fitLid === void 0 ? true : fitLid;
    const blinnScale = 1.3;
    blinn = blinn === void 0 ? true : blinn;
    const maxHeight = 3.15 * (blinn ? 1 : blinnScale);
    const maxHeight2 = maxHeight / 2;
    const trueSize = size2 / maxHeight2;
    let numTriangles = bottom ? (8 * segments - 4) * segments : 0;
    numTriangles += lid ? (16 * segments - 4) * segments : 0;
    numTriangles += body ? 40 * segments * segments : 0;
    const indices = new Uint32Array(numTriangles * 3);
    let numVertices = bottom ? 4 : 0;
    numVertices += lid ? 8 : 0;
    numVertices += body ? 20 : 0;
    numVertices *= (segments + 1) * (segments + 1);
    const vertices = new Float32Array(numVertices * 3);
    const normals = new Float32Array(numVertices * 3);
    const uvs = new Float32Array(numVertices * 2);
    const ms = new Matrix4();
    ms.set(-1, 3, -3, 1, 3, -6, 3, 0, -3, 3, 0, 0, 1, 0, 0, 0);
    const g2 = [];
    let i2, r, c;
    const sp = [];
    const tp = [];
    const dsp = [];
    const dtp = [];
    const mgm = [];
    const vert = [];
    const sdir = [];
    const tdir = [];
    const norm = new Vector3();
    let tcoord;
    let sstep, tstep;
    let vertPerRow;
    let s, t2, sval, tval, p;
    let dsval = 0;
    let dtval = 0;
    const normOut = new Vector3();
    let v12, v2, v3, v4;
    const gmx = new Matrix4();
    const tmtx = new Matrix4();
    const vsp = new Vector4();
    const vtp = new Vector4();
    const vdsp = new Vector4();
    const vdtp = new Vector4();
    const vsdir = new Vector3();
    const vtdir = new Vector3();
    const mst = ms.clone();
    mst.transpose();
    const notDegenerate = (vtx1, vtx2, vtx3) => !(vertices[vtx1 * 3] === vertices[vtx2 * 3] && vertices[vtx1 * 3 + 1] === vertices[vtx2 * 3 + 1] && vertices[vtx1 * 3 + 2] === vertices[vtx2 * 3 + 2] || vertices[vtx1 * 3] === vertices[vtx3 * 3] && vertices[vtx1 * 3 + 1] === vertices[vtx3 * 3 + 1] && vertices[vtx1 * 3 + 2] === vertices[vtx3 * 3 + 2] || vertices[vtx2 * 3] === vertices[vtx3 * 3] && vertices[vtx2 * 3 + 1] === vertices[vtx3 * 3 + 1] && vertices[vtx2 * 3 + 2] === vertices[vtx3 * 3 + 2]);
    for (i2 = 0; i2 < 3; i2++) {
      mgm[i2] = new Matrix4();
    }
    const minPatches = body ? 0 : 20;
    const maxPatches = bottom ? 32 : 28;
    vertPerRow = segments + 1;
    let surfCount = 0;
    let vertCount = 0;
    let normCount = 0;
    let uvCount = 0;
    let indexCount = 0;
    for (let surf = minPatches; surf < maxPatches; surf++) {
      if (lid || surf < 20 || surf >= 28) {
        for (i2 = 0; i2 < 3; i2++) {
          for (r = 0; r < 4; r++) {
            for (c = 0; c < 4; c++) {
              g2[c * 4 + r] = teapotVertices[teapotPatches[surf * 16 + r * 4 + c] * 3 + i2];
              if (fitLid && surf >= 20 && surf < 28 && i2 !== 2) {
                g2[c * 4 + r] *= 1.077;
              }
              if (!blinn && i2 === 2) {
                g2[c * 4 + r] *= blinnScale;
              }
            }
          }
          gmx.set(g2[0], g2[1], g2[2], g2[3], g2[4], g2[5], g2[6], g2[7], g2[8], g2[9], g2[10], g2[11], g2[12], g2[13], g2[14], g2[15]);
          tmtx.multiplyMatrices(gmx, ms);
          mgm[i2].multiplyMatrices(mst, tmtx);
        }
        for (sstep = 0; sstep <= segments; sstep++) {
          s = sstep / segments;
          for (tstep = 0; tstep <= segments; tstep++) {
            t2 = tstep / segments;
            for (p = 4, sval = tval = 1; p--; ) {
              sp[p] = sval;
              tp[p] = tval;
              sval *= s;
              tval *= t2;
              if (p === 3) {
                dsp[p] = dtp[p] = 0;
                dsval = dtval = 1;
              } else {
                dsp[p] = dsval * (3 - p);
                dtp[p] = dtval * (3 - p);
                dsval *= s;
                dtval *= t2;
              }
            }
            vsp.fromArray(sp);
            vtp.fromArray(tp);
            vdsp.fromArray(dsp);
            vdtp.fromArray(dtp);
            for (i2 = 0; i2 < 3; i2++) {
              tcoord = vsp.clone();
              tcoord.applyMatrix4(mgm[i2]);
              vert[i2] = tcoord.dot(vtp);
              tcoord = vdsp.clone();
              tcoord.applyMatrix4(mgm[i2]);
              sdir[i2] = tcoord.dot(vtp);
              tcoord = vsp.clone();
              tcoord.applyMatrix4(mgm[i2]);
              tdir[i2] = tcoord.dot(vdtp);
            }
            vsdir.fromArray(sdir);
            vtdir.fromArray(tdir);
            norm.crossVectors(vtdir, vsdir);
            norm.normalize();
            if (vert[0] === 0 && vert[1] === 0) {
              normOut.set(0, vert[2] > maxHeight2 ? 1 : -1, 0);
            } else {
              normOut.set(norm.x, norm.z, -norm.y);
            }
            vertices[vertCount++] = trueSize * vert[0];
            vertices[vertCount++] = trueSize * (vert[2] - maxHeight2);
            vertices[vertCount++] = -trueSize * vert[1];
            normals[normCount++] = normOut.x;
            normals[normCount++] = normOut.y;
            normals[normCount++] = normOut.z;
            uvs[uvCount++] = 1 - t2;
            uvs[uvCount++] = 1 - s;
          }
        }
        for (sstep = 0; sstep < segments; sstep++) {
          for (tstep = 0; tstep < segments; tstep++) {
            v12 = surfCount * vertPerRow * vertPerRow + sstep * vertPerRow + tstep;
            v2 = v12 + 1;
            v3 = v2 + vertPerRow;
            v4 = v12 + vertPerRow;
            if (notDegenerate(v12, v2, v3)) {
              indices[indexCount++] = v12;
              indices[indexCount++] = v2;
              indices[indexCount++] = v3;
            }
            if (notDegenerate(v12, v3, v4)) {
              indices[indexCount++] = v12;
              indices[indexCount++] = v3;
              indices[indexCount++] = v4;
            }
          }
        }
        surfCount++;
      }
    }
    this.setIndex(new BufferAttribute(indices, 1));
    this.setAttribute("position", new BufferAttribute(vertices, 3));
    this.setAttribute("normal", new BufferAttribute(normals, 3));
    this.setAttribute("uv", new BufferAttribute(uvs, 2));
    this.computeBoundingSphere();
  }
};

// node_modules/three-stdlib/geometries/TextGeometry.js
var TextGeometry = class extends ExtrudeGeometry {
  constructor(text, parameters) {
    const {
      bevelEnabled = false,
      bevelSize = 8,
      bevelThickness = 10,
      font,
      height = 50,
      size: size2 = 100,
      lineHeight = 1,
      letterSpacing = 0,
      ...rest
    } = parameters;
    const shapes = font.generateShapes(text, size2, {
      lineHeight,
      letterSpacing
    });
    super(shapes, {
      ...rest,
      bevelEnabled,
      bevelSize,
      bevelThickness,
      depth: height
    });
    this.type = "TextGeometry";
  }
};

// node_modules/three-stdlib/csm/CSMFrustum.js
var inverseProjectionMatrix = new Matrix4();
var CSMFrustum = class {
  constructor(data) {
    data = data || {};
    this.vertices = {
      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],
      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]
    };
    if (data.projectionMatrix !== void 0) {
      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 1e4);
    }
  }
  setFromProjectionMatrix(projectionMatrix, maxFar) {
    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;
    inverseProjectionMatrix.copy(projectionMatrix).invert();
    this.vertices.near[0].set(1, 1, -1);
    this.vertices.near[1].set(1, -1, -1);
    this.vertices.near[2].set(-1, -1, -1);
    this.vertices.near[3].set(-1, 1, -1);
    this.vertices.near.forEach(function(v) {
      v.applyMatrix4(inverseProjectionMatrix);
    });
    this.vertices.far[0].set(1, 1, 1);
    this.vertices.far[1].set(1, -1, 1);
    this.vertices.far[2].set(-1, -1, 1);
    this.vertices.far[3].set(-1, 1, 1);
    this.vertices.far.forEach(function(v) {
      v.applyMatrix4(inverseProjectionMatrix);
      const absZ = Math.abs(v.z);
      if (isOrthographic) {
        v.z *= Math.min(maxFar / absZ, 1);
      } else {
        v.multiplyScalar(Math.min(maxFar / absZ, 1));
      }
    });
    return this.vertices;
  }
  split(breaks, target) {
    while (breaks.length > target.length) {
      target.push(new CSMFrustum());
    }
    target.length = breaks.length;
    for (let i2 = 0; i2 < breaks.length; i2++) {
      const cascade = target[i2];
      if (i2 === 0) {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.near[j2].copy(this.vertices.near[j2]);
        }
      } else {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.near[j2].lerpVectors(this.vertices.near[j2], this.vertices.far[j2], breaks[i2 - 1]);
        }
      }
      if (i2 === breaks.length - 1) {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.far[j2].copy(this.vertices.far[j2]);
        }
      } else {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.far[j2].lerpVectors(this.vertices.near[j2], this.vertices.far[j2], breaks[i2]);
        }
      }
    }
  }
  toSpace(cameraMatrix, target) {
    for (let i2 = 0; i2 < 4; i2++) {
      target.vertices.near[i2].copy(this.vertices.near[i2]).applyMatrix4(cameraMatrix);
      target.vertices.far[i2].copy(this.vertices.far[i2]).applyMatrix4(cameraMatrix);
    }
  }
};

// node_modules/three-stdlib/csm/CSMShader.js
var CSMShader = {
  lights_fragment_begin: `
GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
	vec2 cascade;
	float cascadeCenter;
	float closestEdge;
	float margin;
	float csmx;
	float csmy;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );

	  	#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
			// NOTE: Depth gets larger away from the camera.
			// cascade.x is closer, cascade.y is further
			cascade = CSM_cascades[ i ];
			cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
			closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
			margin = 0.25 * pow( closestEdge, 2.0 );
			csmx = cascade.x - margin / 2.0;
			csmy = cascade.y + margin / 2.0;
			if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

				float dist = min( linearDepth - csmx, csmy - linearDepth );
				float ratio = clamp( dist / margin, 0.0, 1.0 );

				vec3 prevColor = directLight.color;
				directionalLightShadow = directionalLightShadows[ i ];
				directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

				bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
				directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

				ReflectedLight prevLight = reflectedLight;
				RE_Direct( directLight, geometry, material, reflectedLight );

				bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
				float blendRatio = shouldBlend ? ratio : 1.0;

				reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
				reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
				reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
				reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

			}
	  	#endif

	}
	#pragma unroll_loop_end
	#else

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, geometry, directLight );

			#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

			directionalLightShadow = directionalLightShadows[ i ];
			if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

			if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );

			#endif

		}
		#pragma unroll_loop_end

	#endif

	#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)
		// compute the lights not casting shadows (if any)

		#pragma unroll_loop_start
		for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];

			getDirectionalLightInfo( directionalLight, geometry, directLight );

			RE_Direct( directLight, geometry, material, reflectedLight );

		}
		#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`,
  lights_pars_begin: `
#if defined( USE_CSM ) && defined( CSM_CASCADES )
uniform vec2 CSM_cascades[CSM_CASCADES];
uniform float cameraNear;
uniform float shadowFar;
#endif
	` + ShaderChunk.lights_pars_begin
};

// node_modules/three-stdlib/csm/CSM.js
var _cameraToLightMatrix = new Matrix4();
var _lightSpaceFrustum = new CSMFrustum();
var _center2 = new Vector3();
var _bbox = new Box3();
var _uniformArray = [];
var _logArray = [];
var CSM = class {
  constructor(data) {
    data = data || {};
    this.camera = data.camera;
    this.parent = data.parent;
    this.cascades = data.cascades || 3;
    this.maxFar = data.maxFar || 1e5;
    this.mode = data.mode || "practical";
    this.shadowMapSize = data.shadowMapSize || 2048;
    this.shadowBias = data.shadowBias || 1e-6;
    this.lightDirection = data.lightDirection || new Vector3(1, -1, 1).normalize();
    this.lightIntensity = data.lightIntensity || 1;
    this.lightNear = data.lightNear || 1;
    this.lightFar = data.lightFar || 2e3;
    this.lightMargin = data.lightMargin || 200;
    this.customSplitsCallback = data.customSplitsCallback;
    this.fade = false;
    this.mainFrustum = new CSMFrustum();
    this.frustums = [];
    this.breaks = [];
    this.lights = [];
    this.shaders = /* @__PURE__ */ new Map();
    this.createLights();
    this.updateFrustums();
    this.injectInclude();
  }
  createLights() {
    for (let i2 = 0; i2 < this.cascades; i2++) {
      const light = new DirectionalLight(16777215, this.lightIntensity);
      light.castShadow = true;
      light.shadow.mapSize.width = this.shadowMapSize;
      light.shadow.mapSize.height = this.shadowMapSize;
      light.shadow.camera.near = this.lightNear;
      light.shadow.camera.far = this.lightFar;
      light.shadow.bias = this.shadowBias;
      this.parent.add(light);
      this.parent.add(light.target);
      this.lights.push(light);
    }
  }
  initCascades() {
    const camera = this.camera;
    camera.updateProjectionMatrix();
    this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);
    this.mainFrustum.split(this.breaks, this.frustums);
  }
  updateShadowBounds() {
    const frustums = this.frustums;
    for (let i2 = 0; i2 < frustums.length; i2++) {
      const light = this.lights[i2];
      const shadowCam = light.shadow.camera;
      const frustum = this.frustums[i2];
      const nearVerts = frustum.vertices.near;
      const farVerts = frustum.vertices.far;
      const point1 = farVerts[0];
      let point2;
      if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {
        point2 = farVerts[2];
      } else {
        point2 = nearVerts[2];
      }
      let squaredBBWidth = point1.distanceTo(point2);
      if (this.fade) {
        const camera = this.camera;
        const far = Math.max(camera.far, this.maxFar);
        const linearDepth = frustum.vertices.far[0].z / (far - camera.near);
        const margin = 0.25 * Math.pow(linearDepth, 2) * (far - camera.near);
        squaredBBWidth += margin;
      }
      shadowCam.left = -squaredBBWidth / 2;
      shadowCam.right = squaredBBWidth / 2;
      shadowCam.top = squaredBBWidth / 2;
      shadowCam.bottom = -squaredBBWidth / 2;
      shadowCam.updateProjectionMatrix();
    }
  }
  getBreaks() {
    const camera = this.camera;
    const far = Math.min(camera.far, this.maxFar);
    this.breaks.length = 0;
    switch (this.mode) {
      case "uniform":
        uniformSplit(this.cascades, camera.near, far, this.breaks);
        break;
      case "logarithmic":
        logarithmicSplit(this.cascades, camera.near, far, this.breaks);
        break;
      case "practical":
        practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);
        break;
      case "custom":
        if (this.customSplitsCallback === void 0)
          console.error("CSM: Custom split scheme callback not defined.");
        this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);
        break;
    }
    function uniformSplit(amount, near, far2, target) {
      for (let i2 = 1; i2 < amount; i2++) {
        target.push((near + (far2 - near) * i2 / amount) / far2);
      }
      target.push(1);
    }
    function logarithmicSplit(amount, near, far2, target) {
      for (let i2 = 1; i2 < amount; i2++) {
        target.push(near * (far2 / near) ** (i2 / amount) / far2);
      }
      target.push(1);
    }
    function practicalSplit(amount, near, far2, lambda, target) {
      _uniformArray.length = 0;
      _logArray.length = 0;
      logarithmicSplit(amount, near, far2, _logArray);
      uniformSplit(amount, near, far2, _uniformArray);
      for (let i2 = 1; i2 < amount; i2++) {
        target.push(MathUtils.lerp(_uniformArray[i2 - 1], _logArray[i2 - 1], lambda));
      }
      target.push(1);
    }
  }
  update() {
    const camera = this.camera;
    const frustums = this.frustums;
    for (let i2 = 0; i2 < frustums.length; i2++) {
      const light = this.lights[i2];
      const shadowCam = light.shadow.camera;
      const texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;
      const texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;
      light.shadow.camera.updateMatrixWorld(true);
      _cameraToLightMatrix.multiplyMatrices(light.shadow.camera.matrixWorldInverse, camera.matrixWorld);
      frustums[i2].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);
      const nearVerts = _lightSpaceFrustum.vertices.near;
      const farVerts = _lightSpaceFrustum.vertices.far;
      _bbox.makeEmpty();
      for (let j2 = 0; j2 < 4; j2++) {
        _bbox.expandByPoint(nearVerts[j2]);
        _bbox.expandByPoint(farVerts[j2]);
      }
      _bbox.getCenter(_center2);
      _center2.z = _bbox.max.z + this.lightMargin;
      _center2.x = Math.floor(_center2.x / texelWidth) * texelWidth;
      _center2.y = Math.floor(_center2.y / texelHeight) * texelHeight;
      _center2.applyMatrix4(light.shadow.camera.matrixWorld);
      light.position.copy(_center2);
      light.target.position.copy(_center2);
      light.target.position.x += this.lightDirection.x;
      light.target.position.y += this.lightDirection.y;
      light.target.position.z += this.lightDirection.z;
    }
  }
  injectInclude() {
    ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;
    ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;
  }
  setupMaterial(material) {
    material.defines = material.defines || {};
    material.defines.USE_CSM = 1;
    material.defines.CSM_CASCADES = this.cascades;
    if (this.fade) {
      material.defines.CSM_FADE = "";
    }
    const breaksVec2 = [];
    const scope2 = this;
    const shaders2 = this.shaders;
    material.onBeforeCompile = function(shader) {
      const far = Math.min(scope2.camera.far, scope2.maxFar);
      scope2.getExtendedBreaks(breaksVec2);
      shader.uniforms.CSM_cascades = {
        value: breaksVec2
      };
      shader.uniforms.cameraNear = {
        value: scope2.camera.near
      };
      shader.uniforms.shadowFar = {
        value: far
      };
      shaders2.set(material, shader);
    };
    shaders2.set(material, null);
  }
  updateUniforms() {
    const far = Math.min(this.camera.far, this.maxFar);
    const shaders2 = this.shaders;
    shaders2.forEach(function(shader, material) {
      if (shader !== null) {
        const uniforms = shader.uniforms;
        this.getExtendedBreaks(uniforms.CSM_cascades.value);
        uniforms.cameraNear.value = this.camera.near;
        uniforms.shadowFar.value = far;
      }
      if (!this.fade && "CSM_FADE" in material.defines) {
        delete material.defines.CSM_FADE;
        material.needsUpdate = true;
      } else if (this.fade && !("CSM_FADE" in material.defines)) {
        material.defines.CSM_FADE = "";
        material.needsUpdate = true;
      }
    }, this);
  }
  getExtendedBreaks(target) {
    while (target.length < this.breaks.length) {
      target.push(new Vector2());
    }
    target.length = this.breaks.length;
    for (let i2 = 0; i2 < this.cascades; i2++) {
      const amount = this.breaks[i2];
      const prev = this.breaks[i2 - 1] || 0;
      target[i2].x = prev;
      target[i2].y = amount;
    }
  }
  updateFrustums() {
    this.getBreaks();
    this.initCascades();
    this.updateShadowBounds();
    this.updateUniforms();
  }
  remove() {
    for (let i2 = 0; i2 < this.lights.length; i2++) {
      this.parent.remove(this.lights[i2]);
    }
  }
  dispose() {
    const shaders2 = this.shaders;
    shaders2.forEach(function(shader, material) {
      delete material.onBeforeCompile;
      delete material.defines.USE_CSM;
      delete material.defines.CSM_CASCADES;
      delete material.defines.CSM_FADE;
      if (shader !== null) {
        delete shader.uniforms.CSM_cascades;
        delete shader.uniforms.cameraNear;
        delete shader.uniforms.shadowFar;
      }
      material.needsUpdate = true;
    });
    shaders2.clear();
  }
};

// node_modules/three-stdlib/csm/CSMHelper.js
var CSMHelper = class extends Group {
  constructor(csm) {
    super();
    this.csm = csm;
    this.displayFrustum = true;
    this.displayPlanes = true;
    this.displayShadowBounds = true;
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = new Float32Array(24);
    const frustumGeometry = new BufferGeometry();
    frustumGeometry.setIndex(new BufferAttribute(indices, 1));
    frustumGeometry.setAttribute("position", new BufferAttribute(positions, 3, false));
    const frustumLines = new LineSegments(frustumGeometry, new LineBasicMaterial());
    this.add(frustumLines);
    this.frustumLines = frustumLines;
    this.cascadeLines = [];
    this.cascadePlanes = [];
    this.shadowLines = [];
  }
  updateVisibility() {
    const displayFrustum = this.displayFrustum;
    const displayPlanes = this.displayPlanes;
    const displayShadowBounds = this.displayShadowBounds;
    const frustumLines = this.frustumLines;
    const cascadeLines = this.cascadeLines;
    const cascadePlanes = this.cascadePlanes;
    const shadowLines = this.shadowLines;
    for (let i2 = 0, l = cascadeLines.length; i2 < l; i2++) {
      const cascadeLine = cascadeLines[i2];
      const cascadePlane = cascadePlanes[i2];
      const shadowLineGroup = shadowLines[i2];
      cascadeLine.visible = displayFrustum;
      cascadePlane.visible = displayFrustum && displayPlanes;
      shadowLineGroup.visible = displayShadowBounds;
    }
    frustumLines.visible = displayFrustum;
  }
  update() {
    const csm = this.csm;
    const camera = csm.camera;
    const cascades = csm.cascades;
    const mainFrustum = csm.mainFrustum;
    const frustums = csm.frustums;
    const lights = csm.lights;
    const frustumLines = this.frustumLines;
    const frustumLinePositions = frustumLines.geometry.getAttribute("position");
    const cascadeLines = this.cascadeLines;
    const cascadePlanes = this.cascadePlanes;
    const shadowLines = this.shadowLines;
    this.position.copy(camera.position);
    this.quaternion.copy(camera.quaternion);
    this.scale.copy(camera.scale);
    this.updateMatrixWorld(true);
    while (cascadeLines.length > cascades) {
      this.remove(cascadeLines.pop());
      this.remove(cascadePlanes.pop());
      this.remove(shadowLines.pop());
    }
    while (cascadeLines.length < cascades) {
      const cascadeLine = new Box3Helper(new Box3(), 16777215);
      const planeMat = new MeshBasicMaterial({
        transparent: true,
        opacity: 0.1,
        depthWrite: false,
        side: DoubleSide
      });
      const cascadePlane = new Mesh(new PlaneGeometry(), planeMat);
      const shadowLineGroup = new Group();
      const shadowLine = new Box3Helper(new Box3(), 16776960);
      shadowLineGroup.add(shadowLine);
      this.add(cascadeLine);
      this.add(cascadePlane);
      this.add(shadowLineGroup);
      cascadeLines.push(cascadeLine);
      cascadePlanes.push(cascadePlane);
      shadowLines.push(shadowLineGroup);
    }
    for (let i2 = 0; i2 < cascades; i2++) {
      const frustum = frustums[i2];
      const light = lights[i2];
      const shadowCam = light.shadow.camera;
      const farVerts2 = frustum.vertices.far;
      const cascadeLine = cascadeLines[i2];
      const cascadePlane = cascadePlanes[i2];
      const shadowLineGroup = shadowLines[i2];
      const shadowLine = shadowLineGroup.children[0];
      cascadeLine.box.min.copy(farVerts2[2]);
      cascadeLine.box.max.copy(farVerts2[0]);
      cascadeLine.box.max.z += 1e-4;
      cascadePlane.position.addVectors(farVerts2[0], farVerts2[2]);
      cascadePlane.position.multiplyScalar(0.5);
      cascadePlane.scale.subVectors(farVerts2[0], farVerts2[2]);
      cascadePlane.scale.z = 1e-4;
      this.remove(shadowLineGroup);
      shadowLineGroup.position.copy(shadowCam.position);
      shadowLineGroup.quaternion.copy(shadowCam.quaternion);
      shadowLineGroup.scale.copy(shadowCam.scale);
      shadowLineGroup.updateMatrixWorld(true);
      this.attach(shadowLineGroup);
      shadowLine.box.min.set(shadowCam.bottom, shadowCam.left, -shadowCam.far);
      shadowLine.box.max.set(shadowCam.top, shadowCam.right, -shadowCam.near);
    }
    const nearVerts = mainFrustum.vertices.near;
    const farVerts = mainFrustum.vertices.far;
    frustumLinePositions.setXYZ(0, farVerts[0].x, farVerts[0].y, farVerts[0].z);
    frustumLinePositions.setXYZ(1, farVerts[3].x, farVerts[3].y, farVerts[3].z);
    frustumLinePositions.setXYZ(2, farVerts[2].x, farVerts[2].y, farVerts[2].z);
    frustumLinePositions.setXYZ(3, farVerts[1].x, farVerts[1].y, farVerts[1].z);
    frustumLinePositions.setXYZ(4, nearVerts[0].x, nearVerts[0].y, nearVerts[0].z);
    frustumLinePositions.setXYZ(5, nearVerts[3].x, nearVerts[3].y, nearVerts[3].z);
    frustumLinePositions.setXYZ(6, nearVerts[2].x, nearVerts[2].y, nearVerts[2].z);
    frustumLinePositions.setXYZ(7, nearVerts[1].x, nearVerts[1].y, nearVerts[1].z);
    frustumLinePositions.needsUpdate = true;
  }
};

// node_modules/three-stdlib/shaders/ACESFilmicToneMappingShader.js
var ACESFilmicToneMappingShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    exposure: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#define saturate(a) clamp( a, 0.0, 1.0 )",
    "uniform sampler2D tDiffuse;",
    "uniform float exposure;",
    "varying vec2 vUv;",
    "vec3 RRTAndODTFit( vec3 v ) {",
    "	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;",
    "	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;",
    "	return a / b;",
    "}",
    "vec3 ACESFilmicToneMapping( vec3 color ) {",
    "	const mat3 ACESInputMat = mat3(",
    "		vec3( 0.59719, 0.07600, 0.02840 ),",
    "		vec3( 0.35458, 0.90834, 0.13383 ),",
    "		vec3( 0.04823, 0.01566, 0.83777 )",
    "	);",
    "	const mat3 ACESOutputMat = mat3(",
    "		vec3(  1.60475, -0.10208, -0.00327 ),",
    "		vec3( -0.53108,  1.10813, -0.07276 ),",
    "		vec3( -0.07367, -0.00605,  1.07602 )",
    "	);",
    "	color = ACESInputMat * color;",
    "	color = RRTAndODTFit( color );",
    "	color = ACESOutputMat * color;",
    "	return saturate( color );",
    "}",
    "void main() {",
    "	vec4 tex = texture2D( tDiffuse, vUv );",
    "	tex.rgb *= exposure / 0.6;",
    "	gl_FragColor = vec4( ACESFilmicToneMapping( tex.rgb ), tex.a );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/BasicShader.js
var BasicShader = {
  uniforms: {},
  vertexShader: ["void main() {", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["void main() {", "	gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/BleachBypassShader.js
var BleachBypassShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    opacity: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 base = texture2D( tDiffuse, vUv );", "	vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );", "	float lum = dot( lumCoeff, base.rgb );", "	vec3 blend = vec3( lum );", "	float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );", "	vec3 result1 = 2.0 * base.rgb * blend;", "	vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );", "	vec3 newColor = mix( result1, result2, L );", "	float A2 = opacity * base.a;", "	vec3 mixRGB = A2 * newColor.rgb;", "	mixRGB += ( ( 1.0 - A2 ) * base.rgb );", "	gl_FragColor = vec4( mixRGB, base.a );", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/BlendShader.js
var BlendShader = {
  uniforms: {
    tDiffuse1: {
      value: null
    },
    tDiffuse2: {
      value: null
    },
    mixRatio: {
      value: 0.5
    },
    opacity: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform float mixRatio;", "uniform sampler2D tDiffuse1;", "uniform sampler2D tDiffuse2;", "varying vec2 vUv;", "void main() {", "	vec4 texel1 = texture2D( tDiffuse1, vUv );", "	vec4 texel2 = texture2D( tDiffuse2, vUv );", "	gl_FragColor = opacity * mix( texel1, texel2, mixRatio );", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/BrightnessContrastShader.js
var BrightnessContrastShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    brightness: {
      value: 0
    },
    contrast: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float brightness;", "uniform float contrast;", "varying vec2 vUv;", "void main() {", "	gl_FragColor = texture2D( tDiffuse, vUv );", "	gl_FragColor.rgb += brightness;", "	if (contrast > 0.0) {", "		gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;", "	} else {", "		gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;", "	}", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/ColorCorrectionShader.js
var ColorCorrectionShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    powRGB: {
      value: new Vector3(2, 2, 2)
    },
    mulRGB: {
      value: new Vector3(1, 1, 1)
    },
    addRGB: {
      value: new Vector3(0, 0, 0)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec3 powRGB;", "uniform vec3 mulRGB;", "uniform vec3 addRGB;", "varying vec2 vUv;", "void main() {", "	gl_FragColor = texture2D( tDiffuse, vUv );", "	gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/ColorifyShader.js
var ColorifyShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    color: {
      value: new Color(16777215)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform vec3 color;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	vec3 luma = vec3( 0.299, 0.587, 0.114 );", "	float v = dot( texel.xyz, luma );", "	gl_FragColor = vec4( v * color, texel.w );", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/DOFMipMapShader.js
var DOFMipMapShader = {
  uniforms: {
    tColor: {
      value: null
    },
    tDepth: {
      value: null
    },
    focus: {
      value: 1
    },
    maxblur: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float focus;", "uniform float maxblur;", "uniform sampler2D tColor;", "uniform sampler2D tDepth;", "varying vec2 vUv;", "void main() {", "	vec4 depth = texture2D( tDepth, vUv );", "	float factor = depth.x - focus;", "	vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );", "	gl_FragColor = col;", "	gl_FragColor.a = 1.0;", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/FXAAShader.js
var FXAAShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2(1 / 1024, 1 / 512)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["precision highp float;", "", "uniform sampler2D tDiffuse;", "", "uniform vec2 resolution;", "", "varying vec2 vUv;", "", "// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)", "", "//----------------------------------------------------------------------------------", "// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag", "// SDK Version: v3.00", "// Email:       gameworks@nvidia.com", "// Site:        http://developer.nvidia.com/", "//", "// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.", "//", "// Redistribution and use in source and binary forms, with or without", "// modification, are permitted provided that the following conditions", "// are met:", "//  * Redistributions of source code must retain the above copyright", "//    notice, this list of conditions and the following disclaimer.", "//  * Redistributions in binary form must reproduce the above copyright", "//    notice, this list of conditions and the following disclaimer in the", "//    documentation and/or other materials provided with the distribution.", "//  * Neither the name of NVIDIA CORPORATION nor the names of its", "//    contributors may be used to endorse or promote products derived", "//    from this software without specific prior written permission.", "//", "// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY", "// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", "// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR", "// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR", "// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,", "// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,", "// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR", "// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY", "// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT", "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE", "// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", "//", "//----------------------------------------------------------------------------------", "", "#define FXAA_PC 1", "#define FXAA_GLSL_100 1", "#define FXAA_QUALITY_PRESET 12", "", "#define FXAA_GREEN_AS_LUMA 1", "", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_PC_CONSOLE", "    //", "    // The console algorithm for PC is included", "    // for developers targeting really low spec machines.", "    // Likely better to just run FXAA_PC, and use a really low preset.", "    //", "    #define FXAA_PC_CONSOLE 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_120", "    #define FXAA_GLSL_120 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_130", "    #define FXAA_GLSL_130 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_3", "    #define FXAA_HLSL_3 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_4", "    #define FXAA_HLSL_4 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_5", "    #define FXAA_HLSL_5 0", "#endif", "/*==========================================================================*/", "#ifndef FXAA_GREEN_AS_LUMA", "    //", "    // For those using non-linear color,", "    // and either not able to get luma in alpha, or not wanting to,", "    // this enables FXAA to run using green as a proxy for luma.", "    // So with this enabled, no need to pack luma in alpha.", "    //", "    // This will turn off AA on anything which lacks some amount of green.", "    // Pure red and blue or combination of only R and B, will get no AA.", "    //", "    // Might want to lower the settings for both,", "    //    fxaaConsoleEdgeThresholdMin", "    //    fxaaQualityEdgeThresholdMin", "    // In order to insure AA does not get turned off on colors", "    // which contain a minor amount of green.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_GREEN_AS_LUMA 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_EARLY_EXIT", "    //", "    // Controls algorithm's early exit path.", "    // On PS3 turning this ON adds 2 cycles to the shader.", "    // On 360 turning this OFF adds 10ths of a millisecond to the shader.", "    // Turning this off on console will result in a more blurry image.", "    // So this defaults to on.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_EARLY_EXIT 1", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_DISCARD", "    //", "    // Only valid for PC OpenGL currently.", "    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.", "    //", "    // 1 = Use discard on pixels which don't need AA.", "    //     For APIs which enable concurrent TEX+ROP from same surface.", "    // 0 = Return unchanged color on pixels which don't need AA.", "    //", "    #define FXAA_DISCARD 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_FAST_PIXEL_OFFSET", "    //", "    // Used for GLSL 120 only.", "    //", "    // 1 = GL API supports fast pixel offsets", "    // 0 = do not use fast pixel offsets", "    //", "    #ifdef GL_EXT_gpu_shader4", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifndef FXAA_FAST_PIXEL_OFFSET", "        #define FXAA_FAST_PIXEL_OFFSET 0", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GATHER4_ALPHA", "    //", "    // 1 = API supports gather4 on alpha channel.", "    // 0 = API does not support gather4 on alpha channel.", "    //", "    #if (FXAA_HLSL_5 == 1)", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifndef FXAA_GATHER4_ALPHA", "        #define FXAA_GATHER4_ALPHA 0", "    #endif", "#endif", "", "", "/*============================================================================", "                        FXAA QUALITY - TUNING KNOBS", "------------------------------------------------------------------------------", "NOTE the other tuning knobs are now in the shader function inputs!", "============================================================================*/", "#ifndef FXAA_QUALITY_PRESET", "    //", "    // Choose the quality preset.", "    // This needs to be compiled into the shader as it effects code.", "    // Best option to include multiple presets is to", "    // in each shader define the preset, then include this file.", "    //", "    // OPTIONS", "    // -----------------------------------------------------------------------", "    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)", "    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)", "    // 39       - no dither, very expensive", "    //", "    // NOTES", "    // -----------------------------------------------------------------------", "    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)", "    // 13 = about same speed as FXAA 3.9 and better than 12", "    // 23 = closest to FXAA 3.9 visually and performance wise", "    //  _ = the lowest digit is directly related to performance", "    // _  = the highest digit is directly related to style", "    //", "    #define FXAA_QUALITY_PRESET 12", "#endif", "", "", "/*============================================================================", "", "                           FXAA QUALITY - PRESETS", "", "============================================================================*/", "", "/*============================================================================", "                     FXAA QUALITY - MEDIUM DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 10)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 3.0", "    #define FXAA_QUALITY_P2 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 11)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 3.0", "    #define FXAA_QUALITY_P3 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 12)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 4.0", "    #define FXAA_QUALITY_P4 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 13)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 4.0", "    #define FXAA_QUALITY_P5 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 14)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 4.0", "    #define FXAA_QUALITY_P6 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 15)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 12.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - LOW DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 20)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 2.0", "    #define FXAA_QUALITY_P2 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 21)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 22)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 23)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 24)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 3.0", "    #define FXAA_QUALITY_P6 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 25)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 26)", "    #define FXAA_QUALITY_PS 9", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 4.0", "    #define FXAA_QUALITY_P8 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 27)", "    #define FXAA_QUALITY_PS 10", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 4.0", "    #define FXAA_QUALITY_P9 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 28)", "    #define FXAA_QUALITY_PS 11", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 4.0", "    #define FXAA_QUALITY_P10 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 29)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - EXTREME QUALITY", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 39)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.0", "    #define FXAA_QUALITY_P2 1.0", "    #define FXAA_QUALITY_P3 1.0", "    #define FXAA_QUALITY_P4 1.0", "    #define FXAA_QUALITY_P5 1.5", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "", "", "/*============================================================================", "", "                                API PORTING", "", "============================================================================*/", "#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)", "    #define FxaaBool bool", "    #define FxaaDiscard discard", "    #define FxaaFloat float", "    #define FxaaFloat2 vec2", "    #define FxaaFloat3 vec3", "    #define FxaaFloat4 vec4", "    #define FxaaHalf float", "    #define FxaaHalf2 vec2", "    #define FxaaHalf3 vec3", "    #define FxaaHalf4 vec4", "    #define FxaaInt2 ivec2", "    #define FxaaSat(x) clamp(x, 0.0, 1.0)", "    #define FxaaTex sampler2D", "#else", "    #define FxaaBool bool", "    #define FxaaDiscard clip(-1)", "    #define FxaaFloat float", "    #define FxaaFloat2 float2", "    #define FxaaFloat3 float3", "    #define FxaaFloat4 float4", "    #define FxaaHalf half", "    #define FxaaHalf2 half2", "    #define FxaaHalf3 half3", "    #define FxaaHalf4 half4", "    #define FxaaSat(x) saturate(x)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_100 == 1)", "  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)", "  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_120 == 1)", "    // Requires,", "    //  #version 120", "    // And at least,", "    //  #extension GL_EXT_gpu_shader4 : enable", "    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)", "    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)", "    #if (FXAA_FAST_PIXEL_OFFSET == 1)", "        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)", "    #else", "        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)", "    #endif", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_130 == 1)", '    // Requires "#version 130" or better', "    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_3 == 1)", "    #define FxaaInt2 float2", "    #define FxaaTex sampler2D", "    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))", "    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_4 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_5 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)", "    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)", "    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)", "    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)", "#endif", "", "", "/*============================================================================", "                   GREEN AS LUMA OPTION SUPPORT FUNCTION", "============================================================================*/", "#if (FXAA_GREEN_AS_LUMA == 0)", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }", "#else", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }", "#endif", "", "", "", "", "/*============================================================================", "", "                             FXAA3 QUALITY - PC", "", "============================================================================*/", "#if (FXAA_PC == 1)", "/*--------------------------------------------------------------------------*/", "FxaaFloat4 FxaaPixelShader(", "    //", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy} = center of pixel", "    FxaaFloat2 pos,", "    //", "    // Used only for FXAA Console, and not used on the 360 version.", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy_} = upper left of pixel", "    // {_zw} = lower right of pixel", "    FxaaFloat4 fxaaConsolePosPos,", "    //", "    // Input color texture.", "    // {rgb_} = color in linear or perceptual color space", "    // if (FXAA_GREEN_AS_LUMA == 0)", "    //     {__a} = luma in perceptual color space (not linear)", "    FxaaTex tex,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", '    // For everything but 360, just use the same input here as for "tex".', "    // For 360, same texture, just alias with a 2nd sampler.", "    // This sampler needs to have an exponent bias of -1.", "    FxaaTex fxaaConsole360TexExpBiasNegOne,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", '    // For everything but 360, just use the same input here as for "tex".', "    // For 360, same texture, just alias with a 3nd sampler.", "    // This sampler needs to have an exponent bias of -2.", "    FxaaTex fxaaConsole360TexExpBiasNegTwo,", "    //", "    // Only used on FXAA Quality.", "    // This must be from a constant/uniform.", "    // {x_} = 1.0/screenWidthInPixels", "    // {_y} = 1.0/screenHeightInPixels", "    FxaaFloat2 fxaaQualityRcpFrame,", "    //", "    // Only used on FXAA Console.", "    // This must be from a constant/uniform.", "    // This effects sub-pixel AA quality and inversely sharpness.", "    //   Where N ranges between,", "    //     N = 0.50 (default)", "    //     N = 0.33 (sharper)", "    // {x__} = -N/screenWidthInPixels", "    // {_y_} = -N/screenHeightInPixels", "    // {_z_} =  N/screenWidthInPixels", "    // {__w} =  N/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt,", "    //", "    // Only used on FXAA Console.", "    // Not used on 360, but used on PS3 and PC.", "    // This must be from a constant/uniform.", "    // {x__} = -2.0/screenWidthInPixels", "    // {_y_} = -2.0/screenHeightInPixels", "    // {_z_} =  2.0/screenWidthInPixels", "    // {__w} =  2.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt2,", "    //", "    // Only used on FXAA Console.", "    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.", "    // This must be from a constant/uniform.", "    // {x__} =  8.0/screenWidthInPixels", "    // {_y_} =  8.0/screenHeightInPixels", "    // {_z_} = -4.0/screenWidthInPixels", "    // {__w} = -4.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsole360RcpFrameOpt2,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_SUBPIX define.", "    // It is here now to allow easier tuning.", "    // Choose the amount of sub-pixel aliasing removal.", "    // This can effect sharpness.", "    //   1.00 - upper limit (softer)", "    //   0.75 - default amount of filtering", "    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)", "    //   0.25 - almost off", "    //   0.00 - completely off", "    FxaaFloat fxaaQualitySubpix,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // The minimum amount of local contrast required to apply algorithm.", "    //   0.333 - too little (faster)", "    //   0.250 - low quality", "    //   0.166 - default", "    //   0.125 - high quality", "    //   0.063 - overkill (slower)", "    FxaaFloat fxaaQualityEdgeThreshold,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    //   0.0833 - upper limit (default, the start of visible unfiltered edges)", "    //   0.0625 - high quality (faster)", "    //   0.0312 - visible limit (slower)", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaQualityEdgeThresholdMin,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only three safe values here: 2 and 4 and 8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // For all other platforms can be a non-power of two.", "    //   8.0 is sharper (default!!!)", "    //   4.0 is softer", "    //   2.0 is really soft (good only for vector graphics inputs)", "    FxaaFloat fxaaConsoleEdgeSharpness,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only two safe values here: 1/4 and 1/8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // The console setting has a different mapping than the quality setting.", "    // Other platforms can use other values.", "    //   0.125 leaves less aliasing, but is softer (default!!!)", "    //   0.25 leaves more aliasing, and is sharper", "    FxaaFloat fxaaConsoleEdgeThreshold,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    // The console setting has a different mapping than the quality setting.", "    // This only applies when FXAA_EARLY_EXIT is 1.", "    // This does not apply to PS3,", "    // PS3 was simplified to avoid more shader instructions.", "    //   0.06 - faster but more aliasing in darks", "    //   0.05 - default", "    //   0.04 - slower and less aliasing in darks", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaConsoleEdgeThresholdMin,", "    //", "    // Extra constants for 360 FXAA Console only.", "    // Use zeros or anything else for other platforms.", "    // These must be in physical constant registers and NOT immediates.", "    // Immediates will result in compiler un-optimizing.", "    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)", "    FxaaFloat4 fxaaConsole360ConstDir", ") {", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posM;", "    posM.x = pos.x;", "    posM.y = pos.y;", "    #if (FXAA_GATHER4_ALPHA == 1)", "        #if (FXAA_DISCARD == 0)", "            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "            #if (FXAA_GREEN_AS_LUMA == 0)", "                #define lumaM rgbyM.w", "            #else", "                #define lumaM rgbyM.y", "            #endif", "        #endif", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));", "        #else", "            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));", "        #endif", "        #if (FXAA_DISCARD == 1)", "            #define lumaM luma4A.w", "        #endif", "        #define lumaE luma4A.z", "        #define lumaS luma4A.x", "        #define lumaSE luma4A.y", "        #define lumaNW luma4B.w", "        #define lumaN luma4B.z", "        #define lumaW luma4B.x", "    #else", "        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            #define lumaM rgbyM.w", "        #else", "            #define lumaM rgbyM.y", "        #endif", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));", "        #endif", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat maxSM = max(lumaS, lumaM);", "    FxaaFloat minSM = min(lumaS, lumaM);", "    FxaaFloat maxESM = max(lumaE, maxSM);", "    FxaaFloat minESM = min(lumaE, minSM);", "    FxaaFloat maxWN = max(lumaN, lumaW);", "    FxaaFloat minWN = min(lumaN, lumaW);", "    FxaaFloat rangeMax = max(maxWN, maxESM);", "    FxaaFloat rangeMin = min(minWN, minESM);", "    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;", "    FxaaFloat range = rangeMax - rangeMin;", "    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);", "    FxaaBool earlyExit = range < rangeMaxClamped;", "/*--------------------------------------------------------------------------*/", "    if(earlyExit)", "        #if (FXAA_DISCARD == 1)", "            FxaaDiscard;", "        #else", "            return rgbyM;", "        #endif", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_GATHER4_ALPHA == 0)", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "        #endif", "    #else", "        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));", "        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNS = lumaN + lumaS;", "    FxaaFloat lumaWE = lumaW + lumaE;", "    FxaaFloat subpixRcpRange = 1.0/range;", "    FxaaFloat subpixNSWE = lumaNS + lumaWE;", "    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;", "    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNESE = lumaNE + lumaSE;", "    FxaaFloat lumaNWNE = lumaNW + lumaNE;", "    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;", "    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNWSW = lumaNW + lumaSW;", "    FxaaFloat lumaSWSE = lumaSW + lumaSE;", "    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);", "    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);", "    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;", "    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;", "    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;", "    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;", "    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;", "    FxaaBool horzSpan = edgeHorz >= edgeVert;", "    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;", "/*--------------------------------------------------------------------------*/", "    if(!horzSpan) lumaN = lumaW;", "    if(!horzSpan) lumaS = lumaE;", "    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;", "    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat gradientN = lumaN - lumaM;", "    FxaaFloat gradientS = lumaS - lumaM;", "    FxaaFloat lumaNN = lumaN + lumaM;", "    FxaaFloat lumaSS = lumaS + lumaM;", "    FxaaBool pairN = abs(gradientN) >= abs(gradientS);", "    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));", "    if(pairN) lengthSign = -lengthSign;", "    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posB;", "    posB.x = posM.x;", "    posB.y = posM.y;", "    FxaaFloat2 offNP;", "    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;", "    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;", "    if(!horzSpan) posB.x += lengthSign * 0.5;", "    if( horzSpan) posB.y += lengthSign * 0.5;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posN;", "    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;", "    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat2 posP;", "    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;", "    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;", "    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));", "    FxaaFloat subpixE = subpixC * subpixC;", "    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));", "/*--------------------------------------------------------------------------*/", "    if(!pairN) lumaNN = lumaSS;", "    FxaaFloat gradientScaled = gradient * 1.0/4.0;", "    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;", "    FxaaFloat subpixF = subpixD * subpixE;", "    FxaaBool lumaMLTZero = lumaMM < 0.0;", "/*--------------------------------------------------------------------------*/", "    lumaEndN -= lumaNN * 0.5;", "    lumaEndP -= lumaNN * 0.5;", "    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;", "    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;", "    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;", "    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;", "    FxaaBool doneNP = (!doneN) || (!doneP);", "    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;", "    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;", "/*--------------------------------------------------------------------------*/", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 3)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 4)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 5)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 6)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;", "/*--------------------------------------------------------------------------*/", "                        #if (FXAA_QUALITY_PS > 7)", "                        if(doneNP) {", "                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                            doneN = abs(lumaEndN) >= gradientScaled;", "                            doneP = abs(lumaEndP) >= gradientScaled;", "                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;", "                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;", "                            doneNP = (!doneN) || (!doneP);", "                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;", "                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_QUALITY_PS > 8)", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 9)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 10)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 11)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 12)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "    #endif", "/*--------------------------------------------------------------------------*/", "                        }", "                        #endif", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "/*--------------------------------------------------------------------------*/", "    FxaaFloat dstN = posM.x - posN.x;", "    FxaaFloat dstP = posP.x - posM.x;", "    if(!horzSpan) dstN = posM.y - posN.y;", "    if(!horzSpan) dstP = posP.y - posM.y;", "/*--------------------------------------------------------------------------*/", "    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;", "    FxaaFloat spanLength = (dstP + dstN);", "    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;", "    FxaaFloat spanLengthRcp = 1.0/spanLength;", "/*--------------------------------------------------------------------------*/", "    FxaaBool directionN = dstN < dstP;", "    FxaaFloat dst = min(dstN, dstP);", "    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;", "    FxaaFloat subpixG = subpixF * subpixF;", "    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;", "    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;", "    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);", "    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;", "    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;", "    #if (FXAA_DISCARD == 1)", "        return FxaaTexTop(tex, posM);", "    #else", "        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);", "    #endif", "}", "/*==========================================================================*/", "#endif", "", "void main() {", "  gl_FragColor = FxaaPixelShader(", "    vUv,", "    vec4(0.0),", "    tDiffuse,", "    tDiffuse,", "    tDiffuse,", "    resolution,", "    vec4(0.0),", "    vec4(0.0),", "    vec4(0.0),", "    0.75,", "    0.166,", "    0.0833,", "    0.0,", "    0.0,", "    0.0,", "    vec4(0.0)", "  );", "", "  // TODO avoid querying texture twice for same texel", "  gl_FragColor.a = texture2D(tDiffuse, vUv).a;", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/FocusShader.js
var FocusShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    screenWidth: {
      value: 1024
    },
    screenHeight: {
      value: 1024
    },
    sampleDistance: {
      value: 0.94
    },
    waveFactor: {
      value: 125e-5
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float screenWidth;", "uniform float screenHeight;", "uniform float sampleDistance;", "uniform float waveFactor;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 color, org, tmp, add;", "	float sample_dist, f;", "	vec2 vin;", "	vec2 uv = vUv;", "	add = color = org = texture2D( tDiffuse, uv );", "	vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );", "	sample_dist = dot( vin, vin ) * 2.0;", "	f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;", "	vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );", "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );", "	color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );", "	gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/FreiChenShader.js
var FreiChenShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    aspect: {
      value: new Vector2(512, 512)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "uniform vec2 aspect;",
    "vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);",
    "mat3 G[9];",
    "const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );",
    "const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );",
    "const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );",
    "const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );",
    "const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );",
    "const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );",
    "const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );",
    "const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );",
    "const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );",
    "void main(void)",
    "{",
    "	G[0] = g0,",
    "	G[1] = g1,",
    "	G[2] = g2,",
    "	G[3] = g3,",
    "	G[4] = g4,",
    "	G[5] = g5,",
    "	G[6] = g6,",
    "	G[7] = g7,",
    "	G[8] = g8;",
    "	mat3 I;",
    "	float cnv[9];",
    "	vec3 sample;",
    "	for (float i=0.0; i<3.0; i++) {",
    "		for (float j=0.0; j<3.0; j++) {",
    "			sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;",
    "			I[int(i)][int(j)] = length(sample);",
    "		}",
    "	}",
    "	for (int i=0; i<9; i++) {",
    "		float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);",
    "		cnv[i] = dp3 * dp3;",
    "	}",
    "	float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);",
    "	float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);",
    "	gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/FresnelShader.js
var FresnelShader = {
  uniforms: {
    mRefractionRatio: {
      value: 1.02
    },
    mFresnelBias: {
      value: 0.1
    },
    mFresnelPower: {
      value: 2
    },
    mFresnelScale: {
      value: 1
    },
    tCube: {
      value: null
    }
  },
  vertexShader: ["uniform float mRefractionRatio;", "uniform float mFresnelBias;", "uniform float mFresnelScale;", "uniform float mFresnelPower;", "varying vec3 vReflect;", "varying vec3 vRefract[3];", "varying float vReflectionFactor;", "void main() {", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "	vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );", "	vec3 I = worldPosition.xyz - cameraPosition;", "	vReflect = reflect( I, worldNormal );", "	vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );", "	vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );", "	vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );", "	vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );", "	gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),
  fragmentShader: ["uniform samplerCube tCube;", "varying vec3 vReflect;", "varying vec3 vRefract[3];", "varying float vReflectionFactor;", "void main() {", "	vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );", "	vec4 refractedColor = vec4( 1.0 );", "	refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;", "	refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;", "	refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;", "	gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/GammaCorrectionShader.js
var GammaCorrectionShader = {
  uniforms: {
    tDiffuse: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 tex = texture2D( tDiffuse, vUv );", "	gl_FragColor = LinearTosRGB( tex );", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/GodRaysShader.js
var GodRaysDepthMaskShader = {
  uniforms: {
    tInput: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", " vUv = uv;", " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["varying vec2 vUv;", "uniform sampler2D tInput;", "void main() {", "	gl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );", "}"].join("\n")
};
var GodRaysGenerateShader = {
  uniforms: {
    tInput: {
      value: null
    },
    fStepSize: {
      value: 1
    },
    vSunPositionScreenSpace: {
      value: new Vector3()
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", " vUv = uv;", " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#define TAPS_PER_PASS 6.0",
    "varying vec2 vUv;",
    "uniform sampler2D tInput;",
    "uniform vec3 vSunPositionScreenSpace;",
    "uniform float fStepSize;",
    "void main() {",
    "	vec2 delta = vSunPositionScreenSpace.xy - vUv;",
    "	float dist = length( delta );",
    "	vec2 stepv = fStepSize * delta / dist;",
    "	float iters = dist/fStepSize;",
    "	vec2 uv = vUv.xy;",
    "	float col = 0.0;",
    "	float f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );",
    "	if ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	gl_FragColor = vec4( col/TAPS_PER_PASS );",
    "	gl_FragColor.a = 1.0;",
    "}"
  ].join("\n")
};
var GodRaysCombineShader = {
  uniforms: {
    tColors: {
      value: null
    },
    tGodRays: {
      value: null
    },
    fGodRayIntensity: {
      value: 0.69
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "varying vec2 vUv;",
    "uniform sampler2D tColors;",
    "uniform sampler2D tGodRays;",
    "uniform float fGodRayIntensity;",
    "void main() {",
    "	gl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );",
    "	gl_FragColor.a = 1.0;",
    "}"
  ].join("\n")
};
var GodRaysFakeSunShader = {
  uniforms: {
    vSunPositionScreenSpace: {
      value: new Vector3()
    },
    fAspect: {
      value: 1
    },
    sunColor: {
      value: new Color(16772608)
    },
    bgColor: {
      value: new Color(0)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "varying vec2 vUv;",
    "uniform vec3 vSunPositionScreenSpace;",
    "uniform float fAspect;",
    "uniform vec3 sunColor;",
    "uniform vec3 bgColor;",
    "void main() {",
    "	vec2 diff = vUv - vSunPositionScreenSpace.xy;",
    "	diff.x *= fAspect;",
    "	float prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );",
    "	prop = 0.35 * pow( 1.0 - prop, 3.0 );",
    "	gl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;",
    "	gl_FragColor.w = 1.0;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/HorizontalBlurShader.js
var HorizontalBlurShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    h: {
      value: 1 / 512
    }
  },
  vertexShader: `
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `
};

// node_modules/three-stdlib/shaders/HorizontalTiltShiftShader.js
var HorizontalTiltShiftShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    h: {
      value: 1 / 512
    },
    r: {
      value: 0.35
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float h;", "uniform float r;", "varying vec2 vUv;", "void main() {", "	vec4 sum = vec4( 0.0 );", "	float hh = h * abs( r - vUv.y );", "	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;", "	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;", "	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;", "	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;", "	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;", "	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;", "	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;", "	gl_FragColor = sum;", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/HueSaturationShader.js
var HueSaturationShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    hue: {
      value: 0
    },
    saturation: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform float hue;",
    "uniform float saturation;",
    "varying vec2 vUv;",
    "void main() {",
    "	gl_FragColor = texture2D( tDiffuse, vUv );",
    "	float angle = hue * 3.14159265;",
    "	float s = sin(angle), c = cos(angle);",
    "	vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;",
    "	float len = length(gl_FragColor.rgb);",
    "	gl_FragColor.rgb = vec3(",
    "		dot(gl_FragColor.rgb, weights.xyz),",
    "		dot(gl_FragColor.rgb, weights.zxy),",
    "		dot(gl_FragColor.rgb, weights.yzx)",
    "	);",
    "	float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;",
    "	if (saturation > 0.0) {",
    "		gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));",
    "	} else {",
    "		gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);",
    "	}",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/KaleidoShader.js
var KaleidoShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    sides: {
      value: 6
    },
    angle: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float sides;", "uniform float angle;", "varying vec2 vUv;", "void main() {", "	vec2 p = vUv - 0.5;", "	float r = length(p);", "	float a = atan(p.y, p.x) + angle;", "	float tau = 2. * 3.1416 ;", "	a = mod(a, tau/sides);", "	a = abs(a - tau/sides/2.) ;", "	p = r * vec2(cos(a), sin(a));", "	vec4 color = texture2D(tDiffuse, p + 0.5);", "	gl_FragColor = color;", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/MirrorShader.js
var MirrorShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    side: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform int side;", "varying vec2 vUv;", "void main() {", "	vec2 p = vUv;", "	if (side == 0){", "		if (p.x > 0.5) p.x = 1.0 - p.x;", "	}else if (side == 1){", "		if (p.x < 0.5) p.x = 1.0 - p.x;", "	}else if (side == 2){", "		if (p.y < 0.5) p.y = 1.0 - p.y;", "	}else if (side == 3){", "		if (p.y > 0.5) p.y = 1.0 - p.y;", "	} ", "	vec4 color = texture2D(tDiffuse, p);", "	gl_FragColor = color;", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/NormalMapShader.js
var NormalMapShader = {
  uniforms: {
    heightMap: {
      value: null
    },
    resolution: {
      value: new Vector2(512, 512)
    },
    scale: {
      value: new Vector2(1, 1)
    },
    height: {
      value: 0.05
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float height;", "uniform vec2 resolution;", "uniform sampler2D heightMap;", "varying vec2 vUv;", "void main() {", "	float val = texture2D( heightMap, vUv ).x;", "	float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;", "	float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;", "	gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/ParallaxShader.js
var ParallaxShader = {
  modes: {
    none: "NO_PARALLAX",
    basic: "USE_BASIC_PARALLAX",
    steep: "USE_STEEP_PARALLAX",
    occlusion: "USE_OCLUSION_PARALLAX",
    relief: "USE_RELIEF_PARALLAX"
  },
  uniforms: {
    bumpMap: {
      value: null
    },
    map: {
      value: null
    },
    parallaxScale: {
      value: null
    },
    parallaxMinLayers: {
      value: null
    },
    parallaxMaxLayers: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "varying vec3 vViewPosition;", "varying vec3 vNormal;", "void main() {", "	vUv = uv;", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	vViewPosition = -mvPosition.xyz;", "	vNormal = normalize( normalMatrix * normal );", "	gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D bumpMap;",
    "uniform sampler2D map;",
    "uniform float parallaxScale;",
    "uniform float parallaxMinLayers;",
    "uniform float parallaxMaxLayers;",
    "varying vec2 vUv;",
    "varying vec3 vViewPosition;",
    "varying vec3 vNormal;",
    "#ifdef USE_BASIC_PARALLAX",
    "	vec2 parallaxMap( in vec3 V ) {",
    "		float initialHeight = texture2D( bumpMap, vUv ).r;",
    "		vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;",
    "		return vUv - texCoordOffset;",
    "	}",
    "#else",
    "	vec2 parallaxMap( in vec3 V ) {",
    "		float numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );",
    "		float layerHeight = 1.0 / numLayers;",
    "		float currentLayerHeight = 0.0;",
    "		vec2 dtex = parallaxScale * V.xy / V.z / numLayers;",
    "		vec2 currentTextureCoords = vUv;",
    "		float heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
    "		for ( int i = 0; i < 30; i += 1 ) {",
    "			if ( heightFromTexture <= currentLayerHeight ) {",
    "				break;",
    "			}",
    "			currentLayerHeight += layerHeight;",
    "			currentTextureCoords -= dtex;",
    "			heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
    "		}",
    "		#ifdef USE_STEEP_PARALLAX",
    "			return currentTextureCoords;",
    "		#elif defined( USE_RELIEF_PARALLAX )",
    "			vec2 deltaTexCoord = dtex / 2.0;",
    "			float deltaHeight = layerHeight / 2.0;",
    "			currentTextureCoords += deltaTexCoord;",
    "			currentLayerHeight -= deltaHeight;",
    "			const int numSearches = 5;",
    "			for ( int i = 0; i < numSearches; i += 1 ) {",
    "				deltaTexCoord /= 2.0;",
    "				deltaHeight /= 2.0;",
    "				heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
    "				if( heightFromTexture > currentLayerHeight ) {",
    "					currentTextureCoords -= deltaTexCoord;",
    "					currentLayerHeight += deltaHeight;",
    "				} else {",
    "					currentTextureCoords += deltaTexCoord;",
    "					currentLayerHeight -= deltaHeight;",
    "				}",
    "			}",
    "			return currentTextureCoords;",
    "		#elif defined( USE_OCLUSION_PARALLAX )",
    "			vec2 prevTCoords = currentTextureCoords + dtex;",
    "			float nextH = heightFromTexture - currentLayerHeight;",
    "			float prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;",
    "			float weight = nextH / ( nextH - prevH );",
    "			return prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );",
    "		#else",
    "			return vUv;",
    "		#endif",
    "	}",
    "#endif",
    "vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {",
    "	vec2 texDx = dFdx( vUv );",
    "	vec2 texDy = dFdy( vUv );",
    "	vec3 vSigmaX = dFdx( surfPosition );",
    "	vec3 vSigmaY = dFdy( surfPosition );",
    "	vec3 vR1 = cross( vSigmaY, surfNormal );",
    "	vec3 vR2 = cross( surfNormal, vSigmaX );",
    "	float fDet = dot( vSigmaX, vR1 );",
    "	vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );",
    "	vec3 vProjVtex;",
    "	vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;",
    "	vProjVtex.z = dot( surfNormal, viewPosition );",
    "	return parallaxMap( vProjVtex );",
    "}",
    "void main() {",
    "	vec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );",
    "	gl_FragColor = texture2D( map, mapUv );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/PixelShader.js
var PixelShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: null
    },
    pixelSize: {
      value: 1
    }
  },
  vertexShader: ["varying highp vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float pixelSize;", "uniform vec2 resolution;", "varying highp vec2 vUv;", "void main(){", "vec2 dxy = pixelSize / resolution;", "vec2 coord = dxy * floor( vUv / dxy );", "gl_FragColor = texture2D(tDiffuse, coord);", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/RGBShiftShader.js
var RGBShiftShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    amount: {
      value: 5e-3
    },
    angle: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float amount;", "uniform float angle;", "varying vec2 vUv;", "void main() {", "	vec2 offset = amount * vec2( cos(angle), sin(angle));", "	vec4 cr = texture2D(tDiffuse, vUv + offset);", "	vec4 cga = texture2D(tDiffuse, vUv);", "	vec4 cb = texture2D(tDiffuse, vUv - offset);", "	gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/SepiaShader.js
var SepiaShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    amount: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float amount;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 color = texture2D( tDiffuse, vUv );", "	vec3 c = color.rgb;", "	color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );", "	color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );", "	color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );", "	gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/SobelOperatorShader.js
var SobelOperatorShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2()
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );",
    "	const mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );",
    "	const mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );",
    "	float tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;",
    "	float tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;",
    "	float tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;",
    "	float tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;",
    "	float tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;",
    "	float tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;",
    "	float tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;",
    "	float tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;",
    "	float tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;",
    "	float valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + ",
    "		Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + ",
    "		Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; ",
    "	float valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + ",
    "		Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + ",
    "		Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; ",
    "	float G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );",
    "	gl_FragColor = vec4( vec3( G ), 1 );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/SubsurfaceScatteringShader.js
function replaceAll(string, find, replace) {
  return string.split(find).join(replace);
}
var meshphong_frag_head = ShaderChunk["meshphong_frag"].slice(0, ShaderChunk["meshphong_frag"].indexOf("void main() {"));
var meshphong_frag_body = ShaderChunk["meshphong_frag"].slice(ShaderChunk["meshphong_frag"].indexOf("void main() {"));
var SubsurfaceScatteringShader = {
  uniforms: UniformsUtils.merge([ShaderLib["phong"].uniforms, {
    thicknessMap: {
      value: null
    },
    thicknessColor: {
      value: new Color(16777215)
    },
    thicknessDistortion: {
      value: 0.1
    },
    thicknessAmbient: {
      value: 0
    },
    thicknessAttenuation: {
      value: 0.1
    },
    thicknessPower: {
      value: 2
    },
    thicknessScale: {
      value: 10
    }
  }]),
  vertexShader: ["#define USE_UV", ShaderChunk["meshphong_vert"]].join("\n"),
  fragmentShader: ["#define USE_UV", "#define SUBSURFACE", meshphong_frag_head, "uniform sampler2D thicknessMap;", "uniform float thicknessPower;", "uniform float thicknessScale;", "uniform float thicknessDistortion;", "uniform float thicknessAmbient;", "uniform float thicknessAttenuation;", "uniform vec3 thicknessColor;", "void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {", "	vec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;", "	vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));", "	float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;", "	vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;", "	reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;", "}", meshphong_frag_body.replace("#include <lights_fragment_begin>", replaceAll(ShaderChunk["lights_fragment_begin"], "RE_Direct( directLight, geometry, material, reflectedLight );", ["RE_Direct( directLight, geometry, material, reflectedLight );", "#if defined( SUBSURFACE ) && defined( USE_UV )", " RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);", "#endif"].join("\n")))].join("\n")
};

// node_modules/three-stdlib/shaders/TechnicolorShader.js
var TechnicolorShader = {
  uniforms: {
    tDiffuse: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );", "	vec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);", "	gl_FragColor = newTex;", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/ToonShader.js
var ToonShader1 = {
  uniforms: {
    uDirLightPos: {
      value: new Vector3()
    },
    uDirLightColor: {
      value: new Color(15658734)
    },
    uAmbientLightColor: {
      value: new Color(328965)
    },
    uBaseColor: {
      value: new Color(16777215)
    }
  },
  vertexShader: ["varying vec3 vNormal;", "varying vec3 vRefract;", "void main() {", "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	vec3 worldNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );", "	vNormal = normalize( normalMatrix * normal );", "	vec3 I = worldPosition.xyz - cameraPosition;", "	vRefract = refract( normalize( I ), worldNormal, 1.02 );", "	gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),
  fragmentShader: ["uniform vec3 uBaseColor;", "uniform vec3 uDirLightPos;", "uniform vec3 uDirLightColor;", "uniform vec3 uAmbientLightColor;", "varying vec3 vNormal;", "varying vec3 vRefract;", "void main() {", "	float directionalLightWeighting = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);", "	vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;", "	float intensity = smoothstep( - 0.5, 1.0, pow( length(lightWeighting), 20.0 ) );", "	intensity += length(lightWeighting) * 0.2;", "	float cameraWeighting = dot( normalize( vNormal ), vRefract );", "	intensity += pow( 1.0 - length( cameraWeighting ), 6.0 );", "	intensity = intensity * 0.2 + 0.3;", "	if ( intensity < 0.50 ) {", "		gl_FragColor = vec4( 2.0 * intensity * uBaseColor, 1.0 );", "	} else {", "		gl_FragColor = vec4( 1.0 - 2.0 * ( 1.0 - intensity ) * ( 1.0 - uBaseColor ), 1.0 );", "}", "}"].join("\n")
};
var ToonShader2 = {
  uniforms: {
    uDirLightPos: {
      value: new Vector3()
    },
    uDirLightColor: {
      value: new Color(15658734)
    },
    uAmbientLightColor: {
      value: new Color(328965)
    },
    uBaseColor: {
      value: new Color(15658734)
    },
    uLineColor1: {
      value: new Color(8421504)
    },
    uLineColor2: {
      value: new Color(0)
    },
    uLineColor3: {
      value: new Color(0)
    },
    uLineColor4: {
      value: new Color(0)
    }
  },
  vertexShader: ["varying vec3 vNormal;", "void main() {", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "	vNormal = normalize( normalMatrix * normal );", "}"].join("\n"),
  fragmentShader: ["uniform vec3 uBaseColor;", "uniform vec3 uLineColor1;", "uniform vec3 uLineColor2;", "uniform vec3 uLineColor3;", "uniform vec3 uLineColor4;", "uniform vec3 uDirLightPos;", "uniform vec3 uDirLightColor;", "uniform vec3 uAmbientLightColor;", "varying vec3 vNormal;", "void main() {", "	float camera = max( dot( normalize( vNormal ), vec3( 0.0, 0.0, 1.0 ) ), 0.4);", "	float light = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);", "	gl_FragColor = vec4( uBaseColor, 1.0 );", "	if ( length(uAmbientLightColor + uDirLightColor * light) < 1.00 ) {", "		gl_FragColor *= vec4( uLineColor1, 1.0 );", "	}", "	if ( length(uAmbientLightColor + uDirLightColor * camera) < 0.50 ) {", "		gl_FragColor *= vec4( uLineColor2, 1.0 );", "	}", "}"].join("\n")
};
var ToonShaderHatching = {
  uniforms: {
    uDirLightPos: {
      value: new Vector3()
    },
    uDirLightColor: {
      value: new Color(15658734)
    },
    uAmbientLightColor: {
      value: new Color(328965)
    },
    uBaseColor: {
      value: new Color(16777215)
    },
    uLineColor1: {
      value: new Color(0)
    },
    uLineColor2: {
      value: new Color(0)
    },
    uLineColor3: {
      value: new Color(0)
    },
    uLineColor4: {
      value: new Color(0)
    }
  },
  vertexShader: ["varying vec3 vNormal;", "void main() {", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "	vNormal = normalize( normalMatrix * normal );", "}"].join("\n"),
  fragmentShader: ["uniform vec3 uBaseColor;", "uniform vec3 uLineColor1;", "uniform vec3 uLineColor2;", "uniform vec3 uLineColor3;", "uniform vec3 uLineColor4;", "uniform vec3 uDirLightPos;", "uniform vec3 uDirLightColor;", "uniform vec3 uAmbientLightColor;", "varying vec3 vNormal;", "void main() {", "	float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);", "	vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;", "	gl_FragColor = vec4( uBaseColor, 1.0 );", "	if ( length(lightWeighting) < 1.00 ) {", "		if ( mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {", "			gl_FragColor = vec4( uLineColor1, 1.0 );", "		}", "	}", "	if ( length(lightWeighting) < 0.75 ) {", "		if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {", "			gl_FragColor = vec4( uLineColor2, 1.0 );", "		}", "	}", "	if ( length(lightWeighting) < 0.50 ) {", "		if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {", "			gl_FragColor = vec4( uLineColor3, 1.0 );", "		}", "	}", "	if ( length(lightWeighting) < 0.3465 ) {", "		if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {", "			gl_FragColor = vec4( uLineColor4, 1.0 );", "	}", "	}", "}"].join("\n")
};
var ToonShaderDotted = {
  uniforms: {
    uDirLightPos: {
      value: new Vector3()
    },
    uDirLightColor: {
      value: new Color(15658734)
    },
    uAmbientLightColor: {
      value: new Color(328965)
    },
    uBaseColor: {
      value: new Color(16777215)
    },
    uLineColor1: {
      value: new Color(0)
    }
  },
  vertexShader: ["varying vec3 vNormal;", "void main() {", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "	vNormal = normalize( normalMatrix * normal );", "}"].join("\n"),
  fragmentShader: ["uniform vec3 uBaseColor;", "uniform vec3 uLineColor1;", "uniform vec3 uLineColor2;", "uniform vec3 uLineColor3;", "uniform vec3 uLineColor4;", "uniform vec3 uDirLightPos;", "uniform vec3 uDirLightColor;", "uniform vec3 uAmbientLightColor;", "varying vec3 vNormal;", "void main() {", "float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);", "vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;", "gl_FragColor = vec4( uBaseColor, 1.0 );", "if ( length(lightWeighting) < 1.00 ) {", "		if ( ( mod(gl_FragCoord.x, 4.001) + mod(gl_FragCoord.y, 4.0) ) > 6.00 ) {", "			gl_FragColor = vec4( uLineColor1, 1.0 );", "		}", "	}", "	if ( length(lightWeighting) < 0.50 ) {", "		if ( ( mod(gl_FragCoord.x + 2.0, 4.001) + mod(gl_FragCoord.y + 2.0, 4.0) ) > 6.00 ) {", "			gl_FragColor = vec4( uLineColor1, 1.0 );", "		}", "	}", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/TriangleBlurShader.js
var TriangleBlurShader = {
  uniforms: {
    texture: {
      value: null
    },
    delta: {
      value: new Vector2(1, 1)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#include <common>",
    "#define ITERATIONS 10.0",
    "uniform sampler2D texture;",
    "uniform vec2 delta;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 color = vec4( 0.0 );",
    "	float total = 0.0;",
    "	float offset = rand( vUv );",
    "	for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {",
    "		float percent = ( t + offset - 0.5 ) / ITERATIONS;",
    "		float weight = 1.0 - abs( percent );",
    "		color += texture2D( texture, vUv + delta * percent ) * weight;",
    "		total += weight;",
    "	}",
    "	gl_FragColor = color / total;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/VerticalBlurShader.js
var VerticalBlurShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    v: {
      value: 1 / 512
    }
  },
  vertexShader: `
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `,
  fragmentShader: `

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `
};

// node_modules/three-stdlib/shaders/VerticalTiltShiftShader.js
var VerticalTiltShiftShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    v: {
      value: 1 / 512
    },
    r: {
      value: 0.35
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float v;", "uniform float r;", "varying vec2 vUv;", "void main() {", "	vec4 sum = vec4( 0.0 );", "	float vv = v * abs( r - vUv.y );", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;", "	gl_FragColor = sum;", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/VignetteShader.js
var VignetteShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    offset: {
      value: 1
    },
    darkness: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform float offset;",
    "uniform float darkness;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 texel = texture2D( tDiffuse, vUv );",
    "	vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );",
    "	gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/VolumeShader.js
var VolumeRenderShader1 = {
  uniforms: {
    u_size: {
      value: new Vector3(1, 1, 1)
    },
    u_renderstyle: {
      value: 0
    },
    u_renderthreshold: {
      value: 0.5
    },
    u_clim: {
      value: new Vector2(1, 1)
    },
    u_data: {
      value: null
    },
    u_cmdata: {
      value: null
    }
  },
  vertexShader: [
    "		varying vec4 v_nearpos;",
    "		varying vec4 v_farpos;",
    "		varying vec3 v_position;",
    "		void main() {",
    "				mat4 viewtransformf = modelViewMatrix;",
    "				mat4 viewtransformi = inverse(modelViewMatrix);",
    "				vec4 position4 = vec4(position, 1.0);",
    "				vec4 pos_in_cam = viewtransformf * position4;",
    "				pos_in_cam.z = -pos_in_cam.w;",
    "				v_nearpos = viewtransformi * pos_in_cam;",
    "				pos_in_cam.z = pos_in_cam.w;",
    "				v_farpos = viewtransformi * pos_in_cam;",
    "				v_position = position;",
    "				gl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;",
    "		}"
  ].join("\n"),
  fragmentShader: [
    "		precision highp float;",
    "		precision mediump sampler3D;",
    "		uniform vec3 u_size;",
    "		uniform int u_renderstyle;",
    "		uniform float u_renderthreshold;",
    "		uniform vec2 u_clim;",
    "		uniform sampler3D u_data;",
    "		uniform sampler2D u_cmdata;",
    "		varying vec3 v_position;",
    "		varying vec4 v_nearpos;",
    "		varying vec4 v_farpos;",
    "		const int MAX_STEPS = 887;	// 887 for 512^3, 1774 for 1024^3",
    "		const int REFINEMENT_STEPS = 4;",
    "		const float relative_step_size = 1.0;",
    "		const vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);",
    "		const vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);",
    "		const vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);",
    "		const float shininess = 40.0;",
    "		void cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);",
    "		void cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);",
    "		float sample1(vec3 texcoords);",
    "		vec4 apply_colormap(float val);",
    "		vec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);",
    "		void main() {",
    "				vec3 farpos = v_farpos.xyz / v_farpos.w;",
    "				vec3 nearpos = v_nearpos.xyz / v_nearpos.w;",
    "				vec3 view_ray = normalize(nearpos.xyz - farpos.xyz);",
    "				float distance = dot(nearpos - v_position, view_ray);",
    "				distance = max(distance, min((-0.5 - v_position.x) / view_ray.x,",
    "																		(u_size.x - 0.5 - v_position.x) / view_ray.x));",
    "				distance = max(distance, min((-0.5 - v_position.y) / view_ray.y,",
    "																		(u_size.y - 0.5 - v_position.y) / view_ray.y));",
    "				distance = max(distance, min((-0.5 - v_position.z) / view_ray.z,",
    "																		(u_size.z - 0.5 - v_position.z) / view_ray.z));",
    "				vec3 front = v_position + view_ray * distance;",
    "				int nsteps = int(-distance / relative_step_size + 0.5);",
    "				if ( nsteps < 1 )",
    "						discard;",
    "				vec3 step = ((v_position - front) / u_size) / float(nsteps);",
    "				vec3 start_loc = front / u_size;",
    "				if (u_renderstyle == 0)",
    "						cast_mip(start_loc, step, nsteps, view_ray);",
    "				else if (u_renderstyle == 1)",
    "						cast_iso(start_loc, step, nsteps, view_ray);",
    "				if (gl_FragColor.a < 0.05)",
    "						discard;",
    "		}",
    "		float sample1(vec3 texcoords) {",
    "				/* Sample float value from a 3D texture. Assumes intensity data. */",
    "				return texture(u_data, texcoords.xyz).r;",
    "		}",
    "		vec4 apply_colormap(float val) {",
    "				val = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);",
    "				return texture2D(u_cmdata, vec2(val, 0.5));",
    "		}",
    "		void cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {",
    "				float max_val = -1e6;",
    "				int max_i = 100;",
    "				vec3 loc = start_loc;",
    "				for (int iter=0; iter<MAX_STEPS; iter++) {",
    "						if (iter >= nsteps)",
    "								break;",
    "						float val = sample1(loc);",
    "						if (val > max_val) {",
    "								max_val = val;",
    "								max_i = iter;",
    "						}",
    "						loc += step;",
    "				}",
    "				vec3 iloc = start_loc + step * (float(max_i) - 0.5);",
    "				vec3 istep = step / float(REFINEMENT_STEPS);",
    "				for (int i=0; i<REFINEMENT_STEPS; i++) {",
    "						max_val = max(max_val, sample1(iloc));",
    "						iloc += istep;",
    "				}",
    "				gl_FragColor = apply_colormap(max_val);",
    "		}",
    "		void cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {",
    "				gl_FragColor = vec4(0.0);	// init transparent",
    "				vec4 color3 = vec4(0.0);	// final color",
    "				vec3 dstep = 1.5 / u_size;	// step to sample derivative",
    "				vec3 loc = start_loc;",
    "				float low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);",
    "				for (int iter=0; iter<MAX_STEPS; iter++) {",
    "						if (iter >= nsteps)",
    "								break;",
    "						float val = sample1(loc);",
    "						if (val > low_threshold) {",
    "								vec3 iloc = loc - 0.5 * step;",
    "								vec3 istep = step / float(REFINEMENT_STEPS);",
    "								for (int i=0; i<REFINEMENT_STEPS; i++) {",
    "										val = sample1(iloc);",
    "										if (val > u_renderthreshold) {",
    "												gl_FragColor = add_lighting(val, iloc, dstep, view_ray);",
    "												return;",
    "										}",
    "										iloc += istep;",
    "								}",
    "						}",
    "						loc += step;",
    "				}",
    "		}",
    "		vec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)",
    "		{",
    "				vec3 V = normalize(view_ray);",
    "				vec3 N;",
    "				float val1, val2;",
    "				val1 = sample1(loc + vec3(-step[0], 0.0, 0.0));",
    "				val2 = sample1(loc + vec3(+step[0], 0.0, 0.0));",
    "				N[0] = val1 - val2;",
    "				val = max(max(val1, val2), val);",
    "				val1 = sample1(loc + vec3(0.0, -step[1], 0.0));",
    "				val2 = sample1(loc + vec3(0.0, +step[1], 0.0));",
    "				N[1] = val1 - val2;",
    "				val = max(max(val1, val2), val);",
    "				val1 = sample1(loc + vec3(0.0, 0.0, -step[2]));",
    "				val2 = sample1(loc + vec3(0.0, 0.0, +step[2]));",
    "				N[2] = val1 - val2;",
    "				val = max(max(val1, val2), val);",
    "				float gm = length(N); // gradient magnitude",
    "				N = normalize(N);",
    "				float Nselect = float(dot(N, V) > 0.0);",
    "				N = (2.0 * Nselect - 1.0) * N;	// ==	Nselect * N - (1.0-Nselect)*N;",
    "				vec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);",
    "				vec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);",
    "				vec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);",
    "				for (int i=0; i<1; i++)",
    "				{",
    "						vec3 L = normalize(view_ray);	//lightDirs[i];",
    "						float lightEnabled = float( length(L) > 0.0 );",
    "						L = normalize(L + (1.0 - lightEnabled));",
    "						float lambertTerm = clamp(dot(N, L), 0.0, 1.0);",
    "						vec3 H = normalize(L+V); // Halfway vector",
    "						float specularTerm = pow(max(dot(H, N), 0.0), shininess);",
    "						float mask1 = lightEnabled;",
    "						ambient_color +=	mask1 * ambient_color;	// * gl_LightSource[i].ambient;",
    "						diffuse_color +=	mask1 * lambertTerm;",
    "						specular_color += mask1 * specularTerm * specular_color;",
    "				}",
    "				vec4 final_color;",
    "				vec4 color = apply_colormap(val);",
    "				final_color = color * (ambient_color + diffuse_color) + specular_color;",
    "				final_color.a = color.a;",
    "				return final_color;",
    "		}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/WaterRefractionShader.js
var WaterRefractionShader = {
  uniforms: {
    color: {
      value: null
    },
    time: {
      value: 0
    },
    tDiffuse: {
      value: null
    },
    tDudv: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: ["uniform mat4 textureMatrix;", "varying vec2 vUv;", "varying vec4 vUvRefraction;", "void main() {", "	vUv = uv;", "	vUvRefraction = textureMatrix * vec4( position, 1.0 );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform vec3 color;",
    "uniform float time;",
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tDudv;",
    "varying vec2 vUv;",
    "varying vec4 vUvRefraction;",
    "float blendOverlay( float base, float blend ) {",
    "	return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );",
    "}",
    "vec3 blendOverlay( vec3 base, vec3 blend ) {",
    "	return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );",
    "}",
    "void main() {",
    " float waveStrength = 0.1;",
    " float waveSpeed = 0.03;",
    "	vec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;",
    "	distortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );",
    "	vec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;",
    " vec4 uv = vec4( vUvRefraction );",
    " uv.xy += distortion;",
    "	vec4 base = texture2DProj( tDiffuse, uv );",
    "	gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/interactive/SelectionHelper.js
var SelectionHelper = (() => {
  class SelectionHelper2 {
    constructor(selectionBox, renderer, cssClassName) {
      this.element = document.createElement("div");
      this.element.classList.add(cssClassName);
      this.element.style.pointerEvents = "none";
      this.renderer = renderer;
      this.startPoint = new Vector2();
      this.pointTopLeft = new Vector2();
      this.pointBottomRight = new Vector2();
      this.isDown = false;
      this.renderer.domElement.addEventListener("pointerdown", (event) => {
        this.isDown = true;
        this.onSelectStart(event);
      });
      this.renderer.domElement.addEventListener("pointermove", (event) => {
        if (this.isDown) {
          this.onSelectMove(event);
        }
      });
      this.renderer.domElement.addEventListener("pointerup", (event) => {
        this.isDown = false;
        this.onSelectOver(event);
      });
    }
    onSelectStart(event) {
      this.renderer.domElement.parentElement.appendChild(this.element);
      this.element.style.left = `${event.clientX}px`;
      this.element.style.top = `${event.clientY}px`;
      this.element.style.width = "0px";
      this.element.style.height = "0px";
      this.startPoint.x = event.clientX;
      this.startPoint.y = event.clientY;
    }
    onSelectMove(event) {
      this.pointBottomRight.x = Math.max(this.startPoint.x, event.clientX);
      this.pointBottomRight.y = Math.max(this.startPoint.y, event.clientY);
      this.pointTopLeft.x = Math.min(this.startPoint.x, event.clientX);
      this.pointTopLeft.y = Math.min(this.startPoint.y, event.clientY);
      this.element.style.left = `${this.pointTopLeft.x}px`;
      this.element.style.top = `${this.pointTopLeft.y}px`;
      this.element.style.width = `${this.pointBottomRight.x - this.pointTopLeft.x}px`;
      this.element.style.height = `${this.pointBottomRight.y - this.pointTopLeft.y}px`;
    }
    onSelectOver() {
      this.element.parentElement.removeChild(this.element);
    }
  }
  return SelectionHelper2;
})();

// node_modules/three-stdlib/interactive/SelectionBox.js
var SelectionBox = (() => {
  const frustum = new Frustum();
  const center = new Vector3();
  const tmpPoint = new Vector3();
  const vecNear = new Vector3();
  const vecTopLeft = new Vector3();
  const vecTopRight = new Vector3();
  const vecDownRight = new Vector3();
  const vecDownLeft = new Vector3();
  const vecFarTopLeft = new Vector3();
  const vecFarTopRight = new Vector3();
  const vecFarDownRight = new Vector3();
  const vecFarDownLeft = new Vector3();
  const vectemp1 = new Vector3();
  const vectemp2 = new Vector3();
  const vectemp3 = new Vector3();
  class SelectionBox2 {
    constructor(camera, scene, deep) {
      this.camera = camera;
      this.scene = scene;
      this.startPoint = new Vector3();
      this.endPoint = new Vector3();
      this.collection = [];
      this.deep = deep || Number.MAX_VALUE;
    }
    select(startPoint, endPoint) {
      this.startPoint = startPoint || this.startPoint;
      this.endPoint = endPoint || this.endPoint;
      this.collection = [];
      this.updateFrustum(this.startPoint, this.endPoint);
      this.searchChildInFrustum(frustum, this.scene);
      return this.collection;
    }
    updateFrustum(startPoint, endPoint) {
      startPoint = startPoint || this.startPoint;
      endPoint = endPoint || this.endPoint;
      if (startPoint.x === endPoint.x) {
        endPoint.x += Number.EPSILON;
      }
      if (startPoint.y === endPoint.y) {
        endPoint.y += Number.EPSILON;
      }
      this.camera.updateProjectionMatrix();
      this.camera.updateMatrixWorld();
      if (this.camera.isPerspectiveCamera) {
        tmpPoint.copy(startPoint);
        tmpPoint.x = Math.min(startPoint.x, endPoint.x);
        tmpPoint.y = Math.max(startPoint.y, endPoint.y);
        endPoint.x = Math.max(startPoint.x, endPoint.x);
        endPoint.y = Math.min(startPoint.y, endPoint.y);
        vecNear.setFromMatrixPosition(this.camera.matrixWorld);
        vecTopLeft.copy(tmpPoint);
        vecTopRight.set(endPoint.x, tmpPoint.y, 0);
        vecDownRight.copy(endPoint);
        vecDownLeft.set(tmpPoint.x, endPoint.y, 0);
        vecTopLeft.unproject(this.camera);
        vecTopRight.unproject(this.camera);
        vecDownRight.unproject(this.camera);
        vecDownLeft.unproject(this.camera);
        vectemp1.copy(vecTopLeft).sub(vecNear);
        vectemp2.copy(vecTopRight).sub(vecNear);
        vectemp3.copy(vecDownRight).sub(vecNear);
        vectemp1.normalize();
        vectemp2.normalize();
        vectemp3.normalize();
        vectemp1.multiplyScalar(this.deep);
        vectemp2.multiplyScalar(this.deep);
        vectemp3.multiplyScalar(this.deep);
        vectemp1.add(vecNear);
        vectemp2.add(vecNear);
        vectemp3.add(vecNear);
        var planes = frustum.planes;
        planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);
        planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);
        planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);
        planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);
        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);
        planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);
        planes[5].normal.multiplyScalar(-1);
      } else if (this.camera.isOrthographicCamera) {
        const left = Math.min(startPoint.x, endPoint.x);
        const top = Math.max(startPoint.y, endPoint.y);
        const right = Math.max(startPoint.x, endPoint.x);
        const down = Math.min(startPoint.y, endPoint.y);
        vecTopLeft.set(left, top, -1);
        vecTopRight.set(right, top, -1);
        vecDownRight.set(right, down, -1);
        vecDownLeft.set(left, down, -1);
        vecFarTopLeft.set(left, top, 1);
        vecFarTopRight.set(right, top, 1);
        vecFarDownRight.set(right, down, 1);
        vecFarDownLeft.set(left, down, 1);
        vecTopLeft.unproject(this.camera);
        vecTopRight.unproject(this.camera);
        vecDownRight.unproject(this.camera);
        vecDownLeft.unproject(this.camera);
        vecFarTopLeft.unproject(this.camera);
        vecFarTopRight.unproject(this.camera);
        vecFarDownRight.unproject(this.camera);
        vecFarDownLeft.unproject(this.camera);
        var planes = frustum.planes;
        planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);
        planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);
        planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);
        planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);
        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);
        planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);
        planes[5].normal.multiplyScalar(-1);
      } else {
        console.error("THREE.SelectionBox: Unsupported camera type.");
      }
    }
    searchChildInFrustum(frustum2, object) {
      if (object.isMesh || object.isLine || object.isPoints) {
        if (object.material !== void 0) {
          if (object.geometry.boundingSphere === null)
            object.geometry.computeBoundingSphere();
          center.copy(object.geometry.boundingSphere.center);
          center.applyMatrix4(object.matrixWorld);
          if (frustum2.containsPoint(center)) {
            this.collection.push(object);
          }
        }
      }
      if (object.children.length > 0) {
        for (let x = 0; x < object.children.length; x++) {
          this.searchChildInFrustum(frustum2, object.children[x]);
        }
      }
    }
  }
  return SelectionBox2;
})();

// node_modules/three-stdlib/physics/AmmoPhysics.js
async function AmmoPhysics() {
  if ("Ammo" in window === false) {
    console.error("AmmoPhysics: Couldn't find Ammo.js");
    return;
  }
  const AmmoLib = await Ammo();
  const frameRate = 60;
  const collisionConfiguration = new AmmoLib.btDefaultCollisionConfiguration();
  const dispatcher = new AmmoLib.btCollisionDispatcher(collisionConfiguration);
  const broadphase = new AmmoLib.btDbvtBroadphase();
  const solver = new AmmoLib.btSequentialImpulseConstraintSolver();
  const world2 = new AmmoLib.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
  world2.setGravity(new AmmoLib.btVector3(0, -9.8, 0));
  const worldTransform = new AmmoLib.btTransform();
  function getShape(geometry) {
    const parameters = geometry.parameters;
    if (geometry.type === "BoxGeometry") {
      const sx = parameters.width !== void 0 ? parameters.width / 2 : 0.5;
      const sy = parameters.height !== void 0 ? parameters.height / 2 : 0.5;
      const sz = parameters.depth !== void 0 ? parameters.depth / 2 : 0.5;
      const shape = new AmmoLib.btBoxShape(new AmmoLib.btVector3(sx, sy, sz));
      shape.setMargin(0.05);
      return shape;
    } else if (geometry.type === "SphereGeometry" || geometry.type === "IcosahedronGeometry") {
      const radius = parameters.radius !== void 0 ? parameters.radius : 1;
      const shape = new AmmoLib.btSphereShape(radius);
      shape.setMargin(0.05);
      return shape;
    }
    return null;
  }
  const meshes = [];
  const meshMap = /* @__PURE__ */ new WeakMap();
  function addMesh(mesh, mass = 0) {
    const shape = getShape(mesh.geometry);
    if (shape !== null) {
      if (mesh.isInstancedMesh) {
        handleInstancedMesh(mesh, mass, shape);
      } else if (mesh.isMesh) {
        handleMesh(mesh, mass, shape);
      }
    }
  }
  function handleMesh(mesh, mass, shape) {
    const position = mesh.position;
    const quaternion = mesh.quaternion;
    const transform = new AmmoLib.btTransform();
    transform.setIdentity();
    transform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));
    transform.setRotation(new AmmoLib.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));
    const motionState = new AmmoLib.btDefaultMotionState(transform);
    const localInertia = new AmmoLib.btVector3(0, 0, 0);
    shape.calculateLocalInertia(mass, localInertia);
    const rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
    const body = new AmmoLib.btRigidBody(rbInfo);
    world2.addRigidBody(body);
    if (mass > 0) {
      meshes.push(mesh);
      meshMap.set(mesh, body);
    }
  }
  function handleInstancedMesh(mesh, mass, shape) {
    const array = mesh.instanceMatrix.array;
    const bodies = [];
    for (let i2 = 0; i2 < mesh.count; i2++) {
      const index = i2 * 16;
      const transform = new AmmoLib.btTransform();
      transform.setFromOpenGLMatrix(array.slice(index, index + 16));
      const motionState = new AmmoLib.btDefaultMotionState(transform);
      const localInertia = new AmmoLib.btVector3(0, 0, 0);
      shape.calculateLocalInertia(mass, localInertia);
      const rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
      const body = new AmmoLib.btRigidBody(rbInfo);
      world2.addRigidBody(body);
      bodies.push(body);
    }
    if (mass > 0) {
      mesh.instanceMatrix.setUsage(35048);
      meshes.push(mesh);
      meshMap.set(mesh, bodies);
    }
  }
  function setMeshPosition(mesh, position, index = 0) {
    if (mesh.isInstancedMesh) {
      const bodies = meshMap.get(mesh);
      const body = bodies[index];
      body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0));
      body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0));
      worldTransform.setIdentity();
      worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));
      body.setWorldTransform(worldTransform);
    } else if (mesh.isMesh) {
      const body = meshMap.get(mesh);
      body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0));
      body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0));
      worldTransform.setIdentity();
      worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));
      body.setWorldTransform(worldTransform);
    }
  }
  let lastTime = 0;
  function step2() {
    const time = performance.now();
    if (lastTime > 0) {
      const delta = (time - lastTime) / 1e3;
      world2.stepSimulation(delta, 10);
    }
    lastTime = time;
    for (let i2 = 0, l = meshes.length; i2 < l; i2++) {
      const mesh = meshes[i2];
      if (mesh.isInstancedMesh) {
        const array = mesh.instanceMatrix.array;
        const bodies = meshMap.get(mesh);
        for (let j2 = 0; j2 < bodies.length; j2++) {
          const body = bodies[j2];
          const motionState = body.getMotionState();
          motionState.getWorldTransform(worldTransform);
          const position = worldTransform.getOrigin();
          const quaternion = worldTransform.getRotation();
          compose(position, quaternion, array, j2 * 16);
        }
        mesh.instanceMatrix.needsUpdate = true;
      } else if (mesh.isMesh) {
        const body = meshMap.get(mesh);
        const motionState = body.getMotionState();
        motionState.getWorldTransform(worldTransform);
        const position = worldTransform.getOrigin();
        const quaternion = worldTransform.getRotation();
        mesh.position.set(position.x(), position.y(), position.z());
        mesh.quaternion.set(quaternion.x(), quaternion.y(), quaternion.z(), quaternion.w());
      }
    }
  }
  setInterval(step2, 1e3 / frameRate);
  return {
    addMesh,
    setMeshPosition
  };
}
function compose(position, quaternion, array, index) {
  const x = quaternion.x(), y = quaternion.y(), z = quaternion.z(), w = quaternion.w();
  const x2 = x + x, y2 = y + y, z2 = z + z;
  const xx = x * x2, xy = x * y2, xz = x * z2;
  const yy = y * y2, yz = y * z2, zz = z * z2;
  const wx = w * x2, wy = w * y2, wz = w * z2;
  array[index + 0] = 1 - (yy + zz);
  array[index + 1] = xy + wz;
  array[index + 2] = xz - wy;
  array[index + 3] = 0;
  array[index + 4] = xy - wz;
  array[index + 5] = 1 - (xx + zz);
  array[index + 6] = yz + wx;
  array[index + 7] = 0;
  array[index + 8] = xz + wy;
  array[index + 9] = yz - wx;
  array[index + 10] = 1 - (xx + yy);
  array[index + 11] = 0;
  array[index + 12] = position.x();
  array[index + 13] = position.y();
  array[index + 14] = position.z();
  array[index + 15] = 1;
}

// node_modules/three-stdlib/effects/ParallaxBarrierEffect.js
var ParallaxBarrierEffect = function(renderer) {
  const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
  const _scene = new Scene();
  const _stereo = new StereoCamera();
  const _params = {
    minFilter: LinearFilter,
    magFilter: NearestFilter,
    format: RGBAFormat
  };
  const _renderTargetL = new WebGLRenderTarget(512, 512, _params);
  const _renderTargetR = new WebGLRenderTarget(512, 512, _params);
  const _material = new ShaderMaterial({
    uniforms: {
      mapLeft: {
        value: _renderTargetL.texture
      },
      mapRight: {
        value: _renderTargetR.texture
      }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = vec2( uv.x, uv.y );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: ["uniform sampler2D mapLeft;", "uniform sampler2D mapRight;", "varying vec2 vUv;", "void main() {", "	vec2 uv = vUv;", "	if ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {", "		gl_FragColor = texture2D( mapLeft, uv );", "	} else {", "		gl_FragColor = texture2D( mapRight, uv );", "	}", "}"].join("\n")
  });
  const mesh = new Mesh(new PlaneGeometry(2, 2), _material);
  _scene.add(mesh);
  this.setSize = (width, height) => {
    renderer.setSize(width, height);
    const pixelRatio = renderer.getPixelRatio();
    _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);
    _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);
  };
  this.render = (scene, camera) => {
    scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    _stereo.update(camera);
    renderer.setRenderTarget(_renderTargetL);
    renderer.clear();
    renderer.render(scene, _stereo.cameraL);
    renderer.setRenderTarget(_renderTargetR);
    renderer.clear();
    renderer.render(scene, _stereo.cameraR);
    renderer.setRenderTarget(null);
    renderer.render(_scene, _camera);
  };
};

// node_modules/three-stdlib/effects/PeppersGhostEffect.js
var PeppersGhostEffect = function(renderer) {
  const scope2 = this;
  scope2.cameraDistance = 15;
  scope2.reflectFromAbove = false;
  let _halfWidth, _width, _height;
  const _cameraF = new PerspectiveCamera();
  const _cameraB = new PerspectiveCamera();
  const _cameraL = new PerspectiveCamera();
  const _cameraR = new PerspectiveCamera();
  const _position = new Vector3();
  const _quaternion = new Quaternion();
  const _scale = new Vector3();
  renderer.autoClear = false;
  this.setSize = (width, height) => {
    _halfWidth = width / 2;
    if (width < height) {
      _width = width / 3;
      _height = width / 3;
    } else {
      _width = height / 3;
      _height = height / 3;
    }
    renderer.setSize(width, height);
  };
  this.render = (scene, camera) => {
    scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    camera.matrixWorld.decompose(_position, _quaternion, _scale);
    _cameraF.position.copy(_position);
    _cameraF.quaternion.copy(_quaternion);
    _cameraF.translateZ(scope2.cameraDistance);
    _cameraF.lookAt(scene.position);
    _cameraB.position.copy(_position);
    _cameraB.quaternion.copy(_quaternion);
    _cameraB.translateZ(-scope2.cameraDistance);
    _cameraB.lookAt(scene.position);
    _cameraB.rotation.z += 180 * (Math.PI / 180);
    _cameraL.position.copy(_position);
    _cameraL.quaternion.copy(_quaternion);
    _cameraL.translateX(-scope2.cameraDistance);
    _cameraL.lookAt(scene.position);
    _cameraL.rotation.x += 90 * (Math.PI / 180);
    _cameraR.position.copy(_position);
    _cameraR.quaternion.copy(_quaternion);
    _cameraR.translateX(scope2.cameraDistance);
    _cameraR.lookAt(scene.position);
    _cameraR.rotation.x += 90 * (Math.PI / 180);
    renderer.clear();
    renderer.setScissorTest(true);
    renderer.setScissor(_halfWidth - _width / 2, _height * 2, _width, _height);
    renderer.setViewport(_halfWidth - _width / 2, _height * 2, _width, _height);
    if (scope2.reflectFromAbove) {
      renderer.render(scene, _cameraB);
    } else {
      renderer.render(scene, _cameraF);
    }
    renderer.setScissor(_halfWidth - _width / 2, 0, _width, _height);
    renderer.setViewport(_halfWidth - _width / 2, 0, _width, _height);
    if (scope2.reflectFromAbove) {
      renderer.render(scene, _cameraF);
    } else {
      renderer.render(scene, _cameraB);
    }
    renderer.setScissor(_halfWidth - _width / 2 - _width, _height, _width, _height);
    renderer.setViewport(_halfWidth - _width / 2 - _width, _height, _width, _height);
    if (scope2.reflectFromAbove) {
      renderer.render(scene, _cameraR);
    } else {
      renderer.render(scene, _cameraL);
    }
    renderer.setScissor(_halfWidth + _width / 2, _height, _width, _height);
    renderer.setViewport(_halfWidth + _width / 2, _height, _width, _height);
    if (scope2.reflectFromAbove) {
      renderer.render(scene, _cameraL);
    } else {
      renderer.render(scene, _cameraR);
    }
    renderer.setScissorTest(false);
  };
};

// node_modules/three-stdlib/effects/OutlineEffect.js
var OutlineEffect = function(renderer, parameters) {
  parameters = parameters || {};
  this.enabled = true;
  const defaultThickness = parameters.defaultThickness !== void 0 ? parameters.defaultThickness : 3e-3;
  const defaultColor = new Color().fromArray(parameters.defaultColor !== void 0 ? parameters.defaultColor : [0, 0, 0]);
  const defaultAlpha = parameters.defaultAlpha !== void 0 ? parameters.defaultAlpha : 1;
  const defaultKeepAlive = parameters.defaultKeepAlive !== void 0 ? parameters.defaultKeepAlive : false;
  const cache = {};
  const removeThresholdCount = 60;
  const originalMaterials = {};
  const originalOnBeforeRenders = {};
  const uniformsOutline = {
    outlineThickness: {
      value: defaultThickness
    },
    outlineColor: {
      value: defaultColor
    },
    outlineAlpha: {
      value: defaultAlpha
    }
  };
  const vertexShader = [
    "#include <common>",
    "#include <uv_pars_vertex>",
    "#include <displacementmap_pars_vertex>",
    "#include <fog_pars_vertex>",
    "#include <morphtarget_pars_vertex>",
    "#include <skinning_pars_vertex>",
    "#include <logdepthbuf_pars_vertex>",
    "#include <clipping_planes_pars_vertex>",
    "uniform float outlineThickness;",
    "vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {",
    "	float thickness = outlineThickness;",
    "	const float ratio = 1.0;",
    "	vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );",
    "	vec4 norm = normalize( pos - pos2 );",
    "	return pos + norm * thickness * pos.w * ratio;",
    "}",
    "void main() {",
    "	#include <uv_vertex>",
    "	#include <beginnormal_vertex>",
    "	#include <morphnormal_vertex>",
    "	#include <skinbase_vertex>",
    "	#include <skinnormal_vertex>",
    "	#include <begin_vertex>",
    "	#include <morphtarget_vertex>",
    "	#include <skinning_vertex>",
    "	#include <displacementmap_vertex>",
    "	#include <project_vertex>",
    "	vec3 outlineNormal = - objectNormal;",
    "	gl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );",
    "	#include <logdepthbuf_vertex>",
    "	#include <clipping_planes_vertex>",
    "	#include <fog_vertex>",
    "}"
  ].join("\n");
  const fragmentShader = ["#include <common>", "#include <fog_pars_fragment>", "#include <logdepthbuf_pars_fragment>", "#include <clipping_planes_pars_fragment>", "uniform vec3 outlineColor;", "uniform float outlineAlpha;", "void main() {", "	#include <clipping_planes_fragment>", "	#include <logdepthbuf_fragment>", "	gl_FragColor = vec4( outlineColor, outlineAlpha );", "	#include <tonemapping_fragment>", "	#include <encodings_fragment>", "	#include <fog_fragment>", "	#include <premultiplied_alpha_fragment>", "}"].join("\n");
  function createMaterial() {
    return new ShaderMaterial({
      type: "OutlineEffect",
      uniforms: UniformsUtils.merge([UniformsLib["fog"], UniformsLib["displacementmap"], uniformsOutline]),
      vertexShader,
      fragmentShader,
      side: BackSide
    });
  }
  function getOutlineMaterialFromCache(originalMaterial) {
    let data = cache[originalMaterial.uuid];
    if (data === void 0) {
      data = {
        material: createMaterial(),
        used: true,
        keepAlive: defaultKeepAlive,
        count: 0
      };
      cache[originalMaterial.uuid] = data;
    }
    data.used = true;
    return data.material;
  }
  function getOutlineMaterial(originalMaterial) {
    const outlineMaterial = getOutlineMaterialFromCache(originalMaterial);
    originalMaterials[outlineMaterial.uuid] = originalMaterial;
    updateOutlineMaterial(outlineMaterial, originalMaterial);
    return outlineMaterial;
  }
  function isCompatible(object) {
    const geometry = object.geometry;
    let hasNormals = false;
    if (object.geometry !== void 0) {
      if (geometry.isBufferGeometry) {
        hasNormals = geometry.attributes.normal !== void 0;
      } else {
        hasNormals = true;
      }
    }
    return object.isMesh === true && object.material !== void 0 && hasNormals === true;
  }
  function setOutlineMaterial(object) {
    if (isCompatible(object) === false)
      return;
    if (Array.isArray(object.material)) {
      for (let i2 = 0, il = object.material.length; i2 < il; i2++) {
        object.material[i2] = getOutlineMaterial(object.material[i2]);
      }
    } else {
      object.material = getOutlineMaterial(object.material);
    }
    originalOnBeforeRenders[object.uuid] = object.onBeforeRender;
    object.onBeforeRender = onBeforeRender;
  }
  function restoreOriginalMaterial(object) {
    if (isCompatible(object) === false)
      return;
    if (Array.isArray(object.material)) {
      for (let i2 = 0, il = object.material.length; i2 < il; i2++) {
        object.material[i2] = originalMaterials[object.material[i2].uuid];
      }
    } else {
      object.material = originalMaterials[object.material.uuid];
    }
    object.onBeforeRender = originalOnBeforeRenders[object.uuid];
  }
  function onBeforeRender(renderer2, scene, camera, geometry, material) {
    const originalMaterial = originalMaterials[material.uuid];
    if (originalMaterial === void 0)
      return;
    updateUniforms(material, originalMaterial);
  }
  function updateUniforms(material, originalMaterial) {
    const outlineParameters = originalMaterial.userData.outlineParameters;
    material.uniforms.outlineAlpha.value = originalMaterial.opacity;
    if (outlineParameters !== void 0) {
      if (outlineParameters.thickness !== void 0) {
        material.uniforms.outlineThickness.value = outlineParameters.thickness;
      }
      if (outlineParameters.color !== void 0)
        material.uniforms.outlineColor.value.fromArray(outlineParameters.color);
      if (outlineParameters.alpha !== void 0)
        material.uniforms.outlineAlpha.value = outlineParameters.alpha;
    }
    if (originalMaterial.displacementMap) {
      material.uniforms.displacementMap.value = originalMaterial.displacementMap;
      material.uniforms.displacementScale.value = originalMaterial.displacementScale;
      material.uniforms.displacementBias.value = originalMaterial.displacementBias;
    }
  }
  function updateOutlineMaterial(material, originalMaterial) {
    if (material.name === "invisible")
      return;
    const outlineParameters = originalMaterial.userData.outlineParameters;
    material.skinning = originalMaterial.skinning;
    material.morphTargets = originalMaterial.morphTargets;
    material.morphNormals = originalMaterial.morphNormals;
    material.fog = originalMaterial.fog;
    material.toneMapped = originalMaterial.toneMapped;
    material.premultipliedAlpha = originalMaterial.premultipliedAlpha;
    material.displacementMap = originalMaterial.displacementMap;
    if (outlineParameters !== void 0) {
      if (originalMaterial.visible === false) {
        material.visible = false;
      } else {
        material.visible = outlineParameters.visible !== void 0 ? outlineParameters.visible : true;
      }
      material.transparent = outlineParameters.alpha !== void 0 && outlineParameters.alpha < 1 ? true : originalMaterial.transparent;
      if (outlineParameters.keepAlive !== void 0) {
        cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;
      }
    } else {
      material.transparent = originalMaterial.transparent;
      material.visible = originalMaterial.visible;
    }
    if (originalMaterial.wireframe === true || originalMaterial.depthTest === false)
      material.visible = false;
    if (originalMaterial.clippingPlanes) {
      material.clipping = true;
      material.clippingPlanes = originalMaterial.clippingPlanes;
      material.clipIntersection = originalMaterial.clipIntersection;
      material.clipShadows = originalMaterial.clipShadows;
    }
    material.version = originalMaterial.version;
  }
  function cleanupCache() {
    let keys;
    keys = Object.keys(originalMaterials);
    for (let i2 = 0, il = keys.length; i2 < il; i2++) {
      originalMaterials[keys[i2]] = void 0;
    }
    keys = Object.keys(originalOnBeforeRenders);
    for (let i2 = 0, il = keys.length; i2 < il; i2++) {
      originalOnBeforeRenders[keys[i2]] = void 0;
    }
    keys = Object.keys(cache);
    for (let i2 = 0, il = keys.length; i2 < il; i2++) {
      const key = keys[i2];
      if (cache[key].used === false) {
        cache[key].count++;
        if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {
          delete cache[key];
        }
      } else {
        cache[key].used = false;
        cache[key].count = 0;
      }
    }
  }
  this.render = function(scene, camera) {
    let renderTarget;
    let forceClear = false;
    if (arguments[2] !== void 0) {
      console.warn("THREE.OutlineEffect.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
      renderTarget = arguments[2];
    }
    if (arguments[3] !== void 0) {
      console.warn("THREE.OutlineEffect.render(): the forceClear argument has been removed. Use .clear() instead.");
      forceClear = arguments[3];
    }
    if (renderTarget !== void 0)
      renderer.setRenderTarget(renderTarget);
    if (forceClear)
      renderer.clear();
    if (this.enabled === false) {
      renderer.render(scene, camera);
      return;
    }
    const currentAutoClear = renderer.autoClear;
    renderer.autoClear = this.autoClear;
    renderer.render(scene, camera);
    renderer.autoClear = currentAutoClear;
    this.renderOutline(scene, camera);
  };
  this.renderOutline = (scene, camera) => {
    const currentAutoClear = renderer.autoClear;
    const currentSceneAutoUpdate = scene.autoUpdate;
    const currentSceneBackground = scene.background;
    const currentShadowMapEnabled = renderer.shadowMap.enabled;
    scene.autoUpdate = false;
    scene.background = null;
    renderer.autoClear = false;
    renderer.shadowMap.enabled = false;
    scene.traverse(setOutlineMaterial);
    renderer.render(scene, camera);
    scene.traverse(restoreOriginalMaterial);
    cleanupCache();
    scene.autoUpdate = currentSceneAutoUpdate;
    scene.background = currentSceneBackground;
    renderer.autoClear = currentAutoClear;
    renderer.shadowMap.enabled = currentShadowMapEnabled;
  };
  this.autoClear = renderer.autoClear;
  this.domElement = renderer.domElement;
  this.shadowMap = renderer.shadowMap;
  this.clear = (color2, depth, stencil) => {
    renderer.clear(color2, depth, stencil);
  };
  this.getPixelRatio = () => renderer.getPixelRatio();
  this.setPixelRatio = (value) => {
    renderer.setPixelRatio(value);
  };
  this.getSize = (target) => renderer.getSize(target);
  this.setSize = (width, height, updateStyle) => {
    renderer.setSize(width, height, updateStyle);
  };
  this.setViewport = (x, y, width, height) => {
    renderer.setViewport(x, y, width, height);
  };
  this.setScissor = (x, y, width, height) => {
    renderer.setScissor(x, y, width, height);
  };
  this.setScissorTest = (boolean) => {
    renderer.setScissorTest(boolean);
  };
  this.setRenderTarget = (renderTarget) => {
    renderer.setRenderTarget(renderTarget);
  };
};

// node_modules/three-stdlib/effects/AnaglyphEffect.js
var AnaglyphEffect = function(renderer, width, height) {
  this.colorMatrixLeft = new Matrix3().fromArray([0.4561, -0.0400822, -0.0152161, 0.500484, -0.0378246, -0.0205971, 0.176381, -0.0157589, -546856e-8]);
  this.colorMatrixRight = new Matrix3().fromArray([-0.0434706, 0.378476, -0.0721527, -0.0879388, 0.73364, -0.112961, -155529e-8, -0.0184503, 1.2264]);
  const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
  const _scene = new Scene();
  const _stereo = new StereoCamera();
  const _params = {
    minFilter: LinearFilter,
    magFilter: NearestFilter,
    format: RGBAFormat
  };
  if (width === void 0)
    width = 512;
  if (height === void 0)
    height = 512;
  const _renderTargetL = new WebGLRenderTarget(width, height, _params);
  const _renderTargetR = new WebGLRenderTarget(width, height, _params);
  const _material = new ShaderMaterial({
    uniforms: {
      mapLeft: {
        value: _renderTargetL.texture
      },
      mapRight: {
        value: _renderTargetR.texture
      },
      colorMatrixLeft: {
        value: this.colorMatrixLeft
      },
      colorMatrixRight: {
        value: this.colorMatrixRight
      }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = vec2( uv.x, uv.y );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: [
      "uniform sampler2D mapLeft;",
      "uniform sampler2D mapRight;",
      "varying vec2 vUv;",
      "uniform mat3 colorMatrixLeft;",
      "uniform mat3 colorMatrixRight;",
      "float lin( float c ) {",
      "	return c <= 0.04045 ? c * 0.0773993808 :",
      "			pow( c * 0.9478672986 + 0.0521327014, 2.4 );",
      "}",
      "vec4 lin( vec4 c ) {",
      "	return vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );",
      "}",
      "float dev( float c ) {",
      "	return c <= 0.0031308 ? c * 12.92",
      "			: pow( c, 0.41666 ) * 1.055 - 0.055;",
      "}",
      "void main() {",
      "	vec2 uv = vUv;",
      "	vec4 colorL = lin( texture2D( mapLeft, uv ) );",
      "	vec4 colorR = lin( texture2D( mapRight, uv ) );",
      "	vec3 color = clamp(",
      "			colorMatrixLeft * colorL.rgb +",
      "			colorMatrixRight * colorR.rgb, 0., 1. );",
      "	gl_FragColor = vec4(",
      "			dev( color.r ), dev( color.g ), dev( color.b ),",
      "			max( colorL.a, colorR.a ) );",
      "}"
    ].join("\n")
  });
  const _mesh2 = new Mesh(new PlaneGeometry(2, 2), _material);
  _scene.add(_mesh2);
  this.setSize = (width2, height2) => {
    renderer.setSize(width2, height2);
    const pixelRatio = renderer.getPixelRatio();
    _renderTargetL.setSize(width2 * pixelRatio, height2 * pixelRatio);
    _renderTargetR.setSize(width2 * pixelRatio, height2 * pixelRatio);
  };
  this.render = (scene, camera) => {
    const currentRenderTarget = renderer.getRenderTarget();
    scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    _stereo.update(camera);
    renderer.setRenderTarget(_renderTargetL);
    renderer.clear();
    renderer.render(scene, _stereo.cameraL);
    renderer.setRenderTarget(_renderTargetR);
    renderer.clear();
    renderer.render(scene, _stereo.cameraR);
    renderer.setRenderTarget(null);
    renderer.render(_scene, _camera);
    renderer.setRenderTarget(currentRenderTarget);
  };
  this.dispose = () => {
    if (_renderTargetL)
      _renderTargetL.dispose();
    if (_renderTargetR)
      _renderTargetR.dispose();
    if (_mesh2)
      _mesh2.geometry.dispose();
    if (_material)
      _material.dispose();
  };
};

// node_modules/three-stdlib/effects/AsciiEffect.js
var AsciiEffect = function(renderer, charSet, options) {
  charSet = charSet === void 0 ? " .:-=+*#%@" : charSet;
  if (!options)
    options = {};
  const bResolution = !options["resolution"] ? 0.15 : options["resolution"];
  const iScale = !options["scale"] ? 1 : options["scale"];
  const bColor = !options["color"] ? false : options["color"];
  const bAlpha = !options["alpha"] ? false : options["alpha"];
  const bBlock = !options["block"] ? false : options["block"];
  const bInvert = !options["invert"] ? false : options["invert"];
  const strResolution = "low";
  let width, height;
  const domElement = document.createElement("div");
  domElement.style.cursor = "default";
  const oAscii = document.createElement("table");
  domElement.appendChild(oAscii);
  let iWidth, iHeight;
  let oImg;
  this.setSize = (w, h) => {
    width = w;
    height = h;
    renderer.setSize(w, h);
    initAsciiSize();
  };
  this.render = (scene, camera) => {
    renderer.render(scene, camera);
    asciifyImage(renderer, oAscii);
  };
  this.domElement = domElement;
  function initAsciiSize() {
    iWidth = Math.round(width * fResolution);
    iHeight = Math.round(height * fResolution);
    oCanvas.width = iWidth;
    oCanvas.height = iHeight;
    oImg = renderer.domElement;
    if (oImg.style.backgroundColor) {
      oAscii.rows[0].cells[0].style.backgroundColor = oImg.style.backgroundColor;
      oAscii.rows[0].cells[0].style.color = oImg.style.color;
    }
    oAscii.cellSpacing = 0;
    oAscii.cellPadding = 0;
    const oStyle = oAscii.style;
    oStyle.display = "inline";
    oStyle.width = `${Math.round(iWidth / fResolution * iScale)}px`;
    oStyle.height = `${Math.round(iHeight / fResolution * iScale)}px`;
    oStyle.whiteSpace = "pre";
    oStyle.margin = "0px";
    oStyle.padding = "0px";
    oStyle.letterSpacing = `${fLetterSpacing}px`;
    oStyle.fontFamily = strFont;
    oStyle.fontSize = `${fFontSize}px`;
    oStyle.lineHeight = `${fLineHeight}px`;
    oStyle.textAlign = "left";
    oStyle.textDecoration = "none";
  }
  const aDefaultCharList = " .,:;i1tfLCG08@".split("");
  const aDefaultColorCharList = " CGO08@".split("");
  var strFont = "courier new, monospace";
  const oCanvasImg = renderer.domElement;
  var oCanvas = document.createElement("canvas");
  if (!oCanvas.getContext) {
    return;
  }
  const oCtx = oCanvas.getContext("2d");
  if (!oCtx.getImageData) {
    return;
  }
  let aCharList = bColor ? aDefaultColorCharList : aDefaultCharList;
  if (charSet)
    aCharList = charSet;
  var fResolution = 0.5;
  switch (strResolution) {
    case "low":
      fResolution = 0.25;
      break;
    case "medium":
      fResolution = 0.5;
      break;
    case "high":
      fResolution = 1;
      break;
  }
  if (bResolution)
    fResolution = bResolution;
  var fFontSize = 2 / fResolution * iScale;
  var fLineHeight = 2 / fResolution * iScale;
  var fLetterSpacing = 0;
  {
    switch (iScale) {
      case 1:
        fLetterSpacing = -1;
        break;
      case 2:
      case 3:
        fLetterSpacing = -2.1;
        break;
      case 4:
        fLetterSpacing = -3.1;
        break;
      case 5:
        fLetterSpacing = -4.15;
        break;
    }
  }
  function asciifyImage(canvasRenderer, oAscii2) {
    oCtx.clearRect(0, 0, iWidth, iHeight);
    oCtx.drawImage(oCanvasImg, 0, 0, iWidth, iHeight);
    const oImgData = oCtx.getImageData(0, 0, iWidth, iHeight).data;
    let strChars = "";
    for (let y = 0; y < iHeight; y += 2) {
      for (let x = 0; x < iWidth; x++) {
        const iOffset = (y * iWidth + x) * 4;
        const iRed = oImgData[iOffset];
        const iGreen = oImgData[iOffset + 1];
        const iBlue = oImgData[iOffset + 2];
        const iAlpha = oImgData[iOffset + 3];
        let iCharIdx;
        let fBrightness;
        fBrightness = (0.3 * iRed + 0.59 * iGreen + 0.11 * iBlue) / 255;
        if (iAlpha == 0) {
          fBrightness = 1;
        }
        iCharIdx = Math.floor((1 - fBrightness) * (aCharList.length - 1));
        if (bInvert) {
          iCharIdx = aCharList.length - iCharIdx - 1;
        }
        let strThisChar = aCharList[iCharIdx];
        if (strThisChar === void 0 || strThisChar == " ")
          strThisChar = "&nbsp;";
        if (bColor) {
          strChars += `<span style='color:rgb(${iRed},${iGreen},${iBlue});${bBlock ? `background-color:rgb(${iRed},${iGreen},${iBlue});` : ""}${bAlpha ? `opacity:${iAlpha / 255};` : ""}'>${strThisChar}</span>`;
        } else {
          strChars += strThisChar;
        }
      }
      strChars += "<br/>";
    }
    oAscii2.innerHTML = `<tr><td>${strChars}</td></tr>`;
  }
};

// node_modules/three-stdlib/effects/StereoEffect.js
var StereoEffect = function(renderer) {
  const _stereo = new StereoCamera();
  _stereo.aspect = 0.5;
  const size2 = new Vector2();
  this.setEyeSeparation = (eyeSep) => {
    _stereo.eyeSep = eyeSep;
  };
  this.setSize = (width, height) => {
    renderer.setSize(width, height);
  };
  this.render = (scene, camera) => {
    scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    _stereo.update(camera);
    renderer.getSize(size2);
    if (renderer.autoClear)
      renderer.clear();
    renderer.setScissorTest(true);
    renderer.setScissor(0, 0, size2.width / 2, size2.height);
    renderer.setViewport(0, 0, size2.width / 2, size2.height);
    renderer.render(scene, _stereo.cameraL);
    renderer.setScissor(size2.width / 2, 0, size2.width / 2, size2.height);
    renderer.setViewport(size2.width / 2, 0, size2.width / 2, size2.height);
    renderer.render(scene, _stereo.cameraR);
    renderer.setScissorTest(false);
  };
};

// node_modules/three-stdlib/curves/NURBSUtils.js
function findSpan(p, u, U) {
  const n = U.length - p - 1;
  if (u >= U[n]) {
    return n - 1;
  }
  if (u <= U[p]) {
    return p;
  }
  let low = p;
  let high = n;
  let mid = Math.floor((low + high) / 2);
  while (u < U[mid] || u >= U[mid + 1]) {
    if (u < U[mid]) {
      high = mid;
    } else {
      low = mid;
    }
    mid = Math.floor((low + high) / 2);
  }
  return mid;
}
function calcBasisFunctions(span, u, p, U) {
  const N = [];
  const left = [];
  const right = [];
  N[0] = 1;
  for (let j2 = 1; j2 <= p; ++j2) {
    left[j2] = u - U[span + 1 - j2];
    right[j2] = U[span + j2] - u;
    let saved = 0;
    for (let r = 0; r < j2; ++r) {
      const rv = right[r + 1];
      const lv = left[j2 - r];
      const temp2 = N[r] / (rv + lv);
      N[r] = saved + rv * temp2;
      saved = lv * temp2;
    }
    N[j2] = saved;
  }
  return N;
}
function calcBSplinePoint(p, U, P, u) {
  const span = findSpan(p, u, U);
  const N = calcBasisFunctions(span, u, p, U);
  const C2 = new Vector4(0, 0, 0, 0);
  for (let j2 = 0; j2 <= p; ++j2) {
    const point = P[span - p + j2];
    const Nj = N[j2];
    const wNj = point.w * Nj;
    C2.x += point.x * wNj;
    C2.y += point.y * wNj;
    C2.z += point.z * wNj;
    C2.w += point.w * Nj;
  }
  return C2;
}
function calcBasisFunctionDerivatives(span, u, p, n, U) {
  const zeroArr = [];
  for (let i2 = 0; i2 <= p; ++i2)
    zeroArr[i2] = 0;
  const ders = [];
  for (let i2 = 0; i2 <= n; ++i2)
    ders[i2] = zeroArr.slice(0);
  const ndu = [];
  for (let i2 = 0; i2 <= p; ++i2)
    ndu[i2] = zeroArr.slice(0);
  ndu[0][0] = 1;
  const left = zeroArr.slice(0);
  const right = zeroArr.slice(0);
  for (let j3 = 1; j3 <= p; ++j3) {
    left[j3] = u - U[span + 1 - j3];
    right[j3] = U[span + j3] - u;
    let saved = 0;
    for (let r2 = 0; r2 < j3; ++r2) {
      const rv = right[r2 + 1];
      const lv = left[j3 - r2];
      ndu[j3][r2] = rv + lv;
      const temp2 = ndu[r2][j3 - 1] / ndu[j3][r2];
      ndu[r2][j3] = saved + rv * temp2;
      saved = lv * temp2;
    }
    ndu[j3][j3] = saved;
  }
  for (let j3 = 0; j3 <= p; ++j3) {
    ders[0][j3] = ndu[j3][p];
  }
  for (let r2 = 0; r2 <= p; ++r2) {
    let s1 = 0;
    let s2 = 1;
    const a2 = [];
    for (let i2 = 0; i2 <= p; ++i2) {
      a2[i2] = zeroArr.slice(0);
    }
    a2[0][0] = 1;
    for (let k = 1; k <= n; ++k) {
      let d = 0;
      const rk = r2 - k;
      const pk = p - k;
      if (r2 >= k) {
        a2[s2][0] = a2[s1][0] / ndu[pk + 1][rk];
        d = a2[s2][0] * ndu[rk][pk];
      }
      const j1 = rk >= -1 ? 1 : -rk;
      const j22 = r2 - 1 <= pk ? k - 1 : p - r2;
      for (let j3 = j1; j3 <= j22; ++j3) {
        a2[s2][j3] = (a2[s1][j3] - a2[s1][j3 - 1]) / ndu[pk + 1][rk + j3];
        d += a2[s2][j3] * ndu[rk + j3][pk];
      }
      if (r2 <= pk) {
        a2[s2][k] = -a2[s1][k - 1] / ndu[pk + 1][r2];
        d += a2[s2][k] * ndu[r2][pk];
      }
      ders[k][r2] = d;
      var j2 = s1;
      s1 = s2;
      s2 = j2;
    }
  }
  var r = p;
  for (let k = 1; k <= n; ++k) {
    for (let j3 = 0; j3 <= p; ++j3) {
      ders[k][j3] *= r;
    }
    r *= p - k;
  }
  return ders;
}
function calcBSplineDerivatives(p, U, P, u, nd) {
  const du = nd < p ? nd : p;
  const CK = [];
  const span = findSpan(p, u, U);
  const nders = calcBasisFunctionDerivatives(span, u, p, du, U);
  const Pw = [];
  for (let i2 = 0; i2 < P.length; ++i2) {
    var point = P[i2].clone();
    const w = point.w;
    point.x *= w;
    point.y *= w;
    point.z *= w;
    Pw[i2] = point;
  }
  for (let k = 0; k <= du; ++k) {
    var point = Pw[span - p].clone().multiplyScalar(nders[k][0]);
    for (let j2 = 1; j2 <= p; ++j2) {
      point.add(Pw[span - p + j2].clone().multiplyScalar(nders[k][j2]));
    }
    CK[k] = point;
  }
  for (let k = du + 1; k <= nd + 1; ++k) {
    CK[k] = new Vector4(0, 0, 0);
  }
  return CK;
}
function calcKoverI(k, i2) {
  let nom = 1;
  for (let j2 = 2; j2 <= k; ++j2) {
    nom *= j2;
  }
  let denom = 1;
  for (let j2 = 2; j2 <= i2; ++j2) {
    denom *= j2;
  }
  for (let j2 = 2; j2 <= k - i2; ++j2) {
    denom *= j2;
  }
  return nom / denom;
}
function calcRationalCurveDerivatives(Pders) {
  const nd = Pders.length;
  const Aders = [];
  const wders = [];
  for (let i2 = 0; i2 < nd; ++i2) {
    const point = Pders[i2];
    Aders[i2] = new Vector3(point.x, point.y, point.z);
    wders[i2] = point.w;
  }
  const CK = [];
  for (let k = 0; k < nd; ++k) {
    const v = Aders[k].clone();
    for (let i2 = 1; i2 <= k; ++i2) {
      v.sub(CK[k - i2].clone().multiplyScalar(calcKoverI(k, i2) * wders[i2]));
    }
    CK[k] = v.divideScalar(wders[0]);
  }
  return CK;
}
function calcNURBSDerivatives(p, U, P, u, nd) {
  const Pders = calcBSplineDerivatives(p, U, P, u, nd);
  return calcRationalCurveDerivatives(Pders);
}
function calcSurfacePoint(p, q, U, V, P, u, v, target) {
  const uspan = findSpan(p, u, U);
  const vspan = findSpan(q, v, V);
  const Nu = calcBasisFunctions(uspan, u, p, U);
  const Nv = calcBasisFunctions(vspan, v, q, V);
  const temp2 = [];
  for (let l = 0; l <= q; ++l) {
    temp2[l] = new Vector4(0, 0, 0, 0);
    for (let k = 0; k <= p; ++k) {
      const point = P[uspan - p + k][vspan - q + l].clone();
      const w = point.w;
      point.x *= w;
      point.y *= w;
      point.z *= w;
      temp2[l].add(point.multiplyScalar(Nu[k]));
    }
  }
  const Sw = new Vector4(0, 0, 0, 0);
  for (let l = 0; l <= q; ++l) {
    Sw.add(temp2[l].multiplyScalar(Nv[l]));
  }
  Sw.divideScalar(Sw.w);
  target.set(Sw.x, Sw.y, Sw.z);
}

// node_modules/three-stdlib/curves/NURBSCurve.js
var NURBSCurve = class extends Curve {
  constructor(degree, knots, controlPoints, startKnot, endKnot) {
    super();
    this.degree = degree;
    this.knots = knots;
    this.controlPoints = [];
    this.startKnot = startKnot || 0;
    this.endKnot = endKnot || this.knots.length - 1;
    for (let i2 = 0; i2 < controlPoints.length; ++i2) {
      const point = controlPoints[i2];
      this.controlPoints[i2] = new Vector4(point.x, point.y, point.z, point.w);
    }
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    const u = this.knots[this.startKnot] + t2 * (this.knots[this.endKnot] - this.knots[this.startKnot]);
    const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);
    if (hpoint.w != 1) {
      hpoint.divideScalar(hpoint.w);
    }
    return point.set(hpoint.x, hpoint.y, hpoint.z);
  }
  getTangent(t2, optionalTarget) {
    const tangent = optionalTarget || new Vector3();
    const u = this.knots[0] + t2 * (this.knots[this.knots.length - 1] - this.knots[0]);
    const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);
    tangent.copy(ders[1]).normalize();
    return tangent;
  }
};

// node_modules/three-stdlib/loaders/FBXLoader.js
var fbxTree;
var connections;
var sceneGraph;
var FBXLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const path = scope2.path === "" ? LoaderUtils.extractUrlBase(url) : scope2.path;
    const loader = new FileLoader2(this.manager);
    loader.setPath(scope2.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(buffer2) {
      try {
        onLoad(scope2.parse(buffer2, path));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(FBXBuffer, path) {
    if (isFbxFormatBinary(FBXBuffer)) {
      fbxTree = new BinaryParser().parse(FBXBuffer);
    } else {
      const FBXText = convertArrayBufferToString(FBXBuffer);
      if (!isFbxFormatASCII(FBXText)) {
        throw new Error("THREE.FBXLoader: Unknown format.");
      }
      if (getFbxVersion(FBXText) < 7e3) {
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion(FBXText));
      }
      fbxTree = new TextParser().parse(FBXText);
    }
    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);
  }
};
var FBXTreeParser = class {
  constructor(textureLoader, manager) {
    this.textureLoader = textureLoader;
    this.manager = manager;
  }
  parse() {
    connections = this.parseConnections();
    const images = this.parseImages();
    const textures = this.parseTextures(images);
    const materials = this.parseMaterials(textures);
    const deformers = this.parseDeformers();
    const geometryMap = new GeometryParser().parse(deformers);
    this.parseScene(deformers, geometryMap, materials);
    return sceneGraph;
  }
  parseConnections() {
    const connectionMap = /* @__PURE__ */ new Map();
    if ("Connections" in fbxTree) {
      const rawConnections = fbxTree.Connections.connections;
      rawConnections.forEach(function(rawConnection) {
        const fromID = rawConnection[0];
        const toID = rawConnection[1];
        const relationship = rawConnection[2];
        if (!connectionMap.has(fromID)) {
          connectionMap.set(fromID, {
            parents: [],
            children: []
          });
        }
        const parentRelationship = {
          ID: toID,
          relationship
        };
        connectionMap.get(fromID).parents.push(parentRelationship);
        if (!connectionMap.has(toID)) {
          connectionMap.set(toID, {
            parents: [],
            children: []
          });
        }
        const childRelationship = {
          ID: fromID,
          relationship
        };
        connectionMap.get(toID).children.push(childRelationship);
      });
    }
    return connectionMap;
  }
  parseImages() {
    const images = {};
    const blobs = {};
    if ("Video" in fbxTree.Objects) {
      const videoNodes = fbxTree.Objects.Video;
      for (const nodeID in videoNodes) {
        const videoNode = videoNodes[nodeID];
        const id = parseInt(nodeID);
        images[id] = videoNode.RelativeFilename || videoNode.Filename;
        if ("Content" in videoNode) {
          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
          const base64Content = typeof videoNode.Content === "string" && videoNode.Content !== "";
          if (arrayBufferContent || base64Content) {
            const image = this.parseImage(videoNodes[nodeID]);
            blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
          }
        }
      }
    }
    for (const id in images) {
      const filename = images[id];
      if (blobs[filename] !== void 0)
        images[id] = blobs[filename];
      else
        images[id] = images[id].split("\\").pop();
    }
    return images;
  }
  parseImage(videoNode) {
    const content = videoNode.Content;
    const fileName = videoNode.RelativeFilename || videoNode.Filename;
    const extension = fileName.slice(fileName.lastIndexOf(".") + 1).toLowerCase();
    let type2;
    switch (extension) {
      case "bmp":
        type2 = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        type2 = "image/jpeg";
        break;
      case "png":
        type2 = "image/png";
        break;
      case "tif":
        type2 = "image/tiff";
        break;
      case "tga":
        if (this.manager.getHandler(".tga") === null) {
          console.warn("FBXLoader: TGA loader not found, skipping ", fileName);
        }
        type2 = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
        return;
    }
    if (typeof content === "string") {
      return "data:" + type2 + ";base64," + content;
    } else {
      const array = new Uint8Array(content);
      return window.URL.createObjectURL(new Blob([array], {
        type: type2
      }));
    }
  }
  parseTextures(images) {
    const textureMap = /* @__PURE__ */ new Map();
    if ("Texture" in fbxTree.Objects) {
      const textureNodes = fbxTree.Objects.Texture;
      for (const nodeID in textureNodes) {
        const texture2 = this.parseTexture(textureNodes[nodeID], images);
        textureMap.set(parseInt(nodeID), texture2);
      }
    }
    return textureMap;
  }
  parseTexture(textureNode, images) {
    const texture2 = this.loadTexture(textureNode, images);
    texture2.ID = textureNode.id;
    texture2.name = textureNode.attrName;
    const wrapModeU = textureNode.WrapModeU;
    const wrapModeV = textureNode.WrapModeV;
    const valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;
    const valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;
    texture2.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
    texture2.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;
    if ("Scaling" in textureNode) {
      const values = textureNode.Scaling.value;
      texture2.repeat.x = values[0];
      texture2.repeat.y = values[1];
    }
    return texture2;
  }
  loadTexture(textureNode, images) {
    let fileName;
    const currentPath = this.textureLoader.path;
    const children = connections.get(textureNode.id).children;
    if (children !== void 0 && children.length > 0 && images[children[0].ID] !== void 0) {
      fileName = images[children[0].ID];
      if (fileName.indexOf("blob:") === 0 || fileName.indexOf("data:") === 0) {
        this.textureLoader.setPath(void 0);
      }
    }
    let texture2;
    const extension = textureNode.FileName.slice(-3).toLowerCase();
    if (extension === "tga") {
      const loader = this.manager.getHandler(".tga");
      if (loader === null) {
        console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", textureNode.RelativeFilename);
        texture2 = new Texture();
      } else {
        loader.setPath(this.textureLoader.path);
        texture2 = loader.load(fileName);
      }
    } else if (extension === "psd") {
      console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", textureNode.RelativeFilename);
      texture2 = new Texture();
    } else {
      texture2 = this.textureLoader.load(fileName);
    }
    this.textureLoader.setPath(currentPath);
    return texture2;
  }
  parseMaterials(textureMap) {
    const materialMap = /* @__PURE__ */ new Map();
    if ("Material" in fbxTree.Objects) {
      const materialNodes = fbxTree.Objects.Material;
      for (const nodeID in materialNodes) {
        const material = this.parseMaterial(materialNodes[nodeID], textureMap);
        if (material !== null)
          materialMap.set(parseInt(nodeID), material);
      }
    }
    return materialMap;
  }
  parseMaterial(materialNode, textureMap) {
    const ID = materialNode.id;
    const name = materialNode.attrName;
    let type2 = materialNode.ShadingModel;
    if (typeof type2 === "object") {
      type2 = type2.value;
    }
    if (!connections.has(ID))
      return null;
    const parameters = this.parseParameters(materialNode, textureMap, ID);
    let material;
    switch (type2.toLowerCase()) {
      case "phong":
        material = new MeshPhongMaterial();
        break;
      case "lambert":
        material = new MeshLambertMaterial();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type2);
        material = new MeshPhongMaterial();
        break;
    }
    material.setValues(parameters);
    material.name = name;
    return material;
  }
  parseParameters(materialNode, textureMap, ID) {
    const parameters = {};
    if (materialNode.BumpFactor) {
      parameters.bumpScale = materialNode.BumpFactor.value;
    }
    if (materialNode.Diffuse) {
      parameters.color = new Color().fromArray(materialNode.Diffuse.value);
    } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === "Color" || materialNode.DiffuseColor.type === "ColorRGB")) {
      parameters.color = new Color().fromArray(materialNode.DiffuseColor.value);
    }
    if (materialNode.DisplacementFactor) {
      parameters.displacementScale = materialNode.DisplacementFactor.value;
    }
    if (materialNode.Emissive) {
      parameters.emissive = new Color().fromArray(materialNode.Emissive.value);
    } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === "Color" || materialNode.EmissiveColor.type === "ColorRGB")) {
      parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value);
    }
    if (materialNode.EmissiveFactor) {
      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
    }
    if (materialNode.Opacity) {
      parameters.opacity = parseFloat(materialNode.Opacity.value);
    }
    if (parameters.opacity < 1) {
      parameters.transparent = true;
    }
    if (materialNode.ReflectionFactor) {
      parameters.reflectivity = materialNode.ReflectionFactor.value;
    }
    if (materialNode.Shininess) {
      parameters.shininess = materialNode.Shininess.value;
    }
    if (materialNode.Specular) {
      parameters.specular = new Color().fromArray(materialNode.Specular.value);
    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === "Color") {
      parameters.specular = new Color().fromArray(materialNode.SpecularColor.value);
    }
    const scope2 = this;
    connections.get(ID).children.forEach(function(child) {
      const type2 = child.relationship;
      switch (type2) {
        case "Bump":
          parameters.bumpMap = scope2.getTexture(textureMap, child.ID);
          break;
        case "Maya|TEX_ao_map":
          parameters.aoMap = scope2.getTexture(textureMap, child.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          parameters.map = scope2.getTexture(textureMap, child.ID);
          if (parameters.map !== void 0) {
            parameters.map.encoding = sRGBEncoding;
          }
          break;
        case "DisplacementColor":
          parameters.displacementMap = scope2.getTexture(textureMap, child.ID);
          break;
        case "EmissiveColor":
          parameters.emissiveMap = scope2.getTexture(textureMap, child.ID);
          if (parameters.emissiveMap !== void 0) {
            parameters.emissiveMap.encoding = sRGBEncoding;
          }
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          parameters.normalMap = scope2.getTexture(textureMap, child.ID);
          break;
        case "ReflectionColor":
          parameters.envMap = scope2.getTexture(textureMap, child.ID);
          if (parameters.envMap !== void 0) {
            parameters.envMap.mapping = EquirectangularReflectionMapping;
            parameters.envMap.encoding = sRGBEncoding;
          }
          break;
        case "SpecularColor":
          parameters.specularMap = scope2.getTexture(textureMap, child.ID);
          if (parameters.specularMap !== void 0) {
            parameters.specularMap.encoding = sRGBEncoding;
          }
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          parameters.alphaMap = scope2.getTexture(textureMap, child.ID);
          parameters.transparent = true;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", type2);
          break;
      }
    });
    return parameters;
  }
  getTexture(textureMap, id) {
    if ("LayeredTexture" in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {
      console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.");
      id = connections.get(id).children[0].ID;
    }
    return textureMap.get(id);
  }
  parseDeformers() {
    const skeletons = {};
    const morphTargets = {};
    if ("Deformer" in fbxTree.Objects) {
      const DeformerNodes = fbxTree.Objects.Deformer;
      for (const nodeID in DeformerNodes) {
        const deformerNode = DeformerNodes[nodeID];
        const relationships = connections.get(parseInt(nodeID));
        if (deformerNode.attrType === "Skin") {
          const skeleton = this.parseSkeleton(relationships, DeformerNodes);
          skeleton.ID = nodeID;
          if (relationships.parents.length > 1) {
            console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported.");
          }
          skeleton.geometryID = relationships.parents[0].ID;
          skeletons[nodeID] = skeleton;
        } else if (deformerNode.attrType === "BlendShape") {
          const morphTarget = {
            id: nodeID
          };
          morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
          morphTarget.id = nodeID;
          if (relationships.parents.length > 1) {
            console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported.");
          }
          morphTargets[nodeID] = morphTarget;
        }
      }
    }
    return {
      skeletons,
      morphTargets
    };
  }
  parseSkeleton(relationships, deformerNodes) {
    const rawBones = [];
    relationships.children.forEach(function(child) {
      const boneNode = deformerNodes[child.ID];
      if (boneNode.attrType !== "Cluster")
        return;
      const rawBone = {
        ID: child.ID,
        indices: [],
        weights: [],
        transformLink: new Matrix4().fromArray(boneNode.TransformLink.a)
      };
      if ("Indexes" in boneNode) {
        rawBone.indices = boneNode.Indexes.a;
        rawBone.weights = boneNode.Weights.a;
      }
      rawBones.push(rawBone);
    });
    return {
      rawBones,
      bones: []
    };
  }
  parseMorphTargets(relationships, deformerNodes) {
    const rawMorphTargets = [];
    for (let i2 = 0; i2 < relationships.children.length; i2++) {
      const child = relationships.children[i2];
      const morphTargetNode = deformerNodes[child.ID];
      const rawMorphTarget = {
        name: morphTargetNode.attrName,
        initialWeight: morphTargetNode.DeformPercent,
        id: morphTargetNode.id,
        fullWeights: morphTargetNode.FullWeights.a
      };
      if (morphTargetNode.attrType !== "BlendShapeChannel")
        return;
      rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function(child2) {
        return child2.relationship === void 0;
      })[0].ID;
      rawMorphTargets.push(rawMorphTarget);
    }
    return rawMorphTargets;
  }
  parseScene(deformers, geometryMap, materialMap) {
    sceneGraph = new Group();
    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
    const modelNodes = fbxTree.Objects.Model;
    const scope2 = this;
    modelMap.forEach(function(model) {
      const modelNode = modelNodes[model.ID];
      scope2.setLookAtProperties(model, modelNode);
      const parentConnections = connections.get(model.ID).parents;
      parentConnections.forEach(function(connection) {
        const parent = modelMap.get(connection.ID);
        if (parent !== void 0)
          parent.add(model);
      });
      if (model.parent === null) {
        sceneGraph.add(model);
      }
    });
    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
    this.createAmbientLight();
    sceneGraph.traverse(function(node) {
      if (node.userData.transformData) {
        if (node.parent) {
          node.userData.transformData.parentMatrix = node.parent.matrix;
          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
        }
        const transform = generateTransform(node.userData.transformData);
        node.applyMatrix4(transform);
        node.updateWorldMatrix();
      }
    });
    const animations = new AnimationParser().parse();
    if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
      sceneGraph.children[0].animations = animations;
      sceneGraph = sceneGraph.children[0];
    }
    sceneGraph.animations = animations;
  }
  parseModels(skeletons, geometryMap, materialMap) {
    const modelMap = /* @__PURE__ */ new Map();
    const modelNodes = fbxTree.Objects.Model;
    for (const nodeID in modelNodes) {
      const id = parseInt(nodeID);
      const node = modelNodes[nodeID];
      const relationships = connections.get(id);
      let model = this.buildSkeleton(relationships, skeletons, id, node.attrName);
      if (!model) {
        switch (node.attrType) {
          case "Camera":
            model = this.createCamera(relationships);
            break;
          case "Light":
            model = this.createLight(relationships);
            break;
          case "Mesh":
            model = this.createMesh(relationships, geometryMap, materialMap);
            break;
          case "NurbsCurve":
            model = this.createCurve(relationships, geometryMap);
            break;
          case "LimbNode":
          case "Root":
            model = new Bone();
            break;
          case "Null":
          default:
            model = new Group();
            break;
        }
        model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : "";
        model.ID = id;
      }
      this.getTransformData(model, node);
      modelMap.set(id, model);
    }
    return modelMap;
  }
  buildSkeleton(relationships, skeletons, id, name) {
    let bone = null;
    relationships.parents.forEach(function(parent) {
      for (const ID in skeletons) {
        const skeleton = skeletons[ID];
        skeleton.rawBones.forEach(function(rawBone, i2) {
          if (rawBone.ID === parent.ID) {
            const subBone = bone;
            bone = new Bone();
            bone.matrixWorld.copy(rawBone.transformLink);
            bone.name = name ? PropertyBinding.sanitizeNodeName(name) : "";
            bone.ID = id;
            skeleton.bones[i2] = bone;
            if (subBone !== null) {
              bone.add(subBone);
            }
          }
        });
      }
    });
    return bone;
  }
  createCamera(relationships) {
    let model;
    let cameraAttribute;
    relationships.children.forEach(function(child) {
      const attr = fbxTree.Objects.NodeAttribute[child.ID];
      if (attr !== void 0) {
        cameraAttribute = attr;
      }
    });
    if (cameraAttribute === void 0) {
      model = new Object3D();
    } else {
      let type2 = 0;
      if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {
        type2 = 1;
      }
      let nearClippingPlane = 1;
      if (cameraAttribute.NearPlane !== void 0) {
        nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;
      }
      let farClippingPlane = 1e3;
      if (cameraAttribute.FarPlane !== void 0) {
        farClippingPlane = cameraAttribute.FarPlane.value / 1e3;
      }
      let width = window.innerWidth;
      let height = window.innerHeight;
      if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {
        width = cameraAttribute.AspectWidth.value;
        height = cameraAttribute.AspectHeight.value;
      }
      const aspect = width / height;
      let fov = 45;
      if (cameraAttribute.FieldOfView !== void 0) {
        fov = cameraAttribute.FieldOfView.value;
      }
      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;
      switch (type2) {
        case 0:
          model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);
          if (focalLength !== null)
            model.setFocalLength(focalLength);
          break;
        case 1:
          model = new OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + type2 + ".");
          model = new Object3D();
          break;
      }
    }
    return model;
  }
  createLight(relationships) {
    let model;
    let lightAttribute;
    relationships.children.forEach(function(child) {
      const attr = fbxTree.Objects.NodeAttribute[child.ID];
      if (attr !== void 0) {
        lightAttribute = attr;
      }
    });
    if (lightAttribute === void 0) {
      model = new Object3D();
    } else {
      let type2;
      if (lightAttribute.LightType === void 0) {
        type2 = 0;
      } else {
        type2 = lightAttribute.LightType.value;
      }
      let color2 = 16777215;
      if (lightAttribute.Color !== void 0) {
        color2 = new Color().fromArray(lightAttribute.Color.value);
      }
      let intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;
      if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {
        intensity = 0;
      }
      let distance2 = 0;
      if (lightAttribute.FarAttenuationEnd !== void 0) {
        if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {
          distance2 = 0;
        } else {
          distance2 = lightAttribute.FarAttenuationEnd.value;
        }
      }
      const decay = 1;
      switch (type2) {
        case 0:
          model = new PointLight(color2, intensity, distance2, decay);
          break;
        case 1:
          model = new DirectionalLight(color2, intensity);
          break;
        case 2:
          let angle = Math.PI / 3;
          if (lightAttribute.InnerAngle !== void 0) {
            angle = MathUtils.degToRad(lightAttribute.InnerAngle.value);
          }
          let penumbra = 0;
          if (lightAttribute.OuterAngle !== void 0) {
            penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);
            penumbra = Math.max(penumbra, 1);
          }
          model = new SpotLight(color2, intensity, distance2, angle, penumbra, decay);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + lightAttribute.LightType.value + ", defaulting to a PointLight.");
          model = new PointLight(color2, intensity);
          break;
      }
      if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {
        model.castShadow = true;
      }
    }
    return model;
  }
  createMesh(relationships, geometryMap, materialMap) {
    let model;
    let geometry = null;
    let material = null;
    const materials = [];
    relationships.children.forEach(function(child) {
      if (geometryMap.has(child.ID)) {
        geometry = geometryMap.get(child.ID);
      }
      if (materialMap.has(child.ID)) {
        materials.push(materialMap.get(child.ID));
      }
    });
    if (materials.length > 1) {
      material = materials;
    } else if (materials.length > 0) {
      material = materials[0];
    } else {
      material = new MeshPhongMaterial({
        color: 13421772
      });
      materials.push(material);
    }
    if ("color" in geometry.attributes) {
      materials.forEach(function(material2) {
        material2.vertexColors = true;
      });
    }
    if (geometry.FBX_Deformer) {
      model = new SkinnedMesh(geometry, material);
      model.normalizeSkinWeights();
    } else {
      model = new Mesh(geometry, material);
    }
    return model;
  }
  createCurve(relationships, geometryMap) {
    const geometry = relationships.children.reduce(function(geo, child) {
      if (geometryMap.has(child.ID))
        geo = geometryMap.get(child.ID);
      return geo;
    }, null);
    const material = new LineBasicMaterial({
      color: 3342591,
      linewidth: 1
    });
    return new Line(geometry, material);
  }
  getTransformData(model, modelNode) {
    const transformData = {};
    if ("InheritType" in modelNode)
      transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ("RotationOrder" in modelNode)
      transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
    else
      transformData.eulerOrder = "ZYX";
    if ("Lcl_Translation" in modelNode)
      transformData.translation = modelNode.Lcl_Translation.value;
    if ("PreRotation" in modelNode)
      transformData.preRotation = modelNode.PreRotation.value;
    if ("Lcl_Rotation" in modelNode)
      transformData.rotation = modelNode.Lcl_Rotation.value;
    if ("PostRotation" in modelNode)
      transformData.postRotation = modelNode.PostRotation.value;
    if ("Lcl_Scaling" in modelNode)
      transformData.scale = modelNode.Lcl_Scaling.value;
    if ("ScalingOffset" in modelNode)
      transformData.scalingOffset = modelNode.ScalingOffset.value;
    if ("ScalingPivot" in modelNode)
      transformData.scalingPivot = modelNode.ScalingPivot.value;
    if ("RotationOffset" in modelNode)
      transformData.rotationOffset = modelNode.RotationOffset.value;
    if ("RotationPivot" in modelNode)
      transformData.rotationPivot = modelNode.RotationPivot.value;
    model.userData.transformData = transformData;
  }
  setLookAtProperties(model, modelNode) {
    if ("LookAtProperty" in modelNode) {
      const children = connections.get(model.ID).children;
      children.forEach(function(child) {
        if (child.relationship === "LookAtProperty") {
          const lookAtTarget = fbxTree.Objects.Model[child.ID];
          if ("Lcl_Translation" in lookAtTarget) {
            const pos = lookAtTarget.Lcl_Translation.value;
            if (model.target !== void 0) {
              model.target.position.fromArray(pos);
              sceneGraph.add(model.target);
            } else {
              model.lookAt(new Vector3().fromArray(pos));
            }
          }
        }
      });
    }
  }
  bindSkeleton(skeletons, geometryMap, modelMap) {
    const bindMatrices = this.parsePoseNodes();
    for (const ID in skeletons) {
      const skeleton = skeletons[ID];
      const parents = connections.get(parseInt(skeleton.ID)).parents;
      parents.forEach(function(parent) {
        if (geometryMap.has(parent.ID)) {
          const geoID = parent.ID;
          const geoRelationships = connections.get(geoID);
          geoRelationships.parents.forEach(function(geoConnParent) {
            if (modelMap.has(geoConnParent.ID)) {
              const model = modelMap.get(geoConnParent.ID);
              model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
            }
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const bindMatrices = {};
    if ("Pose" in fbxTree.Objects) {
      const BindPoseNode = fbxTree.Objects.Pose;
      for (const nodeID in BindPoseNode) {
        if (BindPoseNode[nodeID].attrType === "BindPose" && BindPoseNode[nodeID].NbPoseNodes > 0) {
          const poseNodes = BindPoseNode[nodeID].PoseNode;
          if (Array.isArray(poseNodes)) {
            poseNodes.forEach(function(poseNode) {
              bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);
            });
          } else {
            bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);
          }
        }
      }
    }
    return bindMatrices;
  }
  createAmbientLight() {
    if ("GlobalSettings" in fbxTree && "AmbientColor" in fbxTree.GlobalSettings) {
      const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
      const r = ambientColor[0];
      const g2 = ambientColor[1];
      const b3 = ambientColor[2];
      if (r !== 0 || g2 !== 0 || b3 !== 0) {
        const color2 = new Color(r, g2, b3);
        sceneGraph.add(new AmbientLight(color2, 1));
      }
    }
  }
};
var GeometryParser = class {
  parse(deformers) {
    const geometryMap = /* @__PURE__ */ new Map();
    if ("Geometry" in fbxTree.Objects) {
      const geoNodes = fbxTree.Objects.Geometry;
      for (const nodeID in geoNodes) {
        const relationships = connections.get(parseInt(nodeID));
        const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
        geometryMap.set(parseInt(nodeID), geo);
      }
    }
    return geometryMap;
  }
  parseGeometry(relationships, geoNode, deformers) {
    switch (geoNode.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(relationships, geoNode, deformers);
      case "NurbsCurve":
        return this.parseNurbsGeometry(geoNode);
    }
  }
  parseMeshGeometry(relationships, geoNode, deformers) {
    const skeletons = deformers.skeletons;
    const morphTargets = [];
    const modelNodes = relationships.parents.map(function(parent) {
      return fbxTree.Objects.Model[parent.ID];
    });
    if (modelNodes.length === 0)
      return;
    const skeleton = relationships.children.reduce(function(skeleton2, child) {
      if (skeletons[child.ID] !== void 0)
        skeleton2 = skeletons[child.ID];
      return skeleton2;
    }, null);
    relationships.children.forEach(function(child) {
      if (deformers.morphTargets[child.ID] !== void 0) {
        morphTargets.push(deformers.morphTargets[child.ID]);
      }
    });
    const modelNode = modelNodes[0];
    const transformData = {};
    if ("RotationOrder" in modelNode)
      transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
    if ("InheritType" in modelNode)
      transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ("GeometricTranslation" in modelNode)
      transformData.translation = modelNode.GeometricTranslation.value;
    if ("GeometricRotation" in modelNode)
      transformData.rotation = modelNode.GeometricRotation.value;
    if ("GeometricScaling" in modelNode)
      transformData.scale = modelNode.GeometricScaling.value;
    const transform = generateTransform(transformData);
    return this.genGeometry(geoNode, skeleton, morphTargets, transform);
  }
  genGeometry(geoNode, skeleton, morphTargets, preTransform) {
    const geo = new BufferGeometry();
    if (geoNode.attrName)
      geo.name = geoNode.attrName;
    const geoInfo = this.parseGeoNode(geoNode, skeleton);
    const buffers = this.genBuffers(geoInfo);
    const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);
    positionAttribute.applyMatrix4(preTransform);
    geo.setAttribute("position", positionAttribute);
    if (buffers.colors.length > 0) {
      geo.setAttribute("color", new Float32BufferAttribute(buffers.colors, 3));
    }
    if (skeleton) {
      geo.setAttribute("skinIndex", new Uint16BufferAttribute(buffers.weightsIndices, 4));
      geo.setAttribute("skinWeight", new Float32BufferAttribute(buffers.vertexWeights, 4));
      geo.FBX_Deformer = skeleton;
    }
    if (buffers.normal.length > 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(preTransform);
      const normalAttribute = new Float32BufferAttribute(buffers.normal, 3);
      normalAttribute.applyNormalMatrix(normalMatrix);
      geo.setAttribute("normal", normalAttribute);
    }
    buffers.uvs.forEach(function(uvBuffer, i2) {
      let name = "uv" + (i2 + 1).toString();
      if (i2 === 0) {
        name = "uv";
      }
      geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i2], 2));
    });
    if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
      let prevMaterialIndex = buffers.materialIndex[0];
      let startIndex = 0;
      buffers.materialIndex.forEach(function(currentIndex, i2) {
        if (currentIndex !== prevMaterialIndex) {
          geo.addGroup(startIndex, i2 - startIndex, prevMaterialIndex);
          prevMaterialIndex = currentIndex;
          startIndex = i2;
        }
      });
      if (geo.groups.length > 0) {
        const lastGroup = geo.groups[geo.groups.length - 1];
        const lastIndex = lastGroup.start + lastGroup.count;
        if (lastIndex !== buffers.materialIndex.length) {
          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
        }
      }
      if (geo.groups.length === 0) {
        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
      }
    }
    this.addMorphTargets(geo, geoNode, morphTargets, preTransform);
    return geo;
  }
  parseGeoNode(geoNode, skeleton) {
    const geoInfo = {};
    geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];
    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];
    if (geoNode.LayerElementColor) {
      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
    }
    if (geoNode.LayerElementMaterial) {
      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
    }
    if (geoNode.LayerElementNormal) {
      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
    }
    if (geoNode.LayerElementUV) {
      geoInfo.uv = [];
      let i2 = 0;
      while (geoNode.LayerElementUV[i2]) {
        if (geoNode.LayerElementUV[i2].UV) {
          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i2]));
        }
        i2++;
      }
    }
    geoInfo.weightTable = {};
    if (skeleton !== null) {
      geoInfo.skeleton = skeleton;
      skeleton.rawBones.forEach(function(rawBone, i2) {
        rawBone.indices.forEach(function(index, j2) {
          if (geoInfo.weightTable[index] === void 0)
            geoInfo.weightTable[index] = [];
          geoInfo.weightTable[index].push({
            id: i2,
            weight: rawBone.weights[j2]
          });
        });
      });
    }
    return geoInfo;
  }
  genBuffers(geoInfo) {
    const buffers = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let polygonIndex = 0;
    let faceLength = 0;
    let displayedWeightsWarning = false;
    let facePositionIndexes = [];
    let faceNormals = [];
    let faceColors = [];
    let faceUVs = [];
    let faceWeights = [];
    let faceWeightIndices = [];
    const scope2 = this;
    geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {
      let materialIndex;
      let endOfFace = false;
      if (vertexIndex < 0) {
        vertexIndex = vertexIndex ^ -1;
        endOfFace = true;
      }
      let weightIndices = [];
      let weights = [];
      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);
      if (geoInfo.color) {
        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);
        faceColors.push(data[0], data[1], data[2]);
      }
      if (geoInfo.skeleton) {
        if (geoInfo.weightTable[vertexIndex] !== void 0) {
          geoInfo.weightTable[vertexIndex].forEach(function(wt) {
            weights.push(wt.weight);
            weightIndices.push(wt.id);
          });
        }
        if (weights.length > 4) {
          if (!displayedWeightsWarning) {
            console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.");
            displayedWeightsWarning = true;
          }
          const wIndex = [0, 0, 0, 0];
          const Weight = [0, 0, 0, 0];
          weights.forEach(function(weight, weightIndex) {
            let currentWeight = weight;
            let currentIndex = weightIndices[weightIndex];
            Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {
              if (currentWeight > comparedWeight) {
                comparedWeightArray[comparedWeightIndex] = currentWeight;
                currentWeight = comparedWeight;
                const tmp = wIndex[comparedWeightIndex];
                wIndex[comparedWeightIndex] = currentIndex;
                currentIndex = tmp;
              }
            });
          });
          weightIndices = wIndex;
          weights = Weight;
        }
        while (weights.length < 4) {
          weights.push(0);
          weightIndices.push(0);
        }
        for (let i2 = 0; i2 < 4; ++i2) {
          faceWeights.push(weights[i2]);
          faceWeightIndices.push(weightIndices[i2]);
        }
      }
      if (geoInfo.normal) {
        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);
        faceNormals.push(data[0], data[1], data[2]);
      }
      if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
        materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
      }
      if (geoInfo.uv) {
        geoInfo.uv.forEach(function(uv2, i2) {
          const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv2);
          if (faceUVs[i2] === void 0) {
            faceUVs[i2] = [];
          }
          faceUVs[i2].push(data[0]);
          faceUVs[i2].push(data[1]);
        });
      }
      faceLength++;
      if (endOfFace) {
        scope2.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
        polygonIndex++;
        faceLength = 0;
        facePositionIndexes = [];
        faceNormals = [];
        faceColors = [];
        faceUVs = [];
        faceWeights = [];
        faceWeightIndices = [];
      }
    });
    return buffers;
  }
  genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
    for (let i2 = 2; i2 < faceLength; i2++) {
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i2 - 1) * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i2 - 1) * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i2 - 1) * 3 + 2]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3 + 2]]);
      if (geoInfo.skeleton) {
        buffers.vertexWeights.push(faceWeights[0]);
        buffers.vertexWeights.push(faceWeights[1]);
        buffers.vertexWeights.push(faceWeights[2]);
        buffers.vertexWeights.push(faceWeights[3]);
        buffers.vertexWeights.push(faceWeights[(i2 - 1) * 4]);
        buffers.vertexWeights.push(faceWeights[(i2 - 1) * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[(i2 - 1) * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[(i2 - 1) * 4 + 3]);
        buffers.vertexWeights.push(faceWeights[i2 * 4]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[0]);
        buffers.weightsIndices.push(faceWeightIndices[1]);
        buffers.weightsIndices.push(faceWeightIndices[2]);
        buffers.weightsIndices.push(faceWeightIndices[3]);
        buffers.weightsIndices.push(faceWeightIndices[(i2 - 1) * 4]);
        buffers.weightsIndices.push(faceWeightIndices[(i2 - 1) * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[(i2 - 1) * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[(i2 - 1) * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 3]);
      }
      if (geoInfo.color) {
        buffers.colors.push(faceColors[0]);
        buffers.colors.push(faceColors[1]);
        buffers.colors.push(faceColors[2]);
        buffers.colors.push(faceColors[(i2 - 1) * 3]);
        buffers.colors.push(faceColors[(i2 - 1) * 3 + 1]);
        buffers.colors.push(faceColors[(i2 - 1) * 3 + 2]);
        buffers.colors.push(faceColors[i2 * 3]);
        buffers.colors.push(faceColors[i2 * 3 + 1]);
        buffers.colors.push(faceColors[i2 * 3 + 2]);
      }
      if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
        buffers.materialIndex.push(materialIndex);
        buffers.materialIndex.push(materialIndex);
        buffers.materialIndex.push(materialIndex);
      }
      if (geoInfo.normal) {
        buffers.normal.push(faceNormals[0]);
        buffers.normal.push(faceNormals[1]);
        buffers.normal.push(faceNormals[2]);
        buffers.normal.push(faceNormals[(i2 - 1) * 3]);
        buffers.normal.push(faceNormals[(i2 - 1) * 3 + 1]);
        buffers.normal.push(faceNormals[(i2 - 1) * 3 + 2]);
        buffers.normal.push(faceNormals[i2 * 3]);
        buffers.normal.push(faceNormals[i2 * 3 + 1]);
        buffers.normal.push(faceNormals[i2 * 3 + 2]);
      }
      if (geoInfo.uv) {
        geoInfo.uv.forEach(function(uv2, j2) {
          if (buffers.uvs[j2] === void 0)
            buffers.uvs[j2] = [];
          buffers.uvs[j2].push(faceUVs[j2][0]);
          buffers.uvs[j2].push(faceUVs[j2][1]);
          buffers.uvs[j2].push(faceUVs[j2][(i2 - 1) * 2]);
          buffers.uvs[j2].push(faceUVs[j2][(i2 - 1) * 2 + 1]);
          buffers.uvs[j2].push(faceUVs[j2][i2 * 2]);
          buffers.uvs[j2].push(faceUVs[j2][i2 * 2 + 1]);
        });
      }
    }
  }
  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {
    if (morphTargets.length === 0)
      return;
    parentGeo.morphTargetsRelative = true;
    parentGeo.morphAttributes.position = [];
    const scope2 = this;
    morphTargets.forEach(function(morphTarget) {
      morphTarget.rawTargets.forEach(function(rawTarget) {
        const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];
        if (morphGeoNode !== void 0) {
          scope2.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
        }
      });
    });
  }
  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {
    const vertexIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];
    const morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];
    const indices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];
    const length2 = parentGeo.attributes.position.count * 3;
    const morphPositions = new Float32Array(length2);
    for (let i2 = 0; i2 < indices.length; i2++) {
      const morphIndex = indices[i2] * 3;
      morphPositions[morphIndex] = morphPositionsSparse[i2 * 3];
      morphPositions[morphIndex + 1] = morphPositionsSparse[i2 * 3 + 1];
      morphPositions[morphIndex + 2] = morphPositionsSparse[i2 * 3 + 2];
    }
    const morphGeoInfo = {
      vertexIndices,
      vertexPositions: morphPositions
    };
    const morphBuffers = this.genBuffers(morphGeoInfo);
    const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);
    positionAttribute.name = name || morphGeoNode.attrName;
    positionAttribute.applyMatrix4(preTransform);
    parentGeo.morphAttributes.position.push(positionAttribute);
  }
  parseNormals(NormalNode2) {
    const mappingType = NormalNode2.MappingInformationType;
    const referenceType = NormalNode2.ReferenceInformationType;
    const buffer2 = NormalNode2.Normals.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      if ("NormalIndex" in NormalNode2) {
        indexBuffer = NormalNode2.NormalIndex.a;
      } else if ("NormalsIndex" in NormalNode2) {
        indexBuffer = NormalNode2.NormalsIndex.a;
      }
    }
    return {
      dataSize: 3,
      buffer: buffer2,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  parseUVs(UVNode2) {
    const mappingType = UVNode2.MappingInformationType;
    const referenceType = UVNode2.ReferenceInformationType;
    const buffer2 = UVNode2.UV.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      indexBuffer = UVNode2.UVIndex.a;
    }
    return {
      dataSize: 2,
      buffer: buffer2,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  parseVertexColors(ColorNode) {
    const mappingType = ColorNode.MappingInformationType;
    const referenceType = ColorNode.ReferenceInformationType;
    const buffer2 = ColorNode.Colors.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      indexBuffer = ColorNode.ColorIndex.a;
    }
    return {
      dataSize: 4,
      buffer: buffer2,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  parseMaterialIndices(MaterialNode2) {
    const mappingType = MaterialNode2.MappingInformationType;
    const referenceType = MaterialNode2.ReferenceInformationType;
    if (mappingType === "NoMappingInformation") {
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType
      };
    }
    const materialIndexBuffer = MaterialNode2.Materials.a;
    const materialIndices = [];
    for (let i2 = 0; i2 < materialIndexBuffer.length; ++i2) {
      materialIndices.push(i2);
    }
    return {
      dataSize: 1,
      buffer: materialIndexBuffer,
      indices: materialIndices,
      mappingType,
      referenceType
    };
  }
  parseNurbsGeometry(geoNode) {
    if (NURBSCurve === void 0) {
      console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.");
      return new BufferGeometry();
    }
    const order = parseInt(geoNode.Order);
    if (isNaN(order)) {
      console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", geoNode.Order, geoNode.id);
      return new BufferGeometry();
    }
    const degree = order - 1;
    const knots = geoNode.KnotVector.a;
    const controlPoints = [];
    const pointsValues = geoNode.Points.a;
    for (let i2 = 0, l = pointsValues.length; i2 < l; i2 += 4) {
      controlPoints.push(new Vector4().fromArray(pointsValues, i2));
    }
    let startKnot, endKnot;
    if (geoNode.Form === "Closed") {
      controlPoints.push(controlPoints[0]);
    } else if (geoNode.Form === "Periodic") {
      startKnot = degree;
      endKnot = knots.length - 1 - startKnot;
      for (let i2 = 0; i2 < degree; ++i2) {
        controlPoints.push(controlPoints[i2]);
      }
    }
    const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);
    const points = curve.getPoints(controlPoints.length * 12);
    return new BufferGeometry().setFromPoints(points);
  }
};
var AnimationParser = class {
  parse() {
    const animationClips = [];
    const rawClips = this.parseClips();
    if (rawClips !== void 0) {
      for (const key in rawClips) {
        const rawClip = rawClips[key];
        const clip = this.addClip(rawClip);
        animationClips.push(clip);
      }
    }
    return animationClips;
  }
  parseClips() {
    if (fbxTree.Objects.AnimationCurve === void 0)
      return void 0;
    const curveNodesMap = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(curveNodesMap);
    const layersMap = this.parseAnimationLayers(curveNodesMap);
    const rawClips = this.parseAnimStacks(layersMap);
    return rawClips;
  }
  parseAnimationCurveNodes() {
    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;
    const curveNodesMap = /* @__PURE__ */ new Map();
    for (const nodeID in rawCurveNodes) {
      const rawCurveNode = rawCurveNodes[nodeID];
      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const curveNode = {
          id: rawCurveNode.id,
          attr: rawCurveNode.attrName,
          curves: {}
        };
        curveNodesMap.set(curveNode.id, curveNode);
      }
    }
    return curveNodesMap;
  }
  parseAnimationCurves(curveNodesMap) {
    const rawCurves = fbxTree.Objects.AnimationCurve;
    for (const nodeID in rawCurves) {
      const animationCurve = {
        id: rawCurves[nodeID].id,
        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
        values: rawCurves[nodeID].KeyValueFloat.a
      };
      const relationships = connections.get(animationCurve.id);
      if (relationships !== void 0) {
        const animationCurveID = relationships.parents[0].ID;
        const animationCurveRelationship = relationships.parents[0].relationship;
        if (animationCurveRelationship.match(/X/)) {
          curveNodesMap.get(animationCurveID).curves["x"] = animationCurve;
        } else if (animationCurveRelationship.match(/Y/)) {
          curveNodesMap.get(animationCurveID).curves["y"] = animationCurve;
        } else if (animationCurveRelationship.match(/Z/)) {
          curveNodesMap.get(animationCurveID).curves["z"] = animationCurve;
        } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {
          curveNodesMap.get(animationCurveID).curves["morph"] = animationCurve;
        }
      }
    }
  }
  parseAnimationLayers(curveNodesMap) {
    const rawLayers = fbxTree.Objects.AnimationLayer;
    const layersMap = /* @__PURE__ */ new Map();
    for (const nodeID in rawLayers) {
      const layerCurveNodes = [];
      const connection = connections.get(parseInt(nodeID));
      if (connection !== void 0) {
        const children = connection.children;
        children.forEach(function(child, i2) {
          if (curveNodesMap.has(child.ID)) {
            const curveNode = curveNodesMap.get(child.ID);
            if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {
              if (layerCurveNodes[i2] === void 0) {
                const modelID = connections.get(child.ID).parents.filter(function(parent) {
                  return parent.relationship !== void 0;
                })[0].ID;
                if (modelID !== void 0) {
                  const rawModel = fbxTree.Objects.Model[modelID.toString()];
                  if (rawModel === void 0) {
                    console.warn("THREE.FBXLoader: Encountered a unused curve.", child);
                    return;
                  }
                  const node = {
                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                    ID: rawModel.id,
                    initialPosition: [0, 0, 0],
                    initialRotation: [0, 0, 0],
                    initialScale: [1, 1, 1]
                  };
                  sceneGraph.traverse(function(child2) {
                    if (child2.ID === rawModel.id) {
                      node.transform = child2.matrix;
                      if (child2.userData.transformData)
                        node.eulerOrder = child2.userData.transformData.eulerOrder;
                    }
                  });
                  if (!node.transform)
                    node.transform = new Matrix4();
                  if ("PreRotation" in rawModel)
                    node.preRotation = rawModel.PreRotation.value;
                  if ("PostRotation" in rawModel)
                    node.postRotation = rawModel.PostRotation.value;
                  layerCurveNodes[i2] = node;
                }
              }
              if (layerCurveNodes[i2])
                layerCurveNodes[i2][curveNode.attr] = curveNode;
            } else if (curveNode.curves.morph !== void 0) {
              if (layerCurveNodes[i2] === void 0) {
                const deformerID = connections.get(child.ID).parents.filter(function(parent) {
                  return parent.relationship !== void 0;
                })[0].ID;
                const morpherID = connections.get(deformerID).parents[0].ID;
                const geoID = connections.get(morpherID).parents[0].ID;
                const modelID = connections.get(geoID).parents[0].ID;
                const rawModel = fbxTree.Objects.Model[modelID];
                const node = {
                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                  morphName: fbxTree.Objects.Deformer[deformerID].attrName
                };
                layerCurveNodes[i2] = node;
              }
              layerCurveNodes[i2][curveNode.attr] = curveNode;
            }
          }
        });
        layersMap.set(parseInt(nodeID), layerCurveNodes);
      }
    }
    return layersMap;
  }
  parseAnimStacks(layersMap) {
    const rawStacks = fbxTree.Objects.AnimationStack;
    const rawClips = {};
    for (const nodeID in rawStacks) {
      const children = connections.get(parseInt(nodeID)).children;
      if (children.length > 1) {
        console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      }
      const layer = layersMap.get(children[0].ID);
      rawClips[nodeID] = {
        name: rawStacks[nodeID].attrName,
        layer
      };
    }
    return rawClips;
  }
  addClip(rawClip) {
    let tracks = [];
    const scope2 = this;
    rawClip.layer.forEach(function(rawTracks) {
      tracks = tracks.concat(scope2.generateTracks(rawTracks));
    });
    return new AnimationClip(rawClip.name, -1, tracks);
  }
  generateTracks(rawTracks) {
    const tracks = [];
    let initialPosition = new Vector3();
    let initialRotation = new Quaternion();
    let initialScale = new Vector3();
    if (rawTracks.transform)
      rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);
    initialPosition = initialPosition.toArray();
    initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();
    initialScale = initialScale.toArray();
    if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {
      const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, "position");
      if (positionTrack !== void 0)
        tracks.push(positionTrack);
    }
    if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {
      const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);
      if (rotationTrack !== void 0)
        tracks.push(rotationTrack);
    }
    if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {
      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, "scale");
      if (scaleTrack !== void 0)
        tracks.push(scaleTrack);
    }
    if (rawTracks.DeformPercent !== void 0) {
      const morphTrack = this.generateMorphTrack(rawTracks);
      if (morphTrack !== void 0)
        tracks.push(morphTrack);
    }
    return tracks;
  }
  generateVectorTrack(modelName, curves, initialValue, type2) {
    const times = this.getTimesForAllAxes(curves);
    const values = this.getKeyframeTrackValues(times, curves, initialValue);
    return new VectorKeyframeTrack(modelName + "." + type2, times, values);
  }
  generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {
    if (curves.x !== void 0) {
      this.interpolateRotations(curves.x);
      curves.x.values = curves.x.values.map(MathUtils.degToRad);
    }
    if (curves.y !== void 0) {
      this.interpolateRotations(curves.y);
      curves.y.values = curves.y.values.map(MathUtils.degToRad);
    }
    if (curves.z !== void 0) {
      this.interpolateRotations(curves.z);
      curves.z.values = curves.z.values.map(MathUtils.degToRad);
    }
    const times = this.getTimesForAllAxes(curves);
    const values = this.getKeyframeTrackValues(times, curves, initialValue);
    if (preRotation !== void 0) {
      preRotation = preRotation.map(MathUtils.degToRad);
      preRotation.push(eulerOrder);
      preRotation = new Euler().fromArray(preRotation);
      preRotation = new Quaternion().setFromEuler(preRotation);
    }
    if (postRotation !== void 0) {
      postRotation = postRotation.map(MathUtils.degToRad);
      postRotation.push(eulerOrder);
      postRotation = new Euler().fromArray(postRotation);
      postRotation = new Quaternion().setFromEuler(postRotation).invert();
    }
    const quaternion = new Quaternion();
    const euler = new Euler();
    const quaternionValues = [];
    for (let i2 = 0; i2 < values.length; i2 += 3) {
      euler.set(values[i2], values[i2 + 1], values[i2 + 2], eulerOrder);
      quaternion.setFromEuler(euler);
      if (preRotation !== void 0)
        quaternion.premultiply(preRotation);
      if (postRotation !== void 0)
        quaternion.multiply(postRotation);
      quaternion.toArray(quaternionValues, i2 / 3 * 4);
    }
    return new QuaternionKeyframeTrack(modelName + ".quaternion", times, quaternionValues);
  }
  generateMorphTrack(rawTracks) {
    const curves = rawTracks.DeformPercent.curves.morph;
    const values = curves.values.map(function(val) {
      return val / 100;
    });
    const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
    return new NumberKeyframeTrack(rawTracks.modelName + ".morphTargetInfluences[" + morphNum + "]", curves.times, values);
  }
  getTimesForAllAxes(curves) {
    let times = [];
    if (curves.x !== void 0)
      times = times.concat(curves.x.times);
    if (curves.y !== void 0)
      times = times.concat(curves.y.times);
    if (curves.z !== void 0)
      times = times.concat(curves.z.times);
    times = times.sort(function(a2, b3) {
      return a2 - b3;
    });
    if (times.length > 1) {
      let targetIndex = 1;
      let lastValue = times[0];
      for (let i2 = 1; i2 < times.length; i2++) {
        const currentValue = times[i2];
        if (currentValue !== lastValue) {
          times[targetIndex] = currentValue;
          lastValue = currentValue;
          targetIndex++;
        }
      }
      times = times.slice(0, targetIndex);
    }
    return times;
  }
  getKeyframeTrackValues(times, curves, initialValue) {
    const prevValue = initialValue;
    const values = [];
    let xIndex = -1;
    let yIndex = -1;
    let zIndex = -1;
    times.forEach(function(time) {
      if (curves.x)
        xIndex = curves.x.times.indexOf(time);
      if (curves.y)
        yIndex = curves.y.times.indexOf(time);
      if (curves.z)
        zIndex = curves.z.times.indexOf(time);
      if (xIndex !== -1) {
        const xValue = curves.x.values[xIndex];
        values.push(xValue);
        prevValue[0] = xValue;
      } else {
        values.push(prevValue[0]);
      }
      if (yIndex !== -1) {
        const yValue = curves.y.values[yIndex];
        values.push(yValue);
        prevValue[1] = yValue;
      } else {
        values.push(prevValue[1]);
      }
      if (zIndex !== -1) {
        const zValue = curves.z.values[zIndex];
        values.push(zValue);
        prevValue[2] = zValue;
      } else {
        values.push(prevValue[2]);
      }
    });
    return values;
  }
  interpolateRotations(curve) {
    for (let i2 = 1; i2 < curve.values.length; i2++) {
      const initialValue = curve.values[i2 - 1];
      const valuesSpan = curve.values[i2] - initialValue;
      const absoluteSpan = Math.abs(valuesSpan);
      if (absoluteSpan >= 180) {
        const numSubIntervals = absoluteSpan / 180;
        const step2 = valuesSpan / numSubIntervals;
        let nextValue = initialValue + step2;
        const initialTime = curve.times[i2 - 1];
        const timeSpan = curve.times[i2] - initialTime;
        const interval = timeSpan / numSubIntervals;
        let nextTime = initialTime + interval;
        const interpolatedTimes = [];
        const interpolatedValues = [];
        while (nextTime < curve.times[i2]) {
          interpolatedTimes.push(nextTime);
          nextTime += interval;
          interpolatedValues.push(nextValue);
          nextValue += step2;
        }
        curve.times = inject(curve.times, i2, interpolatedTimes);
        curve.values = inject(curve.values, i2, interpolatedValues);
      }
    }
  }
};
var TextParser = class {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(node) {
    this.nodeStack.push(node);
    this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop();
    this.currentIndent -= 1;
  }
  setCurrentProp(val, name) {
    this.currentProp = val;
    this.currentPropName = name;
  }
  parse(text) {
    this.currentIndent = 0;
    this.allNodes = new FBXTree();
    this.nodeStack = [];
    this.currentProp = [];
    this.currentPropName = "";
    const scope2 = this;
    const split = text.split(/[\r\n]+/);
    split.forEach(function(line2, i2) {
      const matchComment = line2.match(/^[\s\t]*;/);
      const matchEmpty = line2.match(/^[\s\t]*$/);
      if (matchComment || matchEmpty)
        return;
      const matchBeginning = line2.match("^\\t{" + scope2.currentIndent + "}(\\w+):(.*){", "");
      const matchProperty = line2.match("^\\t{" + scope2.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)");
      const matchEnd = line2.match("^\\t{" + (scope2.currentIndent - 1) + "}}");
      if (matchBeginning) {
        scope2.parseNodeBegin(line2, matchBeginning);
      } else if (matchProperty) {
        scope2.parseNodeProperty(line2, matchProperty, split[++i2]);
      } else if (matchEnd) {
        scope2.popStack();
      } else if (line2.match(/^[^\s\t}]/)) {
        scope2.parseNodePropertyContinued(line2);
      }
    });
    return this.allNodes;
  }
  parseNodeBegin(line2, property) {
    const nodeName = property[1].trim().replace(/^"/, "").replace(/"$/, "");
    const nodeAttrs = property[2].split(",").map(function(attr) {
      return attr.trim().replace(/^"/, "").replace(/"$/, "");
    });
    const node = {
      name: nodeName
    };
    const attrs = this.parseNodeAttr(nodeAttrs);
    const currentNode = this.getCurrentNode();
    if (this.currentIndent === 0) {
      this.allNodes.add(nodeName, node);
    } else {
      if (nodeName in currentNode) {
        if (nodeName === "PoseNode") {
          currentNode.PoseNode.push(node);
        } else if (currentNode[nodeName].id !== void 0) {
          currentNode[nodeName] = {};
          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
        }
        if (attrs.id !== "")
          currentNode[nodeName][attrs.id] = node;
      } else if (typeof attrs.id === "number") {
        currentNode[nodeName] = {};
        currentNode[nodeName][attrs.id] = node;
      } else if (nodeName !== "Properties70") {
        if (nodeName === "PoseNode")
          currentNode[nodeName] = [node];
        else
          currentNode[nodeName] = node;
      }
    }
    if (typeof attrs.id === "number")
      node.id = attrs.id;
    if (attrs.name !== "")
      node.attrName = attrs.name;
    if (attrs.type !== "")
      node.attrType = attrs.type;
    this.pushStack(node);
  }
  parseNodeAttr(attrs) {
    let id = attrs[0];
    if (attrs[0] !== "") {
      id = parseInt(attrs[0]);
      if (isNaN(id)) {
        id = attrs[0];
      }
    }
    let name = "", type2 = "";
    if (attrs.length > 1) {
      name = attrs[1].replace(/^(\w+)::/, "");
      type2 = attrs[2];
    }
    return {
      id,
      name,
      type: type2
    };
  }
  parseNodeProperty(line2, property, contentLine) {
    let propName = property[1].replace(/^"/, "").replace(/"$/, "").trim();
    let propValue = property[2].replace(/^"/, "").replace(/"$/, "").trim();
    if (propName === "Content" && propValue === ",") {
      propValue = contentLine.replace(/"/g, "").replace(/,$/, "").trim();
    }
    const currentNode = this.getCurrentNode();
    const parentName = currentNode.name;
    if (parentName === "Properties70") {
      this.parseNodeSpecialProperty(line2, propName, propValue);
      return;
    }
    if (propName === "C") {
      const connProps = propValue.split(",").slice(1);
      const from = parseInt(connProps[0]);
      const to = parseInt(connProps[1]);
      let rest = propValue.split(",").slice(3);
      rest = rest.map(function(elem) {
        return elem.trim().replace(/^"/, "");
      });
      propName = "connections";
      propValue = [from, to];
      append(propValue, rest);
      if (currentNode[propName] === void 0) {
        currentNode[propName] = [];
      }
    }
    if (propName === "Node")
      currentNode.id = propValue;
    if (propName in currentNode && Array.isArray(currentNode[propName])) {
      currentNode[propName].push(propValue);
    } else {
      if (propName !== "a")
        currentNode[propName] = propValue;
      else
        currentNode.a = propValue;
    }
    this.setCurrentProp(currentNode, propName);
    if (propName === "a" && propValue.slice(-1) !== ",") {
      currentNode.a = parseNumberArray(propValue);
    }
  }
  parseNodePropertyContinued(line2) {
    const currentNode = this.getCurrentNode();
    currentNode.a += line2;
    if (line2.slice(-1) !== ",") {
      currentNode.a = parseNumberArray(currentNode.a);
    }
  }
  parseNodeSpecialProperty(line2, propName, propValue) {
    const props = propValue.split('",').map(function(prop) {
      return prop.trim().replace(/^\"/, "").replace(/\s/, "_");
    });
    const innerPropName = props[0];
    const innerPropType1 = props[1];
    const innerPropType2 = props[2];
    const innerPropFlag = props[3];
    let innerPropValue = props[4];
    switch (innerPropType1) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        innerPropValue = parseFloat(innerPropValue);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        innerPropValue = parseNumberArray(innerPropValue);
        break;
    }
    this.getPrevNode()[innerPropName] = {
      type: innerPropType1,
      type2: innerPropType2,
      flag: innerPropFlag,
      value: innerPropValue
    };
    this.setCurrentProp(this.getPrevNode(), innerPropName);
  }
};
var BinaryParser = class {
  parse(buffer2) {
    const reader = new BinaryReader(buffer2);
    reader.skip(23);
    const version = reader.getUint32();
    if (version < 6400) {
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + version);
    }
    const allNodes = new FBXTree();
    while (!this.endOfContent(reader)) {
      const node = this.parseNode(reader, version);
      if (node !== null)
        allNodes.add(node.name, node);
    }
    return allNodes;
  }
  endOfContent(reader) {
    if (reader.size() % 16 === 0) {
      return (reader.getOffset() + 160 + 16 & ~15) >= reader.size();
    } else {
      return reader.getOffset() + 160 + 16 >= reader.size();
    }
  }
  parseNode(reader, version) {
    const node = {};
    const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
    const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();
    version >= 7500 ? reader.getUint64() : reader.getUint32();
    const nameLen = reader.getUint8();
    const name = reader.getString(nameLen);
    if (endOffset === 0)
      return null;
    const propertyList = [];
    for (let i2 = 0; i2 < numProperties; i2++) {
      propertyList.push(this.parseProperty(reader));
    }
    const id = propertyList.length > 0 ? propertyList[0] : "";
    const attrName = propertyList.length > 1 ? propertyList[1] : "";
    const attrType = propertyList.length > 2 ? propertyList[2] : "";
    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;
    while (endOffset > reader.getOffset()) {
      const subNode = this.parseNode(reader, version);
      if (subNode !== null)
        this.parseSubNode(name, node, subNode);
    }
    node.propertyList = propertyList;
    if (typeof id === "number")
      node.id = id;
    if (attrName !== "")
      node.attrName = attrName;
    if (attrType !== "")
      node.attrType = attrType;
    if (name !== "")
      node.name = name;
    return node;
  }
  parseSubNode(name, node, subNode) {
    if (subNode.singleProperty === true) {
      const value = subNode.propertyList[0];
      if (Array.isArray(value)) {
        node[subNode.name] = subNode;
        subNode.a = value;
      } else {
        node[subNode.name] = value;
      }
    } else if (name === "Connections" && subNode.name === "C") {
      const array = [];
      subNode.propertyList.forEach(function(property, i2) {
        if (i2 !== 0)
          array.push(property);
      });
      if (node.connections === void 0) {
        node.connections = [];
      }
      node.connections.push(array);
    } else if (subNode.name === "Properties70") {
      const keys = Object.keys(subNode);
      keys.forEach(function(key) {
        node[key] = subNode[key];
      });
    } else if (name === "Properties70" && subNode.name === "P") {
      let innerPropName = subNode.propertyList[0];
      let innerPropType1 = subNode.propertyList[1];
      const innerPropType2 = subNode.propertyList[2];
      const innerPropFlag = subNode.propertyList[3];
      let innerPropValue;
      if (innerPropName.indexOf("Lcl ") === 0)
        innerPropName = innerPropName.replace("Lcl ", "Lcl_");
      if (innerPropType1.indexOf("Lcl ") === 0)
        innerPropType1 = innerPropType1.replace("Lcl ", "Lcl_");
      if (innerPropType1 === "Color" || innerPropType1 === "ColorRGB" || innerPropType1 === "Vector" || innerPropType1 === "Vector3D" || innerPropType1.indexOf("Lcl_") === 0) {
        innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];
      } else {
        innerPropValue = subNode.propertyList[4];
      }
      node[innerPropName] = {
        type: innerPropType1,
        type2: innerPropType2,
        flag: innerPropFlag,
        value: innerPropValue
      };
    } else if (node[subNode.name] === void 0) {
      if (typeof subNode.id === "number") {
        node[subNode.name] = {};
        node[subNode.name][subNode.id] = subNode;
      } else {
        node[subNode.name] = subNode;
      }
    } else {
      if (subNode.name === "PoseNode") {
        if (!Array.isArray(node[subNode.name])) {
          node[subNode.name] = [node[subNode.name]];
        }
        node[subNode.name].push(subNode);
      } else if (node[subNode.name][subNode.id] === void 0) {
        node[subNode.name][subNode.id] = subNode;
      }
    }
  }
  parseProperty(reader) {
    const type2 = reader.getString(1);
    let length2;
    switch (type2) {
      case "C":
        return reader.getBoolean();
      case "D":
        return reader.getFloat64();
      case "F":
        return reader.getFloat32();
      case "I":
        return reader.getInt32();
      case "L":
        return reader.getInt64();
      case "R":
        length2 = reader.getUint32();
        return reader.getArrayBuffer(length2);
      case "S":
        length2 = reader.getUint32();
        return reader.getString(length2);
      case "Y":
        return reader.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const arrayLength = reader.getUint32();
        const encoding = reader.getUint32();
        const compressedLength = reader.getUint32();
        if (encoding === 0) {
          switch (type2) {
            case "b":
            case "c":
              return reader.getBooleanArray(arrayLength);
            case "d":
              return reader.getFloat64Array(arrayLength);
            case "f":
              return reader.getFloat32Array(arrayLength);
            case "i":
              return reader.getInt32Array(arrayLength);
            case "l":
              return reader.getInt64Array(arrayLength);
          }
        }
        const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)));
        const reader2 = new BinaryReader(data.buffer);
        switch (type2) {
          case "b":
          case "c":
            return reader2.getBooleanArray(arrayLength);
          case "d":
            return reader2.getFloat64Array(arrayLength);
          case "f":
            return reader2.getFloat32Array(arrayLength);
          case "i":
            return reader2.getInt32Array(arrayLength);
          case "l":
            return reader2.getInt64Array(arrayLength);
        }
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + type2);
    }
  }
};
var BinaryReader = class {
  constructor(buffer2, littleEndian) {
    this.dv = new DataView(buffer2);
    this.offset = 0;
    this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(length2) {
    this.offset += length2;
  }
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(size2) {
    const a2 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a2.push(this.getBoolean());
    }
    return a2;
  }
  getUint8() {
    const value = this.dv.getUint8(this.offset);
    this.offset += 1;
    return value;
  }
  getInt16() {
    const value = this.dv.getInt16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  }
  getInt32() {
    const value = this.dv.getInt32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getInt32Array(size2) {
    const a2 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a2.push(this.getInt32());
    }
    return a2;
  }
  getUint32() {
    const value = this.dv.getUint32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getInt64() {
    let low, high;
    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }
    if (high & 2147483648) {
      high = ~high & 4294967295;
      low = ~low & 4294967295;
      if (low === 4294967295)
        high = high + 1 & 4294967295;
      low = low + 1 & 4294967295;
      return -(high * 4294967296 + low);
    }
    return high * 4294967296 + low;
  }
  getInt64Array(size2) {
    const a2 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a2.push(this.getInt64());
    }
    return a2;
  }
  getUint64() {
    let low, high;
    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }
    return high * 4294967296 + low;
  }
  getFloat32() {
    const value = this.dv.getFloat32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getFloat32Array(size2) {
    const a2 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a2.push(this.getFloat32());
    }
    return a2;
  }
  getFloat64() {
    const value = this.dv.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  }
  getFloat64Array(size2) {
    const a2 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a2.push(this.getFloat64());
    }
    return a2;
  }
  getArrayBuffer(size2) {
    const value = this.dv.buffer.slice(this.offset, this.offset + size2);
    this.offset += size2;
    return value;
  }
  getString(size2) {
    let a2 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a2[i2] = this.getUint8();
    }
    const nullByte = a2.indexOf(0);
    if (nullByte >= 0)
      a2 = a2.slice(0, nullByte);
    return LoaderUtils.decodeText(new Uint8Array(a2));
  }
};
var FBXTree = class {
  add(key, val) {
    this[key] = val;
  }
};
function isFbxFormatBinary(buffer2) {
  const CORRECT = "Kaydara FBX Binary  \0";
  return buffer2.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer2, 0, CORRECT.length);
}
function isFbxFormatASCII(text) {
  const CORRECT = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let cursor = 0;
  function read2(offset) {
    const result = text[offset - 1];
    text = text.slice(cursor + offset);
    cursor++;
    return result;
  }
  for (let i2 = 0; i2 < CORRECT.length; ++i2) {
    const num = read2(1);
    if (num === CORRECT[i2]) {
      return false;
    }
  }
  return true;
}
function getFbxVersion(text) {
  const versionRegExp = /FBXVersion: (\d+)/;
  const match = text.match(versionRegExp);
  if (match) {
    const version = parseInt(match[1]);
    return version;
  }
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function convertFBXTimeToSeconds(time) {
  return time / 46186158e3;
}
var dataArray = [];
function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
  let index;
  switch (infoObject.mappingType) {
    case "ByPolygonVertex":
      index = polygonVertexIndex;
      break;
    case "ByPolygon":
      index = polygonIndex;
      break;
    case "ByVertice":
      index = vertexIndex;
      break;
    case "AllSame":
      index = infoObject.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + infoObject.mappingType);
  }
  if (infoObject.referenceType === "IndexToDirect")
    index = infoObject.indices[index];
  const from = index * infoObject.dataSize;
  const to = from + infoObject.dataSize;
  return slice(dataArray, infoObject.buffer, from, to);
}
var tempEuler = new Euler();
var tempVec = new Vector3();
function generateTransform(transformData) {
  const lTranslationM = new Matrix4();
  const lPreRotationM = new Matrix4();
  const lRotationM = new Matrix4();
  const lPostRotationM = new Matrix4();
  const lScalingM = new Matrix4();
  const lScalingPivotM = new Matrix4();
  const lScalingOffsetM = new Matrix4();
  const lRotationOffsetM = new Matrix4();
  const lRotationPivotM = new Matrix4();
  const lParentGX = new Matrix4();
  const lParentLX = new Matrix4();
  const lGlobalT = new Matrix4();
  const inheritType = transformData.inheritType ? transformData.inheritType : 0;
  if (transformData.translation)
    lTranslationM.setPosition(tempVec.fromArray(transformData.translation));
  if (transformData.preRotation) {
    const array = transformData.preRotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder);
    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }
  if (transformData.rotation) {
    const array = transformData.rotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder);
    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }
  if (transformData.postRotation) {
    const array = transformData.postRotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder);
    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
    lPostRotationM.invert();
  }
  if (transformData.scale)
    lScalingM.scale(tempVec.fromArray(transformData.scale));
  if (transformData.scalingOffset)
    lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));
  if (transformData.scalingPivot)
    lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));
  if (transformData.rotationOffset)
    lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));
  if (transformData.rotationPivot)
    lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));
  if (transformData.parentMatrixWorld) {
    lParentLX.copy(transformData.parentMatrix);
    lParentGX.copy(transformData.parentMatrixWorld);
  }
  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);
  const lParentGRM = new Matrix4();
  lParentGRM.extractRotation(lParentGX);
  const lParentTM = new Matrix4();
  lParentTM.copyPosition(lParentGX);
  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);
  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);
  const lLSM = lScalingM;
  const lGlobalRS = new Matrix4();
  if (inheritType === 0) {
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
  } else if (inheritType === 1) {
    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
  } else {
    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX));
    const lParentLSM_inv = lParentLSM.clone().invert();
    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
  }
  const lRotationPivotM_inv = lRotationPivotM.clone().invert();
  const lScalingPivotM_inv = lScalingPivotM.clone().invert();
  let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);
  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
  lGlobalT.copyPosition(lGlobalTranslation);
  lTransform = lGlobalT.clone().multiply(lGlobalRS);
  lTransform.premultiply(lParentGX.invert());
  return lTransform;
}
function getEulerOrder(order) {
  order = order || 0;
  const enums = [
    "ZYX",
    "YZX",
    "XZY",
    "ZXY",
    "YXZ",
    "XYZ"
  ];
  if (order === 6) {
    console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.");
    return enums[0];
  }
  return enums[order];
}
function parseNumberArray(value) {
  const array = value.split(",").map(function(val) {
    return parseFloat(val);
  });
  return array;
}
function convertArrayBufferToString(buffer2, from, to) {
  if (from === void 0)
    from = 0;
  if (to === void 0)
    to = buffer2.byteLength;
  return LoaderUtils.decodeText(new Uint8Array(buffer2, from, to));
}
function append(a2, b3) {
  for (let i2 = 0, j2 = a2.length, l = b3.length; i2 < l; i2++, j2++) {
    a2[j2] = b3[i2];
  }
}
function slice(a2, b3, from, to) {
  for (let i2 = from, j2 = 0; i2 < to; i2++, j2++) {
    a2[j2] = b3[i2];
  }
  return a2;
}
function inject(a1, index, a2) {
  return a1.slice(0, index).concat(a2).concat(a1.slice(index));
}

// node_modules/three-stdlib/loaders/FontLoader.js
var FontLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (response) => {
      if (typeof response !== "string")
        throw new Error("unsupported data type");
      const json = JSON.parse(response);
      const font = this.parse(json);
      if (onLoad)
        onLoad(font);
    }, onProgress, onError);
  }
  parse(json) {
    return new Font(json);
  }
};
var Font = class {
  constructor(data) {
    _defineProperty(this, "data", void 0);
    this.data = data;
  }
  generateShapes(text, size2 = 100, _options) {
    const shapes = [];
    const options = {
      letterSpacing: 0,
      lineHeight: 1,
      ..._options
    };
    const paths = createPaths(text, size2, this.data, options);
    for (let p = 0, pl = paths.length; p < pl; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes(false));
    }
    return shapes;
  }
};
_defineProperty(Font, "isFont", void 0);
_defineProperty(Font, "type", void 0);
function createPaths(text, size2, data, options) {
  const chars = Array.from(text);
  const scale = size2 / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i2 = 0; i2 < chars.length; i2++) {
    const char = chars[i2];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height * options.lineHeight;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      if (ret) {
        offsetX += ret.offsetX + options.letterSpacing;
        paths.push(ret.path);
      }
    }
  }
  return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i2 = 0, l = outline.length; i2 < l; ) {
      const action = outline[i2++];
      switch (action) {
        case "m":
          x = parseInt(outline[i2++]) * scale + offsetX;
          y = parseInt(outline[i2++]) * scale + offsetY;
          path.moveTo(x, y);
          break;
        case "l":
          x = parseInt(outline[i2++]) * scale + offsetX;
          y = parseInt(outline[i2++]) * scale + offsetY;
          path.lineTo(x, y);
          break;
        case "q":
          cpx = parseInt(outline[i2++]) * scale + offsetX;
          cpy = parseInt(outline[i2++]) * scale + offsetY;
          cpx1 = parseInt(outline[i2++]) * scale + offsetX;
          cpy1 = parseInt(outline[i2++]) * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = parseInt(outline[i2++]) * scale + offsetX;
          cpy = parseInt(outline[i2++]) * scale + offsetY;
          cpx1 = parseInt(outline[i2++]) * scale + offsetX;
          cpy1 = parseInt(outline[i2++]) * scale + offsetY;
          cpx2 = parseInt(outline[i2++]) * scale + offsetX;
          cpy2 = parseInt(outline[i2++]) * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return {
    offsetX: glyph.ha * scale,
    path
  };
}

// node_modules/three-stdlib/loaders/TGALoader.js
var TGALoader = class extends DataTextureLoader {
  constructor(manager) {
    super(manager);
  }
  parse(buffer2) {
    function tgaCheckHeader(header2) {
      switch (header2.image_type) {
        case TGA_TYPE_INDEXED:
        case TGA_TYPE_RLE_INDEXED:
          if (header2.colormap_length > 256 || header2.colormap_size !== 24 || header2.colormap_type !== 1) {
            console.error("THREE.TGALoader: Invalid type colormap data for indexed type.");
          }
          break;
        case TGA_TYPE_RGB:
        case TGA_TYPE_GREY:
        case TGA_TYPE_RLE_RGB:
        case TGA_TYPE_RLE_GREY:
          if (header2.colormap_type) {
            console.error("THREE.TGALoader: Invalid type colormap data for colormap type.");
          }
          break;
        case TGA_TYPE_NO_DATA:
          console.error("THREE.TGALoader: No data.");
        default:
          console.error('THREE.TGALoader: Invalid type "%s".', header2.image_type);
      }
      if (header2.width <= 0 || header2.height <= 0) {
        console.error("THREE.TGALoader: Invalid image size.");
      }
      if (header2.pixel_size !== 8 && header2.pixel_size !== 16 && header2.pixel_size !== 24 && header2.pixel_size !== 32) {
        console.error('THREE.TGALoader: Invalid pixel size "%s".', header2.pixel_size);
      }
    }
    function tgaParse(use_rle2, use_pal2, header2, offset2, data) {
      let pixel_data, palettes;
      const pixel_size = header2.pixel_size >> 3;
      const pixel_total = header2.width * header2.height * pixel_size;
      if (use_pal2) {
        palettes = data.subarray(offset2, offset2 += header2.colormap_length * (header2.colormap_size >> 3));
      }
      if (use_rle2) {
        pixel_data = new Uint8Array(pixel_total);
        let c, count, i2;
        let shift = 0;
        const pixels = new Uint8Array(pixel_size);
        while (shift < pixel_total) {
          c = data[offset2++];
          count = (c & 127) + 1;
          if (c & 128) {
            for (i2 = 0; i2 < pixel_size; ++i2) {
              pixels[i2] = data[offset2++];
            }
            for (i2 = 0; i2 < count; ++i2) {
              pixel_data.set(pixels, shift + i2 * pixel_size);
            }
            shift += pixel_size * count;
          } else {
            count *= pixel_size;
            for (i2 = 0; i2 < count; ++i2) {
              pixel_data[shift + i2] = data[offset2++];
            }
            shift += count;
          }
        }
      } else {
        pixel_data = data.subarray(offset2, offset2 += use_pal2 ? header2.width * header2.height : pixel_total);
      }
      return {
        pixel_data,
        palettes
      };
    }
    function tgaGetImageData8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {
      const colormap = palettes;
      let color2, i2 = 0, x, y;
      const width = header.width;
      for (y = y_start; y !== y_end; y += y_step) {
        for (x = x_start; x !== x_end; x += x_step, i2++) {
          color2 = image[i2];
          imageData2[(x + width * y) * 4 + 3] = 255;
          imageData2[(x + width * y) * 4 + 2] = colormap[color2 * 3 + 0];
          imageData2[(x + width * y) * 4 + 1] = colormap[color2 * 3 + 1];
          imageData2[(x + width * y) * 4 + 0] = colormap[color2 * 3 + 2];
        }
      }
      return imageData2;
    }
    function tgaGetImageData16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
      let color2, i2 = 0, x, y;
      const width = header.width;
      for (y = y_start; y !== y_end; y += y_step) {
        for (x = x_start; x !== x_end; x += x_step, i2 += 2) {
          color2 = image[i2 + 0] + (image[i2 + 1] << 8);
          imageData2[(x + width * y) * 4 + 0] = (color2 & 31744) >> 7;
          imageData2[(x + width * y) * 4 + 1] = (color2 & 992) >> 2;
          imageData2[(x + width * y) * 4 + 2] = (color2 & 31) >> 3;
          imageData2[(x + width * y) * 4 + 3] = color2 & 32768 ? 0 : 255;
        }
      }
      return imageData2;
    }
    function tgaGetImageData24bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
      let i2 = 0, x, y;
      const width = header.width;
      for (y = y_start; y !== y_end; y += y_step) {
        for (x = x_start; x !== x_end; x += x_step, i2 += 3) {
          imageData2[(x + width * y) * 4 + 3] = 255;
          imageData2[(x + width * y) * 4 + 2] = image[i2 + 0];
          imageData2[(x + width * y) * 4 + 1] = image[i2 + 1];
          imageData2[(x + width * y) * 4 + 0] = image[i2 + 2];
        }
      }
      return imageData2;
    }
    function tgaGetImageData32bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
      let i2 = 0, x, y;
      const width = header.width;
      for (y = y_start; y !== y_end; y += y_step) {
        for (x = x_start; x !== x_end; x += x_step, i2 += 4) {
          imageData2[(x + width * y) * 4 + 2] = image[i2 + 0];
          imageData2[(x + width * y) * 4 + 1] = image[i2 + 1];
          imageData2[(x + width * y) * 4 + 0] = image[i2 + 2];
          imageData2[(x + width * y) * 4 + 3] = image[i2 + 3];
        }
      }
      return imageData2;
    }
    function tgaGetImageDataGrey8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
      let color2, i2 = 0, x, y;
      const width = header.width;
      for (y = y_start; y !== y_end; y += y_step) {
        for (x = x_start; x !== x_end; x += x_step, i2++) {
          color2 = image[i2];
          imageData2[(x + width * y) * 4 + 0] = color2;
          imageData2[(x + width * y) * 4 + 1] = color2;
          imageData2[(x + width * y) * 4 + 2] = color2;
          imageData2[(x + width * y) * 4 + 3] = 255;
        }
      }
      return imageData2;
    }
    function tgaGetImageDataGrey16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
      let i2 = 0, x, y;
      const width = header.width;
      for (y = y_start; y !== y_end; y += y_step) {
        for (x = x_start; x !== x_end; x += x_step, i2 += 2) {
          imageData2[(x + width * y) * 4 + 0] = image[i2 + 0];
          imageData2[(x + width * y) * 4 + 1] = image[i2 + 0];
          imageData2[(x + width * y) * 4 + 2] = image[i2 + 0];
          imageData2[(x + width * y) * 4 + 3] = image[i2 + 1];
        }
      }
      return imageData2;
    }
    function getTgaRGBA(data, width, height, image, palette) {
      let x_start, y_start, x_step, y_step, x_end, y_end;
      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {
        default:
        case TGA_ORIGIN_UL:
          x_start = 0;
          x_step = 1;
          x_end = width;
          y_start = 0;
          y_step = 1;
          y_end = height;
          break;
        case TGA_ORIGIN_BL:
          x_start = 0;
          x_step = 1;
          x_end = width;
          y_start = height - 1;
          y_step = -1;
          y_end = -1;
          break;
        case TGA_ORIGIN_UR:
          x_start = width - 1;
          x_step = -1;
          x_end = -1;
          y_start = 0;
          y_step = 1;
          y_end = height;
          break;
        case TGA_ORIGIN_BR:
          x_start = width - 1;
          x_step = -1;
          x_end = -1;
          y_start = height - 1;
          y_step = -1;
          y_end = -1;
          break;
      }
      if (use_grey) {
        switch (header.pixel_size) {
          case 8:
            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;
          case 16:
            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;
          default:
            console.error("THREE.TGALoader: Format not supported.");
            break;
        }
      } else {
        switch (header.pixel_size) {
          case 8:
            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);
            break;
          case 16:
            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;
          case 24:
            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;
          case 32:
            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;
          default:
            console.error("THREE.TGALoader: Format not supported.");
            break;
        }
      }
      return data;
    }
    const TGA_TYPE_NO_DATA = 0, TGA_TYPE_INDEXED = 1, TGA_TYPE_RGB = 2, TGA_TYPE_GREY = 3, TGA_TYPE_RLE_INDEXED = 9, TGA_TYPE_RLE_RGB = 10, TGA_TYPE_RLE_GREY = 11, TGA_ORIGIN_MASK = 48, TGA_ORIGIN_SHIFT = 4, TGA_ORIGIN_BL = 0, TGA_ORIGIN_BR = 1, TGA_ORIGIN_UL = 2, TGA_ORIGIN_UR = 3;
    if (buffer2.length < 19)
      console.error("THREE.TGALoader: Not enough data to contain header.");
    let offset = 0;
    const content = new Uint8Array(buffer2), header = {
      id_length: content[offset++],
      colormap_type: content[offset++],
      image_type: content[offset++],
      colormap_index: content[offset++] | content[offset++] << 8,
      colormap_length: content[offset++] | content[offset++] << 8,
      colormap_size: content[offset++],
      origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],
      width: content[offset++] | content[offset++] << 8,
      height: content[offset++] | content[offset++] << 8,
      pixel_size: content[offset++],
      flags: content[offset++]
    };
    tgaCheckHeader(header);
    if (header.id_length + offset > buffer2.length) {
      console.error("THREE.TGALoader: No data.");
    }
    offset += header.id_length;
    let use_rle = false, use_pal = false, use_grey = false;
    switch (header.image_type) {
      case TGA_TYPE_RLE_INDEXED:
        use_rle = true;
        use_pal = true;
        break;
      case TGA_TYPE_INDEXED:
        use_pal = true;
        break;
      case TGA_TYPE_RLE_RGB:
        use_rle = true;
        break;
      case TGA_TYPE_RGB:
        break;
      case TGA_TYPE_RLE_GREY:
        use_rle = true;
        use_grey = true;
        break;
      case TGA_TYPE_GREY:
        use_grey = true;
        break;
    }
    const imageData = new Uint8Array(header.width * header.height * 4);
    const result = tgaParse(use_rle, use_pal, header, offset, content);
    getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);
    return {
      data: imageData,
      width: header.width,
      height: header.height,
      flipY: true,
      generateMipmaps: true,
      minFilter: LinearMipmapLinearFilter
    };
  }
};

// node_modules/three-stdlib/loaders/LUTCubeLoader.js
var LUTCubeLoader = class extends Loader {
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("text");
    loader.load(url, (text) => {
      try {
        onLoad(this.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        this.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(str) {
    str = str.replace(/^#.*?(\n|\r)/gm, "").replace(/^\s*?(\n|\r)/gm, "").trim();
    let title = null;
    let size2 = null;
    const domainMin = new Vector3(0, 0, 0);
    const domainMax = new Vector3(1, 1, 1);
    const lines = str.split(/[\n\r]+/g);
    let data = null;
    let currIndex = 0;
    for (let i2 = 0, l = lines.length; i2 < l; i2++) {
      const line2 = lines[i2].trim();
      const split = line2.split(/\s/g);
      switch (split[0]) {
        case "TITLE":
          title = line2.substring(7, line2.length - 1);
          break;
        case "LUT_3D_SIZE":
          const sizeToken = split[1];
          size2 = parseFloat(sizeToken);
          data = new Uint8Array(size2 * size2 * size2 * 4);
          break;
        case "DOMAIN_MIN":
          domainMin.x = parseFloat(split[1]);
          domainMin.y = parseFloat(split[2]);
          domainMin.z = parseFloat(split[3]);
          break;
        case "DOMAIN_MAX":
          domainMax.x = parseFloat(split[1]);
          domainMax.y = parseFloat(split[2]);
          domainMax.z = parseFloat(split[3]);
          break;
        default:
          const r = parseFloat(split[0]);
          const g2 = parseFloat(split[1]);
          const b3 = parseFloat(split[2]);
          if (r > 1 || r < 0 || g2 > 1 || g2 < 0 || b3 > 1 || b3 < 0) {
            throw new Error("LUTCubeLoader : Non normalized values not supported.");
          }
          data[currIndex + 0] = r * 255;
          data[currIndex + 1] = g2 * 255;
          data[currIndex + 2] = b3 * 255;
          data[currIndex + 3] = 255;
          currIndex += 4;
      }
    }
    const texture2 = new DataTexture();
    texture2.image.data = data;
    texture2.image.width = size2;
    texture2.image.height = size2 * size2;
    texture2.type = UnsignedByteType;
    texture2.magFilter = LinearFilter;
    texture2.minFilter = LinearFilter;
    texture2.wrapS = ClampToEdgeWrapping;
    texture2.wrapT = ClampToEdgeWrapping;
    texture2.generateMipmaps = false;
    const texture3D = new DataTexture3D();
    texture3D.image.data = data;
    texture3D.image.width = size2;
    texture3D.image.height = size2;
    texture3D.image.depth = size2;
    texture3D.type = UnsignedByteType;
    texture3D.magFilter = LinearFilter;
    texture3D.minFilter = LinearFilter;
    texture3D.wrapS = ClampToEdgeWrapping;
    texture3D.wrapT = ClampToEdgeWrapping;
    texture3D.wrapR = ClampToEdgeWrapping;
    texture3D.generateMipmaps = false;
    return {
      title,
      size: size2,
      domainMin,
      domainMax,
      texture: texture2,
      texture3D
    };
  }
};

// node_modules/three-stdlib/loaders/NRRDLoader.js
var NRRDLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(data) {
      try {
        onLoad(scope2.parse(data));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(data) {
    let _data = data;
    let _dataPointer = 0;
    const _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0;
    const _littleEndian = true;
    const headerObject = {};
    function scan(type2, chunks) {
      if (chunks === void 0 || chunks === null) {
        chunks = 1;
      }
      let _chunkSize = 1;
      let _array_type = Uint8Array;
      switch (type2) {
        case "uchar":
          break;
        case "schar":
          _array_type = Int8Array;
          break;
        case "ushort":
          _array_type = Uint16Array;
          _chunkSize = 2;
          break;
        case "sshort":
          _array_type = Int16Array;
          _chunkSize = 2;
          break;
        case "uint":
          _array_type = Uint32Array;
          _chunkSize = 4;
          break;
        case "sint":
          _array_type = Int32Array;
          _chunkSize = 4;
          break;
        case "float":
          _array_type = Float32Array;
          _chunkSize = 4;
          break;
        case "complex":
          _array_type = Float64Array;
          _chunkSize = 8;
          break;
        case "double":
          _array_type = Float64Array;
          _chunkSize = 8;
          break;
      }
      let _bytes2 = new _array_type(_data.slice(_dataPointer, _dataPointer += chunks * _chunkSize));
      if (_nativeLittleEndian != _littleEndian) {
        _bytes2 = flipEndianness(_bytes2, _chunkSize);
      }
      if (chunks == 1) {
        return _bytes2[0];
      }
      return _bytes2;
    }
    function flipEndianness(array, chunkSize) {
      const u82 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
      for (let i3 = 0; i3 < array.byteLength; i3 += chunkSize) {
        for (let j2 = i3 + chunkSize - 1, k = i3; j2 > k; j2--, k++) {
          const tmp = u82[k];
          u82[k] = u82[j2];
          u82[j2] = tmp;
        }
      }
      return array;
    }
    function parseHeader(header) {
      let data2, field, fn, i3, l, m, _i, _len;
      const lines = header.split(/\r?\n/);
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        l = lines[_i];
        if (l.match(/NRRD\d+/)) {
          headerObject.isNrrd = true;
        } else if (l.match(/^#/))
          ;
        else if (m = l.match(/(.*):(.*)/)) {
          field = m[1].trim();
          data2 = m[2].trim();
          fn = _fieldFunctions[field];
          if (fn) {
            fn.call(headerObject, data2);
          } else {
            headerObject[field] = data2;
          }
        }
      }
      if (!headerObject.isNrrd) {
        throw new Error("Not an NRRD file");
      }
      if (headerObject.encoding === "bz2" || headerObject.encoding === "bzip2") {
        throw new Error("Bzip is not supported");
      }
      if (!headerObject.vectors) {
        headerObject.vectors = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)];
        if (headerObject.spacings) {
          for (i3 = 0; i3 <= 2; i3++) {
            if (!isNaN(headerObject.spacings[i3])) {
              headerObject.vectors[i3].multiplyScalar(headerObject.spacings[i3]);
            }
          }
        }
      }
    }
    function parseDataAsText(data2, start, end) {
      let number = "";
      start = start || 0;
      end = end || data2.length;
      let value;
      const lengthOfTheResult = headerObject.sizes.reduce(function(previous, current) {
        return previous * current;
      }, 1);
      let base = 10;
      if (headerObject.encoding === "hex") {
        base = 16;
      }
      const result = new headerObject.__array(lengthOfTheResult);
      let resultIndex = 0;
      let parsingFunction = parseInt;
      if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {
        parsingFunction = parseFloat;
      }
      for (let i3 = start; i3 < end; i3++) {
        value = data2[i3];
        if ((value < 9 || value > 13) && value !== 32) {
          number += String.fromCharCode(value);
        } else {
          if (number !== "") {
            result[resultIndex] = parsingFunction(number, base);
            resultIndex++;
          }
          number = "";
        }
      }
      if (number !== "") {
        result[resultIndex] = parsingFunction(number, base);
        resultIndex++;
      }
      return result;
    }
    const _bytes = scan("uchar", data.byteLength);
    const _length = _bytes.length;
    let _header = null;
    let _data_start = 0;
    let i2;
    for (i2 = 1; i2 < _length; i2++) {
      if (_bytes[i2 - 1] == 10 && _bytes[i2] == 10) {
        _header = this.parseChars(_bytes, 0, i2 - 2);
        _data_start = i2 + 1;
        break;
      }
    }
    parseHeader(_header);
    _data = _bytes.subarray(_data_start);
    if (headerObject.encoding.substring(0, 2) === "gz") {
      _data = gunzipSync(new Uint8Array(_data));
    } else if (headerObject.encoding === "ascii" || headerObject.encoding === "text" || headerObject.encoding === "txt" || headerObject.encoding === "hex") {
      _data = parseDataAsText(_data);
    } else if (headerObject.encoding === "raw") {
      const _copy = new Uint8Array(_data.length);
      for (let i3 = 0; i3 < _data.length; i3++) {
        _copy[i3] = _data[i3];
      }
      _data = _copy;
    }
    _data = _data.buffer;
    const volume = new Volume();
    volume.header = headerObject;
    volume.data = new headerObject.__array(_data);
    const min_max = volume.computeMinMax();
    const min2 = min_max[0];
    const max3 = min_max[1];
    volume.windowLow = min2;
    volume.windowHigh = max3;
    volume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]];
    volume.xLength = volume.dimensions[0];
    volume.yLength = volume.dimensions[1];
    volume.zLength = volume.dimensions[2];
    const spacingX = new Vector3(headerObject.vectors[0][0], headerObject.vectors[0][1], headerObject.vectors[0][2]).length();
    const spacingY = new Vector3(headerObject.vectors[1][0], headerObject.vectors[1][1], headerObject.vectors[1][2]).length();
    const spacingZ = new Vector3(headerObject.vectors[2][0], headerObject.vectors[2][1], headerObject.vectors[2][2]).length();
    volume.spacing = [spacingX, spacingY, spacingZ];
    volume.matrix = new Matrix4();
    let _spaceX = 1;
    let _spaceY = 1;
    const _spaceZ = 1;
    if (headerObject.space == "left-posterior-superior") {
      _spaceX = -1;
      _spaceY = -1;
    } else if (headerObject.space === "left-anterior-superior") {
      _spaceX = -1;
    }
    if (!headerObject.vectors) {
      volume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1);
    } else {
      const v = headerObject.vectors;
      volume.matrix.set(_spaceX * v[0][0], _spaceX * v[1][0], _spaceX * v[2][0], 0, _spaceY * v[0][1], _spaceY * v[1][1], _spaceY * v[2][1], 0, _spaceZ * v[0][2], _spaceZ * v[1][2], _spaceZ * v[2][2], 0, 0, 0, 0, 1);
    }
    volume.inverseMatrix = new Matrix4();
    volume.inverseMatrix.copy(volume.matrix).invert();
    volume.RASDimensions = new Vector3(volume.xLength, volume.yLength, volume.zLength).applyMatrix4(volume.matrix).round().toArray().map(Math.abs);
    if (volume.lowerThreshold === -Infinity) {
      volume.lowerThreshold = min2;
    }
    if (volume.upperThreshold === Infinity) {
      volume.upperThreshold = max3;
    }
    return volume;
  }
  parseChars(array, start, end) {
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = array.length;
    }
    let output = "";
    let i2 = 0;
    for (i2 = start; i2 < end; ++i2) {
      output += String.fromCharCode(array[i2]);
    }
    return output;
  }
};
var _fieldFunctions = {
  type: function(data) {
    switch (data) {
      case "uchar":
      case "unsigned char":
      case "uint8":
      case "uint8_t":
        this.__array = Uint8Array;
        break;
      case "signed char":
      case "int8":
      case "int8_t":
        this.__array = Int8Array;
        break;
      case "short":
      case "short int":
      case "signed short":
      case "signed short int":
      case "int16":
      case "int16_t":
        this.__array = Int16Array;
        break;
      case "ushort":
      case "unsigned short":
      case "unsigned short int":
      case "uint16":
      case "uint16_t":
        this.__array = Uint16Array;
        break;
      case "int":
      case "signed int":
      case "int32":
      case "int32_t":
        this.__array = Int32Array;
        break;
      case "uint":
      case "unsigned int":
      case "uint32":
      case "uint32_t":
        this.__array = Uint32Array;
        break;
      case "float":
        this.__array = Float32Array;
        break;
      case "double":
        this.__array = Float64Array;
        break;
      default:
        throw new Error("Unsupported NRRD data type: " + data);
    }
    return this.type = data;
  },
  endian: function(data) {
    return this.endian = data;
  },
  encoding: function(data) {
    return this.encoding = data;
  },
  dimension: function(data) {
    return this.dim = parseInt(data, 10);
  },
  sizes: function(data) {
    let i2;
    return this.sizes = function() {
      const _ref = data.split(/\s+/);
      const _results = [];
      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {
        i2 = _ref[_i];
        _results.push(parseInt(i2, 10));
      }
      return _results;
    }();
  },
  space: function(data) {
    return this.space = data;
  },
  "space origin": function(data) {
    return this.space_origin = data.split("(")[1].split(")")[0].split(",");
  },
  "space directions": function(data) {
    let f, v;
    const parts = data.match(/\(.*?\)/g);
    return this.vectors = function() {
      const _results = [];
      for (let _i = 0, _len = parts.length; _i < _len; _i++) {
        v = parts[_i];
        _results.push(function() {
          const _ref = v.slice(1, -1).split(/,/);
          const _results2 = [];
          for (let _j = 0, _len2 = _ref.length; _j < _len2; _j++) {
            f = _ref[_j];
            _results2.push(parseFloat(f));
          }
          return _results2;
        }());
      }
      return _results;
    }();
  },
  spacings: function(data) {
    let f;
    const parts = data.split(/\s+/);
    return this.spacings = function() {
      const _results = [];
      for (let _i = 0, _len = parts.length; _i < _len; _i++) {
        f = parts[_i];
        _results.push(parseFloat(f));
      }
      return _results;
    }();
  }
};

// node_modules/three-stdlib/loaders/STLLoader.js
var STLLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope2.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(data) {
    function isBinary(data2) {
      const reader = new DataView(data2);
      const face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
      const n_faces = reader.getUint32(80, true);
      const expect = 80 + 32 / 8 + n_faces * face_size;
      if (expect === reader.byteLength) {
        return true;
      }
      const solid = [115, 111, 108, 105, 100];
      for (let off = 0; off < 5; off++) {
        if (matchDataViewAt(solid, reader, off))
          return false;
      }
      return true;
    }
    function matchDataViewAt(query, reader, offset) {
      for (let i2 = 0, il = query.length; i2 < il; i2++) {
        if (query[i2] !== reader.getUint8(offset + i2, false))
          return false;
      }
      return true;
    }
    function parseBinary(data2) {
      const reader = new DataView(data2);
      const faces = reader.getUint32(80, true);
      let r, g2, b3, hasColors = false, colors;
      let defaultR, defaultG, defaultB, alpha;
      for (let index = 0; index < 80 - 10; index++) {
        if (reader.getUint32(index, false) == 1129270351 && reader.getUint8(index + 4) == 82 && reader.getUint8(index + 5) == 61) {
          hasColors = true;
          colors = new Float32Array(faces * 3 * 3);
          defaultR = reader.getUint8(index + 6) / 255;
          defaultG = reader.getUint8(index + 7) / 255;
          defaultB = reader.getUint8(index + 8) / 255;
          alpha = reader.getUint8(index + 9) / 255;
        }
      }
      const dataOffset = 84;
      const faceLength = 12 * 4 + 2;
      const geometry = new BufferGeometry();
      const vertices = new Float32Array(faces * 3 * 3);
      const normals = new Float32Array(faces * 3 * 3);
      for (let face = 0; face < faces; face++) {
        const start = dataOffset + face * faceLength;
        const normalX = reader.getFloat32(start, true);
        const normalY = reader.getFloat32(start + 4, true);
        const normalZ = reader.getFloat32(start + 8, true);
        if (hasColors) {
          const packedColor = reader.getUint16(start + 48, true);
          if ((packedColor & 32768) === 0) {
            r = (packedColor & 31) / 31;
            g2 = (packedColor >> 5 & 31) / 31;
            b3 = (packedColor >> 10 & 31) / 31;
          } else {
            r = defaultR;
            g2 = defaultG;
            b3 = defaultB;
          }
        }
        for (let i2 = 1; i2 <= 3; i2++) {
          const vertexstart = start + i2 * 12;
          const componentIdx = face * 3 * 3 + (i2 - 1) * 3;
          vertices[componentIdx] = reader.getFloat32(vertexstart, true);
          vertices[componentIdx + 1] = reader.getFloat32(vertexstart + 4, true);
          vertices[componentIdx + 2] = reader.getFloat32(vertexstart + 8, true);
          normals[componentIdx] = normalX;
          normals[componentIdx + 1] = normalY;
          normals[componentIdx + 2] = normalZ;
          if (hasColors) {
            colors[componentIdx] = r;
            colors[componentIdx + 1] = g2;
            colors[componentIdx + 2] = b3;
          }
        }
      }
      geometry.setAttribute("position", new BufferAttribute(vertices, 3));
      geometry.setAttribute("normal", new BufferAttribute(normals, 3));
      if (hasColors) {
        geometry.setAttribute("color", new BufferAttribute(colors, 3));
        geometry.hasColors = true;
        geometry.alpha = alpha;
      }
      return geometry;
    }
    function parseASCII(data2) {
      const geometry = new BufferGeometry();
      const patternSolid = /solid([\s\S]*?)endsolid/g;
      const patternFace = /facet([\s\S]*?)endfacet/g;
      let faceCounter = 0;
      const patternFloat = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source;
      const patternVertex = new RegExp("vertex" + patternFloat + patternFloat + patternFloat, "g");
      const patternNormal = new RegExp("normal" + patternFloat + patternFloat + patternFloat, "g");
      const vertices = [];
      const normals = [];
      const normal = new Vector3();
      let result;
      let groupCount = 0;
      let startVertex = 0;
      let endVertex = 0;
      while ((result = patternSolid.exec(data2)) !== null) {
        startVertex = endVertex;
        const solid = result[0];
        while ((result = patternFace.exec(solid)) !== null) {
          let vertexCountPerFace = 0;
          let normalCountPerFace = 0;
          const text = result[0];
          while ((result = patternNormal.exec(text)) !== null) {
            normal.x = parseFloat(result[1]);
            normal.y = parseFloat(result[2]);
            normal.z = parseFloat(result[3]);
            normalCountPerFace++;
          }
          while ((result = patternVertex.exec(text)) !== null) {
            vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
            normals.push(normal.x, normal.y, normal.z);
            vertexCountPerFace++;
            endVertex++;
          }
          if (normalCountPerFace !== 1) {
            console.error("THREE.STLLoader: Something isn't right with the normal of face number " + faceCounter);
          }
          if (vertexCountPerFace !== 3) {
            console.error("THREE.STLLoader: Something isn't right with the vertices of face number " + faceCounter);
          }
          faceCounter++;
        }
        const start = startVertex;
        const count = endVertex - startVertex;
        geometry.addGroup(start, count, groupCount);
        groupCount++;
      }
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      return geometry;
    }
    function ensureString(buffer2) {
      if (typeof buffer2 !== "string") {
        return LoaderUtils.decodeText(new Uint8Array(buffer2));
      }
      return buffer2;
    }
    function ensureBinary(buffer2) {
      if (typeof buffer2 === "string") {
        const array_buffer = new Uint8Array(buffer2.length);
        for (let i2 = 0; i2 < buffer2.length; i2++) {
          array_buffer[i2] = buffer2.charCodeAt(i2) & 255;
        }
        return array_buffer.buffer || array_buffer;
      } else {
        return buffer2;
      }
    }
    const binData = ensureBinary(data);
    return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data));
  }
};

// node_modules/three-stdlib/loaders/MTLLoader.js
var MTLLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope2.parse(text, path));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  setMaterialOptions(value) {
    this.materialOptions = value;
    return this;
  }
  parse(text, path) {
    const lines = text.split("\n");
    let info = {};
    const delimiter_pattern = /\s+/;
    const materialsInfo = {};
    for (let i2 = 0; i2 < lines.length; i2++) {
      let line2 = lines[i2];
      line2 = line2.trim();
      if (line2.length === 0 || line2.charAt(0) === "#") {
        continue;
      }
      const pos = line2.indexOf(" ");
      let key = pos >= 0 ? line2.substring(0, pos) : line2;
      key = key.toLowerCase();
      let value = pos >= 0 ? line2.substring(pos + 1) : "";
      value = value.trim();
      if (key === "newmtl") {
        info = {
          name: value
        };
        materialsInfo[value] = info;
      } else {
        if (key === "ka" || key === "kd" || key === "ks" || key === "ke") {
          const ss = value.split(delimiter_pattern, 3);
          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];
        } else {
          info[key] = value;
        }
      }
    }
    const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);
    materialCreator.setCrossOrigin(this.crossOrigin);
    materialCreator.setManager(this.manager);
    materialCreator.setMaterials(materialsInfo);
    return materialCreator;
  }
};
var MaterialCreator = class {
  constructor(baseUrl = "", options = {}) {
    this.baseUrl = baseUrl;
    this.options = options;
    this.materialsInfo = {};
    this.materials = {};
    this.materialsArray = [];
    this.nameLookup = {};
    this.crossOrigin = "anonymous";
    this.side = this.options.side !== void 0 ? this.options.side : FrontSide;
    this.wrap = this.options.wrap !== void 0 ? this.options.wrap : RepeatWrapping;
  }
  setCrossOrigin(value) {
    this.crossOrigin = value;
    return this;
  }
  setManager(value) {
    this.manager = value;
  }
  setMaterials(materialsInfo) {
    this.materialsInfo = this.convert(materialsInfo);
    this.materials = {};
    this.materialsArray = [];
    this.nameLookup = {};
  }
  convert(materialsInfo) {
    if (!this.options)
      return materialsInfo;
    const converted = {};
    for (const mn in materialsInfo) {
      const mat = materialsInfo[mn];
      const covmat = {};
      converted[mn] = covmat;
      for (const prop in mat) {
        let save = true;
        let value = mat[prop];
        const lprop = prop.toLowerCase();
        switch (lprop) {
          case "kd":
          case "ka":
          case "ks":
            if (this.options && this.options.normalizeRGB) {
              value = [value[0] / 255, value[1] / 255, value[2] / 255];
            }
            if (this.options && this.options.ignoreZeroRGBs) {
              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {
                save = false;
              }
            }
            break;
        }
        if (save) {
          covmat[lprop] = value;
        }
      }
    }
    return converted;
  }
  preload() {
    for (const mn in this.materialsInfo) {
      this.create(mn);
    }
  }
  getIndex(materialName) {
    return this.nameLookup[materialName];
  }
  getAsArray() {
    let index = 0;
    for (const mn in this.materialsInfo) {
      this.materialsArray[index] = this.create(mn);
      this.nameLookup[mn] = index;
      index++;
    }
    return this.materialsArray;
  }
  create(materialName) {
    if (this.materials[materialName] === void 0) {
      this.createMaterial_(materialName);
    }
    return this.materials[materialName];
  }
  createMaterial_(materialName) {
    const scope2 = this;
    const mat = this.materialsInfo[materialName];
    const params = {
      name: materialName,
      side: this.side
    };
    function resolveURL(baseUrl, url) {
      if (typeof url !== "string" || url === "")
        return "";
      if (/^https?:\/\//i.test(url))
        return url;
      return baseUrl + url;
    }
    function setMapForType(mapType, value) {
      if (params[mapType])
        return;
      const texParams = scope2.getTextureParams(value, params);
      const map = scope2.loadTexture(resolveURL(scope2.baseUrl, texParams.url));
      map.repeat.copy(texParams.scale);
      map.offset.copy(texParams.offset);
      map.wrapS = scope2.wrap;
      map.wrapT = scope2.wrap;
      params[mapType] = map;
    }
    for (const prop in mat) {
      const value = mat[prop];
      let n;
      if (value === "")
        continue;
      switch (prop.toLowerCase()) {
        case "kd":
          params.color = new Color().fromArray(value);
          break;
        case "ks":
          params.specular = new Color().fromArray(value);
          break;
        case "ke":
          params.emissive = new Color().fromArray(value);
          break;
        case "map_kd":
          setMapForType("map", value);
          break;
        case "map_ks":
          setMapForType("specularMap", value);
          break;
        case "map_ke":
          setMapForType("emissiveMap", value);
          break;
        case "norm":
          setMapForType("normalMap", value);
          break;
        case "map_bump":
        case "bump":
          setMapForType("bumpMap", value);
          break;
        case "map_d":
          setMapForType("alphaMap", value);
          params.transparent = true;
          break;
        case "ns":
          params.shininess = parseFloat(value);
          break;
        case "d":
          n = parseFloat(value);
          if (n < 1) {
            params.opacity = n;
            params.transparent = true;
          }
          break;
        case "tr":
          n = parseFloat(value);
          if (this.options && this.options.invertTrProperty)
            n = 1 - n;
          if (n > 0) {
            params.opacity = 1 - n;
            params.transparent = true;
          }
          break;
      }
    }
    this.materials[materialName] = new MeshPhongMaterial(params);
    return this.materials[materialName];
  }
  getTextureParams(value, matParams) {
    const texParams = {
      scale: new Vector2(1, 1),
      offset: new Vector2(0, 0)
    };
    const items = value.split(/\s+/);
    let pos;
    pos = items.indexOf("-bm");
    if (pos >= 0) {
      matParams.bumpScale = parseFloat(items[pos + 1]);
      items.splice(pos, 2);
    }
    pos = items.indexOf("-s");
    if (pos >= 0) {
      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
      items.splice(pos, 4);
    }
    pos = items.indexOf("-o");
    if (pos >= 0) {
      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
      items.splice(pos, 4);
    }
    texParams.url = items.join(" ").trim();
    return texParams;
  }
  loadTexture(url, mapping, onLoad, onProgress, onError) {
    const manager = this.manager !== void 0 ? this.manager : DefaultLoadingManager;
    let loader = manager.getHandler(url);
    if (loader === null) {
      loader = new TextureLoader(manager);
    }
    if (loader.setCrossOrigin)
      loader.setCrossOrigin(this.crossOrigin);
    const texture2 = loader.load(url, onLoad, onProgress, onError);
    if (mapping !== void 0)
      texture2.mapping = mapping;
    return texture2;
  }
};

// node_modules/three-stdlib/loaders/XLoader.js
var XLoader = function() {
  var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = function() {
    function defineProperties(target, props) {
      for (let i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var XboneInf = function XboneInf2() {
    classCallCheck(this, XboneInf2);
    this.boneName = "";
    this.BoneIndex = 0;
    this.Indeces = [];
    this.Weights = [];
    this.initMatrix = null;
    this.OffsetMatrix = null;
  };
  var XAnimationInfo = function XAnimationInfo2() {
    classCallCheck(this, XAnimationInfo2);
    this.animeName = "";
    this.boneName = "";
    this.targetBone = null;
    this.keyType = 4;
    this.frameStartLv = 0;
    this.keyFrames = [];
    this.InverseMx = null;
  };
  var XAnimationObj = function() {
    function XAnimationObj2(_flags) {
      classCallCheck(this, XAnimationObj2);
      this.fps = 30;
      this.name = "xanimation";
      this.length = 0;
      this.hierarchy = [];
      this.putFlags = _flags;
      if (this.putFlags.putPos === void 0) {
        this.putFlags.putPos = true;
      }
      if (this.putFlags.putRot === void 0) {
        this.putFlags.putRot = true;
      }
      if (this.putFlags.putScl === void 0) {
        this.putFlags.putScl = true;
      }
    }
    createClass(XAnimationObj2, [{
      key: "make",
      value: function make(XAnimationInfoArray) {
        for (let i2 = 0; i2 < XAnimationInfoArray.length; i2++) {
          this.hierarchy.push(this.makeBonekeys(XAnimationInfoArray[i2]));
        }
        this.length = this.hierarchy[0].keys[this.hierarchy[0].keys.length - 1].time;
      }
    }, {
      key: "clone",
      value: function clone() {
        return Object.assign({}, this);
      }
    }, {
      key: "makeBonekeys",
      value: function makeBonekeys(XAnimationInfo2) {
        var refObj = {};
        refObj.name = XAnimationInfo2.boneName;
        refObj.parent = "";
        refObj.keys = this.keyFrameRefactor(XAnimationInfo2);
        refObj.copy = function() {
          return Object.assign({}, this);
        };
        return refObj;
      }
    }, {
      key: "keyFrameRefactor",
      value: function keyFrameRefactor(XAnimationInfo2) {
        var keys = [];
        for (let i2 = 0; i2 < XAnimationInfo2.keyFrames.length; i2++) {
          var keyframe = {};
          keyframe.time = XAnimationInfo2.keyFrames[i2].time * this.fps;
          if (XAnimationInfo2.keyFrames[i2].pos && this.putFlags.putPos) {
            keyframe.pos = XAnimationInfo2.keyFrames[i2].pos;
          }
          if (XAnimationInfo2.keyFrames[i2].rot && this.putFlags.putRot) {
            keyframe.rot = XAnimationInfo2.keyFrames[i2].rot;
          }
          if (XAnimationInfo2.keyFrames[i2].scl && this.putFlags.putScl) {
            keyframe.scl = XAnimationInfo2.keyFrames[i2].scl;
          }
          if (XAnimationInfo2.keyFrames[i2].matrix) {
            keyframe.matrix = XAnimationInfo2.keyFrames[i2].matrix;
            if (this.putFlags.putPos) {
              keyframe.pos = new Vector3().setFromMatrixPosition(keyframe.matrix);
            }
            if (this.putFlags.putRot) {
              keyframe.rot = new Quaternion().setFromRotationMatrix(keyframe.matrix);
            }
            if (this.putFlags.putScl) {
              keyframe.scl = new Vector3().setFromMatrixScale(keyframe.matrix);
            }
          }
          keys.push(keyframe);
        }
        return keys;
      }
    }]);
    return XAnimationObj2;
  }();
  var XKeyFrameInfo = function XKeyFrameInfo2() {
    classCallCheck(this, XKeyFrameInfo2);
    this.index = 0;
    this.Frame = 0;
    this.time = 0;
    this.matrix = null;
  };
  var XLoader2 = function() {
    function XLoader3(manager) {
      Loader.call(this, manager);
      classCallCheck(this, XLoader3);
      this.debug = false;
      this.texloader = new TextureLoader(this.manager);
      this.url = "";
      this._putMatLength = 0;
      this._nowMat = null;
      this._nowFrameName = "";
      this.frameHierarchie = [];
      this.Hierarchies = {};
      this.HieStack = [];
      this._currentObject = {};
      this._currentFrame = {};
      this._data = null;
      this.onLoad = null;
      this.IsUvYReverse = true;
      this.Meshes = [];
      this.animations = [];
      this.animTicksPerSecond = 30;
      this._currentGeo = null;
      this._currentAnime = null;
      this._currentAnimeFrames = null;
    }
    createClass(XLoader3, [{
      key: "_setArgOption",
      value: function _setArgOption(_arg) {
        var _start3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        if (!_arg) {
          return;
        }
        for (let i2 = _start3; i2 < _arg.length; i2++) {
          switch (i2) {
            case 0:
              this.url = _arg[i2];
              break;
            case 1:
              this.options = _arg[i2];
              break;
          }
        }
        if (this.options === void 0) {
          this.options = {};
        }
      }
    }, {
      key: "load",
      value: function load2(_arg, onLoad, onProgress, onError) {
        var _this = this;
        this._setArgOption(_arg);
        var loader = new FileLoader2(this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(this.url, function(response) {
          try {
            _this.parse(response, onLoad);
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            _this.manager.itemError(_this.url);
          }
        }, onProgress, onError);
      }
    }, {
      key: "_readLine",
      value: function _readLine(line2) {
        var readed = 0;
        while (true) {
          var find = -1;
          find = line2.indexOf("//", readed);
          if (find === -1) {
            find = line2.indexOf("#", readed);
          }
          if (find > -1 && find < 2) {
            var foundNewLine = -1;
            foundNewLine = line2.indexOf("\r\n", readed);
            if (foundNewLine > 0) {
              readed = foundNewLine + 2;
            } else {
              foundNewLine = line2.indexOf("\r", readed);
              if (foundNewLine > 0) {
                readed = foundNewLine + 1;
              } else {
                readed = line2.indexOf("\n", readed) + 1;
              }
            }
          } else {
            break;
          }
        }
        return line2.substr(readed);
      }
    }, {
      key: "_readLine",
      value: function _readLine(line2) {
        var readed = 0;
        while (true) {
          var find = -1;
          find = line2.indexOf("//", readed);
          if (find === -1) {
            find = line2.indexOf("#", readed);
          }
          if (find > -1 && find < 2) {
            var foundNewLine = -1;
            foundNewLine = line2.indexOf("\r\n", readed);
            if (foundNewLine > 0) {
              readed = foundNewLine + 2;
            } else {
              foundNewLine = line2.indexOf("\r", readed);
              if (foundNewLine > 0) {
                readed = foundNewLine + 1;
              } else {
                readed = line2.indexOf("\n", readed) + 1;
              }
            }
          } else {
            break;
          }
        }
        return line2.substr(readed);
      }
    }, {
      key: "_isBinary",
      value: function _isBinary(binData) {
        var reader = new DataView(binData);
        var face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
        var n_faces = reader.getUint32(80, true);
        var expect = 80 + 32 / 8 + n_faces * face_size;
        if (expect === reader.byteLength) {
          return true;
        }
        var fileLength = reader.byteLength;
        for (let index = 0; index < fileLength; index++) {
          if (reader.getUint8(index, false) > 127) {
            return true;
          }
        }
        return false;
      }
    }, {
      key: "_ensureBinary",
      value: function _ensureBinary(buf) {
        if (typeof buf === "string") {
          var array_buffer = new Uint8Array(buf.length);
          for (let i2 = 0; i2 < buf.length; i2++) {
            array_buffer[i2] = buf.charCodeAt(i2) & 255;
          }
          return array_buffer.buffer || array_buffer;
        } else {
          return buf;
        }
      }
    }, {
      key: "_ensureString",
      value: function _ensureString(buf) {
        if (typeof buf !== "string") {
          return LoaderUtils.decodeText(new Uint8Array(buf));
        } else {
          return buf;
        }
      }
    }, {
      key: "parse",
      value: function _parse(data, onLoad) {
        var binData = this._ensureBinary(data);
        this._data = this._ensureString(data);
        this.onLoad = onLoad;
        return this._isBinary(binData) ? this._parseBinary(binData) : this._parseASCII();
      }
    }, {
      key: "_parseBinary",
      value: function _parseBinary(data) {
        return this._parseASCII(LoaderUtils.decodeText(new Uint8Array(data)));
      }
    }, {
      key: "_parseASCII",
      value: function _parseASCII() {
        var path;
        if (this.resourcePath !== "") {
          path = this.resourcePath;
        } else if (this.path !== "") {
          path = this.path;
        } else {
          path = LoaderUtils.extractUrlBase(this.url);
        }
        this.texloader.setPath(path).setCrossOrigin(this.crossOrigin);
        var endRead = 16;
        this.Hierarchies.children = [];
        this._hierarchieParse(this.Hierarchies, endRead);
        this._changeRoot();
        this._currentObject = this.Hierarchies.children.shift();
        this._mainloop();
      }
    }, {
      key: "_hierarchieParse",
      value: function _hierarchieParse(_parent, _end3) {
        var endRead = _end3;
        while (true) {
          var find1 = this._data.indexOf("{", endRead) + 1;
          var findEnd = this._data.indexOf("}", endRead);
          var findNext = this._data.indexOf("{", find1) + 1;
          if (find1 > 0 && findEnd > find1) {
            var _currentObject = {};
            _currentObject.children = [];
            var nameData = this._readLine(this._data.substr(endRead, find1 - endRead - 1)).trim();
            var word = nameData.split(/ /g);
            if (word.length > 0) {
              _currentObject.type = word[0];
              if (word.length >= 2) {
                _currentObject.name = word[1];
              } else {
                _currentObject.name = word[0] + this.Hierarchies.children.length;
              }
            } else {
              _currentObject.name = nameData;
              _currentObject.type = "";
            }
            if (_currentObject.type === "Animation") {
              _currentObject.data = this._data.substr(findNext, findEnd - findNext).trim();
              var refs = this._hierarchieParse(_currentObject, findEnd + 1);
              endRead = refs.end;
              _currentObject.children = refs.parent.children;
            } else {
              var DataEnder = this._data.lastIndexOf(";", findNext > 0 ? Math.min(findNext, findEnd) : findEnd);
              _currentObject.data = this._data.substr(find1, DataEnder - find1).trim();
              if (findNext <= 0 || findEnd < findNext) {
                endRead = findEnd + 1;
              } else {
                var nextStart = Math.max(DataEnder + 1, find1);
                var _refs = this._hierarchieParse(_currentObject, nextStart);
                endRead = _refs.end;
                _currentObject.children = _refs.parent.children;
              }
            }
            _currentObject.parent = _parent;
            if (_currentObject.type != "template") {
              _parent.children.push(_currentObject);
            }
          } else {
            endRead = find1 === -1 ? this._data.length : findEnd + 1;
            break;
          }
        }
        return {
          parent: _parent,
          end: endRead
        };
      }
    }, {
      key: "_mainloop",
      value: function _mainloop() {
        var _this2 = this;
        this._mainProc();
        if (this._currentObject.parent || this._currentObject.children.length > 0 || !this._currentObject.worked) {
          setTimeout(function() {
            _this2._mainloop();
          }, 1);
        } else {
          setTimeout(function() {
            _this2.onLoad({
              models: _this2.Meshes,
              animations: _this2.animations
            });
          }, 1);
        }
      }
    }, {
      key: "_mainProc",
      value: function _mainProc() {
        var breakFlag = false;
        while (true) {
          if (!this._currentObject.worked) {
            switch (this._currentObject.type) {
              case "template":
                break;
              case "AnimTicksPerSecond":
                this.animTicksPerSecond = parseInt(this._currentObject.data);
                break;
              case "Frame":
                this._setFrame();
                break;
              case "FrameTransformMatrix":
                this._setFrameTransformMatrix();
                break;
              case "Mesh":
                this._changeRoot();
                this._currentGeo = {};
                this._currentGeo.name = this._currentObject.name.trim();
                this._currentGeo.parentName = this._getParentName(this._currentObject).trim();
                this._currentGeo.VertexSetedBoneCount = [];
                this._currentGeo.GeometryData = {
                  vertices: [],
                  normals: [],
                  uvs: [],
                  skinIndices: [],
                  skinWeights: [],
                  indices: [],
                  materialIndices: []
                };
                this._currentGeo.Materials = [];
                this._currentGeo.normalVectors = [];
                this._currentGeo.BoneInfs = [];
                this._currentGeo.baseFrame = this._currentFrame;
                this._makeBoneFrom_CurrentFrame();
                this._readVertexDatas();
                breakFlag = true;
                break;
              case "MeshNormals":
                this._readVertexDatas();
                break;
              case "MeshTextureCoords":
                this._setMeshTextureCoords();
                break;
              case "VertexDuplicationIndices":
                break;
              case "MeshMaterialList":
                this._setMeshMaterialList();
                break;
              case "Material":
                this._setMaterial();
                break;
              case "SkinWeights":
                this._setSkinWeights();
                break;
              case "AnimationSet":
                this._changeRoot();
                this._currentAnime = {};
                this._currentAnime.name = this._currentObject.name.trim();
                this._currentAnime.AnimeFrames = [];
                break;
              case "Animation":
                if (this._currentAnimeFrames) {
                  this._currentAnime.AnimeFrames.push(this._currentAnimeFrames);
                }
                this._currentAnimeFrames = new XAnimationInfo();
                this._currentAnimeFrames.boneName = this._currentObject.data.trim();
                break;
              case "AnimationKey":
                this._readAnimationKey();
                breakFlag = true;
                break;
            }
            this._currentObject.worked = true;
          }
          if (this._currentObject.children.length > 0) {
            this._currentObject = this._currentObject.children.shift();
            if (this.debug) {
              console.log("processing " + this._currentObject.name);
            }
            if (breakFlag)
              break;
          } else {
            if (this._currentObject.worked) {
              if (this._currentObject.parent && !this._currentObject.parent.parent) {
                this._changeRoot();
              }
            }
            if (this._currentObject.parent) {
              this._currentObject = this._currentObject.parent;
            } else {
              breakFlag = true;
            }
            if (breakFlag)
              break;
          }
        }
        return;
      }
    }, {
      key: "_changeRoot",
      value: function _changeRoot() {
        if (this._currentGeo != null && this._currentGeo.name) {
          this._makeOutputGeometry();
        }
        this._currentGeo = {};
        if (this._currentAnime != null && this._currentAnime.name) {
          if (this._currentAnimeFrames) {
            this._currentAnime.AnimeFrames.push(this._currentAnimeFrames);
            this._currentAnimeFrames = null;
          }
          this._makeOutputAnimation();
        }
        this._currentAnime = {};
      }
    }, {
      key: "_getParentName",
      value: function _getParentName(_obj2) {
        if (_obj2.parent) {
          if (_obj2.parent.name) {
            return _obj2.parent.name;
          } else {
            return this._getParentName(_obj2.parent);
          }
        } else {
          return "";
        }
      }
    }, {
      key: "_setFrame",
      value: function _setFrame() {
        this._nowFrameName = this._currentObject.name.trim();
        this._currentFrame = {};
        this._currentFrame.name = this._nowFrameName;
        this._currentFrame.children = [];
        if (this._currentObject.parent && this._currentObject.parent.name) {
          this._currentFrame.parentName = this._currentObject.parent.name;
        }
        this.frameHierarchie.push(this._nowFrameName);
        this.HieStack[this._nowFrameName] = this._currentFrame;
      }
    }, {
      key: "_setFrameTransformMatrix",
      value: function _setFrameTransformMatrix() {
        this._currentFrame.FrameTransformMatrix = new Matrix4();
        var data = this._currentObject.data.split(",");
        this._ParseMatrixData(this._currentFrame.FrameTransformMatrix, data);
        this._makeBoneFrom_CurrentFrame();
      }
    }, {
      key: "_makeBoneFrom_CurrentFrame",
      value: function _makeBoneFrom_CurrentFrame() {
        if (!this._currentFrame.FrameTransformMatrix) {
          return;
        }
        var b3 = new Bone();
        b3.name = this._currentFrame.name;
        b3.applyMatrix4(this._currentFrame.FrameTransformMatrix);
        b3.matrixWorld = b3.matrix;
        b3.FrameTransformMatrix = this._currentFrame.FrameTransformMatrix;
        this._currentFrame.putBone = b3;
        if (this._currentFrame.parentName) {
          for (let frame in this.HieStack) {
            if (this.HieStack[frame].name === this._currentFrame.parentName) {
              this.HieStack[frame].putBone.add(this._currentFrame.putBone);
            }
          }
        }
      }
    }, {
      key: "_readVertexDatas",
      value: function _readVertexDatas() {
        var endRead = 0;
        var mode = 0;
        var mode_local = 0;
        var maxLength = 0;
        while (true) {
          var changeMode = false;
          if (mode_local === 0) {
            var refO = this._readInt1(endRead);
            endRead = refO.endRead;
            mode_local = 1;
            maxLength = this._currentObject.data.indexOf(";;", endRead) + 1;
            if (maxLength <= 0) {
              maxLength = this._currentObject.data.length;
            }
          } else {
            var find = 0;
            switch (mode) {
              case 0:
                find = this._currentObject.data.indexOf(",", endRead) + 1;
                break;
              case 1:
                find = this._currentObject.data.indexOf(";,", endRead) + 1;
                break;
            }
            if (find === 0 || find > maxLength) {
              find = maxLength;
              mode_local = 0;
              changeMode = true;
            }
            switch (this._currentObject.type) {
              case "Mesh":
                switch (mode) {
                  case 0:
                    this._readVertex1(this._currentObject.data.substr(endRead, find - endRead));
                    break;
                  case 1:
                    this._readFace1(this._currentObject.data.substr(endRead, find - endRead));
                    break;
                }
                break;
              case "MeshNormals":
                switch (mode) {
                  case 0:
                    this._readNormalVector1(this._currentObject.data.substr(endRead, find - endRead));
                    break;
                }
                break;
            }
            endRead = find + 1;
            if (changeMode) {
              mode++;
            }
          }
          if (endRead >= this._currentObject.data.length) {
            break;
          }
        }
      }
    }, {
      key: "_readInt1",
      value: function _readInt1(start) {
        var find = this._currentObject.data.indexOf(";", start);
        return {
          refI: parseInt(this._currentObject.data.substr(start, find - start)),
          endRead: find + 1
        };
      }
    }, {
      key: "_readVertex1",
      value: function _readVertex1(line2) {
        var data = this._readLine(line2.trim()).substr(0, line2.length - 2).split(";");
        this._currentGeo.GeometryData.vertices.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]));
        this._currentGeo.GeometryData.skinIndices.push(0, 0, 0, 0);
        this._currentGeo.GeometryData.skinWeights.push(1, 0, 0, 0);
        this._currentGeo.VertexSetedBoneCount.push(0);
      }
    }, {
      key: "_readFace1",
      value: function _readFace1(line2) {
        var data = this._readLine(line2.trim()).substr(2, line2.length - 4).split(",");
        this._currentGeo.GeometryData.indices.push(parseInt(data[0], 10), parseInt(data[1], 10), parseInt(data[2], 10));
      }
    }, {
      key: "_readNormalVector1",
      value: function _readNormalVector1(line2) {
        var data = this._readLine(line2.trim()).substr(0, line2.length - 2).split(";");
        this._currentGeo.GeometryData.normals.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]));
      }
    }, {
      key: "_buildGeometry",
      value: function _buildGeometry() {
        var bufferGeometry = new BufferGeometry();
        var position = [];
        var normals = [];
        var uvs = [];
        var skinIndices = [];
        var skinWeights = [];
        var data = this._currentGeo.GeometryData;
        for (let i2 = 0, l = data.indices.length; i2 < l; i2++) {
          var stride2 = data.indices[i2] * 2;
          var stride3 = data.indices[i2] * 3;
          var stride4 = data.indices[i2] * 4;
          position.push(data.vertices[stride3], data.vertices[stride3 + 1], data.vertices[stride3 + 2]);
          normals.push(data.normals[stride3], data.normals[stride3 + 1], data.normals[stride3 + 2]);
          skinIndices.push(data.skinIndices[stride4], data.skinIndices[stride4 + 1], data.skinIndices[stride4 + 2], data.skinIndices[stride4 + 3]);
          skinWeights.push(data.skinWeights[stride4], data.skinWeights[stride4 + 1], data.skinWeights[stride4 + 2], data.skinWeights[stride4 + 3]);
          uvs.push(data.uvs[stride2], data.uvs[stride2 + 1]);
        }
        bufferGeometry.setAttribute("position", new Float32BufferAttribute(position, 3));
        bufferGeometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        bufferGeometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        bufferGeometry.setAttribute("skinIndex", new Uint16BufferAttribute(skinIndices, 4));
        bufferGeometry.setAttribute("skinWeight", new Float32BufferAttribute(skinWeights, 4));
        this._computeGroups(bufferGeometry, data.materialIndices);
        return bufferGeometry;
      }
    }, {
      key: "_computeGroups",
      value: function _computeGroups(bufferGeometry, materialIndices) {
        var group;
        var groups = [];
        var materialIndex = void 0;
        for (let i2 = 0; i2 < materialIndices.length; i2++) {
          var currentMaterialIndex = materialIndices[i2];
          if (currentMaterialIndex !== materialIndex) {
            materialIndex = currentMaterialIndex;
            if (group !== void 0) {
              group.count = i2 * 3 - group.start;
              groups.push(group);
            }
            group = {
              start: i2 * 3,
              materialIndex
            };
          }
        }
        if (group !== void 0) {
          group.count = i * 3 - group.start;
          groups.push(group);
        }
        bufferGeometry.groups = groups;
      }
    }, {
      key: "_setMeshTextureCoords",
      value: function _setMeshTextureCoords() {
        var endRead = 0;
        var mode = 0;
        var mode_local = 0;
        while (true) {
          switch (mode) {
            case 0:
              if (mode_local === 0) {
                var refO = this._readInt1(0);
                endRead = refO.endRead;
                mode_local = 1;
              } else {
                var find = this._currentObject.data.indexOf(",", endRead) + 1;
                if (find === 0) {
                  find = this._currentObject.data.length;
                  mode = 2;
                  mode_local = 0;
                }
                var line2 = this._currentObject.data.substr(endRead, find - endRead);
                var data = this._readLine(line2.trim()).split(";");
                if (this.IsUvYReverse) {
                  this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), 1 - parseFloat(data[1]));
                } else {
                  this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), parseFloat(data[1]));
                }
                endRead = find + 1;
              }
              break;
          }
          if (endRead >= this._currentObject.data.length) {
            break;
          }
        }
      }
    }, {
      key: "_setMeshMaterialList",
      value: function _setMeshMaterialList() {
        var endRead = 0;
        var mode = 0;
        var mode_local = 0;
        while (true) {
          if (mode_local < 2) {
            var refO = this._readInt1(endRead);
            endRead = refO.endRead;
            mode_local++;
          } else {
            var find = this._currentObject.data.indexOf(";", endRead);
            if (find === -1) {
              find = this._currentObject.data.length;
              mode = 3;
              mode_local = 0;
            }
            var line2 = this._currentObject.data.substr(endRead, find - endRead);
            var data = this._readLine(line2.trim()).split(",");
            for (let i2 = 0; i2 < data.length; i2++) {
              this._currentGeo.GeometryData.materialIndices[i2] = parseInt(data[i2]);
            }
            endRead = this._currentObject.data.length;
          }
          if (endRead >= this._currentObject.data.length || mode >= 3) {
            break;
          }
        }
      }
    }, {
      key: "_setMaterial",
      value: function _setMaterial() {
        var _nowMat = new MeshPhongMaterial({
          color: Math.random() * 16777215
        });
        _nowMat.side = FrontSide;
        _nowMat.name = this._currentObject.name;
        var endRead = 0;
        var find = this._currentObject.data.indexOf(";;", endRead);
        var line2 = this._currentObject.data.substr(endRead, find - endRead);
        var data = this._readLine(line2.trim()).split(";");
        _nowMat.color.r = parseFloat(data[0]);
        _nowMat.color.g = parseFloat(data[1]);
        _nowMat.color.b = parseFloat(data[2]);
        endRead = find + 2;
        find = this._currentObject.data.indexOf(";", endRead);
        line2 = this._currentObject.data.substr(endRead, find - endRead);
        _nowMat.shininess = parseFloat(this._readLine(line2));
        endRead = find + 1;
        find = this._currentObject.data.indexOf(";;", endRead);
        line2 = this._currentObject.data.substr(endRead, find - endRead);
        var data2 = this._readLine(line2.trim()).split(";");
        _nowMat.specular.r = parseFloat(data2[0]);
        _nowMat.specular.g = parseFloat(data2[1]);
        _nowMat.specular.b = parseFloat(data2[2]);
        endRead = find + 2;
        find = this._currentObject.data.indexOf(";;", endRead);
        if (find === -1) {
          find = this._currentObject.data.length;
        }
        line2 = this._currentObject.data.substr(endRead, find - endRead);
        var data3 = this._readLine(line2.trim()).split(";");
        _nowMat.emissive.r = parseFloat(data3[0]);
        _nowMat.emissive.g = parseFloat(data3[1]);
        _nowMat.emissive.b = parseFloat(data3[2]);
        var localObject = null;
        while (true) {
          if (this._currentObject.children.length > 0) {
            localObject = this._currentObject.children.shift();
            if (this.debug) {
              console.log("processing " + localObject.name);
            }
            var fileName = localObject.data.substr(1, localObject.data.length - 2);
            switch (localObject.type) {
              case "TextureFilename":
                _nowMat.map = this.texloader.load(fileName);
                break;
              case "BumpMapFilename":
                _nowMat.bumpMap = this.texloader.load(fileName);
                _nowMat.bumpScale = 0.05;
                break;
              case "NormalMapFilename":
                _nowMat.normalMap = this.texloader.load(fileName);
                _nowMat.normalScale = new Vector2(2, 2);
                break;
              case "EmissiveMapFilename":
                _nowMat.emissiveMap = this.texloader.load(fileName);
                break;
              case "LightMapFilename":
                _nowMat.lightMap = this.texloader.load(fileName);
                break;
            }
          } else {
            break;
          }
        }
        this._currentGeo.Materials.push(_nowMat);
      }
    }, {
      key: "_setSkinWeights",
      value: function _setSkinWeights() {
        var boneInf = new XboneInf();
        var endRead = 0;
        var find = this._currentObject.data.indexOf(";", endRead);
        var line2 = this._currentObject.data.substr(endRead, find - endRead);
        endRead = find + 1;
        boneInf.boneName = line2.substr(1, line2.length - 2);
        boneInf.BoneIndex = this._currentGeo.BoneInfs.length;
        find = this._currentObject.data.indexOf(";", endRead);
        endRead = find + 1;
        find = this._currentObject.data.indexOf(";", endRead);
        line2 = this._currentObject.data.substr(endRead, find - endRead);
        var data = this._readLine(line2.trim()).split(",");
        for (let i2 = 0; i2 < data.length; i2++) {
          boneInf.Indeces.push(parseInt(data[i2]));
        }
        endRead = find + 1;
        find = this._currentObject.data.indexOf(";", endRead);
        line2 = this._currentObject.data.substr(endRead, find - endRead);
        var data2 = this._readLine(line2.trim()).split(",");
        for (let _i = 0; _i < data2.length; _i++) {
          boneInf.Weights.push(parseFloat(data2[_i]));
        }
        endRead = find + 1;
        find = this._currentObject.data.indexOf(";", endRead);
        if (find <= 0) {
          find = this._currentObject.data.length;
        }
        line2 = this._currentObject.data.substr(endRead, find - endRead);
        var data3 = this._readLine(line2.trim()).split(",");
        boneInf.OffsetMatrix = new Matrix4();
        this._ParseMatrixData(boneInf.OffsetMatrix, data3);
        this._currentGeo.BoneInfs.push(boneInf);
      }
    }, {
      key: "_makePutBoneList",
      value: function _makePutBoneList(_RootName, _bones) {
        var putting = false;
        for (let frame in this.HieStack) {
          if (this.HieStack[frame].name === _RootName || putting) {
            putting = true;
            var b3 = new Bone();
            b3.name = this.HieStack[frame].name;
            b3.applyMatrix4(this.HieStack[frame].FrameTransformMatrix);
            b3.matrixWorld = b3.matrix;
            b3.FrameTransformMatrix = this.HieStack[frame].FrameTransformMatrix;
            b3.pos = new Vector3().setFromMatrixPosition(b3.FrameTransformMatrix).toArray();
            b3.rotq = new Quaternion().setFromRotationMatrix(b3.FrameTransformMatrix).toArray();
            b3.scl = new Vector3().setFromMatrixScale(b3.FrameTransformMatrix).toArray();
            if (this.HieStack[frame].parentName && this.HieStack[frame].parentName.length > 0) {
              for (let i2 = 0; i2 < _bones.length; i2++) {
                if (this.HieStack[frame].parentName === _bones[i2].name) {
                  _bones[i2].add(b3);
                  b3.parent = i2;
                  break;
                }
              }
            }
            _bones.push(b3);
          }
        }
      }
    }, {
      key: "_makeOutputGeometry",
      value: function _makeOutputGeometry() {
        var mesh = null;
        if (this._currentGeo.BoneInfs.length > 0) {
          var putBones = [];
          this._makePutBoneList(this._currentGeo.baseFrame.parentName, putBones);
          for (let bi = 0; bi < this._currentGeo.BoneInfs.length; bi++) {
            var boneIndex = 0;
            for (let bb = 0; bb < putBones.length; bb++) {
              if (putBones[bb].name === this._currentGeo.BoneInfs[bi].boneName) {
                boneIndex = bb;
                putBones[bb].OffsetMatrix = new Matrix4();
                putBones[bb].OffsetMatrix.copy(this._currentGeo.BoneInfs[bi].OffsetMatrix);
                break;
              }
            }
            for (let vi = 0; vi < this._currentGeo.BoneInfs[bi].Indeces.length; vi++) {
              var nowVertexID = this._currentGeo.BoneInfs[bi].Indeces[vi];
              var nowVal = this._currentGeo.BoneInfs[bi].Weights[vi];
              var stride = nowVertexID * 4;
              switch (this._currentGeo.VertexSetedBoneCount[nowVertexID]) {
                case 0:
                  this._currentGeo.GeometryData.skinIndices[stride] = boneIndex;
                  this._currentGeo.GeometryData.skinWeights[stride] = nowVal;
                  break;
                case 1:
                  this._currentGeo.GeometryData.skinIndices[stride + 1] = boneIndex;
                  this._currentGeo.GeometryData.skinWeights[stride + 1] = nowVal;
                  break;
                case 2:
                  this._currentGeo.GeometryData.skinIndices[stride + 2] = boneIndex;
                  this._currentGeo.GeometryData.skinWeights[stride + 2] = nowVal;
                  break;
                case 3:
                  this._currentGeo.GeometryData.skinIndices[stride + 3] = boneIndex;
                  this._currentGeo.GeometryData.skinWeights[stride + 3] = nowVal;
                  break;
              }
              this._currentGeo.VertexSetedBoneCount[nowVertexID]++;
              if (this._currentGeo.VertexSetedBoneCount[nowVertexID] > 4) {
                console.log("warn! over 4 bone weight! :" + nowVertexID);
              }
            }
          }
          for (let sk = 0; sk < this._currentGeo.Materials.length; sk++) {
            this._currentGeo.Materials[sk].skinning = true;
          }
          var offsetList = [];
          for (let _bi = 0; _bi < putBones.length; _bi++) {
            if (putBones[_bi].OffsetMatrix) {
              offsetList.push(putBones[_bi].OffsetMatrix);
            } else {
              offsetList.push(new Matrix4());
            }
          }
          var bufferGeometry = this._buildGeometry();
          mesh = new SkinnedMesh(bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);
          this._initSkeleton(mesh, putBones, offsetList);
        } else {
          var _bufferGeometry = this._buildGeometry();
          mesh = new Mesh(_bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);
        }
        mesh.name = this._currentGeo.name;
        var worldBaseMx = new Matrix4();
        var currentMxFrame = this._currentGeo.baseFrame.putBone;
        if (currentMxFrame && currentMxFrame.parent) {
          while (true) {
            currentMxFrame = currentMxFrame.parent;
            if (currentMxFrame) {
              worldBaseMx.multiply(currentMxFrame.FrameTransformMatrix);
            } else {
              break;
            }
          }
          mesh.applyMatrix4(worldBaseMx);
        }
        this.Meshes.push(mesh);
      }
    }, {
      key: "_initSkeleton",
      value: function _initSkeleton(mesh, boneList, boneInverses) {
        var bones = [], bone, gbone;
        var i2, il;
        for (i2 = 0, il = boneList.length; i2 < il; i2++) {
          gbone = boneList[i2];
          bone = new Bone();
          bones.push(bone);
          bone.name = gbone.name;
          bone.position.fromArray(gbone.pos);
          bone.quaternion.fromArray(gbone.rotq);
          if (gbone.scl !== void 0)
            bone.scale.fromArray(gbone.scl);
        }
        for (i2 = 0, il = boneList.length; i2 < il; i2++) {
          gbone = boneList[i2];
          if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== void 0) {
            bones[gbone.parent].add(bones[i2]);
          } else {
            mesh.add(bones[i2]);
          }
        }
        mesh.updateMatrixWorld(true);
        var skeleton = new Skeleton(bones, boneInverses);
        mesh.bind(skeleton, mesh.matrixWorld);
      }
    }, {
      key: "_readAnimationKey",
      value: function _readAnimationKey() {
        var endRead = 0;
        var find = this._currentObject.data.indexOf(";", endRead);
        var line2 = this._currentObject.data.substr(endRead, find - endRead);
        endRead = find + 1;
        var nowKeyType = parseInt(this._readLine(line2));
        find = this._currentObject.data.indexOf(";", endRead);
        endRead = find + 1;
        line2 = this._currentObject.data.substr(endRead);
        var data = this._readLine(line2.trim()).split(";;,");
        for (let i2 = 0; i2 < data.length; i2++) {
          var data2 = data[i2].split(";");
          var keyInfo = new XKeyFrameInfo();
          keyInfo.type = nowKeyType;
          keyInfo.Frame = parseInt(data2[0]);
          keyInfo.index = this._currentAnimeFrames.keyFrames.length;
          keyInfo.time = keyInfo.Frame;
          if (nowKeyType != 4) {
            var frameFound = false;
            for (let mm = 0; mm < this._currentAnimeFrames.keyFrames.length; mm++) {
              if (this._currentAnimeFrames.keyFrames[mm].Frame === keyInfo.Frame) {
                keyInfo = this._currentAnimeFrames.keyFrames[mm];
                frameFound = true;
                break;
              }
            }
            var frameValue = data2[2].split(",");
            switch (nowKeyType) {
              case 0:
                keyInfo.rot = new Quaternion(parseFloat(frameValue[1]), parseFloat(frameValue[2]), parseFloat(frameValue[3]), parseFloat(frameValue[0]) * -1);
                break;
              case 1:
                keyInfo.scl = new Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));
                break;
              case 2:
                keyInfo.pos = new Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));
                break;
            }
            if (!frameFound) {
              this._currentAnimeFrames.keyFrames.push(keyInfo);
            }
          } else {
            keyInfo.matrix = new Matrix4();
            this._ParseMatrixData(keyInfo.matrix, data2[2].split(","));
            this._currentAnimeFrames.keyFrames.push(keyInfo);
          }
        }
      }
    }, {
      key: "_makeOutputAnimation",
      value: function _makeOutputAnimation() {
        var animationObj = new XAnimationObj(this.options);
        animationObj.fps = this.animTicksPerSecond;
        animationObj.name = this._currentAnime.name;
        animationObj.make(this._currentAnime.AnimeFrames);
        this.animations.push(animationObj);
      }
    }, {
      key: "assignAnimation",
      value: function assignAnimation(_model, _animation) {
        var model = _model;
        var animation = _animation;
        if (!model) {
          model = this.Meshes[0];
        }
        if (!animation) {
          animation = this.animations[0];
        }
        if (!model || !animation) {
          return null;
        }
        var put = {};
        put.fps = animation.fps;
        put.name = animation.name;
        put.length = animation.length;
        put.hierarchy = [];
        for (let b3 = 0; b3 < model.skeleton.bones.length; b3++) {
          var findAnimation = false;
          for (let i2 = 0; i2 < animation.hierarchy.length; i2++) {
            if (model.skeleton.bones[b3].name === animation.hierarchy[i2].name) {
              findAnimation = true;
              var c_key = animation.hierarchy[i2].copy();
              c_key.parent = -1;
              if (model.skeleton.bones[b3].parent && model.skeleton.bones[b3].parent.type === "Bone") {
                for (let bb = 0; bb < put.hierarchy.length; bb++) {
                  if (put.hierarchy[bb].name === model.skeleton.bones[b3].parent.name) {
                    c_key.parent = bb;
                    c_key.parentName = model.skeleton.bones[b3].parent.name;
                  }
                }
              }
              put.hierarchy.push(c_key);
              break;
            }
          }
          if (!findAnimation) {
            var _c_key = animation.hierarchy[0].copy();
            _c_key.name = model.skeleton.bones[b3].name;
            _c_key.parent = -1;
            for (let k = 0; k < _c_key.keys.length; k++) {
              if (_c_key.keys[k].pos) {
                _c_key.keys[k].pos.set(0, 0, 0);
              }
              if (_c_key.keys[k].scl) {
                _c_key.keys[k].scl.set(1, 1, 1);
              }
              if (_c_key.keys[k].rot) {
                _c_key.keys[k].rot.set(0, 0, 0, 1);
              }
            }
            put.hierarchy.push(_c_key);
          }
        }
        if (!model.geometry.animations) {
          model.geometry.animations = [];
        }
        model.geometry.animations.push(AnimationClip.parseAnimation(put, model.skeleton.bones));
        if (!model.animationMixer) {
          model.animationMixer = new AnimationMixer(model);
        }
        return put;
      }
    }, {
      key: "_ParseMatrixData",
      value: function _ParseMatrixData(targetMatrix, data) {
        targetMatrix.set(parseFloat(data[0]), parseFloat(data[4]), parseFloat(data[8]), parseFloat(data[12]), parseFloat(data[1]), parseFloat(data[5]), parseFloat(data[9]), parseFloat(data[13]), parseFloat(data[2]), parseFloat(data[6]), parseFloat(data[10]), parseFloat(data[14]), parseFloat(data[3]), parseFloat(data[7]), parseFloat(data[11]), parseFloat(data[15]));
      }
    }]);
    return XLoader3;
  }();
  return XLoader2;
}();

// node_modules/three-stdlib/loaders/BVHLoader.js
var BVHLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.animateBonePositions = true;
    this.animateBoneRotations = true;
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope2.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(text) {
    function readBvh(lines2) {
      if (nextLine(lines2) !== "HIERARCHY") {
        console.error("THREE.BVHLoader: HIERARCHY expected.");
      }
      const list = [];
      const root = readNode(lines2, nextLine(lines2), list);
      if (nextLine(lines2) !== "MOTION") {
        console.error("THREE.BVHLoader: MOTION expected.");
      }
      let tokens = nextLine(lines2).split(/[\s]+/);
      const numFrames = parseInt(tokens[1]);
      if (isNaN(numFrames)) {
        console.error("THREE.BVHLoader: Failed to read number of frames.");
      }
      tokens = nextLine(lines2).split(/[\s]+/);
      const frameTime = parseFloat(tokens[2]);
      if (isNaN(frameTime)) {
        console.error("THREE.BVHLoader: Failed to read frame time.");
      }
      for (let i2 = 0; i2 < numFrames; i2++) {
        tokens = nextLine(lines2).split(/[\s]+/);
        readFrameData(tokens, i2 * frameTime, root);
      }
      return list;
    }
    function readFrameData(data, frameTime, bone) {
      if (bone.type === "ENDSITE")
        return;
      const keyframe = {
        time: frameTime,
        position: new Vector3(),
        rotation: new Quaternion()
      };
      bone.frames.push(keyframe);
      const quat = new Quaternion();
      const vx = new Vector3(1, 0, 0);
      const vy = new Vector3(0, 1, 0);
      const vz = new Vector3(0, 0, 1);
      for (let i2 = 0; i2 < bone.channels.length; i2++) {
        switch (bone.channels[i2]) {
          case "Xposition":
            keyframe.position.x = parseFloat(data.shift().trim());
            break;
          case "Yposition":
            keyframe.position.y = parseFloat(data.shift().trim());
            break;
          case "Zposition":
            keyframe.position.z = parseFloat(data.shift().trim());
            break;
          case "Xrotation":
            quat.setFromAxisAngle(vx, parseFloat(data.shift().trim()) * Math.PI / 180);
            keyframe.rotation.multiply(quat);
            break;
          case "Yrotation":
            quat.setFromAxisAngle(vy, parseFloat(data.shift().trim()) * Math.PI / 180);
            keyframe.rotation.multiply(quat);
            break;
          case "Zrotation":
            quat.setFromAxisAngle(vz, parseFloat(data.shift().trim()) * Math.PI / 180);
            keyframe.rotation.multiply(quat);
            break;
          default:
            console.warn("THREE.BVHLoader: Invalid channel type.");
        }
      }
      for (let i2 = 0; i2 < bone.children.length; i2++) {
        readFrameData(data, frameTime, bone.children[i2]);
      }
    }
    function readNode(lines2, firstline, list) {
      const node = {
        name: "",
        type: "",
        frames: []
      };
      list.push(node);
      let tokens = firstline.split(/[\s]+/);
      if (tokens[0].toUpperCase() === "END" && tokens[1].toUpperCase() === "SITE") {
        node.type = "ENDSITE";
        node.name = "ENDSITE";
      } else {
        node.name = tokens[1];
        node.type = tokens[0].toUpperCase();
      }
      if (nextLine(lines2) !== "{") {
        console.error("THREE.BVHLoader: Expected opening { after type & name");
      }
      tokens = nextLine(lines2).split(/[\s]+/);
      if (tokens[0] !== "OFFSET") {
        console.error("THREE.BVHLoader: Expected OFFSET but got: " + tokens[0]);
      }
      if (tokens.length !== 4) {
        console.error("THREE.BVHLoader: Invalid number of values for OFFSET.");
      }
      const offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));
      if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {
        console.error("THREE.BVHLoader: Invalid values of OFFSET.");
      }
      node.offset = offset;
      if (node.type !== "ENDSITE") {
        tokens = nextLine(lines2).split(/[\s]+/);
        if (tokens[0] !== "CHANNELS") {
          console.error("THREE.BVHLoader: Expected CHANNELS definition.");
        }
        const numChannels = parseInt(tokens[1]);
        node.channels = tokens.splice(2, numChannels);
        node.children = [];
      }
      while (true) {
        const line2 = nextLine(lines2);
        if (line2 === "}") {
          return node;
        } else {
          node.children.push(readNode(lines2, line2, list));
        }
      }
    }
    function toTHREEBone(source, list) {
      const bone = new Bone();
      list.push(bone);
      bone.position.add(source.offset);
      bone.name = source.name;
      if (source.type !== "ENDSITE") {
        for (let i2 = 0; i2 < source.children.length; i2++) {
          bone.add(toTHREEBone(source.children[i2], list));
        }
      }
      return bone;
    }
    function toTHREEAnimation(bones2) {
      const tracks = [];
      for (let i2 = 0; i2 < bones2.length; i2++) {
        const bone = bones2[i2];
        if (bone.type === "ENDSITE")
          continue;
        const times = [];
        const positions = [];
        const rotations = [];
        for (let j2 = 0; j2 < bone.frames.length; j2++) {
          const frame = bone.frames[j2];
          times.push(frame.time);
          positions.push(frame.position.x + bone.offset.x);
          positions.push(frame.position.y + bone.offset.y);
          positions.push(frame.position.z + bone.offset.z);
          rotations.push(frame.rotation.x);
          rotations.push(frame.rotation.y);
          rotations.push(frame.rotation.z);
          rotations.push(frame.rotation.w);
        }
        if (scope2.animateBonePositions) {
          tracks.push(new VectorKeyframeTrack(".bones[" + bone.name + "].position", times, positions));
        }
        if (scope2.animateBoneRotations) {
          tracks.push(new QuaternionKeyframeTrack(".bones[" + bone.name + "].quaternion", times, rotations));
        }
      }
      return new AnimationClip("animation", -1, tracks);
    }
    function nextLine(lines2) {
      let line2;
      while ((line2 = lines2.shift().trim()).length === 0) {
      }
      return line2;
    }
    const scope2 = this;
    const lines = text.split(/[\r\n]+/g);
    const bones = readBvh(lines);
    const threeBones = [];
    toTHREEBone(bones[0], threeBones);
    const threeClip = toTHREEAnimation(bones);
    return {
      skeleton: new Skeleton(threeBones),
      clip: threeClip
    };
  }
};

// node_modules/three-stdlib/loaders/ColladaLoader.js
var ColladaLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const path = scope2.path === "" ? LoaderUtils.extractUrlBase(url) : scope2.path;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope2.parse(text, path));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(text, path) {
    function getElementsByTagName(xml2, name) {
      const array = [];
      const childNodes = xml2.childNodes;
      for (let i2 = 0, l = childNodes.length; i2 < l; i2++) {
        const child = childNodes[i2];
        if (child.nodeName === name) {
          array.push(child);
        }
      }
      return array;
    }
    function parseStrings(text2) {
      if (text2.length === 0)
        return [];
      const parts = text2.trim().split(/\s+/);
      const array = new Array(parts.length);
      for (let i2 = 0, l = parts.length; i2 < l; i2++) {
        array[i2] = parts[i2];
      }
      return array;
    }
    function parseFloats(text2) {
      if (text2.length === 0)
        return [];
      const parts = text2.trim().split(/\s+/);
      const array = new Array(parts.length);
      for (let i2 = 0, l = parts.length; i2 < l; i2++) {
        array[i2] = parseFloat(parts[i2]);
      }
      return array;
    }
    function parseInts(text2) {
      if (text2.length === 0)
        return [];
      const parts = text2.trim().split(/\s+/);
      const array = new Array(parts.length);
      for (let i2 = 0, l = parts.length; i2 < l; i2++) {
        array[i2] = parseInt(parts[i2]);
      }
      return array;
    }
    function parseId(text2) {
      return text2.substring(1);
    }
    function generateId() {
      return "three_default_" + count++;
    }
    function isEmpty(object) {
      return Object.keys(object).length === 0;
    }
    function parseAsset(xml2) {
      return {
        unit: parseAssetUnit(getElementsByTagName(xml2, "unit")[0]),
        upAxis: parseAssetUpAxis(getElementsByTagName(xml2, "up_axis")[0])
      };
    }
    function parseAssetUnit(xml2) {
      if (xml2 !== void 0 && xml2.hasAttribute("meter") === true) {
        return parseFloat(xml2.getAttribute("meter"));
      } else {
        return 1;
      }
    }
    function parseAssetUpAxis(xml2) {
      return xml2 !== void 0 ? xml2.textContent : "Y_UP";
    }
    function parseLibrary(xml2, libraryName, nodeName, parser) {
      const library2 = getElementsByTagName(xml2, libraryName)[0];
      if (library2 !== void 0) {
        const elements = getElementsByTagName(library2, nodeName);
        for (let i2 = 0; i2 < elements.length; i2++) {
          parser(elements[i2]);
        }
      }
    }
    function buildLibrary(data, builder) {
      for (const name in data) {
        const object = data[name];
        object.build = builder(data[name]);
      }
    }
    function getBuild(data, builder) {
      if (data.build !== void 0)
        return data.build;
      data.build = builder(data);
      return data.build;
    }
    function parseAnimation(xml2) {
      const data = {
        sources: {},
        samplers: {},
        channels: {}
      };
      let hasChildren = false;
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        let id;
        switch (child.nodeName) {
          case "source":
            id = child.getAttribute("id");
            data.sources[id] = parseSource(child);
            break;
          case "sampler":
            id = child.getAttribute("id");
            data.samplers[id] = parseAnimationSampler(child);
            break;
          case "channel":
            id = child.getAttribute("target");
            data.channels[id] = parseAnimationChannel(child);
            break;
          case "animation":
            parseAnimation(child);
            hasChildren = true;
            break;
          default:
            console.log(child);
        }
      }
      if (hasChildren === false) {
        library.animations[xml2.getAttribute("id") || MathUtils.generateUUID()] = data;
      }
    }
    function parseAnimationSampler(xml2) {
      const data = {
        inputs: {}
      };
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "input":
            const id = parseId(child.getAttribute("source"));
            const semantic = child.getAttribute("semantic");
            data.inputs[semantic] = id;
            break;
        }
      }
      return data;
    }
    function parseAnimationChannel(xml2) {
      const data = {};
      const target = xml2.getAttribute("target");
      let parts = target.split("/");
      const id = parts.shift();
      let sid = parts.shift();
      const arraySyntax = sid.indexOf("(") !== -1;
      const memberSyntax = sid.indexOf(".") !== -1;
      if (memberSyntax) {
        parts = sid.split(".");
        sid = parts.shift();
        data.member = parts.shift();
      } else if (arraySyntax) {
        const indices = sid.split("(");
        sid = indices.shift();
        for (let i2 = 0; i2 < indices.length; i2++) {
          indices[i2] = parseInt(indices[i2].replace(/\)/, ""));
        }
        data.indices = indices;
      }
      data.id = id;
      data.sid = sid;
      data.arraySyntax = arraySyntax;
      data.memberSyntax = memberSyntax;
      data.sampler = parseId(xml2.getAttribute("source"));
      return data;
    }
    function buildAnimation(data) {
      const tracks = [];
      const channels = data.channels;
      const samplers = data.samplers;
      const sources = data.sources;
      for (const target in channels) {
        if (channels.hasOwnProperty(target)) {
          const channel = channels[target];
          const sampler2 = samplers[channel.sampler];
          const inputId = sampler2.inputs.INPUT;
          const outputId = sampler2.inputs.OUTPUT;
          const inputSource = sources[inputId];
          const outputSource = sources[outputId];
          const animation = buildAnimationChannel(channel, inputSource, outputSource);
          createKeyframeTracks(animation, tracks);
        }
      }
      return tracks;
    }
    function getAnimation(id) {
      return getBuild(library.animations[id], buildAnimation);
    }
    function buildAnimationChannel(channel, inputSource, outputSource) {
      const node = library.nodes[channel.id];
      const object3D = getNode(node.id);
      const transform = node.transforms[channel.sid];
      const defaultMatrix = node.matrix.clone().transpose();
      let time, stride;
      let i2, il, j2, jl2;
      const data = {};
      switch (transform) {
        case "matrix":
          for (i2 = 0, il = inputSource.array.length; i2 < il; i2++) {
            time = inputSource.array[i2];
            stride = i2 * outputSource.stride;
            if (data[time] === void 0)
              data[time] = {};
            if (channel.arraySyntax === true) {
              const value = outputSource.array[stride];
              const index = channel.indices[0] + 4 * channel.indices[1];
              data[time][index] = value;
            } else {
              for (j2 = 0, jl2 = outputSource.stride; j2 < jl2; j2++) {
                data[time][j2] = outputSource.array[stride + j2];
              }
            }
          }
          break;
        case "translate":
          console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
          break;
        case "rotate":
          console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
          break;
        case "scale":
          console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
          break;
      }
      const keyframes = prepareAnimationData(data, defaultMatrix);
      const animation = {
        name: object3D.uuid,
        keyframes
      };
      return animation;
    }
    function prepareAnimationData(data, defaultMatrix) {
      const keyframes = [];
      for (const time in data) {
        keyframes.push({
          time: parseFloat(time),
          value: data[time]
        });
      }
      keyframes.sort(ascending);
      for (let i2 = 0; i2 < 16; i2++) {
        transformAnimationData(keyframes, i2, defaultMatrix.elements[i2]);
      }
      return keyframes;
      function ascending(a2, b3) {
        return a2.time - b3.time;
      }
    }
    const position = new Vector3();
    const scale = new Vector3();
    const quaternion = new Quaternion();
    function createKeyframeTracks(animation, tracks) {
      const keyframes = animation.keyframes;
      const name = animation.name;
      const times = [];
      const positionData = [];
      const quaternionData = [];
      const scaleData = [];
      for (let i2 = 0, l = keyframes.length; i2 < l; i2++) {
        const keyframe = keyframes[i2];
        const time = keyframe.time;
        const value = keyframe.value;
        matrix3.fromArray(value).transpose();
        matrix3.decompose(position, quaternion, scale);
        times.push(time);
        positionData.push(position.x, position.y, position.z);
        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
        scaleData.push(scale.x, scale.y, scale.z);
      }
      if (positionData.length > 0)
        tracks.push(new VectorKeyframeTrack(name + ".position", times, positionData));
      if (quaternionData.length > 0) {
        tracks.push(new QuaternionKeyframeTrack(name + ".quaternion", times, quaternionData));
      }
      if (scaleData.length > 0)
        tracks.push(new VectorKeyframeTrack(name + ".scale", times, scaleData));
      return tracks;
    }
    function transformAnimationData(keyframes, property, defaultValue) {
      let keyframe;
      let empty = true;
      let i2, l;
      for (i2 = 0, l = keyframes.length; i2 < l; i2++) {
        keyframe = keyframes[i2];
        if (keyframe.value[property] === void 0) {
          keyframe.value[property] = null;
        } else {
          empty = false;
        }
      }
      if (empty === true) {
        for (i2 = 0, l = keyframes.length; i2 < l; i2++) {
          keyframe = keyframes[i2];
          keyframe.value[property] = defaultValue;
        }
      } else {
        createMissingKeyframes(keyframes, property);
      }
    }
    function createMissingKeyframes(keyframes, property) {
      let prev, next;
      for (let i2 = 0, l = keyframes.length; i2 < l; i2++) {
        const keyframe = keyframes[i2];
        if (keyframe.value[property] === null) {
          prev = getPrev(keyframes, i2, property);
          next = getNext(keyframes, i2, property);
          if (prev === null) {
            keyframe.value[property] = next.value[property];
            continue;
          }
          if (next === null) {
            keyframe.value[property] = prev.value[property];
            continue;
          }
          interpolate(keyframe, prev, next, property);
        }
      }
    }
    function getPrev(keyframes, i2, property) {
      while (i2 >= 0) {
        const keyframe = keyframes[i2];
        if (keyframe.value[property] !== null)
          return keyframe;
        i2--;
      }
      return null;
    }
    function getNext(keyframes, i2, property) {
      while (i2 < keyframes.length) {
        const keyframe = keyframes[i2];
        if (keyframe.value[property] !== null)
          return keyframe;
        i2++;
      }
      return null;
    }
    function interpolate(key, prev, next, property) {
      if (next.time - prev.time === 0) {
        key.value[property] = prev.value[property];
        return;
      }
      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];
    }
    function parseAnimationClip(xml2) {
      const data = {
        name: xml2.getAttribute("id") || "default",
        start: parseFloat(xml2.getAttribute("start") || 0),
        end: parseFloat(xml2.getAttribute("end") || 0),
        animations: []
      };
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "instance_animation":
            data.animations.push(parseId(child.getAttribute("url")));
            break;
        }
      }
      library.clips[xml2.getAttribute("id")] = data;
    }
    function buildAnimationClip(data) {
      const tracks = [];
      const name = data.name;
      const duration = data.end - data.start || -1;
      const animations2 = data.animations;
      for (let i2 = 0, il = animations2.length; i2 < il; i2++) {
        const animationTracks = getAnimation(animations2[i2]);
        for (let j2 = 0, jl2 = animationTracks.length; j2 < jl2; j2++) {
          tracks.push(animationTracks[j2]);
        }
      }
      return new AnimationClip(name, duration, tracks);
    }
    function getAnimationClip(id) {
      return getBuild(library.clips[id], buildAnimationClip);
    }
    function parseController(xml2) {
      const data = {};
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "skin":
            data.id = parseId(child.getAttribute("source"));
            data.skin = parseSkin(child);
            break;
          case "morph":
            data.id = parseId(child.getAttribute("source"));
            console.warn("THREE.ColladaLoader: Morph target animation not supported yet.");
            break;
        }
      }
      library.controllers[xml2.getAttribute("id")] = data;
    }
    function parseSkin(xml2) {
      const data = {
        sources: {}
      };
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "bind_shape_matrix":
            data.bindShapeMatrix = parseFloats(child.textContent);
            break;
          case "source":
            const id = child.getAttribute("id");
            data.sources[id] = parseSource(child);
            break;
          case "joints":
            data.joints = parseJoints(child);
            break;
          case "vertex_weights":
            data.vertexWeights = parseVertexWeights(child);
            break;
        }
      }
      return data;
    }
    function parseJoints(xml2) {
      const data = {
        inputs: {}
      };
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "input":
            const semantic = child.getAttribute("semantic");
            const id = parseId(child.getAttribute("source"));
            data.inputs[semantic] = id;
            break;
        }
      }
      return data;
    }
    function parseVertexWeights(xml2) {
      const data = {
        inputs: {}
      };
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "input":
            const semantic = child.getAttribute("semantic");
            const id = parseId(child.getAttribute("source"));
            const offset = parseInt(child.getAttribute("offset"));
            data.inputs[semantic] = {
              id,
              offset
            };
            break;
          case "vcount":
            data.vcount = parseInts(child.textContent);
            break;
          case "v":
            data.v = parseInts(child.textContent);
            break;
        }
      }
      return data;
    }
    function buildController(data) {
      const build = {
        id: data.id
      };
      const geometry = library.geometries[build.id];
      if (data.skin !== void 0) {
        build.skin = buildSkin(data.skin);
        geometry.sources.skinIndices = build.skin.indices;
        geometry.sources.skinWeights = build.skin.weights;
      }
      return build;
    }
    function buildSkin(data) {
      const BONE_LIMIT = 4;
      const build = {
        joints: [],
        indices: {
          array: [],
          stride: BONE_LIMIT
        },
        weights: {
          array: [],
          stride: BONE_LIMIT
        }
      };
      const sources = data.sources;
      const vertexWeights = data.vertexWeights;
      const vcount = vertexWeights.vcount;
      const v = vertexWeights.v;
      const jointOffset = vertexWeights.inputs.JOINT.offset;
      const weightOffset = vertexWeights.inputs.WEIGHT.offset;
      const jointSource = data.sources[data.joints.inputs.JOINT];
      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];
      const weights = sources[vertexWeights.inputs.WEIGHT.id].array;
      let stride = 0;
      let i2, j2, l;
      for (i2 = 0, l = vcount.length; i2 < l; i2++) {
        const jointCount = vcount[i2];
        const vertexSkinData = [];
        for (j2 = 0; j2 < jointCount; j2++) {
          const skinIndex = v[stride + jointOffset];
          const weightId = v[stride + weightOffset];
          const skinWeight = weights[weightId];
          vertexSkinData.push({
            index: skinIndex,
            weight: skinWeight
          });
          stride += 2;
        }
        vertexSkinData.sort(descending);
        for (j2 = 0; j2 < BONE_LIMIT; j2++) {
          const d = vertexSkinData[j2];
          if (d !== void 0) {
            build.indices.array.push(d.index);
            build.weights.array.push(d.weight);
          } else {
            build.indices.array.push(0);
            build.weights.array.push(0);
          }
        }
      }
      if (data.bindShapeMatrix) {
        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();
      } else {
        build.bindMatrix = new Matrix4().identity();
      }
      for (i2 = 0, l = jointSource.array.length; i2 < l; i2++) {
        const name = jointSource.array[i2];
        const boneInverse = new Matrix4().fromArray(inverseSource.array, i2 * inverseSource.stride).transpose();
        build.joints.push({
          name,
          boneInverse
        });
      }
      return build;
      function descending(a2, b3) {
        return b3.weight - a2.weight;
      }
    }
    function getController(id) {
      return getBuild(library.controllers[id], buildController);
    }
    function parseImage(xml2) {
      const data = {
        init_from: getElementsByTagName(xml2, "init_from")[0].textContent
      };
      library.images[xml2.getAttribute("id")] = data;
    }
    function buildImage(data) {
      if (data.build !== void 0)
        return data.build;
      return data.init_from;
    }
    function getImage(id) {
      const data = library.images[id];
      if (data !== void 0) {
        return getBuild(data, buildImage);
      }
      console.warn("THREE.ColladaLoader: Couldn't find image with ID:", id);
      return null;
    }
    function parseEffect(xml2) {
      const data = {};
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "profile_COMMON":
            data.profile = parseEffectProfileCOMMON(child);
            break;
        }
      }
      library.effects[xml2.getAttribute("id")] = data;
    }
    function parseEffectProfileCOMMON(xml2) {
      const data = {
        surfaces: {},
        samplers: {}
      };
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "newparam":
            parseEffectNewparam(child, data);
            break;
          case "technique":
            data.technique = parseEffectTechnique(child);
            break;
          case "extra":
            data.extra = parseEffectExtra(child);
            break;
        }
      }
      return data;
    }
    function parseEffectNewparam(xml2, data) {
      const sid = xml2.getAttribute("sid");
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "surface":
            data.surfaces[sid] = parseEffectSurface(child);
            break;
          case "sampler2D":
            data.samplers[sid] = parseEffectSampler(child);
            break;
        }
      }
    }
    function parseEffectSurface(xml2) {
      const data = {};
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "init_from":
            data.init_from = child.textContent;
            break;
        }
      }
      return data;
    }
    function parseEffectSampler(xml2) {
      const data = {};
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "source":
            data.source = child.textContent;
            break;
        }
      }
      return data;
    }
    function parseEffectTechnique(xml2) {
      const data = {};
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "constant":
          case "lambert":
          case "blinn":
          case "phong":
            data.type = child.nodeName;
            data.parameters = parseEffectParameters(child);
            break;
          case "extra":
            data.extra = parseEffectExtra(child);
            break;
        }
      }
      return data;
    }
    function parseEffectParameters(xml2) {
      const data = {};
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "emission":
          case "diffuse":
          case "specular":
          case "bump":
          case "ambient":
          case "shininess":
          case "transparency":
            data[child.nodeName] = parseEffectParameter(child);
            break;
          case "transparent":
            data[child.nodeName] = {
              opaque: child.hasAttribute("opaque") ? child.getAttribute("opaque") : "A_ONE",
              data: parseEffectParameter(child)
            };
            break;
        }
      }
      return data;
    }
    function parseEffectParameter(xml2) {
      const data = {};
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "color":
            data[child.nodeName] = parseFloats(child.textContent);
            break;
          case "float":
            data[child.nodeName] = parseFloat(child.textContent);
            break;
          case "texture":
            data[child.nodeName] = {
              id: child.getAttribute("texture"),
              extra: parseEffectParameterTexture(child)
            };
            break;
        }
      }
      return data;
    }
    function parseEffectParameterTexture(xml2) {
      const data = {
        technique: {}
      };
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "extra":
            parseEffectParameterTextureExtra(child, data);
            break;
        }
      }
      return data;
    }
    function parseEffectParameterTextureExtra(xml2, data) {
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "technique":
            parseEffectParameterTextureExtraTechnique(child, data);
            break;
        }
      }
    }
    function parseEffectParameterTextureExtraTechnique(xml2, data) {
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "repeatU":
          case "repeatV":
          case "offsetU":
          case "offsetV":
            data.technique[child.nodeName] = parseFloat(child.textContent);
            break;
          case "wrapU":
          case "wrapV":
            if (child.textContent.toUpperCase() === "TRUE") {
              data.technique[child.nodeName] = 1;
            } else if (child.textContent.toUpperCase() === "FALSE") {
              data.technique[child.nodeName] = 0;
            } else {
              data.technique[child.nodeName] = parseInt(child.textContent);
            }
            break;
          case "bump":
            data[child.nodeName] = parseEffectExtraTechniqueBump(child);
            break;
        }
      }
    }
    function parseEffectExtra(xml2) {
      const data = {};
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "technique":
            data.technique = parseEffectExtraTechnique(child);
            break;
        }
      }
      return data;
    }
    function parseEffectExtraTechnique(xml2) {
      const data = {};
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "double_sided":
            data[child.nodeName] = parseInt(child.textContent);
            break;
          case "bump":
            data[child.nodeName] = parseEffectExtraTechniqueBump(child);
            break;
        }
      }
      return data;
    }
    function parseEffectExtraTechniqueBump(xml2) {
      var data = {};
      for (var i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        var child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "texture":
            data[child.nodeName] = {
              id: child.getAttribute("texture"),
              texcoord: child.getAttribute("texcoord"),
              extra: parseEffectParameterTexture(child)
            };
            break;
        }
      }
      return data;
    }
    function buildEffect(data) {
      return data;
    }
    function getEffect(id) {
      return getBuild(library.effects[id], buildEffect);
    }
    function parseMaterial(xml2) {
      const data = {
        name: xml2.getAttribute("name")
      };
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "instance_effect":
            data.url = parseId(child.getAttribute("url"));
            break;
        }
      }
      library.materials[xml2.getAttribute("id")] = data;
    }
    function getTextureLoader(image) {
      let loader;
      let extension = image.slice((image.lastIndexOf(".") - 1 >>> 0) + 2);
      extension = extension.toLowerCase();
      switch (extension) {
        case "tga":
          loader = tgaLoader;
          break;
        default:
          loader = textureLoader;
      }
      return loader;
    }
    function buildMaterial(data) {
      const effect = getEffect(data.url);
      const technique = effect.profile.technique;
      let material;
      switch (technique.type) {
        case "phong":
        case "blinn":
          material = new MeshPhongMaterial();
          break;
        case "lambert":
          material = new MeshLambertMaterial();
          break;
        default:
          material = new MeshBasicMaterial();
          break;
      }
      material.name = data.name || "";
      function getTexture(textureObject) {
        const sampler2 = effect.profile.samplers[textureObject.id];
        let image = null;
        if (sampler2 !== void 0) {
          const surface = effect.profile.surfaces[sampler2.source];
          image = getImage(surface.init_from);
        } else {
          console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).");
          image = getImage(textureObject.id);
        }
        if (image !== null) {
          const loader = getTextureLoader(image);
          if (loader !== void 0) {
            const texture2 = loader.load(image);
            const extra = textureObject.extra;
            if (extra !== void 0 && extra.technique !== void 0 && isEmpty(extra.technique) === false) {
              const technique2 = extra.technique;
              texture2.wrapS = technique2.wrapU ? RepeatWrapping : ClampToEdgeWrapping;
              texture2.wrapT = technique2.wrapV ? RepeatWrapping : ClampToEdgeWrapping;
              texture2.offset.set(technique2.offsetU || 0, technique2.offsetV || 0);
              texture2.repeat.set(technique2.repeatU || 1, technique2.repeatV || 1);
            } else {
              texture2.wrapS = RepeatWrapping;
              texture2.wrapT = RepeatWrapping;
            }
            return texture2;
          } else {
            console.warn("THREE.ColladaLoader: Loader for texture %s not found.", image);
            return null;
          }
        } else {
          console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", textureObject.id);
          return null;
        }
      }
      const parameters = technique.parameters;
      for (const key in parameters) {
        const parameter = parameters[key];
        switch (key) {
          case "diffuse":
            if (parameter.color)
              material.color.fromArray(parameter.color);
            if (parameter.texture)
              material.map = getTexture(parameter.texture);
            break;
          case "specular":
            if (parameter.color && material.specular)
              material.specular.fromArray(parameter.color);
            if (parameter.texture)
              material.specularMap = getTexture(parameter.texture);
            break;
          case "bump":
            if (parameter.texture)
              material.normalMap = getTexture(parameter.texture);
            break;
          case "ambient":
            if (parameter.texture)
              material.lightMap = getTexture(parameter.texture);
            break;
          case "shininess":
            if (parameter.float && material.shininess)
              material.shininess = parameter.float;
            break;
          case "emission":
            if (parameter.color && material.emissive)
              material.emissive.fromArray(parameter.color);
            if (parameter.texture)
              material.emissiveMap = getTexture(parameter.texture);
            break;
        }
      }
      let transparent = parameters["transparent"];
      let transparency = parameters["transparency"];
      if (transparency === void 0 && transparent) {
        transparency = {
          float: 1
        };
      }
      if (transparent === void 0 && transparency) {
        transparent = {
          opaque: "A_ONE",
          data: {
            color: [1, 1, 1, 1]
          }
        };
      }
      if (transparent && transparency) {
        if (transparent.data.texture) {
          material.transparent = true;
        } else {
          const color2 = transparent.data.color;
          switch (transparent.opaque) {
            case "A_ONE":
              material.opacity = color2[3] * transparency.float;
              break;
            case "RGB_ZERO":
              material.opacity = 1 - color2[0] * transparency.float;
              break;
            case "A_ZERO":
              material.opacity = 1 - color2[3] * transparency.float;
              break;
            case "RGB_ONE":
              material.opacity = color2[0] * transparency.float;
              break;
            default:
              console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', transparent.opaque);
          }
          if (material.opacity < 1)
            material.transparent = true;
        }
      }
      if (technique.extra !== void 0 && technique.extra.technique !== void 0) {
        const techniques = technique.extra.technique;
        for (const k in techniques) {
          const v = techniques[k];
          switch (k) {
            case "double_sided":
              material.side = v === 1 ? DoubleSide : FrontSide;
              break;
            case "bump":
              material.normalMap = getTexture(v.texture);
              material.normalScale = new Vector2(1, 1);
              break;
          }
        }
      }
      return material;
    }
    function getMaterial2(id) {
      return getBuild(library.materials[id], buildMaterial);
    }
    function parseCamera(xml2) {
      const data = {
        name: xml2.getAttribute("name")
      };
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "optics":
            data.optics = parseCameraOptics(child);
            break;
        }
      }
      library.cameras[xml2.getAttribute("id")] = data;
    }
    function parseCameraOptics(xml2) {
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        switch (child.nodeName) {
          case "technique_common":
            return parseCameraTechnique(child);
        }
      }
      return {};
    }
    function parseCameraTechnique(xml2) {
      const data = {};
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        switch (child.nodeName) {
          case "perspective":
          case "orthographic":
            data.technique = child.nodeName;
            data.parameters = parseCameraParameters(child);
            break;
        }
      }
      return data;
    }
    function parseCameraParameters(xml2) {
      const data = {};
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        switch (child.nodeName) {
          case "xfov":
          case "yfov":
          case "xmag":
          case "ymag":
          case "znear":
          case "zfar":
          case "aspect_ratio":
            data[child.nodeName] = parseFloat(child.textContent);
            break;
        }
      }
      return data;
    }
    function buildCamera(data) {
      let camera;
      switch (data.optics.technique) {
        case "perspective":
          camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);
          break;
        case "orthographic":
          let ymag = data.optics.parameters.ymag;
          let xmag = data.optics.parameters.xmag;
          const aspectRatio = data.optics.parameters.aspect_ratio;
          xmag = xmag === void 0 ? ymag * aspectRatio : xmag;
          ymag = ymag === void 0 ? xmag / aspectRatio : ymag;
          xmag *= 0.5;
          ymag *= 0.5;
          camera = new OrthographicCamera(
            -xmag,
            xmag,
            ymag,
            -ymag,
            data.optics.parameters.znear,
            data.optics.parameters.zfar
          );
          break;
        default:
          camera = new PerspectiveCamera();
          break;
      }
      camera.name = data.name || "";
      return camera;
    }
    function getCamera(id) {
      const data = library.cameras[id];
      if (data !== void 0) {
        return getBuild(data, buildCamera);
      }
      console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", id);
      return null;
    }
    function parseLight(xml2) {
      let data = {};
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "technique_common":
            data = parseLightTechnique(child);
            break;
        }
      }
      library.lights[xml2.getAttribute("id")] = data;
    }
    function parseLightTechnique(xml2) {
      const data = {};
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "directional":
          case "point":
          case "spot":
          case "ambient":
            data.technique = child.nodeName;
            data.parameters = parseLightParameters(child);
        }
      }
      return data;
    }
    function parseLightParameters(xml2) {
      const data = {};
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "color":
            const array = parseFloats(child.textContent);
            data.color = new Color().fromArray(array);
            break;
          case "falloff_angle":
            data.falloffAngle = parseFloat(child.textContent);
            break;
          case "quadratic_attenuation":
            const f = parseFloat(child.textContent);
            data.distance = f ? Math.sqrt(1 / f) : 0;
            break;
        }
      }
      return data;
    }
    function buildLight(data) {
      let light;
      switch (data.technique) {
        case "directional":
          light = new DirectionalLight();
          break;
        case "point":
          light = new PointLight();
          break;
        case "spot":
          light = new SpotLight();
          break;
        case "ambient":
          light = new AmbientLight();
          break;
      }
      if (data.parameters.color)
        light.color.copy(data.parameters.color);
      if (data.parameters.distance)
        light.distance = data.parameters.distance;
      return light;
    }
    function getLight(id) {
      const data = library.lights[id];
      if (data !== void 0) {
        return getBuild(data, buildLight);
      }
      console.warn("THREE.ColladaLoader: Couldn't find light with ID:", id);
      return null;
    }
    function parseGeometry(xml2) {
      const data = {
        name: xml2.getAttribute("name"),
        sources: {},
        vertices: {},
        primitives: []
      };
      const mesh = getElementsByTagName(xml2, "mesh")[0];
      if (mesh === void 0)
        return;
      for (let i2 = 0; i2 < mesh.childNodes.length; i2++) {
        const child = mesh.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        const id = child.getAttribute("id");
        switch (child.nodeName) {
          case "source":
            data.sources[id] = parseSource(child);
            break;
          case "vertices":
            data.vertices = parseGeometryVertices(child);
            break;
          case "polygons":
            console.warn("THREE.ColladaLoader: Unsupported primitive type: ", child.nodeName);
            break;
          case "lines":
          case "linestrips":
          case "polylist":
          case "triangles":
            data.primitives.push(parseGeometryPrimitive(child));
            break;
          default:
            console.log(child);
        }
      }
      library.geometries[xml2.getAttribute("id")] = data;
    }
    function parseSource(xml2) {
      const data = {
        array: [],
        stride: 3
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "float_array":
            data.array = parseFloats(child.textContent);
            break;
          case "Name_array":
            data.array = parseStrings(child.textContent);
            break;
          case "technique_common":
            const accessor = getElementsByTagName(child, "accessor")[0];
            if (accessor !== void 0) {
              data.stride = parseInt(accessor.getAttribute("stride"));
            }
            break;
        }
      }
      return data;
    }
    function parseGeometryVertices(xml2) {
      const data = {};
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        data[child.getAttribute("semantic")] = parseId(child.getAttribute("source"));
      }
      return data;
    }
    function parseGeometryPrimitive(xml2) {
      const primitive = {
        type: xml2.nodeName,
        material: xml2.getAttribute("material"),
        count: parseInt(xml2.getAttribute("count")),
        inputs: {},
        stride: 0,
        hasUV: false
      };
      for (let i2 = 0, l = xml2.childNodes.length; i2 < l; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "input":
            const id = parseId(child.getAttribute("source"));
            const semantic = child.getAttribute("semantic");
            const offset = parseInt(child.getAttribute("offset"));
            const set = parseInt(child.getAttribute("set"));
            const inputname = set > 0 ? semantic + set : semantic;
            primitive.inputs[inputname] = {
              id,
              offset
            };
            primitive.stride = Math.max(primitive.stride, offset + 1);
            if (semantic === "TEXCOORD")
              primitive.hasUV = true;
            break;
          case "vcount":
            primitive.vcount = parseInts(child.textContent);
            break;
          case "p":
            primitive.p = parseInts(child.textContent);
            break;
        }
      }
      return primitive;
    }
    function groupPrimitives(primitives) {
      const build = {};
      for (let i2 = 0; i2 < primitives.length; i2++) {
        const primitive = primitives[i2];
        if (build[primitive.type] === void 0)
          build[primitive.type] = [];
        build[primitive.type].push(primitive);
      }
      return build;
    }
    function checkUVCoordinates(primitives) {
      let count2 = 0;
      for (let i2 = 0, l = primitives.length; i2 < l; i2++) {
        const primitive = primitives[i2];
        if (primitive.hasUV === true) {
          count2++;
        }
      }
      if (count2 > 0 && count2 < primitives.length) {
        primitives.uvsNeedsFix = true;
      }
    }
    function buildGeometry(data) {
      const build = {};
      const sources = data.sources;
      const vertices = data.vertices;
      const primitives = data.primitives;
      if (primitives.length === 0)
        return {};
      const groupedPrimitives = groupPrimitives(primitives);
      for (const type2 in groupedPrimitives) {
        const primitiveType = groupedPrimitives[type2];
        checkUVCoordinates(primitiveType);
        build[type2] = buildGeometryType(primitiveType, sources, vertices);
      }
      return build;
    }
    function buildGeometryType(primitives, sources, vertices) {
      const build = {};
      const position2 = {
        array: [],
        stride: 0
      };
      const normal = {
        array: [],
        stride: 0
      };
      const uv2 = {
        array: [],
        stride: 0
      };
      const uv22 = {
        array: [],
        stride: 0
      };
      const color2 = {
        array: [],
        stride: 0
      };
      const skinIndex = {
        array: [],
        stride: 4
      };
      const skinWeight = {
        array: [],
        stride: 4
      };
      const geometry = new BufferGeometry();
      const materialKeys = [];
      let start = 0;
      for (let p = 0; p < primitives.length; p++) {
        const primitive = primitives[p];
        const inputs = primitive.inputs;
        let count2 = 0;
        switch (primitive.type) {
          case "lines":
          case "linestrips":
            count2 = primitive.count * 2;
            break;
          case "triangles":
            count2 = primitive.count * 3;
            break;
          case "polylist":
            for (let g2 = 0; g2 < primitive.count; g2++) {
              const vc = primitive.vcount[g2];
              switch (vc) {
                case 3:
                  count2 += 3;
                  break;
                case 4:
                  count2 += 6;
                  break;
                default:
                  count2 += (vc - 2) * 3;
                  break;
              }
            }
            break;
          default:
            console.warn("THREE.ColladaLoader: Unknow primitive type:", primitive.type);
        }
        geometry.addGroup(start, count2, p);
        start += count2;
        if (primitive.material) {
          materialKeys.push(primitive.material);
        }
        for (const name in inputs) {
          const input = inputs[name];
          switch (name) {
            case "VERTEX":
              for (const key in vertices) {
                const id = vertices[key];
                switch (key) {
                  case "POSITION":
                    const prevLength = position2.array.length;
                    buildGeometryData(primitive, sources[id], input.offset, position2.array);
                    position2.stride = sources[id].stride;
                    if (sources.skinWeights && sources.skinIndices) {
                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);
                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);
                    }
                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {
                      const count3 = (position2.array.length - prevLength) / position2.stride;
                      for (let i2 = 0; i2 < count3; i2++) {
                        uv2.array.push(0, 0);
                      }
                    }
                    break;
                  case "NORMAL":
                    buildGeometryData(primitive, sources[id], input.offset, normal.array);
                    normal.stride = sources[id].stride;
                    break;
                  case "COLOR":
                    buildGeometryData(primitive, sources[id], input.offset, color2.array);
                    color2.stride = sources[id].stride;
                    break;
                  case "TEXCOORD":
                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);
                    uv2.stride = sources[id].stride;
                    break;
                  case "TEXCOORD1":
                    buildGeometryData(primitive, sources[id], input.offset, uv22.array);
                    uv2.stride = sources[id].stride;
                    break;
                  default:
                    console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', key);
                }
              }
              break;
            case "NORMAL":
              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);
              normal.stride = sources[input.id].stride;
              break;
            case "COLOR":
              buildGeometryData(primitive, sources[input.id], input.offset, color2.array);
              color2.stride = sources[input.id].stride;
              break;
            case "TEXCOORD":
              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);
              uv2.stride = sources[input.id].stride;
              break;
            case "TEXCOORD1":
              buildGeometryData(primitive, sources[input.id], input.offset, uv22.array);
              uv22.stride = sources[input.id].stride;
              break;
          }
        }
      }
      if (position2.array.length > 0) {
        geometry.setAttribute("position", new Float32BufferAttribute(position2.array, position2.stride));
      }
      if (normal.array.length > 0) {
        geometry.setAttribute("normal", new Float32BufferAttribute(normal.array, normal.stride));
      }
      if (color2.array.length > 0)
        geometry.setAttribute("color", new Float32BufferAttribute(color2.array, color2.stride));
      if (uv2.array.length > 0)
        geometry.setAttribute("uv", new Float32BufferAttribute(uv2.array, uv2.stride));
      if (uv22.array.length > 0)
        geometry.setAttribute("uv2", new Float32BufferAttribute(uv22.array, uv22.stride));
      if (skinIndex.array.length > 0) {
        geometry.setAttribute("skinIndex", new Float32BufferAttribute(skinIndex.array, skinIndex.stride));
      }
      if (skinWeight.array.length > 0) {
        geometry.setAttribute("skinWeight", new Float32BufferAttribute(skinWeight.array, skinWeight.stride));
      }
      build.data = geometry;
      build.type = primitives[0].type;
      build.materialKeys = materialKeys;
      return build;
    }
    function buildGeometryData(primitive, source, offset, array) {
      const indices = primitive.p;
      const stride = primitive.stride;
      const vcount = primitive.vcount;
      function pushVector(i2) {
        let index = indices[i2 + offset] * sourceStride;
        const length2 = index + sourceStride;
        for (; index < length2; index++) {
          array.push(sourceArray[index]);
        }
      }
      const sourceArray = source.array;
      const sourceStride = source.stride;
      if (primitive.vcount !== void 0) {
        let index = 0;
        for (let i2 = 0, l = vcount.length; i2 < l; i2++) {
          const count2 = vcount[i2];
          if (count2 === 4) {
            const a2 = index + stride * 0;
            const b3 = index + stride * 1;
            const c = index + stride * 2;
            const d = index + stride * 3;
            pushVector(a2);
            pushVector(b3);
            pushVector(d);
            pushVector(b3);
            pushVector(c);
            pushVector(d);
          } else if (count2 === 3) {
            const a2 = index + stride * 0;
            const b3 = index + stride * 1;
            const c = index + stride * 2;
            pushVector(a2);
            pushVector(b3);
            pushVector(c);
          } else if (count2 > 4) {
            for (let k = 1, kl = count2 - 2; k <= kl; k++) {
              const a2 = index + stride * 0;
              const b3 = index + stride * k;
              const c = index + stride * (k + 1);
              pushVector(a2);
              pushVector(b3);
              pushVector(c);
            }
          }
          index += stride * count2;
        }
      } else {
        for (let i2 = 0, l = indices.length; i2 < l; i2 += stride) {
          pushVector(i2);
        }
      }
    }
    function getGeometry(id) {
      return getBuild(library.geometries[id], buildGeometry);
    }
    function parseKinematicsModel(xml2) {
      const data = {
        name: xml2.getAttribute("name") || "",
        joints: {},
        links: []
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "technique_common":
            parseKinematicsTechniqueCommon(child, data);
            break;
        }
      }
      library.kinematicsModels[xml2.getAttribute("id")] = data;
    }
    function buildKinematicsModel(data) {
      if (data.build !== void 0)
        return data.build;
      return data;
    }
    function getKinematicsModel(id) {
      return getBuild(library.kinematicsModels[id], buildKinematicsModel);
    }
    function parseKinematicsTechniqueCommon(xml2, data) {
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "joint":
            data.joints[child.getAttribute("sid")] = parseKinematicsJoint(child);
            break;
          case "link":
            data.links.push(parseKinematicsLink(child));
            break;
        }
      }
    }
    function parseKinematicsJoint(xml2) {
      let data;
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "prismatic":
          case "revolute":
            data = parseKinematicsJointParameter(child);
            break;
        }
      }
      return data;
    }
    function parseKinematicsJointParameter(xml2) {
      const data = {
        sid: xml2.getAttribute("sid"),
        name: xml2.getAttribute("name") || "",
        axis: new Vector3(),
        limits: {
          min: 0,
          max: 0
        },
        type: xml2.nodeName,
        static: false,
        zeroPosition: 0,
        middlePosition: 0
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "axis":
            const array = parseFloats(child.textContent);
            data.axis.fromArray(array);
            break;
          case "limits":
            const max3 = child.getElementsByTagName("max")[0];
            const min2 = child.getElementsByTagName("min")[0];
            data.limits.max = parseFloat(max3.textContent);
            data.limits.min = parseFloat(min2.textContent);
            break;
        }
      }
      if (data.limits.min >= data.limits.max) {
        data.static = true;
      }
      data.middlePosition = (data.limits.min + data.limits.max) / 2;
      return data;
    }
    function parseKinematicsLink(xml2) {
      const data = {
        sid: xml2.getAttribute("sid"),
        name: xml2.getAttribute("name") || "",
        attachments: [],
        transforms: []
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "attachment_full":
            data.attachments.push(parseKinematicsAttachment(child));
            break;
          case "matrix":
          case "translate":
          case "rotate":
            data.transforms.push(parseKinematicsTransform(child));
            break;
        }
      }
      return data;
    }
    function parseKinematicsAttachment(xml2) {
      const data = {
        joint: xml2.getAttribute("joint").split("/").pop(),
        transforms: [],
        links: []
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "link":
            data.links.push(parseKinematicsLink(child));
            break;
          case "matrix":
          case "translate":
          case "rotate":
            data.transforms.push(parseKinematicsTransform(child));
            break;
        }
      }
      return data;
    }
    function parseKinematicsTransform(xml2) {
      const data = {
        type: xml2.nodeName
      };
      const array = parseFloats(xml2.textContent);
      switch (data.type) {
        case "matrix":
          data.obj = new Matrix4();
          data.obj.fromArray(array).transpose();
          break;
        case "translate":
          data.obj = new Vector3();
          data.obj.fromArray(array);
          break;
        case "rotate":
          data.obj = new Vector3();
          data.obj.fromArray(array);
          data.angle = MathUtils.degToRad(array[3]);
          break;
      }
      return data;
    }
    function parsePhysicsModel(xml2) {
      const data = {
        name: xml2.getAttribute("name") || "",
        rigidBodies: {}
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "rigid_body":
            data.rigidBodies[child.getAttribute("name")] = {};
            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute("name")]);
            break;
        }
      }
      library.physicsModels[xml2.getAttribute("id")] = data;
    }
    function parsePhysicsRigidBody(xml2, data) {
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "technique_common":
            parsePhysicsTechniqueCommon(child, data);
            break;
        }
      }
    }
    function parsePhysicsTechniqueCommon(xml2, data) {
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "inertia":
            data.inertia = parseFloats(child.textContent);
            break;
          case "mass":
            data.mass = parseFloats(child.textContent)[0];
            break;
        }
      }
    }
    function parseKinematicsScene(xml2) {
      const data = {
        bindJointAxis: []
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "bind_joint_axis":
            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));
            break;
        }
      }
      library.kinematicsScenes[parseId(xml2.getAttribute("url"))] = data;
    }
    function parseKinematicsBindJointAxis(xml2) {
      const data = {
        target: xml2.getAttribute("target").split("/").pop()
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        switch (child.nodeName) {
          case "axis":
            const param = child.getElementsByTagName("param")[0];
            data.axis = param.textContent;
            const tmpJointIndex = data.axis.split("inst_").pop().split("axis")[0];
            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);
            break;
        }
      }
      return data;
    }
    function buildKinematicsScene(data) {
      if (data.build !== void 0)
        return data.build;
      return data;
    }
    function getKinematicsScene(id) {
      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);
    }
    function setupKinematics() {
      const kinematicsModelId = Object.keys(library.kinematicsModels)[0];
      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];
      const visualSceneId = Object.keys(library.visualScenes)[0];
      if (kinematicsModelId === void 0 || kinematicsSceneId === void 0)
        return;
      const kinematicsModel = getKinematicsModel(kinematicsModelId);
      const kinematicsScene = getKinematicsScene(kinematicsSceneId);
      const visualScene = getVisualScene(visualSceneId);
      const bindJointAxis = kinematicsScene.bindJointAxis;
      const jointMap = {};
      for (let i2 = 0, l = bindJointAxis.length; i2 < l; i2++) {
        const axis = bindJointAxis[i2];
        const targetElement = collada.querySelector('[sid="' + axis.target + '"]');
        if (targetElement) {
          const parentVisualElement = targetElement.parentElement;
          connect(axis.jointIndex, parentVisualElement);
        }
      }
      function connect(jointIndex, visualElement) {
        const visualElementName = visualElement.getAttribute("name");
        const joint = kinematicsModel.joints[jointIndex];
        visualScene.traverse(function(object) {
          if (object.name === visualElementName) {
            jointMap[jointIndex] = {
              object,
              transforms: buildTransformList(visualElement),
              joint,
              position: joint.zeroPosition
            };
          }
        });
      }
      const m0 = new Matrix4();
      kinematics = {
        joints: kinematicsModel && kinematicsModel.joints,
        getJointValue: function(jointIndex) {
          const jointData = jointMap[jointIndex];
          if (jointData) {
            return jointData.position;
          } else {
            console.warn("THREE.ColladaLoader: Joint " + jointIndex + " doesn't exist.");
          }
        },
        setJointValue: function(jointIndex, value) {
          const jointData = jointMap[jointIndex];
          if (jointData) {
            const joint = jointData.joint;
            if (value > joint.limits.max || value < joint.limits.min) {
              console.warn("THREE.ColladaLoader: Joint " + jointIndex + " value " + value + " outside of limits (min: " + joint.limits.min + ", max: " + joint.limits.max + ").");
            } else if (joint.static) {
              console.warn("THREE.ColladaLoader: Joint " + jointIndex + " is static.");
            } else {
              const object = jointData.object;
              const axis = joint.axis;
              const transforms = jointData.transforms;
              matrix3.identity();
              for (let i2 = 0; i2 < transforms.length; i2++) {
                const transform = transforms[i2];
                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {
                  switch (joint.type) {
                    case "revolute":
                      matrix3.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));
                      break;
                    case "prismatic":
                      matrix3.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));
                      break;
                    default:
                      console.warn("THREE.ColladaLoader: Unknown joint type: " + joint.type);
                      break;
                  }
                } else {
                  switch (transform.type) {
                    case "matrix":
                      matrix3.multiply(transform.obj);
                      break;
                    case "translate":
                      matrix3.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));
                      break;
                    case "scale":
                      matrix3.scale(transform.obj);
                      break;
                    case "rotate":
                      matrix3.multiply(m0.makeRotationAxis(transform.obj, transform.angle));
                      break;
                  }
                }
              }
              object.matrix.copy(matrix3);
              object.matrix.decompose(object.position, object.quaternion, object.scale);
              jointMap[jointIndex].position = value;
            }
          } else {
            console.log("THREE.ColladaLoader: " + jointIndex + " does not exist.");
          }
        }
      };
    }
    function buildTransformList(node) {
      const transforms = [];
      const xml2 = collada.querySelector('[id="' + node.id + '"]');
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        let array, vector3;
        switch (child.nodeName) {
          case "matrix":
            array = parseFloats(child.textContent);
            const matrix4 = new Matrix4().fromArray(array).transpose();
            transforms.push({
              sid: child.getAttribute("sid"),
              type: child.nodeName,
              obj: matrix4
            });
            break;
          case "translate":
          case "scale":
            array = parseFloats(child.textContent);
            vector3 = new Vector3().fromArray(array);
            transforms.push({
              sid: child.getAttribute("sid"),
              type: child.nodeName,
              obj: vector3
            });
            break;
          case "rotate":
            array = parseFloats(child.textContent);
            vector3 = new Vector3().fromArray(array);
            const angle = MathUtils.degToRad(array[3]);
            transforms.push({
              sid: child.getAttribute("sid"),
              type: child.nodeName,
              obj: vector3,
              angle
            });
            break;
        }
      }
      return transforms;
    }
    function prepareNodes(xml2) {
      const elements = xml2.getElementsByTagName("node");
      for (let i2 = 0; i2 < elements.length; i2++) {
        const element2 = elements[i2];
        if (element2.hasAttribute("id") === false) {
          element2.setAttribute("id", generateId());
        }
      }
    }
    const matrix3 = new Matrix4();
    const vector2 = new Vector3();
    function parseNode(xml2) {
      const data = {
        name: xml2.getAttribute("name") || "",
        type: xml2.getAttribute("type"),
        id: xml2.getAttribute("id"),
        sid: xml2.getAttribute("sid"),
        matrix: new Matrix4(),
        nodes: [],
        instanceCameras: [],
        instanceControllers: [],
        instanceLights: [],
        instanceGeometries: [],
        instanceNodes: [],
        transforms: {}
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        if (child.nodeType !== 1)
          continue;
        let array;
        switch (child.nodeName) {
          case "node":
            data.nodes.push(child.getAttribute("id"));
            parseNode(child);
            break;
          case "instance_camera":
            data.instanceCameras.push(parseId(child.getAttribute("url")));
            break;
          case "instance_controller":
            data.instanceControllers.push(parseNodeInstance(child));
            break;
          case "instance_light":
            data.instanceLights.push(parseId(child.getAttribute("url")));
            break;
          case "instance_geometry":
            data.instanceGeometries.push(parseNodeInstance(child));
            break;
          case "instance_node":
            data.instanceNodes.push(parseId(child.getAttribute("url")));
            break;
          case "matrix":
            array = parseFloats(child.textContent);
            data.matrix.multiply(matrix3.fromArray(array).transpose());
            data.transforms[child.getAttribute("sid")] = child.nodeName;
            break;
          case "translate":
            array = parseFloats(child.textContent);
            vector2.fromArray(array);
            data.matrix.multiply(matrix3.makeTranslation(vector2.x, vector2.y, vector2.z));
            data.transforms[child.getAttribute("sid")] = child.nodeName;
            break;
          case "rotate":
            array = parseFloats(child.textContent);
            const angle = MathUtils.degToRad(array[3]);
            data.matrix.multiply(matrix3.makeRotationAxis(vector2.fromArray(array), angle));
            data.transforms[child.getAttribute("sid")] = child.nodeName;
            break;
          case "scale":
            array = parseFloats(child.textContent);
            data.matrix.scale(vector2.fromArray(array));
            data.transforms[child.getAttribute("sid")] = child.nodeName;
            break;
          case "extra":
            break;
          default:
            console.log(child);
        }
      }
      if (hasNode(data.id)) {
        console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.", data.id);
      } else {
        library.nodes[data.id] = data;
      }
      return data;
    }
    function parseNodeInstance(xml2) {
      const data = {
        id: parseId(xml2.getAttribute("url")),
        materials: {},
        skeletons: []
      };
      for (let i2 = 0; i2 < xml2.childNodes.length; i2++) {
        const child = xml2.childNodes[i2];
        switch (child.nodeName) {
          case "bind_material":
            const instances = child.getElementsByTagName("instance_material");
            for (let j2 = 0; j2 < instances.length; j2++) {
              const instance = instances[j2];
              const symbol = instance.getAttribute("symbol");
              const target = instance.getAttribute("target");
              data.materials[symbol] = parseId(target);
            }
            break;
          case "skeleton":
            data.skeletons.push(parseId(child.textContent));
            break;
        }
      }
      return data;
    }
    function buildSkeleton(skeletons, joints) {
      const boneData = [];
      const sortedBoneData = [];
      let i2, j2, data;
      for (i2 = 0; i2 < skeletons.length; i2++) {
        const skeleton = skeletons[i2];
        let root;
        if (hasNode(skeleton)) {
          root = getNode(skeleton);
          buildBoneHierarchy(root, joints, boneData);
        } else if (hasVisualScene(skeleton)) {
          const visualScene = library.visualScenes[skeleton];
          const children = visualScene.children;
          for (let j3 = 0; j3 < children.length; j3++) {
            const child = children[j3];
            if (child.type === "JOINT") {
              const root2 = getNode(child.id);
              buildBoneHierarchy(root2, joints, boneData);
            }
          }
        } else {
          console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", skeleton);
        }
      }
      for (i2 = 0; i2 < joints.length; i2++) {
        for (j2 = 0; j2 < boneData.length; j2++) {
          data = boneData[j2];
          if (data.bone.name === joints[i2].name) {
            sortedBoneData[i2] = data;
            data.processed = true;
            break;
          }
        }
      }
      for (i2 = 0; i2 < boneData.length; i2++) {
        data = boneData[i2];
        if (data.processed === false) {
          sortedBoneData.push(data);
          data.processed = true;
        }
      }
      const bones = [];
      const boneInverses = [];
      for (i2 = 0; i2 < sortedBoneData.length; i2++) {
        data = sortedBoneData[i2];
        bones.push(data.bone);
        boneInverses.push(data.boneInverse);
      }
      return new Skeleton(bones, boneInverses);
    }
    function buildBoneHierarchy(root, joints, boneData) {
      root.traverse(function(object) {
        if (object.isBone === true) {
          let boneInverse;
          for (let i2 = 0; i2 < joints.length; i2++) {
            const joint = joints[i2];
            if (joint.name === object.name) {
              boneInverse = joint.boneInverse;
              break;
            }
          }
          if (boneInverse === void 0) {
            boneInverse = new Matrix4();
          }
          boneData.push({
            bone: object,
            boneInverse,
            processed: false
          });
        }
      });
    }
    function buildNode(data) {
      const objects = [];
      const matrix4 = data.matrix;
      const nodes = data.nodes;
      const type2 = data.type;
      const instanceCameras = data.instanceCameras;
      const instanceControllers = data.instanceControllers;
      const instanceLights = data.instanceLights;
      const instanceGeometries = data.instanceGeometries;
      const instanceNodes = data.instanceNodes;
      for (let i2 = 0, l = nodes.length; i2 < l; i2++) {
        objects.push(getNode(nodes[i2]));
      }
      for (let i2 = 0, l = instanceCameras.length; i2 < l; i2++) {
        const instanceCamera = getCamera(instanceCameras[i2]);
        if (instanceCamera !== null) {
          objects.push(instanceCamera.clone());
        }
      }
      for (let i2 = 0, l = instanceControllers.length; i2 < l; i2++) {
        const instance = instanceControllers[i2];
        const controller = getController(instance.id);
        const geometries = getGeometry(controller.id);
        const newObjects = buildObjects(geometries, instance.materials);
        const skeletons = instance.skeletons;
        const joints = controller.skin.joints;
        const skeleton = buildSkeleton(skeletons, joints);
        for (let j2 = 0, jl2 = newObjects.length; j2 < jl2; j2++) {
          const object2 = newObjects[j2];
          if (object2.isSkinnedMesh) {
            object2.bind(skeleton, controller.skin.bindMatrix);
            object2.normalizeSkinWeights();
          }
          objects.push(object2);
        }
      }
      for (let i2 = 0, l = instanceLights.length; i2 < l; i2++) {
        const instanceLight = getLight(instanceLights[i2]);
        if (instanceLight !== null) {
          objects.push(instanceLight.clone());
        }
      }
      for (let i2 = 0, l = instanceGeometries.length; i2 < l; i2++) {
        const instance = instanceGeometries[i2];
        const geometries = getGeometry(instance.id);
        const newObjects = buildObjects(geometries, instance.materials);
        for (let j2 = 0, jl2 = newObjects.length; j2 < jl2; j2++) {
          objects.push(newObjects[j2]);
        }
      }
      for (let i2 = 0, l = instanceNodes.length; i2 < l; i2++) {
        objects.push(getNode(instanceNodes[i2]).clone());
      }
      let object;
      if (nodes.length === 0 && objects.length === 1) {
        object = objects[0];
      } else {
        object = type2 === "JOINT" ? new Bone() : new Group();
        for (let i2 = 0; i2 < objects.length; i2++) {
          object.add(objects[i2]);
        }
      }
      object.name = type2 === "JOINT" ? data.sid : data.name;
      object.matrix.copy(matrix4);
      object.matrix.decompose(object.position, object.quaternion, object.scale);
      return object;
    }
    const fallbackMaterial = new MeshBasicMaterial({
      color: 16711935
    });
    function resolveMaterialBinding(keys, instanceMaterials) {
      const materials = [];
      for (let i2 = 0, l = keys.length; i2 < l; i2++) {
        const id = instanceMaterials[keys[i2]];
        if (id === void 0) {
          console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", keys[i2]);
          materials.push(fallbackMaterial);
        } else {
          materials.push(getMaterial2(id));
        }
      }
      return materials;
    }
    function buildObjects(geometries, instanceMaterials) {
      const objects = [];
      for (const type2 in geometries) {
        const geometry = geometries[type2];
        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);
        if (materials.length === 0) {
          if (type2 === "lines" || type2 === "linestrips") {
            materials.push(new LineBasicMaterial());
          } else {
            materials.push(new MeshPhongMaterial());
          }
        }
        const skinning = geometry.data.attributes.skinIndex !== void 0;
        const material = materials.length === 1 ? materials[0] : materials;
        let object;
        switch (type2) {
          case "lines":
            object = new LineSegments(geometry.data, material);
            break;
          case "linestrips":
            object = new Line(geometry.data, material);
            break;
          case "triangles":
          case "polylist":
            if (skinning) {
              object = new SkinnedMesh(geometry.data, material);
            } else {
              object = new Mesh(geometry.data, material);
            }
            break;
        }
        objects.push(object);
      }
      return objects;
    }
    function hasNode(id) {
      return library.nodes[id] !== void 0;
    }
    function getNode(id) {
      return getBuild(library.nodes[id], buildNode);
    }
    function parseVisualScene(xml2) {
      const data = {
        name: xml2.getAttribute("name"),
        children: []
      };
      prepareNodes(xml2);
      const elements = getElementsByTagName(xml2, "node");
      for (let i2 = 0; i2 < elements.length; i2++) {
        data.children.push(parseNode(elements[i2]));
      }
      library.visualScenes[xml2.getAttribute("id")] = data;
    }
    function buildVisualScene(data) {
      const group = new Group();
      group.name = data.name;
      const children = data.children;
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        group.add(getNode(child.id));
      }
      return group;
    }
    function hasVisualScene(id) {
      return library.visualScenes[id] !== void 0;
    }
    function getVisualScene(id) {
      return getBuild(library.visualScenes[id], buildVisualScene);
    }
    function parseScene(xml2) {
      const instance = getElementsByTagName(xml2, "instance_visual_scene")[0];
      return getVisualScene(parseId(instance.getAttribute("url")));
    }
    function setupAnimations() {
      const clips = library.clips;
      if (isEmpty(clips) === true) {
        if (isEmpty(library.animations) === false) {
          const tracks = [];
          for (const id in library.animations) {
            const animationTracks = getAnimation(id);
            for (let i2 = 0, l = animationTracks.length; i2 < l; i2++) {
              tracks.push(animationTracks[i2]);
            }
          }
          animations.push(new AnimationClip("default", -1, tracks));
        }
      } else {
        for (const id in clips) {
          animations.push(getAnimationClip(id));
        }
      }
    }
    function parserErrorToText(parserError2) {
      let result = "";
      const stack = [parserError2];
      while (stack.length) {
        const node = stack.shift();
        if (node.nodeType === Node.TEXT_NODE) {
          result += node.textContent;
        } else {
          result += "\n";
          stack.push.apply(stack, node.childNodes);
        }
      }
      return result.trim();
    }
    if (text.length === 0) {
      return {
        scene: new Scene()
      };
    }
    const xml = new DOMParser().parseFromString(text, "application/xml");
    const collada = getElementsByTagName(xml, "COLLADA")[0];
    const parserError = xml.getElementsByTagName("parsererror")[0];
    if (parserError !== void 0) {
      const errorElement = getElementsByTagName(parserError, "div")[0];
      let errorText;
      if (errorElement) {
        errorText = errorElement.textContent;
      } else {
        errorText = parserErrorToText(parserError);
      }
      console.error("THREE.ColladaLoader: Failed to parse collada file.\n", errorText);
      return null;
    }
    const version = collada.getAttribute("version");
    console.log("THREE.ColladaLoader: File version", version);
    const asset = parseAsset(getElementsByTagName(collada, "asset")[0]);
    const textureLoader = new TextureLoader(this.manager);
    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    let tgaLoader;
    if (TGALoader) {
      tgaLoader = new TGALoader(this.manager);
      tgaLoader.setPath(this.resourcePath || path);
    }
    const animations = [];
    let kinematics = {};
    let count = 0;
    const library = {
      animations: {},
      clips: {},
      controllers: {},
      images: {},
      effects: {},
      materials: {},
      cameras: {},
      lights: {},
      geometries: {},
      nodes: {},
      visualScenes: {},
      kinematicsModels: {},
      physicsModels: {},
      kinematicsScenes: {}
    };
    parseLibrary(collada, "library_animations", "animation", parseAnimation);
    parseLibrary(collada, "library_animation_clips", "animation_clip", parseAnimationClip);
    parseLibrary(collada, "library_controllers", "controller", parseController);
    parseLibrary(collada, "library_images", "image", parseImage);
    parseLibrary(collada, "library_effects", "effect", parseEffect);
    parseLibrary(collada, "library_materials", "material", parseMaterial);
    parseLibrary(collada, "library_cameras", "camera", parseCamera);
    parseLibrary(collada, "library_lights", "light", parseLight);
    parseLibrary(collada, "library_geometries", "geometry", parseGeometry);
    parseLibrary(collada, "library_nodes", "node", parseNode);
    parseLibrary(collada, "library_visual_scenes", "visual_scene", parseVisualScene);
    parseLibrary(collada, "library_kinematics_models", "kinematics_model", parseKinematicsModel);
    parseLibrary(collada, "library_physics_models", "physics_model", parsePhysicsModel);
    parseLibrary(collada, "scene", "instance_kinematics_scene", parseKinematicsScene);
    buildLibrary(library.animations, buildAnimation);
    buildLibrary(library.clips, buildAnimationClip);
    buildLibrary(library.controllers, buildController);
    buildLibrary(library.images, buildImage);
    buildLibrary(library.effects, buildEffect);
    buildLibrary(library.materials, buildMaterial);
    buildLibrary(library.cameras, buildCamera);
    buildLibrary(library.lights, buildLight);
    buildLibrary(library.geometries, buildGeometry);
    buildLibrary(library.visualScenes, buildVisualScene);
    setupAnimations();
    setupKinematics();
    const scene = parseScene(getElementsByTagName(collada, "scene")[0]);
    scene.animations = animations;
    if (asset.upAxis === "Z_UP") {
      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));
    }
    scene.scale.multiplyScalar(asset.unit);
    return {
      get animations() {
        console.warn("THREE.ColladaLoader: Please access animations over scene.animations now.");
        return animations;
      },
      kinematics,
      library,
      scene
    };
  }
};

// node_modules/three-stdlib/loaders/KMZLoader.js
var KMZLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope2.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(data) {
    function findFile(url) {
      for (const path in zip) {
        if (path.substr(-url.length) === url) {
          return zip[path];
        }
      }
    }
    const manager = new LoadingManager();
    manager.setURLModifier(function(url) {
      const image = findFile(url);
      if (image) {
        console.log("Loading", url);
        const blob = new Blob([image.buffer], {
          type: "application/octet-stream"
        });
        return URL.createObjectURL(blob);
      }
      return url;
    });
    const zip = unzipSync(new Uint8Array(data));
    if (zip["doc.kml"]) {
      const xml = new DOMParser().parseFromString(fflate.strFromU8(zip["doc.kml"]), "application/xml");
      const model = xml.querySelector("Placemark Model Link href");
      if (model) {
        const loader = new ColladaLoader(manager);
        return loader.parse(fflate.strFromU8(zip[model.textContent]));
      }
    } else {
      console.warn("KMZLoader: Missing doc.kml file.");
      for (const path in zip) {
        const extension = path.split(".").pop().toLowerCase();
        if (extension === "dae") {
          const loader = new ColladaLoader(manager);
          return loader.parse(fflate.strFromU8(zip[path]));
        }
      }
    }
    console.error("KMZLoader: Couldn't find .dae file.");
    return {
      scene: new Group()
    };
  }
};

// node_modules/three-stdlib/loaders/VRMLoader.js
var VRMLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.gltfLoader = new GLTFLoader(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    this.gltfLoader.load(url, function(gltf) {
      try {
        scope2.parse(gltf, onLoad);
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  setDRACOLoader(dracoLoader) {
    this.gltfLoader.setDRACOLoader(dracoLoader);
    return this;
  }
  parse(gltf, onLoad) {
    onLoad(gltf);
  }
};

// node_modules/chevrotain/lib_esm/api_esm.mjs
var import_api = __toESM(require_api4(), 1);
var Alternation = import_api.default.Alternation;
var Alternative = import_api.default.Alternative;
var CstParser = import_api.default.CstParser;
var EMPTY_ALT = import_api.default.EMPTY_ALT;
var EOF = import_api.default.EOF;
var EarlyExitException = import_api.default.EarlyExitException;
var EmbeddedActionsParser = import_api.default.EmbeddedActionsParser;
var GAstVisitor = import_api.default.GAstVisitor;
var Lexer = import_api.default.Lexer;
var LexerDefinitionErrorType = import_api.default.LexerDefinitionErrorType;
var MismatchedTokenException = import_api.default.MismatchedTokenException;
var NoViableAltException = import_api.default.NoViableAltException;
var NonTerminal = import_api.default.NonTerminal;
var NotAllInputParsedException = import_api.default.NotAllInputParsedException;
var Option = import_api.default.Option;
var Parser2 = import_api.default.Parser;
var ParserDefinitionErrorType = import_api.default.ParserDefinitionErrorType;
var Repetition = import_api.default.Repetition;
var RepetitionMandatory = import_api.default.RepetitionMandatory;
var RepetitionMandatoryWithSeparator = import_api.default.RepetitionMandatoryWithSeparator;
var RepetitionWithSeparator = import_api.default.RepetitionWithSeparator;
var Rule = import_api.default.Rule;
var Terminal = import_api.default.Terminal;
var VERSION = import_api.default.VERSION;
var clearCache = import_api.default.clearCache;
var createSyntaxDiagramsCode = import_api.default.createSyntaxDiagramsCode;
var createToken = import_api.default.createToken;
var createTokenInstance = import_api.default.createTokenInstance;
var defaultLexerErrorProvider = import_api.default.defaultLexerErrorProvider;
var defaultParserErrorProvider = import_api.default.defaultParserErrorProvider;
var generateCstDts = import_api.default.generateCstDts;
var isRecognitionException = import_api.default.isRecognitionException;
var serializeGrammar = import_api.default.serializeGrammar;
var serializeProduction = import_api.default.serializeProduction;
var tokenLabel = import_api.default.tokenLabel;
var tokenMatcher = import_api.default.tokenMatcher;
var tokenName = import_api.default.tokenName;

// node_modules/three-stdlib/loaders/VRMLLoader.js
var VRMLLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const path = scope2.path === "" ? LoaderUtils.extractUrlBase(url) : scope2.path;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope2.parse(text, path));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(data, path) {
    const nodeMap = {};
    function generateVRMLTree(data2) {
      const tokenData = createTokens();
      const lexer = new VRMLLexer(tokenData.tokens);
      const parser = new VRMLParser(tokenData.tokenVocabulary);
      const visitor = createVisitor(parser.getBaseCstVisitorConstructor());
      const lexingResult = lexer.lex(data2);
      parser.input = lexingResult.tokens;
      const cstOutput = parser.vrml();
      if (parser.errors.length > 0) {
        console.error(parser.errors);
        throw Error("THREE.VRMLLoader: Parsing errors detected.");
      }
      const ast = visitor.visit(cstOutput);
      return ast;
    }
    function createTokens() {
      const RouteIdentifier = createToken({
        name: "RouteIdentifier",
        pattern: /[^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*[\.][^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*/
      });
      const Identifier = createToken({
        name: "Identifier",
        pattern: /[^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*/,
        longer_alt: RouteIdentifier
      });
      const nodeTypes = [
        "Anchor",
        "Billboard",
        "Collision",
        "Group",
        "Transform",
        "Inline",
        "LOD",
        "Switch",
        "AudioClip",
        "DirectionalLight",
        "PointLight",
        "Script",
        "Shape",
        "Sound",
        "SpotLight",
        "WorldInfo",
        "CylinderSensor",
        "PlaneSensor",
        "ProximitySensor",
        "SphereSensor",
        "TimeSensor",
        "TouchSensor",
        "VisibilitySensor",
        "Box",
        "Cone",
        "Cylinder",
        "ElevationGrid",
        "Extrusion",
        "IndexedFaceSet",
        "IndexedLineSet",
        "PointSet",
        "Sphere",
        "Color",
        "Coordinate",
        "Normal",
        "TextureCoordinate",
        "Appearance",
        "FontStyle",
        "ImageTexture",
        "Material",
        "MovieTexture",
        "PixelTexture",
        "TextureTransform",
        "ColorInterpolator",
        "CoordinateInterpolator",
        "NormalInterpolator",
        "OrientationInterpolator",
        "PositionInterpolator",
        "ScalarInterpolator",
        "Background",
        "Fog",
        "NavigationInfo",
        "Viewpoint",
        "Text"
      ];
      const Version = createToken({
        name: "Version",
        pattern: /#VRML.*/,
        longer_alt: Identifier
      });
      const NodeName = createToken({
        name: "NodeName",
        pattern: new RegExp(nodeTypes.join("|")),
        longer_alt: Identifier
      });
      const DEF = createToken({
        name: "DEF",
        pattern: /DEF/,
        longer_alt: Identifier
      });
      const USE = createToken({
        name: "USE",
        pattern: /USE/,
        longer_alt: Identifier
      });
      const ROUTE = createToken({
        name: "ROUTE",
        pattern: /ROUTE/,
        longer_alt: Identifier
      });
      const TO = createToken({
        name: "TO",
        pattern: /TO/,
        longer_alt: Identifier
      });
      const StringLiteral = createToken({
        name: "StringLiteral",
        pattern: /"(?:[^\\"\n\r]|\\[bfnrtv"\\/]|\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*"/
      });
      const HexLiteral = createToken({
        name: "HexLiteral",
        pattern: /0[xX][0-9a-fA-F]+/
      });
      const NumberLiteral = createToken({
        name: "NumberLiteral",
        pattern: /[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/
      });
      const TrueLiteral = createToken({
        name: "TrueLiteral",
        pattern: /TRUE/
      });
      const FalseLiteral = createToken({
        name: "FalseLiteral",
        pattern: /FALSE/
      });
      const NullLiteral = createToken({
        name: "NullLiteral",
        pattern: /NULL/
      });
      const LSquare = createToken({
        name: "LSquare",
        pattern: /\[/
      });
      const RSquare = createToken({
        name: "RSquare",
        pattern: /]/
      });
      const LCurly = createToken({
        name: "LCurly",
        pattern: /{/
      });
      const RCurly = createToken({
        name: "RCurly",
        pattern: /}/
      });
      const Comment = createToken({
        name: "Comment",
        pattern: /#.*/,
        group: Lexer.SKIPPED
      });
      const WhiteSpace = createToken({
        name: "WhiteSpace",
        pattern: /[ ,\s]/,
        group: Lexer.SKIPPED
      });
      const tokens = [
        WhiteSpace,
        NodeName,
        DEF,
        USE,
        ROUTE,
        TO,
        TrueLiteral,
        FalseLiteral,
        NullLiteral,
        Version,
        Identifier,
        RouteIdentifier,
        StringLiteral,
        HexLiteral,
        NumberLiteral,
        LSquare,
        RSquare,
        LCurly,
        RCurly,
        Comment
      ];
      const tokenVocabulary = {};
      for (let i2 = 0, l = tokens.length; i2 < l; i2++) {
        const token = tokens[i2];
        tokenVocabulary[token.name] = token;
      }
      return {
        tokens,
        tokenVocabulary
      };
    }
    function createVisitor(BaseVRMLVisitor) {
      function VRMLToASTVisitor() {
        BaseVRMLVisitor.call(this);
        this.validateVisitor();
      }
      VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {
        constructor: VRMLToASTVisitor,
        vrml: function(ctx) {
          const data2 = {
            version: this.visit(ctx.version),
            nodes: [],
            routes: []
          };
          for (let i2 = 0, l = ctx.node.length; i2 < l; i2++) {
            const node = ctx.node[i2];
            data2.nodes.push(this.visit(node));
          }
          if (ctx.route) {
            for (let i2 = 0, l = ctx.route.length; i2 < l; i2++) {
              const route = ctx.route[i2];
              data2.routes.push(this.visit(route));
            }
          }
          return data2;
        },
        version: function(ctx) {
          return ctx.Version[0].image;
        },
        node: function(ctx) {
          const data2 = {
            name: ctx.NodeName[0].image,
            fields: []
          };
          if (ctx.field) {
            for (let i2 = 0, l = ctx.field.length; i2 < l; i2++) {
              const field = ctx.field[i2];
              data2.fields.push(this.visit(field));
            }
          }
          if (ctx.def) {
            data2.DEF = this.visit(ctx.def[0]);
          }
          return data2;
        },
        field: function(ctx) {
          const data2 = {
            name: ctx.Identifier[0].image,
            type: null,
            values: null
          };
          let result;
          if (ctx.singleFieldValue) {
            result = this.visit(ctx.singleFieldValue[0]);
          }
          if (ctx.multiFieldValue) {
            result = this.visit(ctx.multiFieldValue[0]);
          }
          data2.type = result.type;
          data2.values = result.values;
          return data2;
        },
        def: function(ctx) {
          return (ctx.Identifier || ctx.NodeName)[0].image;
        },
        use: function(ctx) {
          return {
            USE: (ctx.Identifier || ctx.NodeName)[0].image
          };
        },
        singleFieldValue: function(ctx) {
          return processField(this, ctx);
        },
        multiFieldValue: function(ctx) {
          return processField(this, ctx);
        },
        route: function(ctx) {
          const data2 = {
            FROM: ctx.RouteIdentifier[0].image,
            TO: ctx.RouteIdentifier[1].image
          };
          return data2;
        }
      });
      function processField(scope2, ctx) {
        const field = {
          type: null,
          values: []
        };
        if (ctx.node) {
          field.type = "node";
          for (let i2 = 0, l = ctx.node.length; i2 < l; i2++) {
            const node = ctx.node[i2];
            field.values.push(scope2.visit(node));
          }
        }
        if (ctx.use) {
          field.type = "use";
          for (let i2 = 0, l = ctx.use.length; i2 < l; i2++) {
            const use = ctx.use[i2];
            field.values.push(scope2.visit(use));
          }
        }
        if (ctx.StringLiteral) {
          field.type = "string";
          for (let i2 = 0, l = ctx.StringLiteral.length; i2 < l; i2++) {
            const stringLiteral = ctx.StringLiteral[i2];
            field.values.push(stringLiteral.image.replace(/'|"/g, ""));
          }
        }
        if (ctx.NumberLiteral) {
          field.type = "number";
          for (let i2 = 0, l = ctx.NumberLiteral.length; i2 < l; i2++) {
            const numberLiteral = ctx.NumberLiteral[i2];
            field.values.push(parseFloat(numberLiteral.image));
          }
        }
        if (ctx.HexLiteral) {
          field.type = "hex";
          for (let i2 = 0, l = ctx.HexLiteral.length; i2 < l; i2++) {
            const hexLiteral = ctx.HexLiteral[i2];
            field.values.push(hexLiteral.image);
          }
        }
        if (ctx.TrueLiteral) {
          field.type = "boolean";
          for (let i2 = 0, l = ctx.TrueLiteral.length; i2 < l; i2++) {
            const trueLiteral = ctx.TrueLiteral[i2];
            if (trueLiteral.image === "TRUE")
              field.values.push(true);
          }
        }
        if (ctx.FalseLiteral) {
          field.type = "boolean";
          for (let i2 = 0, l = ctx.FalseLiteral.length; i2 < l; i2++) {
            const falseLiteral = ctx.FalseLiteral[i2];
            if (falseLiteral.image === "FALSE")
              field.values.push(false);
          }
        }
        if (ctx.NullLiteral) {
          field.type = "null";
          ctx.NullLiteral.forEach(function() {
            field.values.push(null);
          });
        }
        return field;
      }
      return new VRMLToASTVisitor();
    }
    function parseTree(tree2) {
      const nodes = tree2.nodes;
      const scene2 = new Scene();
      for (let i2 = 0, l = nodes.length; i2 < l; i2++) {
        const node = nodes[i2];
        buildNodeMap(node);
      }
      for (let i2 = 0, l = nodes.length; i2 < l; i2++) {
        const node = nodes[i2];
        const object = getNode(node);
        if (object instanceof Object3D)
          scene2.add(object);
        if (node.name === "WorldInfo")
          scene2.userData.worldInfo = object;
      }
      return scene2;
    }
    function buildNodeMap(node) {
      if (node.DEF) {
        nodeMap[node.DEF] = node;
      }
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        if (field.type === "node") {
          const fieldValues = field.values;
          for (let j2 = 0, jl2 = fieldValues.length; j2 < jl2; j2++) {
            buildNodeMap(fieldValues[j2]);
          }
        }
      }
    }
    function getNode(node) {
      if (node.USE) {
        return resolveUSE(node.USE);
      }
      if (node.build !== void 0)
        return node.build;
      node.build = buildNode(node);
      return node.build;
    }
    function buildNode(node) {
      const nodeName = node.name;
      let build;
      switch (nodeName) {
        case "Group":
        case "Transform":
        case "Collision":
          build = buildGroupingNode(node);
          break;
        case "Background":
          build = buildBackgroundNode(node);
          break;
        case "Shape":
          build = buildShapeNode(node);
          break;
        case "Appearance":
          build = buildAppearanceNode(node);
          break;
        case "Material":
          build = buildMaterialNode(node);
          break;
        case "ImageTexture":
          build = buildImageTextureNode(node);
          break;
        case "PixelTexture":
          build = buildPixelTextureNode(node);
          break;
        case "TextureTransform":
          build = buildTextureTransformNode(node);
          break;
        case "IndexedFaceSet":
          build = buildIndexedFaceSetNode(node);
          break;
        case "IndexedLineSet":
          build = buildIndexedLineSetNode(node);
          break;
        case "PointSet":
          build = buildPointSetNode(node);
          break;
        case "Box":
          build = buildBoxNode(node);
          break;
        case "Cone":
          build = buildConeNode(node);
          break;
        case "Cylinder":
          build = buildCylinderNode(node);
          break;
        case "Sphere":
          build = buildSphereNode(node);
          break;
        case "ElevationGrid":
          build = buildElevationGridNode(node);
          break;
        case "Extrusion":
          build = buildExtrusionNode(node);
          break;
        case "Color":
        case "Coordinate":
        case "Normal":
        case "TextureCoordinate":
          build = buildGeometricNode(node);
          break;
        case "WorldInfo":
          build = buildWorldInfoNode(node);
          break;
        case "Anchor":
        case "Billboard":
        case "Inline":
        case "LOD":
        case "Switch":
        case "AudioClip":
        case "DirectionalLight":
        case "PointLight":
        case "Script":
        case "Sound":
        case "SpotLight":
        case "CylinderSensor":
        case "PlaneSensor":
        case "ProximitySensor":
        case "SphereSensor":
        case "TimeSensor":
        case "TouchSensor":
        case "VisibilitySensor":
        case "Text":
        case "FontStyle":
        case "MovieTexture":
        case "ColorInterpolator":
        case "CoordinateInterpolator":
        case "NormalInterpolator":
        case "OrientationInterpolator":
        case "PositionInterpolator":
        case "ScalarInterpolator":
        case "Fog":
        case "NavigationInfo":
        case "Viewpoint":
          break;
        default:
          console.warn("THREE.VRMLLoader: Unknown node:", nodeName);
          break;
      }
      if (build !== void 0 && node.DEF !== void 0 && build.hasOwnProperty("name") === true) {
        build.name = node.DEF;
      }
      return build;
    }
    function buildGroupingNode(node) {
      const object = new Group();
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "bboxCenter":
            break;
          case "bboxSize":
            break;
          case "center":
            break;
          case "children":
            parseFieldChildren(fieldValues, object);
            break;
          case "collide":
            break;
          case "rotation":
            const axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);
            const angle = fieldValues[3];
            object.quaternion.setFromAxisAngle(axis, angle);
            break;
          case "scale":
            object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);
            break;
          case "scaleOrientation":
            break;
          case "translation":
            object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);
            break;
          case "proxy":
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      return object;
    }
    function buildBackgroundNode(node) {
      const group = new Group();
      let groundAngle, groundColor;
      let skyAngle, skyColor;
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "groundAngle":
            groundAngle = fieldValues;
            break;
          case "groundColor":
            groundColor = fieldValues;
            break;
          case "backUrl":
            break;
          case "bottomUrl":
            break;
          case "frontUrl":
            break;
          case "leftUrl":
            break;
          case "rightUrl":
            break;
          case "topUrl":
            break;
          case "skyAngle":
            skyAngle = fieldValues;
            break;
          case "skyColor":
            skyColor = fieldValues;
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      const radius = 1e4;
      if (skyColor) {
        const skyGeometry = new SphereGeometry(radius, 32, 16);
        const skyMaterial = new MeshBasicMaterial({
          fog: false,
          side: BackSide,
          depthWrite: false,
          depthTest: false
        });
        if (skyColor.length > 3) {
          paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);
          skyMaterial.vertexColors = true;
        } else {
          skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);
        }
        const sky = new Mesh(skyGeometry, skyMaterial);
        group.add(sky);
      }
      if (groundColor) {
        if (groundColor.length > 0) {
          const groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);
          const groundMaterial = new MeshBasicMaterial({
            fog: false,
            side: BackSide,
            vertexColors: true,
            depthWrite: false,
            depthTest: false
          });
          paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);
          const ground = new Mesh(groundGeometry, groundMaterial);
          group.add(ground);
        }
      }
      group.renderOrder = -Infinity;
      return group;
    }
    function buildShapeNode(node) {
      const fields = node.fields;
      let material = new MeshBasicMaterial({
        color: 0
      });
      let geometry;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "appearance":
            if (fieldValues[0] !== null) {
              material = getNode(fieldValues[0]);
            }
            break;
          case "geometry":
            if (fieldValues[0] !== null) {
              geometry = getNode(fieldValues[0]);
            }
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      let object;
      if (geometry && geometry.attributes.position) {
        const type2 = geometry._type;
        if (type2 === "points") {
          const pointsMaterial = new PointsMaterial({
            color: 16777215
          });
          if (geometry.attributes.color !== void 0) {
            pointsMaterial.vertexColors = true;
          } else {
            if (material.isMeshPhongMaterial) {
              pointsMaterial.color.copy(material.emissive);
            }
          }
          object = new Points(geometry, pointsMaterial);
        } else if (type2 === "line") {
          const lineMaterial = new LineBasicMaterial({
            color: 16777215
          });
          if (geometry.attributes.color !== void 0) {
            lineMaterial.vertexColors = true;
          } else {
            if (material.isMeshPhongMaterial) {
              lineMaterial.color.copy(material.emissive);
            }
          }
          object = new LineSegments(geometry, lineMaterial);
        } else {
          if (geometry._solid !== void 0) {
            material.side = geometry._solid ? FrontSide : DoubleSide;
          }
          if (geometry.attributes.color !== void 0) {
            material.vertexColors = true;
          }
          object = new Mesh(geometry, material);
        }
      } else {
        object = new Object3D();
        object.visible = false;
      }
      return object;
    }
    function buildAppearanceNode(node) {
      let material = new MeshPhongMaterial();
      let transformData;
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "material":
            if (fieldValues[0] !== null) {
              const materialData = getNode(fieldValues[0]);
              if (materialData.diffuseColor)
                material.color.copy(materialData.diffuseColor);
              if (materialData.emissiveColor)
                material.emissive.copy(materialData.emissiveColor);
              if (materialData.shininess)
                material.shininess = materialData.shininess;
              if (materialData.specularColor)
                material.specular.copy(materialData.specularColor);
              if (materialData.transparency)
                material.opacity = 1 - materialData.transparency;
              if (materialData.transparency > 0)
                material.transparent = true;
            } else {
              material = new MeshBasicMaterial({
                color: 0
              });
            }
            break;
          case "texture":
            const textureNode = fieldValues[0];
            if (textureNode !== null) {
              if (textureNode.name === "ImageTexture" || textureNode.name === "PixelTexture") {
                material.map = getNode(textureNode);
              }
            }
            break;
          case "textureTransform":
            if (fieldValues[0] !== null) {
              transformData = getNode(fieldValues[0]);
            }
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      if (material.map) {
        if (material.map.__type) {
          switch (material.map.__type) {
            case TEXTURE_TYPE.INTENSITY_ALPHA:
              material.opacity = 1;
              break;
            case TEXTURE_TYPE.RGB:
              material.color.set(16777215);
              break;
            case TEXTURE_TYPE.RGBA:
              material.color.set(16777215);
              material.opacity = 1;
              break;
          }
          delete material.map.__type;
        }
        if (transformData) {
          material.map.center.copy(transformData.center);
          material.map.rotation = transformData.rotation;
          material.map.repeat.copy(transformData.scale);
          material.map.offset.copy(transformData.translation);
        }
      }
      return material;
    }
    function buildMaterialNode(node) {
      const materialData = {};
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "ambientIntensity":
            break;
          case "diffuseColor":
            materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);
            break;
          case "emissiveColor":
            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);
            break;
          case "shininess":
            materialData.shininess = fieldValues[0];
            break;
          case "specularColor":
            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);
            break;
          case "transparency":
            materialData.transparency = fieldValues[0];
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      return materialData;
    }
    function parseHexColor(hex, textureType, color2) {
      let value;
      switch (textureType) {
        case TEXTURE_TYPE.INTENSITY:
          value = parseInt(hex);
          color2.r = value;
          color2.g = value;
          color2.b = value;
          color2.a = 1;
          break;
        case TEXTURE_TYPE.INTENSITY_ALPHA:
          value = parseInt("0x" + hex.substring(2, 4));
          color2.r = value;
          color2.g = value;
          color2.b = value;
          color2.a = parseInt("0x" + hex.substring(4, 6));
          break;
        case TEXTURE_TYPE.RGB:
          color2.r = parseInt("0x" + hex.substring(2, 4));
          color2.g = parseInt("0x" + hex.substring(4, 6));
          color2.b = parseInt("0x" + hex.substring(6, 8));
          color2.a = 1;
          break;
        case TEXTURE_TYPE.RGBA:
          color2.r = parseInt("0x" + hex.substring(2, 4));
          color2.g = parseInt("0x" + hex.substring(4, 6));
          color2.b = parseInt("0x" + hex.substring(6, 8));
          color2.a = parseInt("0x" + hex.substring(8, 10));
          break;
      }
    }
    function getTextureType(num_components) {
      let type2;
      switch (num_components) {
        case 1:
          type2 = TEXTURE_TYPE.INTENSITY;
          break;
        case 2:
          type2 = TEXTURE_TYPE.INTENSITY_ALPHA;
          break;
        case 3:
          type2 = TEXTURE_TYPE.RGB;
          break;
        case 4:
          type2 = TEXTURE_TYPE.RGBA;
          break;
      }
      return type2;
    }
    function buildPixelTextureNode(node) {
      let texture2;
      let wrapS = RepeatWrapping;
      let wrapT = RepeatWrapping;
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "image":
            const width = fieldValues[0];
            const height = fieldValues[1];
            const num_components = fieldValues[2];
            const textureType = getTextureType(num_components);
            const data2 = new Uint8Array(4 * width * height);
            const color2 = {
              r: 0,
              g: 0,
              b: 0,
              a: 0
            };
            for (let j2 = 3, k = 0, jl2 = fieldValues.length; j2 < jl2; j2++, k++) {
              parseHexColor(fieldValues[j2], textureType, color2);
              const stride = k * 4;
              data2[stride + 0] = color2.r;
              data2[stride + 1] = color2.g;
              data2[stride + 2] = color2.b;
              data2[stride + 3] = color2.a;
            }
            texture2 = new DataTexture(data2, width, height);
            texture2.needsUpdate = true;
            texture2.__type = textureType;
            break;
          case "repeatS":
            if (fieldValues[0] === false)
              wrapS = ClampToEdgeWrapping;
            break;
          case "repeatT":
            if (fieldValues[0] === false)
              wrapT = ClampToEdgeWrapping;
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      if (texture2) {
        texture2.wrapS = wrapS;
        texture2.wrapT = wrapT;
      }
      return texture2;
    }
    function buildImageTextureNode(node) {
      let texture2;
      let wrapS = RepeatWrapping;
      let wrapT = RepeatWrapping;
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "url":
            const url = fieldValues[0];
            if (url)
              texture2 = textureLoader.load(url);
            break;
          case "repeatS":
            if (fieldValues[0] === false)
              wrapS = ClampToEdgeWrapping;
            break;
          case "repeatT":
            if (fieldValues[0] === false)
              wrapT = ClampToEdgeWrapping;
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      if (texture2) {
        texture2.wrapS = wrapS;
        texture2.wrapT = wrapT;
      }
      return texture2;
    }
    function buildTextureTransformNode(node) {
      const transformData = {
        center: new Vector2(),
        rotation: new Vector2(),
        scale: new Vector2(),
        translation: new Vector2()
      };
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "center":
            transformData.center.set(fieldValues[0], fieldValues[1]);
            break;
          case "rotation":
            transformData.rotation = fieldValues[0];
            break;
          case "scale":
            transformData.scale.set(fieldValues[0], fieldValues[1]);
            break;
          case "translation":
            transformData.translation.set(fieldValues[0], fieldValues[1]);
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      return transformData;
    }
    function buildGeometricNode(node) {
      return node.fields[0].values;
    }
    function buildWorldInfoNode(node) {
      const worldInfo = {};
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "title":
            worldInfo.title = fieldValues[0];
            break;
          case "info":
            worldInfo.info = fieldValues;
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      return worldInfo;
    }
    function buildIndexedFaceSetNode(node) {
      let color2, coord, normal, texCoord;
      let ccw = true, solid = true, creaseAngle = 0;
      let colorIndex, coordIndex, normalIndex, texCoordIndex;
      let colorPerVertex = true, normalPerVertex = true;
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "color":
            const colorNode = fieldValues[0];
            if (colorNode !== null) {
              color2 = getNode(colorNode);
            }
            break;
          case "coord":
            const coordNode = fieldValues[0];
            if (coordNode !== null) {
              coord = getNode(coordNode);
            }
            break;
          case "normal":
            const normalNode = fieldValues[0];
            if (normalNode !== null) {
              normal = getNode(normalNode);
            }
            break;
          case "texCoord":
            const texCoordNode = fieldValues[0];
            if (texCoordNode !== null) {
              texCoord = getNode(texCoordNode);
            }
            break;
          case "ccw":
            ccw = fieldValues[0];
            break;
          case "colorIndex":
            colorIndex = fieldValues;
            break;
          case "colorPerVertex":
            colorPerVertex = fieldValues[0];
            break;
          case "convex":
            break;
          case "coordIndex":
            coordIndex = fieldValues;
            break;
          case "creaseAngle":
            creaseAngle = fieldValues[0];
            break;
          case "normalIndex":
            normalIndex = fieldValues;
            break;
          case "normalPerVertex":
            normalPerVertex = fieldValues[0];
            break;
          case "solid":
            solid = fieldValues[0];
            break;
          case "texCoordIndex":
            texCoordIndex = fieldValues;
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      if (coordIndex === void 0) {
        console.warn("THREE.VRMLLoader: Missing coordIndex.");
        return new BufferGeometry();
      }
      const triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);
      let colorAttribute;
      let normalAttribute;
      let uvAttribute;
      if (color2) {
        if (colorPerVertex === true) {
          if (colorIndex && colorIndex.length > 0) {
            const triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);
            colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color2, 3);
          } else {
            colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color2, 3));
          }
        } else {
          if (colorIndex && colorIndex.length > 0) {
            const flattenFaceColors = flattenData(color2, colorIndex);
            const triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);
            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);
          } else {
            const triangulatedFaceColors = triangulateFaceData(color2, coordIndex);
            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);
          }
        }
      }
      if (normal) {
        if (normalPerVertex === true) {
          if (normalIndex && normalIndex.length > 0) {
            const triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);
            normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);
          } else {
            normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));
          }
        } else {
          if (normalIndex && normalIndex.length > 0) {
            const flattenFaceNormals = flattenData(normal, normalIndex);
            const triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);
            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);
          } else {
            const triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);
            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);
          }
        }
      } else {
        normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);
      }
      if (texCoord) {
        if (texCoordIndex && texCoordIndex.length > 0) {
          const triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);
          uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);
        } else {
          uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));
        }
      }
      const geometry = new BufferGeometry();
      const positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));
      geometry.setAttribute("position", positionAttribute);
      geometry.setAttribute("normal", normalAttribute);
      if (colorAttribute)
        geometry.setAttribute("color", colorAttribute);
      if (uvAttribute)
        geometry.setAttribute("uv", uvAttribute);
      geometry._solid = solid;
      geometry._type = "mesh";
      return geometry;
    }
    function buildIndexedLineSetNode(node) {
      let color2, coord;
      let colorIndex, coordIndex;
      let colorPerVertex = true;
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "color":
            const colorNode = fieldValues[0];
            if (colorNode !== null) {
              color2 = getNode(colorNode);
            }
            break;
          case "coord":
            const coordNode = fieldValues[0];
            if (coordNode !== null) {
              coord = getNode(coordNode);
            }
            break;
          case "colorIndex":
            colorIndex = fieldValues;
            break;
          case "colorPerVertex":
            colorPerVertex = fieldValues[0];
            break;
          case "coordIndex":
            coordIndex = fieldValues;
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      let colorAttribute;
      const expandedLineIndex = expandLineIndex(coordIndex);
      if (color2) {
        if (colorPerVertex === true) {
          if (colorIndex.length > 0) {
            const expandedColorIndex = expandLineIndex(colorIndex);
            colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color2, 3);
          } else {
            colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color2, 3));
          }
        } else {
          if (colorIndex.length > 0) {
            const flattenLineColors = flattenData(color2, colorIndex);
            const expandedLineColors = expandLineData(flattenLineColors, coordIndex);
            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);
          } else {
            const expandedLineColors = expandLineData(color2, coordIndex);
            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);
          }
        }
      }
      const geometry = new BufferGeometry();
      const positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));
      geometry.setAttribute("position", positionAttribute);
      if (colorAttribute)
        geometry.setAttribute("color", colorAttribute);
      geometry._type = "line";
      return geometry;
    }
    function buildPointSetNode(node) {
      let color2, coord;
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "color":
            const colorNode = fieldValues[0];
            if (colorNode !== null) {
              color2 = getNode(colorNode);
            }
            break;
          case "coord":
            const coordNode = fieldValues[0];
            if (coordNode !== null) {
              coord = getNode(coordNode);
            }
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute(coord, 3));
      if (color2)
        geometry.setAttribute("color", new Float32BufferAttribute(color2, 3));
      geometry._type = "points";
      return geometry;
    }
    function buildBoxNode(node) {
      const size2 = new Vector3(2, 2, 2);
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "size":
            size2.x = fieldValues[0];
            size2.y = fieldValues[1];
            size2.z = fieldValues[2];
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      const geometry = new BoxGeometry(size2.x, size2.y, size2.z);
      return geometry;
    }
    function buildConeNode(node) {
      let radius = 1, height = 2, openEnded = false;
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "bottom":
            openEnded = !fieldValues[0];
            break;
          case "bottomRadius":
            radius = fieldValues[0];
            break;
          case "height":
            height = fieldValues[0];
            break;
          case "side":
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      const geometry = new ConeGeometry(radius, height, 16, 1, openEnded);
      return geometry;
    }
    function buildCylinderNode(node) {
      let radius = 1, height = 2;
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "bottom":
            break;
          case "radius":
            radius = fieldValues[0];
            break;
          case "height":
            height = fieldValues[0];
            break;
          case "side":
            break;
          case "top":
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      const geometry = new CylinderGeometry(radius, radius, height, 16, 1);
      return geometry;
    }
    function buildSphereNode(node) {
      let radius = 1;
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "radius":
            radius = fieldValues[0];
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      const geometry = new SphereGeometry(radius, 16, 16);
      return geometry;
    }
    function buildElevationGridNode(node) {
      let color2;
      let normal;
      let texCoord;
      let height;
      let colorPerVertex = true;
      let normalPerVertex = true;
      let solid = true;
      let ccw = true;
      let creaseAngle = 0;
      let xDimension = 2;
      let zDimension = 2;
      let xSpacing = 1;
      let zSpacing = 1;
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "color":
            const colorNode = fieldValues[0];
            if (colorNode !== null) {
              color2 = getNode(colorNode);
            }
            break;
          case "normal":
            const normalNode = fieldValues[0];
            if (normalNode !== null) {
              normal = getNode(normalNode);
            }
            break;
          case "texCoord":
            const texCoordNode = fieldValues[0];
            if (texCoordNode !== null) {
              texCoord = getNode(texCoordNode);
            }
            break;
          case "height":
            height = fieldValues;
            break;
          case "ccw":
            ccw = fieldValues[0];
            break;
          case "colorPerVertex":
            colorPerVertex = fieldValues[0];
            break;
          case "creaseAngle":
            creaseAngle = fieldValues[0];
            break;
          case "normalPerVertex":
            normalPerVertex = fieldValues[0];
            break;
          case "solid":
            solid = fieldValues[0];
            break;
          case "xDimension":
            xDimension = fieldValues[0];
            break;
          case "xSpacing":
            xSpacing = fieldValues[0];
            break;
          case "zDimension":
            zDimension = fieldValues[0];
            break;
          case "zSpacing":
            zSpacing = fieldValues[0];
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      const vertices = [];
      const normals = [];
      const colors = [];
      const uvs = [];
      for (let i2 = 0; i2 < zDimension; i2++) {
        for (let j2 = 0; j2 < xDimension; j2++) {
          const index = i2 * xDimension + j2;
          const x = xSpacing * i2;
          const y = height[index];
          const z = zSpacing * j2;
          vertices.push(x, y, z);
          if (color2 && colorPerVertex === true) {
            const r = color2[index * 3 + 0];
            const g2 = color2[index * 3 + 1];
            const b3 = color2[index * 3 + 2];
            colors.push(r, g2, b3);
          }
          if (normal && normalPerVertex === true) {
            const xn = normal[index * 3 + 0];
            const yn = normal[index * 3 + 1];
            const zn = normal[index * 3 + 2];
            normals.push(xn, yn, zn);
          }
          if (texCoord) {
            const s = texCoord[index * 2 + 0];
            const t2 = texCoord[index * 2 + 1];
            uvs.push(s, t2);
          } else {
            uvs.push(i2 / (xDimension - 1), j2 / (zDimension - 1));
          }
        }
      }
      const indices = [];
      for (let i2 = 0; i2 < xDimension - 1; i2++) {
        for (let j2 = 0; j2 < zDimension - 1; j2++) {
          const a2 = i2 + j2 * xDimension;
          const b3 = i2 + (j2 + 1) * xDimension;
          const c = i2 + 1 + (j2 + 1) * xDimension;
          const d = i2 + 1 + j2 * xDimension;
          if (ccw === true) {
            indices.push(a2, c, b3);
            indices.push(c, a2, d);
          } else {
            indices.push(a2, b3, c);
            indices.push(c, d, a2);
          }
        }
      }
      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));
      const uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));
      let colorAttribute;
      let normalAttribute;
      if (color2) {
        if (colorPerVertex === false) {
          for (let i2 = 0; i2 < xDimension - 1; i2++) {
            for (let j2 = 0; j2 < zDimension - 1; j2++) {
              const index = i2 + j2 * (xDimension - 1);
              const r = color2[index * 3 + 0];
              const g2 = color2[index * 3 + 1];
              const b3 = color2[index * 3 + 2];
              colors.push(r, g2, b3);
              colors.push(r, g2, b3);
              colors.push(r, g2, b3);
              colors.push(r, g2, b3);
              colors.push(r, g2, b3);
              colors.push(r, g2, b3);
            }
          }
          colorAttribute = new Float32BufferAttribute(colors, 3);
        } else {
          colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));
        }
      }
      if (normal) {
        if (normalPerVertex === false) {
          for (let i2 = 0; i2 < xDimension - 1; i2++) {
            for (let j2 = 0; j2 < zDimension - 1; j2++) {
              const index = i2 + j2 * (xDimension - 1);
              const xn = normal[index * 3 + 0];
              const yn = normal[index * 3 + 1];
              const zn = normal[index * 3 + 2];
              normals.push(xn, yn, zn);
              normals.push(xn, yn, zn);
              normals.push(xn, yn, zn);
              normals.push(xn, yn, zn);
              normals.push(xn, yn, zn);
              normals.push(xn, yn, zn);
            }
          }
          normalAttribute = new Float32BufferAttribute(normals, 3);
        } else {
          normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));
        }
      } else {
        normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);
      }
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", positionAttribute);
      geometry.setAttribute("normal", normalAttribute);
      geometry.setAttribute("uv", uvAttribute);
      if (colorAttribute)
        geometry.setAttribute("color", colorAttribute);
      geometry._solid = solid;
      geometry._type = "mesh";
      return geometry;
    }
    function buildExtrusionNode(node) {
      let crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];
      let spine = [0, 0, 0, 0, 1, 0];
      let scale;
      let orientation;
      let beginCap = true;
      let ccw = true;
      let creaseAngle = 0;
      let endCap = true;
      let solid = true;
      const fields = node.fields;
      for (let i2 = 0, l = fields.length; i2 < l; i2++) {
        const field = fields[i2];
        const fieldName = field.name;
        const fieldValues = field.values;
        switch (fieldName) {
          case "beginCap":
            beginCap = fieldValues[0];
            break;
          case "ccw":
            ccw = fieldValues[0];
            break;
          case "convex":
            break;
          case "creaseAngle":
            creaseAngle = fieldValues[0];
            break;
          case "crossSection":
            crossSection = fieldValues;
            break;
          case "endCap":
            endCap = fieldValues[0];
            break;
          case "orientation":
            orientation = fieldValues;
            break;
          case "scale":
            scale = fieldValues;
            break;
          case "solid":
            solid = fieldValues[0];
            break;
          case "spine":
            spine = fieldValues;
            break;
          default:
            console.warn("THREE.VRMLLoader: Unknown field:", fieldName);
            break;
        }
      }
      const crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1];
      const vertices = [];
      const spineVector = new Vector3();
      const scaling = new Vector3();
      const axis = new Vector3();
      const vertex = new Vector3();
      const quaternion = new Quaternion();
      for (let i2 = 0, j2 = 0, o = 0, il = spine.length; i2 < il; i2 += 3, j2 += 2, o += 4) {
        spineVector.fromArray(spine, i2);
        scaling.x = scale ? scale[j2 + 0] : 1;
        scaling.y = 1;
        scaling.z = scale ? scale[j2 + 1] : 1;
        axis.x = orientation ? orientation[o + 0] : 0;
        axis.y = orientation ? orientation[o + 1] : 0;
        axis.z = orientation ? orientation[o + 2] : 1;
        const angle = orientation ? orientation[o + 3] : 0;
        for (let k = 0, kl = crossSection.length; k < kl; k += 2) {
          vertex.x = crossSection[k + 0];
          vertex.y = 0;
          vertex.z = crossSection[k + 1];
          vertex.multiply(scaling);
          quaternion.setFromAxisAngle(axis, angle);
          vertex.applyQuaternion(quaternion);
          vertex.add(spineVector);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
      const indices = [];
      const spineCount = spine.length / 3;
      const crossSectionCount = crossSection.length / 2;
      for (let i2 = 0; i2 < spineCount - 1; i2++) {
        for (let j2 = 0; j2 < crossSectionCount - 1; j2++) {
          const a2 = j2 + i2 * crossSectionCount;
          let b3 = j2 + 1 + i2 * crossSectionCount;
          const c = j2 + (i2 + 1) * crossSectionCount;
          let d = j2 + 1 + (i2 + 1) * crossSectionCount;
          if (j2 === crossSectionCount - 2 && crossSectionClosed === true) {
            b3 = i2 * crossSectionCount;
            d = (i2 + 1) * crossSectionCount;
          }
          if (ccw === true) {
            indices.push(a2, b3, c);
            indices.push(c, b3, d);
          } else {
            indices.push(a2, c, b3);
            indices.push(c, d, b3);
          }
        }
      }
      if (beginCap === true || endCap === true) {
        const contour = [];
        for (let i2 = 0, l = crossSection.length; i2 < l; i2 += 2) {
          contour.push(new Vector2(crossSection[i2], crossSection[i2 + 1]));
        }
        const faces = ShapeUtils.triangulateShape(contour, []);
        const capIndices = [];
        for (let i2 = 0, l = faces.length; i2 < l; i2++) {
          const face = faces[i2];
          capIndices.push(face[0], face[1], face[2]);
        }
        if (beginCap === true) {
          for (let i2 = 0, l = capIndices.length; i2 < l; i2 += 3) {
            if (ccw === true) {
              indices.push(capIndices[i2 + 0], capIndices[i2 + 1], capIndices[i2 + 2]);
            } else {
              indices.push(capIndices[i2 + 0], capIndices[i2 + 2], capIndices[i2 + 1]);
            }
          }
        }
        if (endCap === true) {
          const indexOffset = crossSectionCount * (spineCount - 1);
          for (let i2 = 0, l = capIndices.length; i2 < l; i2 += 3) {
            if (ccw === true) {
              indices.push(indexOffset + capIndices[i2 + 0], indexOffset + capIndices[i2 + 2], indexOffset + capIndices[i2 + 1]);
            } else {
              indices.push(indexOffset + capIndices[i2 + 0], indexOffset + capIndices[i2 + 1], indexOffset + capIndices[i2 + 2]);
            }
          }
        }
      }
      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));
      const normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", positionAttribute);
      geometry.setAttribute("normal", normalAttribute);
      geometry._solid = solid;
      geometry._type = "mesh";
      return geometry;
    }
    function resolveUSE(identifier) {
      const node = nodeMap[identifier];
      const build = getNode(node);
      return build.isObject3D || build.isMaterial ? build.clone() : build;
    }
    function parseFieldChildren(children, owner) {
      for (let i2 = 0, l = children.length; i2 < l; i2++) {
        const object = getNode(children[i2]);
        if (object instanceof Object3D)
          owner.add(object);
      }
    }
    function triangulateFaceIndex(index, ccw) {
      const indices = [];
      let start = 0;
      for (let i2 = 0, l = index.length; i2 < l; i2++) {
        const i1 = index[start];
        const i22 = index[i2 + (ccw ? 1 : 2)];
        const i3 = index[i2 + (ccw ? 2 : 1)];
        indices.push(i1, i22, i3);
        if (index[i2 + 3] === -1 || i2 + 3 >= l) {
          i2 += 3;
          start = i2 + 1;
        }
      }
      return indices;
    }
    function triangulateFaceData(data2, index) {
      const triangulatedData = [];
      let start = 0;
      for (let i2 = 0, l = index.length; i2 < l; i2++) {
        const stride = start * 3;
        const x = data2[stride];
        const y = data2[stride + 1];
        const z = data2[stride + 2];
        triangulatedData.push(x, y, z);
        if (index[i2 + 3] === -1 || i2 + 3 >= l) {
          i2 += 3;
          start++;
        }
      }
      return triangulatedData;
    }
    function flattenData(data2, index) {
      const flattenData2 = [];
      for (let i2 = 0, l = index.length; i2 < l; i2++) {
        const i1 = index[i2];
        const stride = i1 * 3;
        const x = data2[stride];
        const y = data2[stride + 1];
        const z = data2[stride + 2];
        flattenData2.push(x, y, z);
      }
      return flattenData2;
    }
    function expandLineIndex(index) {
      const indices = [];
      for (let i2 = 0, l = index.length; i2 < l; i2++) {
        const i1 = index[i2];
        const i22 = index[i2 + 1];
        indices.push(i1, i22);
        if (index[i2 + 2] === -1 || i2 + 2 >= l) {
          i2 += 2;
        }
      }
      return indices;
    }
    function expandLineData(data2, index) {
      const triangulatedData = [];
      let start = 0;
      for (let i2 = 0, l = index.length; i2 < l; i2++) {
        const stride = start * 3;
        const x = data2[stride];
        const y = data2[stride + 1];
        const z = data2[stride + 2];
        triangulatedData.push(x, y, z);
        if (index[i2 + 2] === -1 || i2 + 2 >= l) {
          i2 += 2;
          start++;
        }
      }
      return triangulatedData;
    }
    const vA = new Vector3();
    const vB = new Vector3();
    const vC = new Vector3();
    const uvA = new Vector2();
    const uvB = new Vector2();
    const uvC = new Vector2();
    function computeAttributeFromIndexedData(coordIndex, index, data2, itemSize) {
      const array = [];
      for (let i2 = 0, l = coordIndex.length; i2 < l; i2 += 3) {
        const a2 = index[i2];
        const b3 = index[i2 + 1];
        const c = index[i2 + 2];
        if (itemSize === 2) {
          uvA.fromArray(data2, a2 * itemSize);
          uvB.fromArray(data2, b3 * itemSize);
          uvC.fromArray(data2, c * itemSize);
          array.push(uvA.x, uvA.y);
          array.push(uvB.x, uvB.y);
          array.push(uvC.x, uvC.y);
        } else {
          vA.fromArray(data2, a2 * itemSize);
          vB.fromArray(data2, b3 * itemSize);
          vC.fromArray(data2, c * itemSize);
          array.push(vA.x, vA.y, vA.z);
          array.push(vB.x, vB.y, vB.z);
          array.push(vC.x, vC.y, vC.z);
        }
      }
      return new Float32BufferAttribute(array, itemSize);
    }
    function computeAttributeFromFaceData(index, faceData) {
      const array = [];
      for (let i2 = 0, j2 = 0, l = index.length; i2 < l; i2 += 3, j2++) {
        vA.fromArray(faceData, j2 * 3);
        array.push(vA.x, vA.y, vA.z);
        array.push(vA.x, vA.y, vA.z);
        array.push(vA.x, vA.y, vA.z);
      }
      return new Float32BufferAttribute(array, 3);
    }
    function computeAttributeFromLineData(index, lineData) {
      const array = [];
      for (let i2 = 0, j2 = 0, l = index.length; i2 < l; i2 += 2, j2++) {
        vA.fromArray(lineData, j2 * 3);
        array.push(vA.x, vA.y, vA.z);
        array.push(vA.x, vA.y, vA.z);
      }
      return new Float32BufferAttribute(array, 3);
    }
    function toNonIndexedAttribute(indices, attribute2) {
      const array = attribute2.array;
      const itemSize = attribute2.itemSize;
      const array2 = new array.constructor(indices.length * itemSize);
      let index = 0, index2 = 0;
      for (let i2 = 0, l = indices.length; i2 < l; i2++) {
        index = indices[i2] * itemSize;
        for (let j2 = 0; j2 < itemSize; j2++) {
          array2[index2++] = array[index++];
        }
      }
      return new Float32BufferAttribute(array2, itemSize);
    }
    const ab2 = new Vector3();
    const cb2 = new Vector3();
    function computeNormalAttribute(index, coord, creaseAngle) {
      const faces = [];
      const vertexNormals = {};
      for (let i2 = 0, l = index.length; i2 < l; i2 += 3) {
        const a2 = index[i2];
        const b3 = index[i2 + 1];
        const c = index[i2 + 2];
        const face = new Face2(a2, b3, c);
        vA.fromArray(coord, a2 * 3);
        vB.fromArray(coord, b3 * 3);
        vC.fromArray(coord, c * 3);
        cb2.subVectors(vC, vB);
        ab2.subVectors(vA, vB);
        cb2.cross(ab2);
        cb2.normalize();
        face.normal.copy(cb2);
        if (vertexNormals[a2] === void 0)
          vertexNormals[a2] = [];
        if (vertexNormals[b3] === void 0)
          vertexNormals[b3] = [];
        if (vertexNormals[c] === void 0)
          vertexNormals[c] = [];
        vertexNormals[a2].push(face.normal);
        vertexNormals[b3].push(face.normal);
        vertexNormals[c].push(face.normal);
        faces.push(face);
      }
      const normals = [];
      for (let i2 = 0, l = faces.length; i2 < l; i2++) {
        const face = faces[i2];
        const nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);
        const nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);
        const nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);
        vA.fromArray(coord, face.a * 3);
        vB.fromArray(coord, face.b * 3);
        vC.fromArray(coord, face.c * 3);
        normals.push(nA.x, nA.y, nA.z);
        normals.push(nB.x, nB.y, nB.z);
        normals.push(nC.x, nC.y, nC.z);
      }
      return new Float32BufferAttribute(normals, 3);
    }
    function weightedNormal(normals, vector2, creaseAngle) {
      const normal = new Vector3();
      if (creaseAngle === 0) {
        normal.copy(vector2);
      } else {
        for (let i2 = 0, l = normals.length; i2 < l; i2++) {
          if (normals[i2].angleTo(vector2) < creaseAngle) {
            normal.add(normals[i2]);
          }
        }
      }
      return normal.normalize();
    }
    function toColorArray(colors) {
      const array = [];
      for (let i2 = 0, l = colors.length; i2 < l; i2 += 3) {
        array.push(new Color(colors[i2], colors[i2 + 1], colors[i2 + 2]));
      }
      return array;
    }
    function paintFaces(geometry, radius, angles, colors, topDown) {
      const thresholds = [];
      const startAngle = topDown === true ? 0 : Math.PI;
      for (let i2 = 0, l = colors.length; i2 < l; i2++) {
        let angle = i2 === 0 ? 0 : angles[i2 - 1];
        angle = topDown === true ? angle : startAngle - angle;
        const point = new Vector3();
        point.setFromSphericalCoords(radius, angle, 0);
        thresholds.push(point);
      }
      const indices = geometry.index;
      const positionAttribute = geometry.attributes.position;
      const colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);
      const position = new Vector3();
      const color2 = new Color();
      for (let i2 = 0; i2 < indices.count; i2++) {
        const index = indices.getX(i2);
        position.fromBufferAttribute(positionAttribute, index);
        let thresholdIndexA, thresholdIndexB;
        let t2 = 1;
        for (let j2 = 1; j2 < thresholds.length; j2++) {
          thresholdIndexA = j2 - 1;
          thresholdIndexB = j2;
          const thresholdA = thresholds[thresholdIndexA];
          const thresholdB = thresholds[thresholdIndexB];
          if (topDown === true) {
            if (position.y <= thresholdA.y && position.y > thresholdB.y) {
              t2 = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);
              break;
            }
          } else {
            if (position.y >= thresholdA.y && position.y < thresholdB.y) {
              t2 = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);
              break;
            }
          }
        }
        const colorA = colors[thresholdIndexA];
        const colorB = colors[thresholdIndexB];
        color2.copy(colorA).lerp(colorB, t2);
        colorAttribute.setXYZ(index, color2.r, color2.g, color2.b);
      }
      geometry.setAttribute("color", colorAttribute);
    }
    const textureLoader = new TextureLoader(this.manager);
    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    if (data.indexOf("#VRML V2.0") === -1) {
      throw Error("THREE.VRMLLexer: Version of VRML asset not supported.");
    }
    const tree = generateVRMLTree(data);
    const scene = parseTree(tree);
    return scene;
  }
};
var VRMLLexer = class {
  constructor(tokens) {
    this.lexer = new Lexer(tokens);
  }
  lex(inputText) {
    const lexingResult = this.lexer.tokenize(inputText);
    if (lexingResult.errors.length > 0) {
      console.error(lexingResult.errors);
      throw Error("THREE.VRMLLexer: Lexing errors detected.");
    }
    return lexingResult;
  }
};
var VRMLParser = class extends CstParser {
  constructor(tokenVocabulary) {
    super(tokenVocabulary);
    const $ = this;
    const Version = tokenVocabulary["Version"];
    const LCurly = tokenVocabulary["LCurly"];
    const RCurly = tokenVocabulary["RCurly"];
    const LSquare = tokenVocabulary["LSquare"];
    const RSquare = tokenVocabulary["RSquare"];
    const Identifier = tokenVocabulary["Identifier"];
    const RouteIdentifier = tokenVocabulary["RouteIdentifier"];
    const StringLiteral = tokenVocabulary["StringLiteral"];
    const HexLiteral = tokenVocabulary["HexLiteral"];
    const NumberLiteral = tokenVocabulary["NumberLiteral"];
    const TrueLiteral = tokenVocabulary["TrueLiteral"];
    const FalseLiteral = tokenVocabulary["FalseLiteral"];
    const NullLiteral = tokenVocabulary["NullLiteral"];
    const DEF = tokenVocabulary["DEF"];
    const USE = tokenVocabulary["USE"];
    const ROUTE = tokenVocabulary["ROUTE"];
    const TO = tokenVocabulary["TO"];
    const NodeName = tokenVocabulary["NodeName"];
    $.RULE("vrml", function() {
      $.SUBRULE($.version);
      $.AT_LEAST_ONE(function() {
        $.SUBRULE($.node);
      });
      $.MANY(function() {
        $.SUBRULE($.route);
      });
    });
    $.RULE("version", function() {
      $.CONSUME(Version);
    });
    $.RULE("node", function() {
      $.OPTION(function() {
        $.SUBRULE($.def);
      });
      $.CONSUME(NodeName);
      $.CONSUME(LCurly);
      $.MANY(function() {
        $.SUBRULE($.field);
      });
      $.CONSUME(RCurly);
    });
    $.RULE("field", function() {
      $.CONSUME(Identifier);
      $.OR2([{
        ALT: function() {
          $.SUBRULE($.singleFieldValue);
        }
      }, {
        ALT: function() {
          $.SUBRULE($.multiFieldValue);
        }
      }]);
    });
    $.RULE("def", function() {
      $.CONSUME(DEF);
      $.OR([{
        ALT: function() {
          $.CONSUME(Identifier);
        }
      }, {
        ALT: function() {
          $.CONSUME(NodeName);
        }
      }]);
    });
    $.RULE("use", function() {
      $.CONSUME(USE);
      $.OR([{
        ALT: function() {
          $.CONSUME(Identifier);
        }
      }, {
        ALT: function() {
          $.CONSUME(NodeName);
        }
      }]);
    });
    $.RULE("singleFieldValue", function() {
      $.AT_LEAST_ONE(function() {
        $.OR([{
          ALT: function() {
            $.SUBRULE($.node);
          }
        }, {
          ALT: function() {
            $.SUBRULE($.use);
          }
        }, {
          ALT: function() {
            $.CONSUME(StringLiteral);
          }
        }, {
          ALT: function() {
            $.CONSUME(HexLiteral);
          }
        }, {
          ALT: function() {
            $.CONSUME(NumberLiteral);
          }
        }, {
          ALT: function() {
            $.CONSUME(TrueLiteral);
          }
        }, {
          ALT: function() {
            $.CONSUME(FalseLiteral);
          }
        }, {
          ALT: function() {
            $.CONSUME(NullLiteral);
          }
        }]);
      });
    });
    $.RULE("multiFieldValue", function() {
      $.CONSUME(LSquare);
      $.MANY(function() {
        $.OR([{
          ALT: function() {
            $.SUBRULE($.node);
          }
        }, {
          ALT: function() {
            $.SUBRULE($.use);
          }
        }, {
          ALT: function() {
            $.CONSUME(StringLiteral);
          }
        }, {
          ALT: function() {
            $.CONSUME(HexLiteral);
          }
        }, {
          ALT: function() {
            $.CONSUME(NumberLiteral);
          }
        }, {
          ALT: function() {
            $.CONSUME(NullLiteral);
          }
        }]);
      });
      $.CONSUME(RSquare);
    });
    $.RULE("route", function() {
      $.CONSUME(ROUTE);
      $.CONSUME(RouteIdentifier);
      $.CONSUME(TO);
      $.CONSUME2(RouteIdentifier);
    });
    this.performSelfAnalysis();
  }
};
var Face2 = class {
  constructor(a2, b3, c) {
    this.a = a2;
    this.b = b3;
    this.c = c;
    this.normal = new Vector3();
  }
};
var TEXTURE_TYPE = {
  INTENSITY: 1,
  INTENSITY_ALPHA: 2,
  RGB: 3,
  RGBA: 4
};

// node_modules/three-stdlib/utils/WorkerPool.js
var WorkerPool = class {
  constructor(pool = 4) {
    this.pool = pool;
    this.queue = [];
    this.workers = [];
    this.workersResolve = [];
    this.workerStatus = 0;
  }
  _initWorker(workerId) {
    if (!this.workers[workerId]) {
      const worker = this.workerCreator();
      worker.addEventListener("message", this._onMessage.bind(this, workerId));
      this.workers[workerId] = worker;
    }
  }
  _getIdleWorker() {
    for (let i2 = 0; i2 < this.pool; i2++)
      if (!(this.workerStatus & 1 << i2))
        return i2;
    return -1;
  }
  _onMessage(workerId, msg) {
    const resolve = this.workersResolve[workerId];
    resolve && resolve(msg);
    if (this.queue.length) {
      const {
        resolve: resolve2,
        msg: msg2,
        transfer
      } = this.queue.shift();
      this.workersResolve[workerId] = resolve2;
      this.workers[workerId].postMessage(msg2, transfer);
    } else {
      this.workerStatus ^= 1 << workerId;
    }
  }
  setWorkerCreator(workerCreator) {
    this.workerCreator = workerCreator;
  }
  setWorkerLimit(pool) {
    this.pool = pool;
  }
  postMessage(msg, transfer) {
    return new Promise((resolve) => {
      const workerId = this._getIdleWorker();
      if (workerId !== -1) {
        this._initWorker(workerId);
        this.workerStatus |= 1 << workerId;
        this.workersResolve[workerId] = resolve;
        this.workers[workerId].postMessage(msg, transfer);
      } else {
        this.queue.push({
          resolve,
          msg,
          transfer
        });
      }
    });
  }
  dispose() {
    this.workers.forEach((worker) => worker.terminate());
    this.workersResolve.length = 0;
    this.workers.length = 0;
    this.queue.length = 0;
    this.workerStatus = 0;
  }
};

// node_modules/ktx-parse/dist/ktx-parse.modern.js
var KHR_SUPERCOMPRESSION_NONE = 0;
var KHR_SUPERCOMPRESSION_ZSTD = 2;
var KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT = 0;
var KHR_DF_VENDORID_KHRONOS = 0;
var KHR_DF_VERSION = 2;
var KHR_DF_MODEL_UNSPECIFIED = 0;
var KHR_DF_FLAG_ALPHA_STRAIGHT = 0;
var KHR_DF_FLAG_ALPHA_PREMULTIPLIED = 1;
var KHR_DF_TRANSFER_SRGB = 2;
var KHR_DF_PRIMARIES_BT709 = 1;
var KHR_DF_SAMPLE_DATATYPE_SIGNED = 64;
var VK_FORMAT_UNDEFINED = 0;
var VK_FORMAT_R8_UNORM = 9;
var VK_FORMAT_R8_SRGB = 15;
var VK_FORMAT_R8G8_UNORM = 16;
var VK_FORMAT_R8G8_SRGB = 22;
var VK_FORMAT_R8G8B8A8_UNORM = 37;
var VK_FORMAT_R8G8B8A8_SRGB = 43;
var VK_FORMAT_R16_SFLOAT = 76;
var VK_FORMAT_R16G16_SFLOAT = 83;
var VK_FORMAT_R16G16B16A16_SFLOAT = 97;
var VK_FORMAT_R32_SFLOAT = 100;
var VK_FORMAT_R32G32_SFLOAT = 103;
var VK_FORMAT_R32G32B32A32_SFLOAT = 109;
var KTX2Container = class {
  constructor() {
    this.vkFormat = VK_FORMAT_UNDEFINED;
    this.typeSize = 1;
    this.pixelWidth = 0;
    this.pixelHeight = 0;
    this.pixelDepth = 0;
    this.layerCount = 0;
    this.faceCount = 1;
    this.supercompressionScheme = KHR_SUPERCOMPRESSION_NONE;
    this.levels = [];
    this.dataFormatDescriptor = [{
      vendorId: KHR_DF_VENDORID_KHRONOS,
      descriptorType: KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,
      descriptorBlockSize: 0,
      versionNumber: KHR_DF_VERSION,
      colorModel: KHR_DF_MODEL_UNSPECIFIED,
      colorPrimaries: KHR_DF_PRIMARIES_BT709,
      transferFunction: KHR_DF_TRANSFER_SRGB,
      flags: KHR_DF_FLAG_ALPHA_STRAIGHT,
      texelBlockDimension: [0, 0, 0, 0],
      bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
      samples: []
    }];
    this.keyValue = {};
    this.globalData = null;
  }
};
var BufferReader = class {
  constructor(data, byteOffset, byteLength, littleEndian) {
    this._dataView = void 0;
    this._littleEndian = void 0;
    this._offset = void 0;
    this._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength);
    this._littleEndian = littleEndian;
    this._offset = 0;
  }
  _nextUint8() {
    const value = this._dataView.getUint8(this._offset);
    this._offset += 1;
    return value;
  }
  _nextUint16() {
    const value = this._dataView.getUint16(this._offset, this._littleEndian);
    this._offset += 2;
    return value;
  }
  _nextUint32() {
    const value = this._dataView.getUint32(this._offset, this._littleEndian);
    this._offset += 4;
    return value;
  }
  _nextUint64() {
    const left = this._dataView.getUint32(this._offset, this._littleEndian);
    const right = this._dataView.getUint32(this._offset + 4, this._littleEndian);
    const value = left + 2 ** 32 * right;
    this._offset += 8;
    return value;
  }
  _nextInt32() {
    const value = this._dataView.getInt32(this._offset, this._littleEndian);
    this._offset += 4;
    return value;
  }
  _skip(bytes) {
    this._offset += bytes;
    return this;
  }
  _scan(maxByteLength, term = 0) {
    const byteOffset = this._offset;
    let byteLength = 0;
    while (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {
      byteLength++;
      this._offset++;
    }
    if (byteLength < maxByteLength)
      this._offset++;
    return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);
  }
};
var NUL = new Uint8Array([0]);
var KTX2_ID = [
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function decodeText(buffer2) {
  if (typeof TextDecoder !== "undefined") {
    return new TextDecoder().decode(buffer2);
  }
  return Buffer.from(buffer2).toString("utf8");
}
function read(data) {
  const id = new Uint8Array(data.buffer, data.byteOffset, KTX2_ID.length);
  if (id[0] !== KTX2_ID[0] || id[1] !== KTX2_ID[1] || id[2] !== KTX2_ID[2] || id[3] !== KTX2_ID[3] || id[4] !== KTX2_ID[4] || id[5] !== KTX2_ID[5] || id[6] !== KTX2_ID[6] || id[7] !== KTX2_ID[7] || id[8] !== KTX2_ID[8] || id[9] !== KTX2_ID[9] || id[10] !== KTX2_ID[10] || id[11] !== KTX2_ID[11]) {
    throw new Error("Missing KTX 2.0 identifier.");
  }
  const container = new KTX2Container();
  const headerByteLength = 17 * Uint32Array.BYTES_PER_ELEMENT;
  const headerReader = new BufferReader(data, KTX2_ID.length, headerByteLength, true);
  container.vkFormat = headerReader._nextUint32();
  container.typeSize = headerReader._nextUint32();
  container.pixelWidth = headerReader._nextUint32();
  container.pixelHeight = headerReader._nextUint32();
  container.pixelDepth = headerReader._nextUint32();
  container.layerCount = headerReader._nextUint32();
  container.faceCount = headerReader._nextUint32();
  const levelCount = headerReader._nextUint32();
  container.supercompressionScheme = headerReader._nextUint32();
  const dfdByteOffset = headerReader._nextUint32();
  const dfdByteLength = headerReader._nextUint32();
  const kvdByteOffset = headerReader._nextUint32();
  const kvdByteLength = headerReader._nextUint32();
  const sgdByteOffset = headerReader._nextUint64();
  const sgdByteLength = headerReader._nextUint64();
  const levelByteLength = levelCount * 3 * 8;
  const levelReader = new BufferReader(data, KTX2_ID.length + headerByteLength, levelByteLength, true);
  for (let i2 = 0; i2 < levelCount; i2++) {
    container.levels.push({
      levelData: new Uint8Array(data.buffer, data.byteOffset + levelReader._nextUint64(), levelReader._nextUint64()),
      uncompressedByteLength: levelReader._nextUint64()
    });
  }
  const dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength, true);
  const dfd = {
    vendorId: dfdReader._skip(
      4
    )._nextUint16(),
    descriptorType: dfdReader._nextUint16(),
    versionNumber: dfdReader._nextUint16(),
    descriptorBlockSize: dfdReader._nextUint16(),
    colorModel: dfdReader._nextUint8(),
    colorPrimaries: dfdReader._nextUint8(),
    transferFunction: dfdReader._nextUint8(),
    flags: dfdReader._nextUint8(),
    texelBlockDimension: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],
    bytesPlane: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],
    samples: []
  };
  const sampleStart = 6;
  const sampleWords = 4;
  const numSamples = (dfd.descriptorBlockSize / 4 - sampleStart) / sampleWords;
  for (let i2 = 0; i2 < numSamples; i2++) {
    const sample = {
      bitOffset: dfdReader._nextUint16(),
      bitLength: dfdReader._nextUint8(),
      channelType: dfdReader._nextUint8(),
      samplePosition: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],
      sampleLower: -Infinity,
      sampleUpper: Infinity
    };
    if (sample.channelType & KHR_DF_SAMPLE_DATATYPE_SIGNED) {
      sample.sampleLower = dfdReader._nextInt32();
      sample.sampleUpper = dfdReader._nextInt32();
    } else {
      sample.sampleLower = dfdReader._nextUint32();
      sample.sampleUpper = dfdReader._nextUint32();
    }
    dfd.samples[i2] = sample;
  }
  container.dataFormatDescriptor.length = 0;
  container.dataFormatDescriptor.push(dfd);
  const kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);
  while (kvdReader._offset < kvdByteLength) {
    const keyValueByteLength = kvdReader._nextUint32();
    const keyData = kvdReader._scan(keyValueByteLength);
    const key = decodeText(keyData);
    const valueData = kvdReader._scan(keyValueByteLength - keyData.byteLength);
    container.keyValue[key] = key.match(/^ktx/i) ? decodeText(valueData) : valueData;
    if (kvdReader._offset % 4)
      kvdReader._skip(4 - kvdReader._offset % 4);
  }
  if (sgdByteLength <= 0)
    return container;
  const sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);
  const endpointCount = sgdReader._nextUint16();
  const selectorCount = sgdReader._nextUint16();
  const endpointsByteLength = sgdReader._nextUint32();
  const selectorsByteLength = sgdReader._nextUint32();
  const tablesByteLength = sgdReader._nextUint32();
  const extendedByteLength = sgdReader._nextUint32();
  const imageDescs = [];
  for (let i2 = 0; i2 < levelCount; i2++) {
    imageDescs.push({
      imageFlags: sgdReader._nextUint32(),
      rgbSliceByteOffset: sgdReader._nextUint32(),
      rgbSliceByteLength: sgdReader._nextUint32(),
      alphaSliceByteOffset: sgdReader._nextUint32(),
      alphaSliceByteLength: sgdReader._nextUint32()
    });
  }
  const endpointsByteOffset = sgdByteOffset + sgdReader._offset;
  const selectorsByteOffset = endpointsByteOffset + endpointsByteLength;
  const tablesByteOffset = selectorsByteOffset + selectorsByteLength;
  const extendedByteOffset = tablesByteOffset + tablesByteLength;
  const endpointsData = new Uint8Array(data.buffer, data.byteOffset + endpointsByteOffset, endpointsByteLength);
  const selectorsData = new Uint8Array(data.buffer, data.byteOffset + selectorsByteOffset, selectorsByteLength);
  const tablesData = new Uint8Array(data.buffer, data.byteOffset + tablesByteOffset, tablesByteLength);
  const extendedData = new Uint8Array(data.buffer, data.byteOffset + extendedByteOffset, extendedByteLength);
  container.globalData = {
    endpointCount,
    selectorCount,
    imageDescs,
    endpointsData,
    selectorsData,
    tablesData,
    extendedData
  };
  return container;
}

// node_modules/zstddec/dist/zstddec.modern.js
var A;
var I;
var B;
var g = { env: { emscripten_notify_memory_growth: function(A2) {
  B = new Uint8Array(I.exports.memory.buffer);
} } };
var Q = class {
  init() {
    return A || (A = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + C).then((A2) => A2.arrayBuffer()).then((A2) => WebAssembly.instantiate(A2, g)).then(this._init) : WebAssembly.instantiate(Buffer.from(C, "base64"), g).then(this._init), A);
  }
  _init(A2) {
    I = A2.instance, g.env.emscripten_notify_memory_growth(0);
  }
  decode(A2, g2 = 0) {
    if (!I)
      throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const Q2 = A2.byteLength, C2 = I.exports.malloc(Q2);
    B.set(A2, C2), g2 = g2 || Number(I.exports.ZSTD_findDecompressedSize(C2, Q2));
    const E = I.exports.malloc(g2), i2 = I.exports.ZSTD_decompress(E, g2, C2, Q2), D = B.slice(E, E + i2);
    return I.exports.free(C2), I.exports.free(E), D;
  }
};
var C = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";

// node_modules/three-stdlib/loaders/KTX2Loader.js
var _taskCache = /* @__PURE__ */ new WeakMap();
var _activeLoaders = 0;
var _zstd;
var KTX2Loader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.transcoderPath = "";
    this.transcoderBinary = null;
    this.transcoderPending = null;
    this.workerPool = new WorkerPool();
    this.workerSourceURL = "";
    this.workerConfig = null;
    if (typeof MSC_TRANSCODER !== "undefined") {
      console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
    }
  }
  setTranscoderPath(path) {
    this.transcoderPath = path;
    return this;
  }
  setWorkerLimit(num) {
    this.workerPool.setWorkerLimit(num);
    return this;
  }
  detectSupport(renderer) {
    this.workerConfig = {
      astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
      etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    };
    if (renderer.capabilities.isWebGL2) {
      this.workerConfig.etc1Supported = false;
    }
    return this;
  }
  init() {
    if (!this.transcoderPending) {
      const jsLoader = new FileLoader2(this.manager);
      jsLoader.setPath(this.transcoderPath);
      jsLoader.setWithCredentials(this.withCredentials);
      const jsContent = jsLoader.loadAsync("basis_transcoder.js");
      const binaryLoader = new FileLoader2(this.manager);
      binaryLoader.setPath(this.transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.withCredentials);
      const binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn = KTX2Loader.BasisWorker.toString();
        const body = ["/* constants */", "let _EngineFormat = " + JSON.stringify(KTX2Loader.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(KTX2Loader.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(KTX2Loader.BasisFormat), "/* basis_transcoder.js */", jsContent2, "/* worker */", fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.transcoderBinary = binaryContent2;
        this.workerPool.setWorkerCreator(() => {
          const worker = new Worker(this.workerSourceURL);
          const transcoderBinary = this.transcoderBinary.slice(0);
          worker.postMessage({
            type: "init",
            config: this.workerConfig,
            transcoderBinary
          }, [transcoderBinary]);
          return worker;
        });
      });
      if (_activeLoaders > 0) {
        console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances.");
      }
      _activeLoaders++;
    }
    return this.transcoderPending;
  }
  load(url, onLoad, onProgress, onError) {
    if (this.workerConfig === null) {
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    }
    const loader = new FileLoader2(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer2) => {
      if (_taskCache.has(buffer2)) {
        const cachedTask = _taskCache.get(buffer2);
        return cachedTask.promise.then(onLoad).catch(onError);
      }
      this._createTexture(buffer2).then((texture2) => onLoad ? onLoad(texture2) : null).catch(onError);
    }, onProgress, onError);
  }
  _createTextureFrom(transcodeResult) {
    const {
      mipmaps,
      width,
      height,
      format,
      type: type2,
      error,
      dfdTransferFn,
      dfdFlags
    } = transcodeResult;
    if (type2 === "error")
      return Promise.reject(error);
    const texture2 = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);
    texture2.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
    texture2.magFilter = LinearFilter;
    texture2.generateMipmaps = false;
    texture2.needsUpdate = true;
    texture2.encoding = dfdTransferFn === KHR_DF_TRANSFER_SRGB ? sRGBEncoding : LinearEncoding;
    texture2.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED);
    return texture2;
  }
  _createTexture(buffer2, config = {}) {
    const container = read(new Uint8Array(buffer2));
    if (container.vkFormat !== VK_FORMAT_UNDEFINED) {
      return createDataTexture(container);
    }
    const taskConfig = config;
    const texturePending = this.init().then(() => {
      return this.workerPool.postMessage({
        type: "transcode",
        buffer: buffer2,
        taskConfig
      }, [buffer2]);
    }).then((e) => this._createTextureFrom(e.data));
    _taskCache.set(buffer2, {
      promise: texturePending
    });
    return texturePending;
  }
  dispose() {
    this.workerPool.dispose();
    if (this.workerSourceURL)
      URL.revokeObjectURL(this.workerSourceURL);
    _activeLoaders--;
    return this;
  }
};
KTX2Loader.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
KTX2Loader.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
KTX2Loader.EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format
};
KTX2Loader.BasisWorker = function() {
  let config;
  let transcoderPending;
  let BasisModule;
  const EngineFormat = _EngineFormat;
  const TranscoderFormat = _TranscoderFormat;
  const BasisFormat = _BasisFormat;
  self.addEventListener("message", function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config = message.config;
        init(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const {
              width,
              height,
              hasAlpha,
              mipmaps,
              format,
              dfdTransferFn,
              dfdFlags
            } = transcode(message.buffer);
            const buffers = [];
            for (let i2 = 0; i2 < mipmaps.length; ++i2) {
              buffers.push(mipmaps[i2].data.buffer);
            }
            self.postMessage({
              type: "transcode",
              id: message.id,
              width,
              height,
              hasAlpha,
              mipmaps,
              format,
              dfdTransferFn,
              dfdFlags
            }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({
              type: "error",
              id: message.id,
              error: error.message
            });
          }
        });
        break;
    }
  });
  function init(wasmBinary) {
    transcoderPending = new Promise((resolve) => {
      BasisModule = {
        wasmBinary,
        onRuntimeInitialized: resolve
      };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
      if (BasisModule.KTX2File === void 0) {
        console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
      }
    });
  }
  function transcode(buffer2) {
    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer2));
    function cleanup() {
      ktx2File.close();
      ktx2File.delete();
    }
    if (!ktx2File.isValid()) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    }
    const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
    const width = ktx2File.getWidth();
    const height = ktx2File.getHeight();
    const levels = ktx2File.getLevels();
    const hasAlpha = ktx2File.getHasAlpha();
    const dfdTransferFn = ktx2File.getDFDTransferFunc();
    const dfdFlags = ktx2File.getDFDFlags();
    const {
      transcoderFormat,
      engineFormat
    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levels) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid texture");
    }
    if (!ktx2File.startTranscoding()) {
      cleanup();
      throw new Error("THREE.KTX2Loader: .startTranscoding failed");
    }
    const mipmaps = [];
    for (let mip = 0; mip < levels; mip++) {
      const levelInfo = ktx2File.getImageLevelInfo(mip, 0, 0);
      const mipWidth = levelInfo.origWidth;
      const mipHeight = levelInfo.origHeight;
      const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, 0, 0, transcoderFormat));
      const status = ktx2File.transcodeImage(dst, mip, 0, 0, transcoderFormat, 0, -1, -1);
      if (!status) {
        cleanup();
        throw new Error("THREE.KTX2Loader: .transcodeImage failed.");
      }
      mipmaps.push({
        data: dst,
        width: mipWidth,
        height: mipHeight
      });
    }
    cleanup();
    return {
      width,
      height,
      hasAlpha,
      mipmaps,
      format: engineFormat,
      dfdTransferFn,
      dfdFlags
    };
  }
  const FORMAT_OPTIONS = [{
    if: "astcSupported",
    basisFormat: [BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
    priorityETC1S: Infinity,
    priorityUASTC: 1,
    needsPowerOfTwo: false
  }, {
    if: "bptcSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
    priorityETC1S: 3,
    priorityUASTC: 2,
    needsPowerOfTwo: false
  }, {
    if: "dxtSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
    priorityETC1S: 4,
    priorityUASTC: 5,
    needsPowerOfTwo: false
  }, {
    if: "etc2Supported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
    priorityETC1S: 1,
    priorityUASTC: 3,
    needsPowerOfTwo: false
  }, {
    if: "etc1Supported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ETC1],
    engineFormat: [EngineFormat.RGB_ETC1_Format],
    priorityETC1S: 2,
    priorityUASTC: 4,
    needsPowerOfTwo: false
  }, {
    if: "pvrtcSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
    priorityETC1S: 5,
    priorityUASTC: 6,
    needsPowerOfTwo: true
  }];
  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b3) {
    return a2.priorityETC1S - b3.priorityETC1S;
  });
  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b3) {
    return a2.priorityUASTC - b3.priorityUASTC;
  });
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    let transcoderFormat;
    let engineFormat;
    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
    for (let i2 = 0; i2 < options.length; i2++) {
      const opt = options[i2];
      if (!config[opt.if])
        continue;
      if (!opt.basisFormat.includes(basisFormat))
        continue;
      if (hasAlpha && opt.transcoderFormat.length < 2)
        continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height)))
        continue;
      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      return {
        transcoderFormat,
        engineFormat
      };
    }
    console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.");
    transcoderFormat = TranscoderFormat.RGBA32;
    engineFormat = EngineFormat.RGBAFormat;
    return {
      transcoderFormat,
      engineFormat
    };
  }
  function isPowerOfTwo(value) {
    if (value <= 2)
      return true;
    return (value & value - 1) === 0 && value !== 0;
  }
};
var FORMAT_MAP = {
  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,
  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,
  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,
  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,
  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,
  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,
  [VK_FORMAT_R8G8_UNORM]: RGFormat,
  [VK_FORMAT_R8G8_SRGB]: RGFormat,
  [VK_FORMAT_R32_SFLOAT]: RedFormat,
  [VK_FORMAT_R16_SFLOAT]: RedFormat,
  [VK_FORMAT_R8_SRGB]: RedFormat,
  [VK_FORMAT_R8_UNORM]: RedFormat
};
var TYPE_MAP = {
  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,
  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,
  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,
  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,
  [VK_FORMAT_R32G32_SFLOAT]: FloatType,
  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,
  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,
  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,
  [VK_FORMAT_R32_SFLOAT]: FloatType,
  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,
  [VK_FORMAT_R8_SRGB]: UnsignedByteType,
  [VK_FORMAT_R8_UNORM]: UnsignedByteType
};
var ENCODING_MAP = {
  [VK_FORMAT_R8G8B8A8_SRGB]: sRGBEncoding,
  [VK_FORMAT_R8G8_SRGB]: sRGBEncoding,
  [VK_FORMAT_R8_SRGB]: sRGBEncoding
};
async function createDataTexture(container) {
  const {
    vkFormat,
    pixelWidth,
    pixelHeight,
    pixelDepth
  } = container;
  if (FORMAT_MAP[vkFormat] === void 0) {
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  }
  const level = container.levels[0];
  let levelData;
  let view;
  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {
    levelData = level.levelData;
  } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {
    if (!_zstd) {
      _zstd = new Promise(async (resolve) => {
        const zstd = new Q();
        await zstd.init();
        resolve(zstd);
      });
    }
    levelData = (await _zstd).decode(level.levelData, level.uncompressedByteLength);
  } else {
    throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
  }
  if (TYPE_MAP[vkFormat] === FloatType) {
    view = new Float32Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Float32Array.BYTES_PER_ELEMENT);
  } else if (TYPE_MAP[vkFormat] === HalfFloatType) {
    view = new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT);
  } else {
    view = levelData;
  }
  const texture2 = pixelDepth === 0 ? new DataTexture(view, pixelWidth, pixelHeight) : new Data3DTexture(view, pixelWidth, pixelHeight, pixelDepth);
  texture2.type = TYPE_MAP[vkFormat];
  texture2.format = FORMAT_MAP[vkFormat];
  texture2.encoding = ENCODING_MAP[vkFormat] || LinearEncoding;
  texture2.needsUpdate = true;
  return Promise.resolve(texture2);
}

// node_modules/three-stdlib/loaders/LottieLoader.js
var LottieLoader = class extends Loader {
  setQuality(value) {
    this._quality = value;
  }
  load(url, onLoad, onProgress, onError) {
    const quality = this._quality || 1;
    const texture2 = new CanvasTexture();
    texture2.minFilter = NearestFilter;
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      const data = JSON.parse(text);
      const container = document.createElement("div");
      container.style.width = data.w + "px";
      container.style.height = data.h + "px";
      document.body.appendChild(container);
      const animation = bodymovin.loadAnimation({
        container,
        animType: "canvas",
        loop: true,
        autoplay: true,
        animationData: data,
        rendererSettings: {
          dpr: quality
        }
      });
      texture2.animation = animation;
      texture2.image = animation.container;
      animation.addEventListener("enterFrame", function() {
        texture2.needsUpdate = true;
      });
      container.style.display = "none";
      if (onLoad !== void 0) {
        onLoad(texture2);
      }
    }, onProgress, onError);
    return texture2;
  }
};

// node_modules/opentype.js/dist/opentype.module.js
if (!String.prototype.codePointAt) {
  (function() {
    var defineProperty = function() {
      try {
        var object = {};
        var $defineProperty = Object.defineProperty;
        var result = $defineProperty(object, object, object) && $defineProperty;
      } catch (error) {
      }
      return result;
    }();
    var codePointAt = function(position) {
      if (this == null) {
        throw TypeError();
      }
      var string = String(this);
      var size2 = string.length;
      var index = position ? Number(position) : 0;
      if (index != index) {
        index = 0;
      }
      if (index < 0 || index >= size2) {
        return void 0;
      }
      var first = string.charCodeAt(index);
      var second;
      if (first >= 55296 && first <= 56319 && size2 > index + 1) {
        second = string.charCodeAt(index + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    };
    if (defineProperty) {
      defineProperty(String.prototype, "codePointAt", {
        "value": codePointAt,
        "configurable": true,
        "writable": true
      });
    } else {
      String.prototype.codePointAt = codePointAt;
    }
  })();
}
var TINF_OK = 0;
var TINF_DATA_ERROR = -3;
function Tree() {
  this.table = new Uint16Array(16);
  this.trans = new Uint16Array(288);
}
function Data(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  this.dest = dest;
  this.destLen = 0;
  this.ltree = new Tree();
  this.dtree = new Tree();
}
var sltree = new Tree();
var sdtree = new Tree();
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);
var clcidx = new Uint8Array([
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15
]);
var code_tree = new Tree();
var lengths = new Uint8Array(288 + 32);
function tinf_build_bits_base(bits2, base, delta, first) {
  var i2, sum;
  for (i2 = 0; i2 < delta; ++i2) {
    bits2[i2] = 0;
  }
  for (i2 = 0; i2 < 30 - delta; ++i2) {
    bits2[i2 + delta] = i2 / delta | 0;
  }
  for (sum = first, i2 = 0; i2 < 30; ++i2) {
    base[i2] = sum;
    sum += 1 << bits2[i2];
  }
}
function tinf_build_fixed_trees(lt, dt) {
  var i2;
  for (i2 = 0; i2 < 7; ++i2) {
    lt.table[i2] = 0;
  }
  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;
  for (i2 = 0; i2 < 24; ++i2) {
    lt.trans[i2] = 256 + i2;
  }
  for (i2 = 0; i2 < 144; ++i2) {
    lt.trans[24 + i2] = i2;
  }
  for (i2 = 0; i2 < 8; ++i2) {
    lt.trans[24 + 144 + i2] = 280 + i2;
  }
  for (i2 = 0; i2 < 112; ++i2) {
    lt.trans[24 + 144 + 8 + i2] = 144 + i2;
  }
  for (i2 = 0; i2 < 5; ++i2) {
    dt.table[i2] = 0;
  }
  dt.table[5] = 32;
  for (i2 = 0; i2 < 32; ++i2) {
    dt.trans[i2] = i2;
  }
}
var offs = new Uint16Array(16);
function tinf_build_tree(t2, lengths2, off, num) {
  var i2, sum;
  for (i2 = 0; i2 < 16; ++i2) {
    t2.table[i2] = 0;
  }
  for (i2 = 0; i2 < num; ++i2) {
    t2.table[lengths2[off + i2]]++;
  }
  t2.table[0] = 0;
  for (sum = 0, i2 = 0; i2 < 16; ++i2) {
    offs[i2] = sum;
    sum += t2.table[i2];
  }
  for (i2 = 0; i2 < num; ++i2) {
    if (lengths2[off + i2]) {
      t2.trans[offs[lengths2[off + i2]]++] = i2;
    }
  }
}
function tinf_getbit(d) {
  if (!d.bitcount--) {
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }
  var bit = d.tag & 1;
  d.tag >>>= 1;
  return bit;
}
function tinf_read_bits(d, num, base) {
  if (!num) {
    return base;
  }
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var val = d.tag & 65535 >>> 16 - num;
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}
function tinf_decode_symbol(d, t2) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var sum = 0, cur = 0, len = 0;
  var tag = d.tag;
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len;
    sum += t2.table[len];
    cur -= t2.table[len];
  } while (cur >= 0);
  d.tag = tag;
  d.bitcount -= len;
  return t2.trans[sum + cur];
}
function tinf_decode_trees(d, lt, dt) {
  var hlit, hdist, hclen;
  var i2, num, length2;
  hlit = tinf_read_bits(d, 5, 257);
  hdist = tinf_read_bits(d, 5, 1);
  hclen = tinf_read_bits(d, 4, 4);
  for (i2 = 0; i2 < 19; ++i2) {
    lengths[i2] = 0;
  }
  for (i2 = 0; i2 < hclen; ++i2) {
    var clen2 = tinf_read_bits(d, 3, 0);
    lengths[clcidx[i2]] = clen2;
  }
  tinf_build_tree(code_tree, lengths, 0, 19);
  for (num = 0; num < hlit + hdist; ) {
    var sym = tinf_decode_symbol(d, code_tree);
    switch (sym) {
      case 16:
        var prev = lengths[num - 1];
        for (length2 = tinf_read_bits(d, 2, 3); length2; --length2) {
          lengths[num++] = prev;
        }
        break;
      case 17:
        for (length2 = tinf_read_bits(d, 3, 3); length2; --length2) {
          lengths[num++] = 0;
        }
        break;
      case 18:
        for (length2 = tinf_read_bits(d, 7, 11); length2; --length2) {
          lengths[num++] = 0;
        }
        break;
      default:
        lengths[num++] = sym;
        break;
    }
  }
  tinf_build_tree(lt, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}
function tinf_inflate_block_data(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol(d, lt);
    if (sym === 256) {
      return TINF_OK;
    }
    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length2, dist, offs2;
      var i2;
      sym -= 257;
      length2 = tinf_read_bits(d, length_bits[sym], length_base[sym]);
      dist = tinf_decode_symbol(d, dt);
      offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
      for (i2 = offs2; i2 < offs2 + length2; ++i2) {
        d.dest[d.destLen++] = d.dest[i2];
      }
    }
  }
}
function tinf_inflate_uncompressed_block(d) {
  var length2, invlength;
  var i2;
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }
  length2 = d.source[d.sourceIndex + 1];
  length2 = 256 * length2 + d.source[d.sourceIndex];
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];
  if (length2 !== (~invlength & 65535)) {
    return TINF_DATA_ERROR;
  }
  d.sourceIndex += 4;
  for (i2 = length2; i2; --i2) {
    d.dest[d.destLen++] = d.source[d.sourceIndex++];
  }
  d.bitcount = 0;
  return TINF_OK;
}
function tinf_uncompress(source, dest) {
  var d = new Data(source, dest);
  var bfinal, btype, res;
  do {
    bfinal = tinf_getbit(d);
    btype = tinf_read_bits(d, 2, 0);
    switch (btype) {
      case 0:
        res = tinf_inflate_uncompressed_block(d);
        break;
      case 1:
        res = tinf_inflate_block_data(d, sltree, sdtree);
        break;
      case 2:
        tinf_decode_trees(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }
    if (res !== TINF_OK) {
      throw new Error("Data error");
    }
  } while (!bfinal);
  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === "function") {
      return d.dest.slice(0, d.destLen);
    } else {
      return d.dest.subarray(0, d.destLen);
    }
  }
  return d.dest;
}
tinf_build_fixed_trees(sltree, sdtree);
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);
length_bits[28] = 0;
length_base[28] = 258;
var tinyInflate = tinf_uncompress;
function derive(v0, v12, v2, v3, t2) {
  return Math.pow(1 - t2, 3) * v0 + 3 * Math.pow(1 - t2, 2) * t2 * v12 + 3 * (1 - t2) * Math.pow(t2, 2) * v2 + Math.pow(t2, 3) * v3;
}
function BoundingBox() {
  this.x1 = Number.NaN;
  this.y1 = Number.NaN;
  this.x2 = Number.NaN;
  this.y2 = Number.NaN;
}
BoundingBox.prototype.isEmpty = function() {
  return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
};
BoundingBox.prototype.addPoint = function(x, y) {
  if (typeof x === "number") {
    if (isNaN(this.x1) || isNaN(this.x2)) {
      this.x1 = x;
      this.x2 = x;
    }
    if (x < this.x1) {
      this.x1 = x;
    }
    if (x > this.x2) {
      this.x2 = x;
    }
  }
  if (typeof y === "number") {
    if (isNaN(this.y1) || isNaN(this.y2)) {
      this.y1 = y;
      this.y2 = y;
    }
    if (y < this.y1) {
      this.y1 = y;
    }
    if (y > this.y2) {
      this.y2 = y;
    }
  }
};
BoundingBox.prototype.addX = function(x) {
  this.addPoint(x, null);
};
BoundingBox.prototype.addY = function(y) {
  this.addPoint(null, y);
};
BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
  var p0 = [x0, y0];
  var p1 = [x1, y1];
  var p2 = [x2, y2];
  var p3 = [x, y];
  this.addPoint(x0, y0);
  this.addPoint(x, y);
  for (var i2 = 0; i2 <= 1; i2++) {
    var b3 = 6 * p0[i2] - 12 * p1[i2] + 6 * p2[i2];
    var a2 = -3 * p0[i2] + 9 * p1[i2] - 9 * p2[i2] + 3 * p3[i2];
    var c = 3 * p1[i2] - 3 * p0[i2];
    if (a2 === 0) {
      if (b3 === 0) {
        continue;
      }
      var t2 = -c / b3;
      if (0 < t2 && t2 < 1) {
        if (i2 === 0) {
          this.addX(derive(p0[i2], p1[i2], p2[i2], p3[i2], t2));
        }
        if (i2 === 1) {
          this.addY(derive(p0[i2], p1[i2], p2[i2], p3[i2], t2));
        }
      }
      continue;
    }
    var b2ac = Math.pow(b3, 2) - 4 * c * a2;
    if (b2ac < 0) {
      continue;
    }
    var t1 = (-b3 + Math.sqrt(b2ac)) / (2 * a2);
    if (0 < t1 && t1 < 1) {
      if (i2 === 0) {
        this.addX(derive(p0[i2], p1[i2], p2[i2], p3[i2], t1));
      }
      if (i2 === 1) {
        this.addY(derive(p0[i2], p1[i2], p2[i2], p3[i2], t1));
      }
    }
    var t22 = (-b3 - Math.sqrt(b2ac)) / (2 * a2);
    if (0 < t22 && t22 < 1) {
      if (i2 === 0) {
        this.addX(derive(p0[i2], p1[i2], p2[i2], p3[i2], t22));
      }
      if (i2 === 1) {
        this.addY(derive(p0[i2], p1[i2], p2[i2], p3[i2], t22));
      }
    }
  }
};
BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
  var cp1x = x0 + 2 / 3 * (x1 - x0);
  var cp1y = y0 + 2 / 3 * (y1 - y0);
  var cp2x = cp1x + 1 / 3 * (x - x0);
  var cp2y = cp1y + 1 / 3 * (y - y0);
  this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
};
function Path2() {
  this.commands = [];
  this.fill = "black";
  this.stroke = null;
  this.strokeWidth = 1;
}
Path2.prototype.moveTo = function(x, y) {
  this.commands.push({
    type: "M",
    x,
    y
  });
};
Path2.prototype.lineTo = function(x, y) {
  this.commands.push({
    type: "L",
    x,
    y
  });
};
Path2.prototype.curveTo = Path2.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
  this.commands.push({
    type: "C",
    x1,
    y1,
    x2,
    y2,
    x,
    y
  });
};
Path2.prototype.quadTo = Path2.prototype.quadraticCurveTo = function(x1, y1, x, y) {
  this.commands.push({
    type: "Q",
    x1,
    y1,
    x,
    y
  });
};
Path2.prototype.close = Path2.prototype.closePath = function() {
  this.commands.push({
    type: "Z"
  });
};
Path2.prototype.extend = function(pathOrCommands) {
  if (pathOrCommands.commands) {
    pathOrCommands = pathOrCommands.commands;
  } else if (pathOrCommands instanceof BoundingBox) {
    var box = pathOrCommands;
    this.moveTo(box.x1, box.y1);
    this.lineTo(box.x2, box.y1);
    this.lineTo(box.x2, box.y2);
    this.lineTo(box.x1, box.y2);
    this.close();
    return;
  }
  Array.prototype.push.apply(this.commands, pathOrCommands);
};
Path2.prototype.getBoundingBox = function() {
  var box = new BoundingBox();
  var startX = 0;
  var startY = 0;
  var prevX = 0;
  var prevY = 0;
  for (var i2 = 0; i2 < this.commands.length; i2++) {
    var cmd = this.commands[i2];
    switch (cmd.type) {
      case "M":
        box.addPoint(cmd.x, cmd.y);
        startX = prevX = cmd.x;
        startY = prevY = cmd.y;
        break;
      case "L":
        box.addPoint(cmd.x, cmd.y);
        prevX = cmd.x;
        prevY = cmd.y;
        break;
      case "Q":
        box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
        prevX = cmd.x;
        prevY = cmd.y;
        break;
      case "C":
        box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        prevX = cmd.x;
        prevY = cmd.y;
        break;
      case "Z":
        prevX = startX;
        prevY = startY;
        break;
      default:
        throw new Error("Unexpected path command " + cmd.type);
    }
  }
  if (box.isEmpty()) {
    box.addPoint(0, 0);
  }
  return box;
};
Path2.prototype.draw = function(ctx) {
  ctx.beginPath();
  for (var i2 = 0; i2 < this.commands.length; i2 += 1) {
    var cmd = this.commands[i2];
    if (cmd.type === "M") {
      ctx.moveTo(cmd.x, cmd.y);
    } else if (cmd.type === "L") {
      ctx.lineTo(cmd.x, cmd.y);
    } else if (cmd.type === "C") {
      ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
    } else if (cmd.type === "Q") {
      ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
    } else if (cmd.type === "Z") {
      ctx.closePath();
    }
  }
  if (this.fill) {
    ctx.fillStyle = this.fill;
    ctx.fill();
  }
  if (this.stroke) {
    ctx.strokeStyle = this.stroke;
    ctx.lineWidth = this.strokeWidth;
    ctx.stroke();
  }
};
Path2.prototype.toPathData = function(decimalPlaces) {
  decimalPlaces = decimalPlaces !== void 0 ? decimalPlaces : 2;
  function floatToString(v) {
    if (Math.round(v) === v) {
      return "" + Math.round(v);
    } else {
      return v.toFixed(decimalPlaces);
    }
  }
  function packValues() {
    var arguments$1 = arguments;
    var s = "";
    for (var i3 = 0; i3 < arguments.length; i3 += 1) {
      var v = arguments$1[i3];
      if (v >= 0 && i3 > 0) {
        s += " ";
      }
      s += floatToString(v);
    }
    return s;
  }
  var d = "";
  for (var i2 = 0; i2 < this.commands.length; i2 += 1) {
    var cmd = this.commands[i2];
    if (cmd.type === "M") {
      d += "M" + packValues(cmd.x, cmd.y);
    } else if (cmd.type === "L") {
      d += "L" + packValues(cmd.x, cmd.y);
    } else if (cmd.type === "C") {
      d += "C" + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
    } else if (cmd.type === "Q") {
      d += "Q" + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
    } else if (cmd.type === "Z") {
      d += "Z";
    }
  }
  return d;
};
Path2.prototype.toSVG = function(decimalPlaces) {
  var svg = '<path d="';
  svg += this.toPathData(decimalPlaces);
  svg += '"';
  if (this.fill && this.fill !== "black") {
    if (this.fill === null) {
      svg += ' fill="none"';
    } else {
      svg += ' fill="' + this.fill + '"';
    }
  }
  if (this.stroke) {
    svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
  }
  svg += "/>";
  return svg;
};
Path2.prototype.toDOMElement = function(decimalPlaces) {
  var temporaryPath = this.toPathData(decimalPlaces);
  var newPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
  newPath.setAttribute("d", temporaryPath);
  return newPath;
};
function fail(message) {
  throw new Error(message);
}
function argument(predicate, message) {
  if (!predicate) {
    fail(message);
  }
}
var check = { fail, argument, assert: argument };
var LIMIT16 = 32768;
var LIMIT32 = 2147483648;
var decode = {};
var encode = {};
var sizeOf = {};
function constant(v) {
  return function() {
    return v;
  };
}
encode.BYTE = function(v) {
  check.argument(v >= 0 && v <= 255, "Byte value should be between 0 and 255.");
  return [v];
};
sizeOf.BYTE = constant(1);
encode.CHAR = function(v) {
  return [v.charCodeAt(0)];
};
sizeOf.CHAR = constant(1);
encode.CHARARRAY = function(v) {
  if (typeof v === "undefined") {
    v = "";
    console.warn("Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.");
  }
  var b3 = [];
  for (var i2 = 0; i2 < v.length; i2 += 1) {
    b3[i2] = v.charCodeAt(i2);
  }
  return b3;
};
sizeOf.CHARARRAY = function(v) {
  if (typeof v === "undefined") {
    return 0;
  }
  return v.length;
};
encode.USHORT = function(v) {
  return [v >> 8 & 255, v & 255];
};
sizeOf.USHORT = constant(2);
encode.SHORT = function(v) {
  if (v >= LIMIT16) {
    v = -(2 * LIMIT16 - v);
  }
  return [v >> 8 & 255, v & 255];
};
sizeOf.SHORT = constant(2);
encode.UINT24 = function(v) {
  return [v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.UINT24 = constant(3);
encode.ULONG = function(v) {
  return [v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.ULONG = constant(4);
encode.LONG = function(v) {
  if (v >= LIMIT32) {
    v = -(2 * LIMIT32 - v);
  }
  return [v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.LONG = constant(4);
encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;
encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;
encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;
encode.LONGDATETIME = function(v) {
  return [0, 0, 0, 0, v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.LONGDATETIME = constant(8);
encode.TAG = function(v) {
  check.argument(v.length === 4, "Tag should be exactly 4 ASCII characters.");
  return [
    v.charCodeAt(0),
    v.charCodeAt(1),
    v.charCodeAt(2),
    v.charCodeAt(3)
  ];
};
sizeOf.TAG = constant(4);
encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;
encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;
encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;
encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;
encode.NUMBER = function(v) {
  if (v >= -107 && v <= 107) {
    return [v + 139];
  } else if (v >= 108 && v <= 1131) {
    v = v - 108;
    return [(v >> 8) + 247, v & 255];
  } else if (v >= -1131 && v <= -108) {
    v = -v - 108;
    return [(v >> 8) + 251, v & 255];
  } else if (v >= -32768 && v <= 32767) {
    return encode.NUMBER16(v);
  } else {
    return encode.NUMBER32(v);
  }
};
sizeOf.NUMBER = function(v) {
  return encode.NUMBER(v).length;
};
encode.NUMBER16 = function(v) {
  return [28, v >> 8 & 255, v & 255];
};
sizeOf.NUMBER16 = constant(3);
encode.NUMBER32 = function(v) {
  return [29, v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.NUMBER32 = constant(5);
encode.REAL = function(v) {
  var value = v.toString();
  var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
  if (m) {
    var epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
    value = (Math.round(v * epsilon) / epsilon).toString();
  }
  var nibbles = "";
  for (var i2 = 0, ii = value.length; i2 < ii; i2 += 1) {
    var c = value[i2];
    if (c === "e") {
      nibbles += value[++i2] === "-" ? "c" : "b";
    } else if (c === ".") {
      nibbles += "a";
    } else if (c === "-") {
      nibbles += "e";
    } else {
      nibbles += c;
    }
  }
  nibbles += nibbles.length & 1 ? "f" : "ff";
  var out = [30];
  for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
    out.push(parseInt(nibbles.substr(i$1, 2), 16));
  }
  return out;
};
sizeOf.REAL = function(v) {
  return encode.REAL(v).length;
};
encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;
encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;
decode.UTF8 = function(data, offset, numBytes) {
  var codePoints = [];
  var numChars = numBytes;
  for (var j2 = 0; j2 < numChars; j2++, offset += 1) {
    codePoints[j2] = data.getUint8(offset);
  }
  return String.fromCharCode.apply(null, codePoints);
};
decode.UTF16 = function(data, offset, numBytes) {
  var codePoints = [];
  var numChars = numBytes / 2;
  for (var j2 = 0; j2 < numChars; j2++, offset += 2) {
    codePoints[j2] = data.getUint16(offset);
  }
  return String.fromCharCode.apply(null, codePoints);
};
encode.UTF16 = function(v) {
  var b3 = [];
  for (var i2 = 0; i2 < v.length; i2 += 1) {
    var codepoint = v.charCodeAt(i2);
    b3[b3.length] = codepoint >> 8 & 255;
    b3[b3.length] = codepoint & 255;
  }
  return b3;
};
sizeOf.UTF16 = function(v) {
  return v.length * 2;
};
var eightBitMacEncodings = {
  "x-mac-croatian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u03A9\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uF8FF\xA9\u2044\u20AC\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7",
  "x-mac-cyrillic": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E",
  "x-mac-gaelic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u1E02\xB1\u2264\u2265\u1E03\u010A\u010B\u1E0A\u1E0B\u1E1E\u1E1F\u0120\u0121\u1E40\xE6\xF8\u1E41\u1E56\u1E57\u027C\u0192\u017F\u1E60\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\u1E61\u1E9B\xFF\u0178\u1E6A\u20AC\u2039\u203A\u0176\u0177\u1E6B\xB7\u1EF2\u1EF3\u204A\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u2663\xD2\xDA\xDB\xD9\u0131\xDD\xFD\u0174\u0175\u1E84\u1E85\u1E80\u1E81\u1E82\u1E83",
  "x-mac-greek": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\u20AC\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\xB7\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xAD",
  "x-mac-icelandic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
  "x-mac-inuit": "\u1403\u1404\u1405\u1406\u140A\u140B\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144E\u144F\u1450\u1451\u1455\u1456\u1466\u146D\u146E\u146F\u1470\u1472\u1473\u1483\u148B\u148C\u148D\u148E\u1490\u1491\xB0\u14A1\u14A5\u14A6\u2022\xB6\u14A7\xAE\xA9\u2122\u14A8\u14AA\u14AB\u14BB\u14C2\u14C3\u14C4\u14C5\u14C7\u14C8\u14D0\u14EF\u14F0\u14F1\u14F2\u14F4\u14F5\u1505\u14D5\u14D6\u14D7\u14D8\u14DA\u14DB\u14EA\u1528\u1529\u152A\u152B\u152D\u2026\xA0\u152E\u153E\u1555\u1556\u1557\u2013\u2014\u201C\u201D\u2018\u2019\u1558\u1559\u155A\u155D\u1546\u1547\u1548\u1549\u154B\u154C\u1550\u157F\u1580\u1581\u1582\u1583\u1584\u1585\u158F\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15A0\u15A1\u15A2\u15A3\u15A4\u15A5\u15A6\u157C\u0141\u0142",
  "x-mac-ce": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7",
  macintosh: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
  "x-mac-romanian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u0218\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\u0103\u0219\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\u021A\u021B\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
  "x-mac-turkish": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\uF8A0\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
};
decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
  var table2 = eightBitMacEncodings[encoding];
  if (table2 === void 0) {
    return void 0;
  }
  var result = "";
  for (var i2 = 0; i2 < dataLength; i2++) {
    var c = dataView.getUint8(offset + i2);
    if (c <= 127) {
      result += String.fromCharCode(c);
    } else {
      result += table2[c & 127];
    }
  }
  return result;
};
var macEncodingTableCache = typeof WeakMap === "function" && /* @__PURE__ */ new WeakMap();
var macEncodingCacheKeys;
var getMacEncodingTable = function(encoding) {
  if (!macEncodingCacheKeys) {
    macEncodingCacheKeys = {};
    for (var e in eightBitMacEncodings) {
      macEncodingCacheKeys[e] = new String(e);
    }
  }
  var cacheKey = macEncodingCacheKeys[encoding];
  if (cacheKey === void 0) {
    return void 0;
  }
  if (macEncodingTableCache) {
    var cachedTable = macEncodingTableCache.get(cacheKey);
    if (cachedTable !== void 0) {
      return cachedTable;
    }
  }
  var decodingTable = eightBitMacEncodings[encoding];
  if (decodingTable === void 0) {
    return void 0;
  }
  var encodingTable = {};
  for (var i2 = 0; i2 < decodingTable.length; i2++) {
    encodingTable[decodingTable.charCodeAt(i2)] = i2 + 128;
  }
  if (macEncodingTableCache) {
    macEncodingTableCache.set(cacheKey, encodingTable);
  }
  return encodingTable;
};
encode.MACSTRING = function(str, encoding) {
  var table2 = getMacEncodingTable(encoding);
  if (table2 === void 0) {
    return void 0;
  }
  var result = [];
  for (var i2 = 0; i2 < str.length; i2++) {
    var c = str.charCodeAt(i2);
    if (c >= 128) {
      c = table2[c];
      if (c === void 0) {
        return void 0;
      }
    }
    result[i2] = c;
  }
  return result;
};
sizeOf.MACSTRING = function(str, encoding) {
  var b3 = encode.MACSTRING(str, encoding);
  if (b3 !== void 0) {
    return b3.length;
  } else {
    return 0;
  }
};
function isByteEncodable(value) {
  return value >= -128 && value <= 127;
}
function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
  var runLength = 0;
  var numDeltas = deltas.length;
  while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
    ++pos;
    ++runLength;
  }
  result.push(128 | runLength - 1);
  return pos;
}
function encodeVarDeltaRunAsBytes(deltas, offset, result) {
  var runLength = 0;
  var numDeltas = deltas.length;
  var pos = offset;
  while (pos < numDeltas && runLength < 64) {
    var value = deltas[pos];
    if (!isByteEncodable(value)) {
      break;
    }
    if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
      break;
    }
    ++pos;
    ++runLength;
  }
  result.push(runLength - 1);
  for (var i2 = offset; i2 < pos; ++i2) {
    result.push(deltas[i2] + 256 & 255);
  }
  return pos;
}
function encodeVarDeltaRunAsWords(deltas, offset, result) {
  var runLength = 0;
  var numDeltas = deltas.length;
  var pos = offset;
  while (pos < numDeltas && runLength < 64) {
    var value = deltas[pos];
    if (value === 0) {
      break;
    }
    if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
      break;
    }
    ++pos;
    ++runLength;
  }
  result.push(64 | runLength - 1);
  for (var i2 = offset; i2 < pos; ++i2) {
    var val = deltas[i2];
    result.push(val + 65536 >> 8 & 255, val + 256 & 255);
  }
  return pos;
}
encode.VARDELTAS = function(deltas) {
  var pos = 0;
  var result = [];
  while (pos < deltas.length) {
    var value = deltas[pos];
    if (value === 0) {
      pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
    } else if (value >= -128 && value <= 127) {
      pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
    } else {
      pos = encodeVarDeltaRunAsWords(deltas, pos, result);
    }
  }
  return result;
};
encode.INDEX = function(l) {
  var offset = 1;
  var offsets = [offset];
  var data = [];
  for (var i2 = 0; i2 < l.length; i2 += 1) {
    var v = encode.OBJECT(l[i2]);
    Array.prototype.push.apply(data, v);
    offset += v.length;
    offsets.push(offset);
  }
  if (data.length === 0) {
    return [0, 0];
  }
  var encodedOffsets = [];
  var offSize = 1 + Math.floor(Math.log(offset) / Math.log(2)) / 8 | 0;
  var offsetEncoder = [void 0, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
  for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
    var encodedOffset = offsetEncoder(offsets[i$1]);
    Array.prototype.push.apply(encodedOffsets, encodedOffset);
  }
  return Array.prototype.concat(
    encode.Card16(l.length),
    encode.OffSize(offSize),
    encodedOffsets,
    data
  );
};
sizeOf.INDEX = function(v) {
  return encode.INDEX(v).length;
};
encode.DICT = function(m) {
  var d = [];
  var keys = Object.keys(m);
  var length2 = keys.length;
  for (var i2 = 0; i2 < length2; i2 += 1) {
    var k = parseInt(keys[i2], 0);
    var v = m[k];
    d = d.concat(encode.OPERAND(v.value, v.type));
    d = d.concat(encode.OPERATOR(k));
  }
  return d;
};
sizeOf.DICT = function(m) {
  return encode.DICT(m).length;
};
encode.OPERATOR = function(v) {
  if (v < 1200) {
    return [v];
  } else {
    return [12, v - 1200];
  }
};
encode.OPERAND = function(v, type2) {
  var d = [];
  if (Array.isArray(type2)) {
    for (var i2 = 0; i2 < type2.length; i2 += 1) {
      check.argument(v.length === type2.length, "Not enough arguments given for type" + type2);
      d = d.concat(encode.OPERAND(v[i2], type2[i2]));
    }
  } else {
    if (type2 === "SID") {
      d = d.concat(encode.NUMBER(v));
    } else if (type2 === "offset") {
      d = d.concat(encode.NUMBER32(v));
    } else if (type2 === "number") {
      d = d.concat(encode.NUMBER(v));
    } else if (type2 === "real") {
      d = d.concat(encode.REAL(v));
    } else {
      throw new Error("Unknown operand type " + type2);
    }
  }
  return d;
};
encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;
var wmm = typeof WeakMap === "function" && /* @__PURE__ */ new WeakMap();
encode.CHARSTRING = function(ops) {
  if (wmm) {
    var cachedValue = wmm.get(ops);
    if (cachedValue !== void 0) {
      return cachedValue;
    }
  }
  var d = [];
  var length2 = ops.length;
  for (var i2 = 0; i2 < length2; i2 += 1) {
    var op = ops[i2];
    d = d.concat(encode[op.type](op.value));
  }
  if (wmm) {
    wmm.set(ops, d);
  }
  return d;
};
sizeOf.CHARSTRING = function(ops) {
  return encode.CHARSTRING(ops).length;
};
encode.OBJECT = function(v) {
  var encodingFunction = encode[v.type];
  check.argument(encodingFunction !== void 0, "No encoding function for type " + v.type);
  return encodingFunction(v.value);
};
sizeOf.OBJECT = function(v) {
  var sizeOfFunction = sizeOf[v.type];
  check.argument(sizeOfFunction !== void 0, "No sizeOf function for type " + v.type);
  return sizeOfFunction(v.value);
};
encode.TABLE = function(table2) {
  var d = [];
  var length2 = table2.fields.length;
  var subtables = [];
  var subtableOffsets = [];
  for (var i2 = 0; i2 < length2; i2 += 1) {
    var field = table2.fields[i2];
    var encodingFunction = encode[field.type];
    check.argument(encodingFunction !== void 0, "No encoding function for field type " + field.type + " (" + field.name + ")");
    var value = table2[field.name];
    if (value === void 0) {
      value = field.value;
    }
    var bytes = encodingFunction(value);
    if (field.type === "TABLE") {
      subtableOffsets.push(d.length);
      d = d.concat([0, 0]);
      subtables.push(bytes);
    } else {
      d = d.concat(bytes);
    }
  }
  for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
    var o = subtableOffsets[i$1];
    var offset = d.length;
    check.argument(offset < 65536, "Table " + table2.tableName + " too big.");
    d[o] = offset >> 8;
    d[o + 1] = offset & 255;
    d = d.concat(subtables[i$1]);
  }
  return d;
};
sizeOf.TABLE = function(table2) {
  var numBytes = 0;
  var length2 = table2.fields.length;
  for (var i2 = 0; i2 < length2; i2 += 1) {
    var field = table2.fields[i2];
    var sizeOfFunction = sizeOf[field.type];
    check.argument(sizeOfFunction !== void 0, "No sizeOf function for field type " + field.type + " (" + field.name + ")");
    var value = table2[field.name];
    if (value === void 0) {
      value = field.value;
    }
    numBytes += sizeOfFunction(value);
    if (field.type === "TABLE") {
      numBytes += 2;
    }
  }
  return numBytes;
};
encode.RECORD = encode.TABLE;
sizeOf.RECORD = sizeOf.TABLE;
encode.LITERAL = function(v) {
  return v;
};
sizeOf.LITERAL = function(v) {
  return v.length;
};
function Table(tableName, fields, options) {
  if (fields.length && (fields[0].name !== "coverageFormat" || fields[0].value === 1)) {
    for (var i2 = 0; i2 < fields.length; i2 += 1) {
      var field = fields[i2];
      this[field.name] = field.value;
    }
  }
  this.tableName = tableName;
  this.fields = fields;
  if (options) {
    var optionKeys = Object.keys(options);
    for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
      var k = optionKeys[i$1];
      var v = options[k];
      if (this[k] !== void 0) {
        this[k] = v;
      }
    }
  }
}
Table.prototype.encode = function() {
  return encode.TABLE(this);
};
Table.prototype.sizeOf = function() {
  return sizeOf.TABLE(this);
};
function ushortList(itemName, list, count) {
  if (count === void 0) {
    count = list.length;
  }
  var fields = new Array(list.length + 1);
  fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
  for (var i2 = 0; i2 < list.length; i2++) {
    fields[i2 + 1] = { name: itemName + i2, type: "USHORT", value: list[i2] };
  }
  return fields;
}
function tableList(itemName, records, itemCallback) {
  var count = records.length;
  var fields = new Array(count + 1);
  fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
  for (var i2 = 0; i2 < count; i2++) {
    fields[i2 + 1] = { name: itemName + i2, type: "TABLE", value: itemCallback(records[i2], i2) };
  }
  return fields;
}
function recordList(itemName, records, itemCallback) {
  var count = records.length;
  var fields = [];
  fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
  for (var i2 = 0; i2 < count; i2++) {
    fields = fields.concat(itemCallback(records[i2], i2));
  }
  return fields;
}
function Coverage(coverageTable) {
  if (coverageTable.format === 1) {
    Table.call(
      this,
      "coverageTable",
      [{ name: "coverageFormat", type: "USHORT", value: 1 }].concat(ushortList("glyph", coverageTable.glyphs))
    );
  } else if (coverageTable.format === 2) {
    Table.call(
      this,
      "coverageTable",
      [{ name: "coverageFormat", type: "USHORT", value: 2 }].concat(recordList("rangeRecord", coverageTable.ranges, function(RangeRecord) {
        return [
          { name: "startGlyphID", type: "USHORT", value: RangeRecord.start },
          { name: "endGlyphID", type: "USHORT", value: RangeRecord.end },
          { name: "startCoverageIndex", type: "USHORT", value: RangeRecord.index }
        ];
      }))
    );
  } else {
    check.assert(false, "Coverage format must be 1 or 2.");
  }
}
Coverage.prototype = Object.create(Table.prototype);
Coverage.prototype.constructor = Coverage;
function ScriptList(scriptListTable) {
  Table.call(
    this,
    "scriptListTable",
    recordList("scriptRecord", scriptListTable, function(scriptRecord, i2) {
      var script = scriptRecord.script;
      var defaultLangSys = script.defaultLangSys;
      check.assert(!!defaultLangSys, "Unable to write GSUB: script " + scriptRecord.tag + " has no default language system.");
      return [
        { name: "scriptTag" + i2, type: "TAG", value: scriptRecord.tag },
        { name: "script" + i2, type: "TABLE", value: new Table("scriptTable", [
          { name: "defaultLangSys", type: "TABLE", value: new Table("defaultLangSys", [
            { name: "lookupOrder", type: "USHORT", value: 0 },
            { name: "reqFeatureIndex", type: "USHORT", value: defaultLangSys.reqFeatureIndex }
          ].concat(ushortList("featureIndex", defaultLangSys.featureIndexes))) }
        ].concat(recordList("langSys", script.langSysRecords, function(langSysRecord, i3) {
          var langSys = langSysRecord.langSys;
          return [
            { name: "langSysTag" + i3, type: "TAG", value: langSysRecord.tag },
            { name: "langSys" + i3, type: "TABLE", value: new Table("langSys", [
              { name: "lookupOrder", type: "USHORT", value: 0 },
              { name: "reqFeatureIndex", type: "USHORT", value: langSys.reqFeatureIndex }
            ].concat(ushortList("featureIndex", langSys.featureIndexes))) }
          ];
        }))) }
      ];
    })
  );
}
ScriptList.prototype = Object.create(Table.prototype);
ScriptList.prototype.constructor = ScriptList;
function FeatureList(featureListTable) {
  Table.call(
    this,
    "featureListTable",
    recordList("featureRecord", featureListTable, function(featureRecord, i2) {
      var feature = featureRecord.feature;
      return [
        { name: "featureTag" + i2, type: "TAG", value: featureRecord.tag },
        { name: "feature" + i2, type: "TABLE", value: new Table("featureTable", [
          { name: "featureParams", type: "USHORT", value: feature.featureParams }
        ].concat(ushortList("lookupListIndex", feature.lookupListIndexes))) }
      ];
    })
  );
}
FeatureList.prototype = Object.create(Table.prototype);
FeatureList.prototype.constructor = FeatureList;
function LookupList(lookupListTable, subtableMakers2) {
  Table.call(this, "lookupListTable", tableList("lookup", lookupListTable, function(lookupTable) {
    var subtableCallback = subtableMakers2[lookupTable.lookupType];
    check.assert(!!subtableCallback, "Unable to write GSUB lookup type " + lookupTable.lookupType + " tables.");
    return new Table("lookupTable", [
      { name: "lookupType", type: "USHORT", value: lookupTable.lookupType },
      { name: "lookupFlag", type: "USHORT", value: lookupTable.lookupFlag }
    ].concat(tableList("subtable", lookupTable.subtables, subtableCallback)));
  }));
}
LookupList.prototype = Object.create(Table.prototype);
LookupList.prototype.constructor = LookupList;
var table = {
  Table,
  Record: Table,
  Coverage,
  ScriptList,
  FeatureList,
  LookupList,
  ushortList,
  tableList,
  recordList
};
function getByte(dataView, offset) {
  return dataView.getUint8(offset);
}
function getUShort(dataView, offset) {
  return dataView.getUint16(offset, false);
}
function getShort(dataView, offset) {
  return dataView.getInt16(offset, false);
}
function getULong(dataView, offset) {
  return dataView.getUint32(offset, false);
}
function getFixed(dataView, offset) {
  var decimal = dataView.getInt16(offset, false);
  var fraction = dataView.getUint16(offset + 2, false);
  return decimal + fraction / 65535;
}
function getTag(dataView, offset) {
  var tag = "";
  for (var i2 = offset; i2 < offset + 4; i2 += 1) {
    tag += String.fromCharCode(dataView.getInt8(i2));
  }
  return tag;
}
function getOffset(dataView, offset, offSize) {
  var v = 0;
  for (var i2 = 0; i2 < offSize; i2 += 1) {
    v <<= 8;
    v += dataView.getUint8(offset + i2);
  }
  return v;
}
function getBytes(dataView, startOffset, endOffset) {
  var bytes = [];
  for (var i2 = startOffset; i2 < endOffset; i2 += 1) {
    bytes.push(dataView.getUint8(i2));
  }
  return bytes;
}
function bytesToString(bytes) {
  var s = "";
  for (var i2 = 0; i2 < bytes.length; i2 += 1) {
    s += String.fromCharCode(bytes[i2]);
  }
  return s;
}
var typeOffsets = {
  byte: 1,
  uShort: 2,
  short: 2,
  uLong: 4,
  fixed: 4,
  longDateTime: 8,
  tag: 4
};
function Parser3(data, offset) {
  this.data = data;
  this.offset = offset;
  this.relativeOffset = 0;
}
Parser3.prototype.parseByte = function() {
  var v = this.data.getUint8(this.offset + this.relativeOffset);
  this.relativeOffset += 1;
  return v;
};
Parser3.prototype.parseChar = function() {
  var v = this.data.getInt8(this.offset + this.relativeOffset);
  this.relativeOffset += 1;
  return v;
};
Parser3.prototype.parseCard8 = Parser3.prototype.parseByte;
Parser3.prototype.parseUShort = function() {
  var v = this.data.getUint16(this.offset + this.relativeOffset);
  this.relativeOffset += 2;
  return v;
};
Parser3.prototype.parseCard16 = Parser3.prototype.parseUShort;
Parser3.prototype.parseSID = Parser3.prototype.parseUShort;
Parser3.prototype.parseOffset16 = Parser3.prototype.parseUShort;
Parser3.prototype.parseShort = function() {
  var v = this.data.getInt16(this.offset + this.relativeOffset);
  this.relativeOffset += 2;
  return v;
};
Parser3.prototype.parseF2Dot14 = function() {
  var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
  this.relativeOffset += 2;
  return v;
};
Parser3.prototype.parseULong = function() {
  var v = getULong(this.data, this.offset + this.relativeOffset);
  this.relativeOffset += 4;
  return v;
};
Parser3.prototype.parseOffset32 = Parser3.prototype.parseULong;
Parser3.prototype.parseFixed = function() {
  var v = getFixed(this.data, this.offset + this.relativeOffset);
  this.relativeOffset += 4;
  return v;
};
Parser3.prototype.parseString = function(length2) {
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  var string = "";
  this.relativeOffset += length2;
  for (var i2 = 0; i2 < length2; i2++) {
    string += String.fromCharCode(dataView.getUint8(offset + i2));
  }
  return string;
};
Parser3.prototype.parseTag = function() {
  return this.parseString(4);
};
Parser3.prototype.parseLongDateTime = function() {
  var v = getULong(this.data, this.offset + this.relativeOffset + 4);
  v -= 2082844800;
  this.relativeOffset += 8;
  return v;
};
Parser3.prototype.parseVersion = function(minorBase) {
  var major = getUShort(this.data, this.offset + this.relativeOffset);
  var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
  this.relativeOffset += 4;
  if (minorBase === void 0) {
    minorBase = 4096;
  }
  return major + minor / minorBase / 10;
};
Parser3.prototype.skip = function(type2, amount) {
  if (amount === void 0) {
    amount = 1;
  }
  this.relativeOffset += typeOffsets[type2] * amount;
};
Parser3.prototype.parseULongList = function(count) {
  if (count === void 0) {
    count = this.parseULong();
  }
  var offsets = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i2 = 0; i2 < count; i2++) {
    offsets[i2] = dataView.getUint32(offset);
    offset += 4;
  }
  this.relativeOffset += count * 4;
  return offsets;
};
Parser3.prototype.parseOffset16List = Parser3.prototype.parseUShortList = function(count) {
  if (count === void 0) {
    count = this.parseUShort();
  }
  var offsets = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i2 = 0; i2 < count; i2++) {
    offsets[i2] = dataView.getUint16(offset);
    offset += 2;
  }
  this.relativeOffset += count * 2;
  return offsets;
};
Parser3.prototype.parseShortList = function(count) {
  var list = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i2 = 0; i2 < count; i2++) {
    list[i2] = dataView.getInt16(offset);
    offset += 2;
  }
  this.relativeOffset += count * 2;
  return list;
};
Parser3.prototype.parseByteList = function(count) {
  var list = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i2 = 0; i2 < count; i2++) {
    list[i2] = dataView.getUint8(offset++);
  }
  this.relativeOffset += count;
  return list;
};
Parser3.prototype.parseList = function(count, itemCallback) {
  if (!itemCallback) {
    itemCallback = count;
    count = this.parseUShort();
  }
  var list = new Array(count);
  for (var i2 = 0; i2 < count; i2++) {
    list[i2] = itemCallback.call(this);
  }
  return list;
};
Parser3.prototype.parseList32 = function(count, itemCallback) {
  if (!itemCallback) {
    itemCallback = count;
    count = this.parseULong();
  }
  var list = new Array(count);
  for (var i2 = 0; i2 < count; i2++) {
    list[i2] = itemCallback.call(this);
  }
  return list;
};
Parser3.prototype.parseRecordList = function(count, recordDescription) {
  if (!recordDescription) {
    recordDescription = count;
    count = this.parseUShort();
  }
  var records = new Array(count);
  var fields = Object.keys(recordDescription);
  for (var i2 = 0; i2 < count; i2++) {
    var rec = {};
    for (var j2 = 0; j2 < fields.length; j2++) {
      var fieldName = fields[j2];
      var fieldType = recordDescription[fieldName];
      rec[fieldName] = fieldType.call(this);
    }
    records[i2] = rec;
  }
  return records;
};
Parser3.prototype.parseRecordList32 = function(count, recordDescription) {
  if (!recordDescription) {
    recordDescription = count;
    count = this.parseULong();
  }
  var records = new Array(count);
  var fields = Object.keys(recordDescription);
  for (var i2 = 0; i2 < count; i2++) {
    var rec = {};
    for (var j2 = 0; j2 < fields.length; j2++) {
      var fieldName = fields[j2];
      var fieldType = recordDescription[fieldName];
      rec[fieldName] = fieldType.call(this);
    }
    records[i2] = rec;
  }
  return records;
};
Parser3.prototype.parseStruct = function(description) {
  if (typeof description === "function") {
    return description.call(this);
  } else {
    var fields = Object.keys(description);
    var struct = {};
    for (var j2 = 0; j2 < fields.length; j2++) {
      var fieldName = fields[j2];
      var fieldType = description[fieldName];
      struct[fieldName] = fieldType.call(this);
    }
    return struct;
  }
};
Parser3.prototype.parseValueRecord = function(valueFormat) {
  if (valueFormat === void 0) {
    valueFormat = this.parseUShort();
  }
  if (valueFormat === 0) {
    return;
  }
  var valueRecord = {};
  if (valueFormat & 1) {
    valueRecord.xPlacement = this.parseShort();
  }
  if (valueFormat & 2) {
    valueRecord.yPlacement = this.parseShort();
  }
  if (valueFormat & 4) {
    valueRecord.xAdvance = this.parseShort();
  }
  if (valueFormat & 8) {
    valueRecord.yAdvance = this.parseShort();
  }
  if (valueFormat & 16) {
    valueRecord.xPlaDevice = void 0;
    this.parseShort();
  }
  if (valueFormat & 32) {
    valueRecord.yPlaDevice = void 0;
    this.parseShort();
  }
  if (valueFormat & 64) {
    valueRecord.xAdvDevice = void 0;
    this.parseShort();
  }
  if (valueFormat & 128) {
    valueRecord.yAdvDevice = void 0;
    this.parseShort();
  }
  return valueRecord;
};
Parser3.prototype.parseValueRecordList = function() {
  var valueFormat = this.parseUShort();
  var valueCount = this.parseUShort();
  var values = new Array(valueCount);
  for (var i2 = 0; i2 < valueCount; i2++) {
    values[i2] = this.parseValueRecord(valueFormat);
  }
  return values;
};
Parser3.prototype.parsePointer = function(description) {
  var structOffset = this.parseOffset16();
  if (structOffset > 0) {
    return new Parser3(this.data, this.offset + structOffset).parseStruct(description);
  }
  return void 0;
};
Parser3.prototype.parsePointer32 = function(description) {
  var structOffset = this.parseOffset32();
  if (structOffset > 0) {
    return new Parser3(this.data, this.offset + structOffset).parseStruct(description);
  }
  return void 0;
};
Parser3.prototype.parseListOfLists = function(itemCallback) {
  var offsets = this.parseOffset16List();
  var count = offsets.length;
  var relativeOffset = this.relativeOffset;
  var list = new Array(count);
  for (var i2 = 0; i2 < count; i2++) {
    var start = offsets[i2];
    if (start === 0) {
      list[i2] = void 0;
      continue;
    }
    this.relativeOffset = start;
    if (itemCallback) {
      var subOffsets = this.parseOffset16List();
      var subList = new Array(subOffsets.length);
      for (var j2 = 0; j2 < subOffsets.length; j2++) {
        this.relativeOffset = start + subOffsets[j2];
        subList[j2] = itemCallback.call(this);
      }
      list[i2] = subList;
    } else {
      list[i2] = this.parseUShortList();
    }
  }
  this.relativeOffset = relativeOffset;
  return list;
};
Parser3.prototype.parseCoverage = function() {
  var startOffset = this.offset + this.relativeOffset;
  var format = this.parseUShort();
  var count = this.parseUShort();
  if (format === 1) {
    return {
      format: 1,
      glyphs: this.parseUShortList(count)
    };
  } else if (format === 2) {
    var ranges = new Array(count);
    for (var i2 = 0; i2 < count; i2++) {
      ranges[i2] = {
        start: this.parseUShort(),
        end: this.parseUShort(),
        index: this.parseUShort()
      };
    }
    return {
      format: 2,
      ranges
    };
  }
  throw new Error("0x" + startOffset.toString(16) + ": Coverage format must be 1 or 2.");
};
Parser3.prototype.parseClassDef = function() {
  var startOffset = this.offset + this.relativeOffset;
  var format = this.parseUShort();
  if (format === 1) {
    return {
      format: 1,
      startGlyph: this.parseUShort(),
      classes: this.parseUShortList()
    };
  } else if (format === 2) {
    return {
      format: 2,
      ranges: this.parseRecordList({
        start: Parser3.uShort,
        end: Parser3.uShort,
        classId: Parser3.uShort
      })
    };
  }
  throw new Error("0x" + startOffset.toString(16) + ": ClassDef format must be 1 or 2.");
};
Parser3.list = function(count, itemCallback) {
  return function() {
    return this.parseList(count, itemCallback);
  };
};
Parser3.list32 = function(count, itemCallback) {
  return function() {
    return this.parseList32(count, itemCallback);
  };
};
Parser3.recordList = function(count, recordDescription) {
  return function() {
    return this.parseRecordList(count, recordDescription);
  };
};
Parser3.recordList32 = function(count, recordDescription) {
  return function() {
    return this.parseRecordList32(count, recordDescription);
  };
};
Parser3.pointer = function(description) {
  return function() {
    return this.parsePointer(description);
  };
};
Parser3.pointer32 = function(description) {
  return function() {
    return this.parsePointer32(description);
  };
};
Parser3.tag = Parser3.prototype.parseTag;
Parser3.byte = Parser3.prototype.parseByte;
Parser3.uShort = Parser3.offset16 = Parser3.prototype.parseUShort;
Parser3.uShortList = Parser3.prototype.parseUShortList;
Parser3.uLong = Parser3.offset32 = Parser3.prototype.parseULong;
Parser3.uLongList = Parser3.prototype.parseULongList;
Parser3.struct = Parser3.prototype.parseStruct;
Parser3.coverage = Parser3.prototype.parseCoverage;
Parser3.classDef = Parser3.prototype.parseClassDef;
var langSysTable = {
  reserved: Parser3.uShort,
  reqFeatureIndex: Parser3.uShort,
  featureIndexes: Parser3.uShortList
};
Parser3.prototype.parseScriptList = function() {
  return this.parsePointer(Parser3.recordList({
    tag: Parser3.tag,
    script: Parser3.pointer({
      defaultLangSys: Parser3.pointer(langSysTable),
      langSysRecords: Parser3.recordList({
        tag: Parser3.tag,
        langSys: Parser3.pointer(langSysTable)
      })
    })
  })) || [];
};
Parser3.prototype.parseFeatureList = function() {
  return this.parsePointer(Parser3.recordList({
    tag: Parser3.tag,
    feature: Parser3.pointer({
      featureParams: Parser3.offset16,
      lookupListIndexes: Parser3.uShortList
    })
  })) || [];
};
Parser3.prototype.parseLookupList = function(lookupTableParsers) {
  return this.parsePointer(Parser3.list(Parser3.pointer(function() {
    var lookupType = this.parseUShort();
    check.argument(1 <= lookupType && lookupType <= 9, "GPOS/GSUB lookup type " + lookupType + " unknown.");
    var lookupFlag = this.parseUShort();
    var useMarkFilteringSet = lookupFlag & 16;
    return {
      lookupType,
      lookupFlag,
      subtables: this.parseList(Parser3.pointer(lookupTableParsers[lookupType])),
      markFilteringSet: useMarkFilteringSet ? this.parseUShort() : void 0
    };
  }))) || [];
};
Parser3.prototype.parseFeatureVariationsList = function() {
  return this.parsePointer32(function() {
    var majorVersion = this.parseUShort();
    var minorVersion = this.parseUShort();
    check.argument(majorVersion === 1 && minorVersion < 1, "GPOS/GSUB feature variations table unknown.");
    var featureVariations = this.parseRecordList32({
      conditionSetOffset: Parser3.offset32,
      featureTableSubstitutionOffset: Parser3.offset32
    });
    return featureVariations;
  }) || [];
};
var parse = {
  getByte,
  getCard8: getByte,
  getUShort,
  getCard16: getUShort,
  getShort,
  getULong,
  getFixed,
  getTag,
  getOffset,
  getBytes,
  bytesToString,
  Parser: Parser3
};
function parseCmapTableFormat12(cmap2, p) {
  p.parseUShort();
  cmap2.length = p.parseULong();
  cmap2.language = p.parseULong();
  var groupCount;
  cmap2.groupCount = groupCount = p.parseULong();
  cmap2.glyphIndexMap = {};
  for (var i2 = 0; i2 < groupCount; i2 += 1) {
    var startCharCode = p.parseULong();
    var endCharCode = p.parseULong();
    var startGlyphId = p.parseULong();
    for (var c = startCharCode; c <= endCharCode; c += 1) {
      cmap2.glyphIndexMap[c] = startGlyphId;
      startGlyphId++;
    }
  }
}
function parseCmapTableFormat4(cmap2, p, data, start, offset) {
  cmap2.length = p.parseUShort();
  cmap2.language = p.parseUShort();
  var segCount;
  cmap2.segCount = segCount = p.parseUShort() >> 1;
  p.skip("uShort", 3);
  cmap2.glyphIndexMap = {};
  var endCountParser = new parse.Parser(data, start + offset + 14);
  var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
  var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
  var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
  var glyphIndexOffset = start + offset + 16 + segCount * 8;
  for (var i2 = 0; i2 < segCount - 1; i2 += 1) {
    var glyphIndex = void 0;
    var endCount = endCountParser.parseUShort();
    var startCount = startCountParser.parseUShort();
    var idDelta = idDeltaParser.parseShort();
    var idRangeOffset = idRangeOffsetParser.parseUShort();
    for (var c = startCount; c <= endCount; c += 1) {
      if (idRangeOffset !== 0) {
        glyphIndexOffset = idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2;
        glyphIndexOffset += idRangeOffset;
        glyphIndexOffset += (c - startCount) * 2;
        glyphIndex = parse.getUShort(data, glyphIndexOffset);
        if (glyphIndex !== 0) {
          glyphIndex = glyphIndex + idDelta & 65535;
        }
      } else {
        glyphIndex = c + idDelta & 65535;
      }
      cmap2.glyphIndexMap[c] = glyphIndex;
    }
  }
}
function parseCmapTable(data, start) {
  var cmap2 = {};
  cmap2.version = parse.getUShort(data, start);
  check.argument(cmap2.version === 0, "cmap table version should be 0.");
  cmap2.numTables = parse.getUShort(data, start + 2);
  var offset = -1;
  for (var i2 = cmap2.numTables - 1; i2 >= 0; i2 -= 1) {
    var platformId = parse.getUShort(data, start + 4 + i2 * 8);
    var encodingId = parse.getUShort(data, start + 4 + i2 * 8 + 2);
    if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10) || platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4)) {
      offset = parse.getULong(data, start + 4 + i2 * 8 + 4);
      break;
    }
  }
  if (offset === -1) {
    throw new Error("No valid cmap sub-tables found.");
  }
  var p = new parse.Parser(data, start + offset);
  cmap2.format = p.parseUShort();
  if (cmap2.format === 12) {
    parseCmapTableFormat12(cmap2, p);
  } else if (cmap2.format === 4) {
    parseCmapTableFormat4(cmap2, p, data, start, offset);
  } else {
    throw new Error("Only format 4 and 12 cmap tables are supported (found format " + cmap2.format + ").");
  }
  return cmap2;
}
function addSegment(t2, code, glyphIndex) {
  t2.segments.push({
    end: code,
    start: code,
    delta: -(code - glyphIndex),
    offset: 0,
    glyphIndex
  });
}
function addTerminatorSegment(t2) {
  t2.segments.push({
    end: 65535,
    start: 65535,
    delta: 1,
    offset: 0
  });
}
function makeCmapTable(glyphs) {
  var isPlan0Only = true;
  var i2;
  for (i2 = glyphs.length - 1; i2 > 0; i2 -= 1) {
    var g2 = glyphs.get(i2);
    if (g2.unicode > 65535) {
      console.log("Adding CMAP format 12 (needed!)");
      isPlan0Only = false;
      break;
    }
  }
  var cmapTable = [
    { name: "version", type: "USHORT", value: 0 },
    { name: "numTables", type: "USHORT", value: isPlan0Only ? 1 : 2 },
    { name: "platformID", type: "USHORT", value: 3 },
    { name: "encodingID", type: "USHORT", value: 1 },
    { name: "offset", type: "ULONG", value: isPlan0Only ? 12 : 12 + 8 }
  ];
  if (!isPlan0Only) {
    cmapTable = cmapTable.concat([
      { name: "cmap12PlatformID", type: "USHORT", value: 3 },
      { name: "cmap12EncodingID", type: "USHORT", value: 10 },
      { name: "cmap12Offset", type: "ULONG", value: 0 }
    ]);
  }
  cmapTable = cmapTable.concat([
    { name: "format", type: "USHORT", value: 4 },
    { name: "cmap4Length", type: "USHORT", value: 0 },
    { name: "language", type: "USHORT", value: 0 },
    { name: "segCountX2", type: "USHORT", value: 0 },
    { name: "searchRange", type: "USHORT", value: 0 },
    { name: "entrySelector", type: "USHORT", value: 0 },
    { name: "rangeShift", type: "USHORT", value: 0 }
  ]);
  var t2 = new table.Table("cmap", cmapTable);
  t2.segments = [];
  for (i2 = 0; i2 < glyphs.length; i2 += 1) {
    var glyph = glyphs.get(i2);
    for (var j2 = 0; j2 < glyph.unicodes.length; j2 += 1) {
      addSegment(t2, glyph.unicodes[j2], i2);
    }
    t2.segments = t2.segments.sort(function(a2, b3) {
      return a2.start - b3.start;
    });
  }
  addTerminatorSegment(t2);
  var segCount = t2.segments.length;
  var segCountToRemove = 0;
  var endCounts = [];
  var startCounts = [];
  var idDeltas = [];
  var idRangeOffsets = [];
  var glyphIds = [];
  var cmap12Groups = [];
  for (i2 = 0; i2 < segCount; i2 += 1) {
    var segment = t2.segments[i2];
    if (segment.end <= 65535 && segment.start <= 65535) {
      endCounts = endCounts.concat({ name: "end_" + i2, type: "USHORT", value: segment.end });
      startCounts = startCounts.concat({ name: "start_" + i2, type: "USHORT", value: segment.start });
      idDeltas = idDeltas.concat({ name: "idDelta_" + i2, type: "SHORT", value: segment.delta });
      idRangeOffsets = idRangeOffsets.concat({ name: "idRangeOffset_" + i2, type: "USHORT", value: segment.offset });
      if (segment.glyphId !== void 0) {
        glyphIds = glyphIds.concat({ name: "glyph_" + i2, type: "USHORT", value: segment.glyphId });
      }
    } else {
      segCountToRemove += 1;
    }
    if (!isPlan0Only && segment.glyphIndex !== void 0) {
      cmap12Groups = cmap12Groups.concat({ name: "cmap12Start_" + i2, type: "ULONG", value: segment.start });
      cmap12Groups = cmap12Groups.concat({ name: "cmap12End_" + i2, type: "ULONG", value: segment.end });
      cmap12Groups = cmap12Groups.concat({ name: "cmap12Glyph_" + i2, type: "ULONG", value: segment.glyphIndex });
    }
  }
  t2.segCountX2 = (segCount - segCountToRemove) * 2;
  t2.searchRange = Math.pow(2, Math.floor(Math.log(segCount - segCountToRemove) / Math.log(2))) * 2;
  t2.entrySelector = Math.log(t2.searchRange / 2) / Math.log(2);
  t2.rangeShift = t2.segCountX2 - t2.searchRange;
  t2.fields = t2.fields.concat(endCounts);
  t2.fields.push({ name: "reservedPad", type: "USHORT", value: 0 });
  t2.fields = t2.fields.concat(startCounts);
  t2.fields = t2.fields.concat(idDeltas);
  t2.fields = t2.fields.concat(idRangeOffsets);
  t2.fields = t2.fields.concat(glyphIds);
  t2.cmap4Length = 14 + endCounts.length * 2 + 2 + startCounts.length * 2 + idDeltas.length * 2 + idRangeOffsets.length * 2 + glyphIds.length * 2;
  if (!isPlan0Only) {
    var cmap12Length = 16 + cmap12Groups.length * 4;
    t2.cmap12Offset = 12 + 2 * 2 + 4 + t2.cmap4Length;
    t2.fields = t2.fields.concat([
      { name: "cmap12Format", type: "USHORT", value: 12 },
      { name: "cmap12Reserved", type: "USHORT", value: 0 },
      { name: "cmap12Length", type: "ULONG", value: cmap12Length },
      { name: "cmap12Language", type: "ULONG", value: 0 },
      { name: "cmap12nGroups", type: "ULONG", value: cmap12Groups.length / 3 }
    ]);
    t2.fields = t2.fields.concat(cmap12Groups);
  }
  return t2;
}
var cmap = { parse: parseCmapTable, make: makeCmapTable };
var cffStandardStrings = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "266 ff",
  "onedotenleader",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall",
  "001.000",
  "001.001",
  "001.002",
  "001.003",
  "Black",
  "Bold",
  "Book",
  "Light",
  "Medium",
  "Regular",
  "Roman",
  "Semibold"
];
var cffStandardEncoding = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "",
  "questiondown",
  "",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "",
  "ring",
  "cedilla",
  "",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "AE",
  "",
  "ordfeminine",
  "",
  "",
  "",
  "",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "",
  "",
  "",
  "",
  "",
  "ae",
  "",
  "",
  "",
  "dotlessi",
  "",
  "",
  "lslash",
  "oslash",
  "oe",
  "germandbls"
];
var cffExpertEncoding = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "",
  "",
  "isuperior",
  "",
  "",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "",
  "",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "",
  "",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "",
  "Dotaccentsmall",
  "",
  "",
  "Macronsmall",
  "",
  "",
  "figuredash",
  "hypheninferior",
  "",
  "",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "",
  "",
  "",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "",
  "",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var standardNames = [
  ".notdef",
  ".null",
  "nonmarkingreturn",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quotesingle",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "grave",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "Adieresis",
  "Aring",
  "Ccedilla",
  "Eacute",
  "Ntilde",
  "Odieresis",
  "Udieresis",
  "aacute",
  "agrave",
  "acircumflex",
  "adieresis",
  "atilde",
  "aring",
  "ccedilla",
  "eacute",
  "egrave",
  "ecircumflex",
  "edieresis",
  "iacute",
  "igrave",
  "icircumflex",
  "idieresis",
  "ntilde",
  "oacute",
  "ograve",
  "ocircumflex",
  "odieresis",
  "otilde",
  "uacute",
  "ugrave",
  "ucircumflex",
  "udieresis",
  "dagger",
  "degree",
  "cent",
  "sterling",
  "section",
  "bullet",
  "paragraph",
  "germandbls",
  "registered",
  "copyright",
  "trademark",
  "acute",
  "dieresis",
  "notequal",
  "AE",
  "Oslash",
  "infinity",
  "plusminus",
  "lessequal",
  "greaterequal",
  "yen",
  "mu",
  "partialdiff",
  "summation",
  "product",
  "pi",
  "integral",
  "ordfeminine",
  "ordmasculine",
  "Omega",
  "ae",
  "oslash",
  "questiondown",
  "exclamdown",
  "logicalnot",
  "radical",
  "florin",
  "approxequal",
  "Delta",
  "guillemotleft",
  "guillemotright",
  "ellipsis",
  "nonbreakingspace",
  "Agrave",
  "Atilde",
  "Otilde",
  "OE",
  "oe",
  "endash",
  "emdash",
  "quotedblleft",
  "quotedblright",
  "quoteleft",
  "quoteright",
  "divide",
  "lozenge",
  "ydieresis",
  "Ydieresis",
  "fraction",
  "currency",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "daggerdbl",
  "periodcentered",
  "quotesinglbase",
  "quotedblbase",
  "perthousand",
  "Acircumflex",
  "Ecircumflex",
  "Aacute",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Oacute",
  "Ocircumflex",
  "apple",
  "Ograve",
  "Uacute",
  "Ucircumflex",
  "Ugrave",
  "dotlessi",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "Lslash",
  "lslash",
  "Scaron",
  "scaron",
  "Zcaron",
  "zcaron",
  "brokenbar",
  "Eth",
  "eth",
  "Yacute",
  "yacute",
  "Thorn",
  "thorn",
  "minus",
  "multiply",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "onehalf",
  "onequarter",
  "threequarters",
  "franc",
  "Gbreve",
  "gbreve",
  "Idotaccent",
  "Scedilla",
  "scedilla",
  "Cacute",
  "cacute",
  "Ccaron",
  "ccaron",
  "dcroat"
];
function DefaultEncoding(font) {
  this.font = font;
}
DefaultEncoding.prototype.charToGlyphIndex = function(c) {
  var code = c.codePointAt(0);
  var glyphs = this.font.glyphs;
  if (glyphs) {
    for (var i2 = 0; i2 < glyphs.length; i2 += 1) {
      var glyph = glyphs.get(i2);
      for (var j2 = 0; j2 < glyph.unicodes.length; j2 += 1) {
        if (glyph.unicodes[j2] === code) {
          return i2;
        }
      }
    }
  }
  return null;
};
function CmapEncoding(cmap2) {
  this.cmap = cmap2;
}
CmapEncoding.prototype.charToGlyphIndex = function(c) {
  return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;
};
function CffEncoding(encoding, charset) {
  this.encoding = encoding;
  this.charset = charset;
}
CffEncoding.prototype.charToGlyphIndex = function(s) {
  var code = s.codePointAt(0);
  var charName = this.encoding[code];
  return this.charset.indexOf(charName);
};
function GlyphNames(post2) {
  switch (post2.version) {
    case 1:
      this.names = standardNames.slice();
      break;
    case 2:
      this.names = new Array(post2.numberOfGlyphs);
      for (var i2 = 0; i2 < post2.numberOfGlyphs; i2++) {
        if (post2.glyphNameIndex[i2] < standardNames.length) {
          this.names[i2] = standardNames[post2.glyphNameIndex[i2]];
        } else {
          this.names[i2] = post2.names[post2.glyphNameIndex[i2] - standardNames.length];
        }
      }
      break;
    case 2.5:
      this.names = new Array(post2.numberOfGlyphs);
      for (var i$1 = 0; i$1 < post2.numberOfGlyphs; i$1++) {
        this.names[i$1] = standardNames[i$1 + post2.glyphNameIndex[i$1]];
      }
      break;
    case 3:
      this.names = [];
      break;
    default:
      this.names = [];
      break;
  }
}
GlyphNames.prototype.nameToGlyphIndex = function(name) {
  return this.names.indexOf(name);
};
GlyphNames.prototype.glyphIndexToName = function(gid) {
  return this.names[gid];
};
function addGlyphNamesAll(font) {
  var glyph;
  var glyphIndexMap = font.tables.cmap.glyphIndexMap;
  var charCodes = Object.keys(glyphIndexMap);
  for (var i2 = 0; i2 < charCodes.length; i2 += 1) {
    var c = charCodes[i2];
    var glyphIndex = glyphIndexMap[c];
    glyph = font.glyphs.get(glyphIndex);
    glyph.addUnicode(parseInt(c));
  }
  for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
    glyph = font.glyphs.get(i$1);
    if (font.cffEncoding) {
      if (font.isCIDFont) {
        glyph.name = "gid" + i$1;
      } else {
        glyph.name = font.cffEncoding.charset[i$1];
      }
    } else if (font.glyphNames.names) {
      glyph.name = font.glyphNames.glyphIndexToName(i$1);
    }
  }
}
function addGlyphNamesToUnicodeMap(font) {
  font._IndexToUnicodeMap = {};
  var glyphIndexMap = font.tables.cmap.glyphIndexMap;
  var charCodes = Object.keys(glyphIndexMap);
  for (var i2 = 0; i2 < charCodes.length; i2 += 1) {
    var c = charCodes[i2];
    var glyphIndex = glyphIndexMap[c];
    if (font._IndexToUnicodeMap[glyphIndex] === void 0) {
      font._IndexToUnicodeMap[glyphIndex] = {
        unicodes: [parseInt(c)]
      };
    } else {
      font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));
    }
  }
}
function addGlyphNames(font, opt) {
  if (opt.lowMemory) {
    addGlyphNamesToUnicodeMap(font);
  } else {
    addGlyphNamesAll(font);
  }
}
function line(ctx, x1, y1, x2, y2) {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
}
var draw = { line };
function getPathDefinition(glyph, path) {
  var _path = path || new Path2();
  return {
    configurable: true,
    get: function() {
      if (typeof _path === "function") {
        _path = _path();
      }
      return _path;
    },
    set: function(p) {
      _path = p;
    }
  };
}
function Glyph(options) {
  this.bindConstructorValues(options);
}
Glyph.prototype.bindConstructorValues = function(options) {
  this.index = options.index || 0;
  this.name = options.name || null;
  this.unicode = options.unicode || void 0;
  this.unicodes = options.unicodes || options.unicode !== void 0 ? [options.unicode] : [];
  if ("xMin" in options) {
    this.xMin = options.xMin;
  }
  if ("yMin" in options) {
    this.yMin = options.yMin;
  }
  if ("xMax" in options) {
    this.xMax = options.xMax;
  }
  if ("yMax" in options) {
    this.yMax = options.yMax;
  }
  if ("advanceWidth" in options) {
    this.advanceWidth = options.advanceWidth;
  }
  Object.defineProperty(this, "path", getPathDefinition(this, options.path));
};
Glyph.prototype.addUnicode = function(unicode) {
  if (this.unicodes.length === 0) {
    this.unicode = unicode;
  }
  this.unicodes.push(unicode);
};
Glyph.prototype.getBoundingBox = function() {
  return this.path.getBoundingBox();
};
Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 72;
  var commands;
  var hPoints;
  if (!options) {
    options = {};
  }
  var xScale = options.xScale;
  var yScale = options.yScale;
  if (options.hinting && font && font.hinting) {
    hPoints = this.path && font.hinting.exec(this, fontSize);
  }
  if (hPoints) {
    commands = font.hinting.getCommands(hPoints);
    x = Math.round(x);
    y = Math.round(y);
    xScale = yScale = 1;
  } else {
    commands = this.path.commands;
    var scale = 1 / (this.path.unitsPerEm || 1e3) * fontSize;
    if (xScale === void 0) {
      xScale = scale;
    }
    if (yScale === void 0) {
      yScale = scale;
    }
  }
  var p = new Path2();
  for (var i2 = 0; i2 < commands.length; i2 += 1) {
    var cmd = commands[i2];
    if (cmd.type === "M") {
      p.moveTo(x + cmd.x * xScale, y + -cmd.y * yScale);
    } else if (cmd.type === "L") {
      p.lineTo(x + cmd.x * xScale, y + -cmd.y * yScale);
    } else if (cmd.type === "Q") {
      p.quadraticCurveTo(
        x + cmd.x1 * xScale,
        y + -cmd.y1 * yScale,
        x + cmd.x * xScale,
        y + -cmd.y * yScale
      );
    } else if (cmd.type === "C") {
      p.curveTo(
        x + cmd.x1 * xScale,
        y + -cmd.y1 * yScale,
        x + cmd.x2 * xScale,
        y + -cmd.y2 * yScale,
        x + cmd.x * xScale,
        y + -cmd.y * yScale
      );
    } else if (cmd.type === "Z") {
      p.closePath();
    }
  }
  return p;
};
Glyph.prototype.getContours = function() {
  if (this.points === void 0) {
    return [];
  }
  var contours = [];
  var currentContour = [];
  for (var i2 = 0; i2 < this.points.length; i2 += 1) {
    var pt = this.points[i2];
    currentContour.push(pt);
    if (pt.lastPointOfContour) {
      contours.push(currentContour);
      currentContour = [];
    }
  }
  check.argument(currentContour.length === 0, "There are still points left in the current contour.");
  return contours;
};
Glyph.prototype.getMetrics = function() {
  var commands = this.path.commands;
  var xCoords = [];
  var yCoords = [];
  for (var i2 = 0; i2 < commands.length; i2 += 1) {
    var cmd = commands[i2];
    if (cmd.type !== "Z") {
      xCoords.push(cmd.x);
      yCoords.push(cmd.y);
    }
    if (cmd.type === "Q" || cmd.type === "C") {
      xCoords.push(cmd.x1);
      yCoords.push(cmd.y1);
    }
    if (cmd.type === "C") {
      xCoords.push(cmd.x2);
      yCoords.push(cmd.y2);
    }
  }
  var metrics = {
    xMin: Math.min.apply(null, xCoords),
    yMin: Math.min.apply(null, yCoords),
    xMax: Math.max.apply(null, xCoords),
    yMax: Math.max.apply(null, yCoords),
    leftSideBearing: this.leftSideBearing
  };
  if (!isFinite(metrics.xMin)) {
    metrics.xMin = 0;
  }
  if (!isFinite(metrics.xMax)) {
    metrics.xMax = this.advanceWidth;
  }
  if (!isFinite(metrics.yMin)) {
    metrics.yMin = 0;
  }
  if (!isFinite(metrics.yMax)) {
    metrics.yMax = 0;
  }
  metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
  return metrics;
};
Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
  this.getPath(x, y, fontSize, options).draw(ctx);
};
Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
  function drawCircles(l, x2, y2, scale2) {
    ctx.beginPath();
    for (var j2 = 0; j2 < l.length; j2 += 1) {
      ctx.moveTo(x2 + l[j2].x * scale2, y2 + l[j2].y * scale2);
      ctx.arc(x2 + l[j2].x * scale2, y2 + l[j2].y * scale2, 2, 0, Math.PI * 2, false);
    }
    ctx.closePath();
    ctx.fill();
  }
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 24;
  var scale = 1 / this.path.unitsPerEm * fontSize;
  var blueCircles = [];
  var redCircles = [];
  var path = this.path;
  for (var i2 = 0; i2 < path.commands.length; i2 += 1) {
    var cmd = path.commands[i2];
    if (cmd.x !== void 0) {
      blueCircles.push({ x: cmd.x, y: -cmd.y });
    }
    if (cmd.x1 !== void 0) {
      redCircles.push({ x: cmd.x1, y: -cmd.y1 });
    }
    if (cmd.x2 !== void 0) {
      redCircles.push({ x: cmd.x2, y: -cmd.y2 });
    }
  }
  ctx.fillStyle = "blue";
  drawCircles(blueCircles, x, y, scale);
  ctx.fillStyle = "red";
  drawCircles(redCircles, x, y, scale);
};
Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
  var scale;
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 24;
  scale = 1 / this.path.unitsPerEm * fontSize;
  ctx.lineWidth = 1;
  ctx.strokeStyle = "black";
  draw.line(ctx, x, -1e4, x, 1e4);
  draw.line(ctx, -1e4, y, 1e4, y);
  var xMin = this.xMin || 0;
  var yMin = this.yMin || 0;
  var xMax = this.xMax || 0;
  var yMax = this.yMax || 0;
  var advanceWidth = this.advanceWidth || 0;
  ctx.strokeStyle = "blue";
  draw.line(ctx, x + xMin * scale, -1e4, x + xMin * scale, 1e4);
  draw.line(ctx, x + xMax * scale, -1e4, x + xMax * scale, 1e4);
  draw.line(ctx, -1e4, y + -yMin * scale, 1e4, y + -yMin * scale);
  draw.line(ctx, -1e4, y + -yMax * scale, 1e4, y + -yMax * scale);
  ctx.strokeStyle = "green";
  draw.line(ctx, x + advanceWidth * scale, -1e4, x + advanceWidth * scale, 1e4);
};
function defineDependentProperty(glyph, externalName, internalName) {
  Object.defineProperty(glyph, externalName, {
    get: function() {
      glyph.path;
      return glyph[internalName];
    },
    set: function(newValue) {
      glyph[internalName] = newValue;
    },
    enumerable: true,
    configurable: true
  });
}
function GlyphSet(font, glyphs) {
  this.font = font;
  this.glyphs = {};
  if (Array.isArray(glyphs)) {
    for (var i2 = 0; i2 < glyphs.length; i2++) {
      var glyph = glyphs[i2];
      glyph.path.unitsPerEm = font.unitsPerEm;
      this.glyphs[i2] = glyph;
    }
  }
  this.length = glyphs && glyphs.length || 0;
}
GlyphSet.prototype.get = function(index) {
  if (this.glyphs[index] === void 0) {
    this.font._push(index);
    if (typeof this.glyphs[index] === "function") {
      this.glyphs[index] = this.glyphs[index]();
    }
    var glyph = this.glyphs[index];
    var unicodeObj = this.font._IndexToUnicodeMap[index];
    if (unicodeObj) {
      for (var j2 = 0; j2 < unicodeObj.unicodes.length; j2++) {
        glyph.addUnicode(unicodeObj.unicodes[j2]);
      }
    }
    if (this.font.cffEncoding) {
      if (this.font.isCIDFont) {
        glyph.name = "gid" + index;
      } else {
        glyph.name = this.font.cffEncoding.charset[index];
      }
    } else if (this.font.glyphNames.names) {
      glyph.name = this.font.glyphNames.glyphIndexToName(index);
    }
    this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;
    this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;
  } else {
    if (typeof this.glyphs[index] === "function") {
      this.glyphs[index] = this.glyphs[index]();
    }
  }
  return this.glyphs[index];
};
GlyphSet.prototype.push = function(index, loader) {
  this.glyphs[index] = loader;
  this.length++;
};
function glyphLoader(font, index) {
  return new Glyph({ index, font });
}
function ttfGlyphLoader(font, index, parseGlyph2, data, position, buildPath2) {
  return function() {
    var glyph = new Glyph({ index, font });
    glyph.path = function() {
      parseGlyph2(glyph, data, position);
      var path = buildPath2(font.glyphs, glyph);
      path.unitsPerEm = font.unitsPerEm;
      return path;
    };
    defineDependentProperty(glyph, "xMin", "_xMin");
    defineDependentProperty(glyph, "xMax", "_xMax");
    defineDependentProperty(glyph, "yMin", "_yMin");
    defineDependentProperty(glyph, "yMax", "_yMax");
    return glyph;
  };
}
function cffGlyphLoader(font, index, parseCFFCharstring2, charstring) {
  return function() {
    var glyph = new Glyph({ index, font });
    glyph.path = function() {
      var path = parseCFFCharstring2(font, glyph, charstring);
      path.unitsPerEm = font.unitsPerEm;
      return path;
    };
    return glyph;
  };
}
var glyphset = { GlyphSet, glyphLoader, ttfGlyphLoader, cffGlyphLoader };
function equals(a2, b3) {
  if (a2 === b3) {
    return true;
  } else if (Array.isArray(a2) && Array.isArray(b3)) {
    if (a2.length !== b3.length) {
      return false;
    }
    for (var i2 = 0; i2 < a2.length; i2 += 1) {
      if (!equals(a2[i2], b3[i2])) {
        return false;
      }
    }
    return true;
  } else {
    return false;
  }
}
function calcCFFSubroutineBias(subrs) {
  var bias;
  if (subrs.length < 1240) {
    bias = 107;
  } else if (subrs.length < 33900) {
    bias = 1131;
  } else {
    bias = 32768;
  }
  return bias;
}
function parseCFFIndex(data, start, conversionFn) {
  var offsets = [];
  var objects = [];
  var count = parse.getCard16(data, start);
  var objectOffset;
  var endOffset;
  if (count !== 0) {
    var offsetSize = parse.getByte(data, start + 2);
    objectOffset = start + (count + 1) * offsetSize + 2;
    var pos = start + 3;
    for (var i2 = 0; i2 < count + 1; i2 += 1) {
      offsets.push(parse.getOffset(data, pos, offsetSize));
      pos += offsetSize;
    }
    endOffset = objectOffset + offsets[count];
  } else {
    endOffset = start + 2;
  }
  for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
    var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
    if (conversionFn) {
      value = conversionFn(value);
    }
    objects.push(value);
  }
  return { objects, startOffset: start, endOffset };
}
function parseCFFIndexLowMemory(data, start) {
  var offsets = [];
  var count = parse.getCard16(data, start);
  var objectOffset;
  var endOffset;
  if (count !== 0) {
    var offsetSize = parse.getByte(data, start + 2);
    objectOffset = start + (count + 1) * offsetSize + 2;
    var pos = start + 3;
    for (var i2 = 0; i2 < count + 1; i2 += 1) {
      offsets.push(parse.getOffset(data, pos, offsetSize));
      pos += offsetSize;
    }
    endOffset = objectOffset + offsets[count];
  } else {
    endOffset = start + 2;
  }
  return { offsets, startOffset: start, endOffset };
}
function getCffIndexObject(i2, offsets, data, start, conversionFn) {
  var count = parse.getCard16(data, start);
  var objectOffset = 0;
  if (count !== 0) {
    var offsetSize = parse.getByte(data, start + 2);
    objectOffset = start + (count + 1) * offsetSize + 2;
  }
  var value = parse.getBytes(data, objectOffset + offsets[i2], objectOffset + offsets[i2 + 1]);
  if (conversionFn) {
    value = conversionFn(value);
  }
  return value;
}
function parseFloatOperand(parser) {
  var s = "";
  var eof = 15;
  var lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
  while (true) {
    var b3 = parser.parseByte();
    var n1 = b3 >> 4;
    var n2 = b3 & 15;
    if (n1 === eof) {
      break;
    }
    s += lookup[n1];
    if (n2 === eof) {
      break;
    }
    s += lookup[n2];
  }
  return parseFloat(s);
}
function parseOperand(parser, b0) {
  var b1;
  var b22;
  var b3;
  var b42;
  if (b0 === 28) {
    b1 = parser.parseByte();
    b22 = parser.parseByte();
    return b1 << 8 | b22;
  }
  if (b0 === 29) {
    b1 = parser.parseByte();
    b22 = parser.parseByte();
    b3 = parser.parseByte();
    b42 = parser.parseByte();
    return b1 << 24 | b22 << 16 | b3 << 8 | b42;
  }
  if (b0 === 30) {
    return parseFloatOperand(parser);
  }
  if (b0 >= 32 && b0 <= 246) {
    return b0 - 139;
  }
  if (b0 >= 247 && b0 <= 250) {
    b1 = parser.parseByte();
    return (b0 - 247) * 256 + b1 + 108;
  }
  if (b0 >= 251 && b0 <= 254) {
    b1 = parser.parseByte();
    return -(b0 - 251) * 256 - b1 - 108;
  }
  throw new Error("Invalid b0 " + b0);
}
function entriesToObject(entries) {
  var o = {};
  for (var i2 = 0; i2 < entries.length; i2 += 1) {
    var key = entries[i2][0];
    var values = entries[i2][1];
    var value = void 0;
    if (values.length === 1) {
      value = values[0];
    } else {
      value = values;
    }
    if (o.hasOwnProperty(key) && !isNaN(o[key])) {
      throw new Error("Object " + o + " already has key " + key);
    }
    o[key] = value;
  }
  return o;
}
function parseCFFDict(data, start, size2) {
  start = start !== void 0 ? start : 0;
  var parser = new parse.Parser(data, start);
  var entries = [];
  var operands = [];
  size2 = size2 !== void 0 ? size2 : data.length;
  while (parser.relativeOffset < size2) {
    var op = parser.parseByte();
    if (op <= 21) {
      if (op === 12) {
        op = 1200 + parser.parseByte();
      }
      entries.push([op, operands]);
      operands = [];
    } else {
      operands.push(parseOperand(parser, op));
    }
  }
  return entriesToObject(entries);
}
function getCFFString(strings, index) {
  if (index <= 390) {
    index = cffStandardStrings[index];
  } else {
    index = strings[index - 391];
  }
  return index;
}
function interpretDict(dict, meta2, strings) {
  var newDict = {};
  var value;
  for (var i2 = 0; i2 < meta2.length; i2 += 1) {
    var m = meta2[i2];
    if (Array.isArray(m.type)) {
      var values = [];
      values.length = m.type.length;
      for (var j2 = 0; j2 < m.type.length; j2++) {
        value = dict[m.op] !== void 0 ? dict[m.op][j2] : void 0;
        if (value === void 0) {
          value = m.value !== void 0 && m.value[j2] !== void 0 ? m.value[j2] : null;
        }
        if (m.type[j2] === "SID") {
          value = getCFFString(strings, value);
        }
        values[j2] = value;
      }
      newDict[m.name] = values;
    } else {
      value = dict[m.op];
      if (value === void 0) {
        value = m.value !== void 0 ? m.value : null;
      }
      if (m.type === "SID") {
        value = getCFFString(strings, value);
      }
      newDict[m.name] = value;
    }
  }
  return newDict;
}
function parseCFFHeader(data, start) {
  var header = {};
  header.formatMajor = parse.getCard8(data, start);
  header.formatMinor = parse.getCard8(data, start + 1);
  header.size = parse.getCard8(data, start + 2);
  header.offsetSize = parse.getCard8(data, start + 3);
  header.startOffset = start;
  header.endOffset = start + 4;
  return header;
}
var TOP_DICT_META = [
  { name: "version", op: 0, type: "SID" },
  { name: "notice", op: 1, type: "SID" },
  { name: "copyright", op: 1200, type: "SID" },
  { name: "fullName", op: 2, type: "SID" },
  { name: "familyName", op: 3, type: "SID" },
  { name: "weight", op: 4, type: "SID" },
  { name: "isFixedPitch", op: 1201, type: "number", value: 0 },
  { name: "italicAngle", op: 1202, type: "number", value: 0 },
  { name: "underlinePosition", op: 1203, type: "number", value: -100 },
  { name: "underlineThickness", op: 1204, type: "number", value: 50 },
  { name: "paintType", op: 1205, type: "number", value: 0 },
  { name: "charstringType", op: 1206, type: "number", value: 2 },
  {
    name: "fontMatrix",
    op: 1207,
    type: ["real", "real", "real", "real", "real", "real"],
    value: [1e-3, 0, 0, 1e-3, 0, 0]
  },
  { name: "uniqueId", op: 13, type: "number" },
  { name: "fontBBox", op: 5, type: ["number", "number", "number", "number"], value: [0, 0, 0, 0] },
  { name: "strokeWidth", op: 1208, type: "number", value: 0 },
  { name: "xuid", op: 14, type: [], value: null },
  { name: "charset", op: 15, type: "offset", value: 0 },
  { name: "encoding", op: 16, type: "offset", value: 0 },
  { name: "charStrings", op: 17, type: "offset", value: 0 },
  { name: "private", op: 18, type: ["number", "offset"], value: [0, 0] },
  { name: "ros", op: 1230, type: ["SID", "SID", "number"] },
  { name: "cidFontVersion", op: 1231, type: "number", value: 0 },
  { name: "cidFontRevision", op: 1232, type: "number", value: 0 },
  { name: "cidFontType", op: 1233, type: "number", value: 0 },
  { name: "cidCount", op: 1234, type: "number", value: 8720 },
  { name: "uidBase", op: 1235, type: "number" },
  { name: "fdArray", op: 1236, type: "offset" },
  { name: "fdSelect", op: 1237, type: "offset" },
  { name: "fontName", op: 1238, type: "SID" }
];
var PRIVATE_DICT_META = [
  { name: "subrs", op: 19, type: "offset", value: 0 },
  { name: "defaultWidthX", op: 20, type: "number", value: 0 },
  { name: "nominalWidthX", op: 21, type: "number", value: 0 }
];
function parseCFFTopDict(data, strings) {
  var dict = parseCFFDict(data, 0, data.byteLength);
  return interpretDict(dict, TOP_DICT_META, strings);
}
function parseCFFPrivateDict(data, start, size2, strings) {
  var dict = parseCFFDict(data, start, size2);
  return interpretDict(dict, PRIVATE_DICT_META, strings);
}
function gatherCFFTopDicts(data, start, cffIndex, strings) {
  var topDictArray = [];
  for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
    var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
    var topDict = parseCFFTopDict(topDictData, strings);
    topDict._subrs = [];
    topDict._subrsBias = 0;
    topDict._defaultWidthX = 0;
    topDict._nominalWidthX = 0;
    var privateSize = topDict.private[0];
    var privateOffset = topDict.private[1];
    if (privateSize !== 0 && privateOffset !== 0) {
      var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
      topDict._defaultWidthX = privateDict.defaultWidthX;
      topDict._nominalWidthX = privateDict.nominalWidthX;
      if (privateDict.subrs !== 0) {
        var subrOffset = privateOffset + privateDict.subrs;
        var subrIndex = parseCFFIndex(data, subrOffset + start);
        topDict._subrs = subrIndex.objects;
        topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
      }
      topDict._privateDict = privateDict;
    }
    topDictArray.push(topDict);
  }
  return topDictArray;
}
function parseCFFCharset(data, start, nGlyphs, strings) {
  var sid;
  var count;
  var parser = new parse.Parser(data, start);
  nGlyphs -= 1;
  var charset = [".notdef"];
  var format = parser.parseCard8();
  if (format === 0) {
    for (var i2 = 0; i2 < nGlyphs; i2 += 1) {
      sid = parser.parseSID();
      charset.push(getCFFString(strings, sid));
    }
  } else if (format === 1) {
    while (charset.length <= nGlyphs) {
      sid = parser.parseSID();
      count = parser.parseCard8();
      for (var i$1 = 0; i$1 <= count; i$1 += 1) {
        charset.push(getCFFString(strings, sid));
        sid += 1;
      }
    }
  } else if (format === 2) {
    while (charset.length <= nGlyphs) {
      sid = parser.parseSID();
      count = parser.parseCard16();
      for (var i$2 = 0; i$2 <= count; i$2 += 1) {
        charset.push(getCFFString(strings, sid));
        sid += 1;
      }
    }
  } else {
    throw new Error("Unknown charset format " + format);
  }
  return charset;
}
function parseCFFEncoding(data, start, charset) {
  var code;
  var enc = {};
  var parser = new parse.Parser(data, start);
  var format = parser.parseCard8();
  if (format === 0) {
    var nCodes = parser.parseCard8();
    for (var i2 = 0; i2 < nCodes; i2 += 1) {
      code = parser.parseCard8();
      enc[code] = i2;
    }
  } else if (format === 1) {
    var nRanges = parser.parseCard8();
    code = 1;
    for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
      var first = parser.parseCard8();
      var nLeft = parser.parseCard8();
      for (var j2 = first; j2 <= first + nLeft; j2 += 1) {
        enc[j2] = code;
        code += 1;
      }
    }
  } else {
    throw new Error("Unknown encoding format " + format);
  }
  return new CffEncoding(enc, charset);
}
function parseCFFCharstring(font, glyph, code) {
  var c1x;
  var c1y;
  var c2x;
  var c2y;
  var p = new Path2();
  var stack = [];
  var nStems = 0;
  var haveWidth = false;
  var open = false;
  var x = 0;
  var y = 0;
  var subrs;
  var subrsBias;
  var defaultWidthX;
  var nominalWidthX;
  if (font.isCIDFont) {
    var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
    var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
    subrs = fdDict._subrs;
    subrsBias = fdDict._subrsBias;
    defaultWidthX = fdDict._defaultWidthX;
    nominalWidthX = fdDict._nominalWidthX;
  } else {
    subrs = font.tables.cff.topDict._subrs;
    subrsBias = font.tables.cff.topDict._subrsBias;
    defaultWidthX = font.tables.cff.topDict._defaultWidthX;
    nominalWidthX = font.tables.cff.topDict._nominalWidthX;
  }
  var width = defaultWidthX;
  function newContour(x2, y2) {
    if (open) {
      p.closePath();
    }
    p.moveTo(x2, y2);
    open = true;
  }
  function parseStems() {
    var hasWidthArg;
    hasWidthArg = stack.length % 2 !== 0;
    if (hasWidthArg && !haveWidth) {
      width = stack.shift() + nominalWidthX;
    }
    nStems += stack.length >> 1;
    stack.length = 0;
    haveWidth = true;
  }
  function parse2(code2) {
    var b1;
    var b22;
    var b3;
    var b42;
    var codeIndex;
    var subrCode;
    var jpx;
    var jpy;
    var c3x;
    var c3y;
    var c4x;
    var c4y;
    var i2 = 0;
    while (i2 < code2.length) {
      var v = code2[i2];
      i2 += 1;
      switch (v) {
        case 1:
          parseStems();
          break;
        case 3:
          parseStems();
          break;
        case 4:
          if (stack.length > 1 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          y += stack.pop();
          newContour(x, y);
          break;
        case 5:
          while (stack.length > 0) {
            x += stack.shift();
            y += stack.shift();
            p.lineTo(x, y);
          }
          break;
        case 6:
          while (stack.length > 0) {
            x += stack.shift();
            p.lineTo(x, y);
            if (stack.length === 0) {
              break;
            }
            y += stack.shift();
            p.lineTo(x, y);
          }
          break;
        case 7:
          while (stack.length > 0) {
            y += stack.shift();
            p.lineTo(x, y);
            if (stack.length === 0) {
              break;
            }
            x += stack.shift();
            p.lineTo(x, y);
          }
          break;
        case 8:
          while (stack.length > 0) {
            c1x = x + stack.shift();
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + stack.shift();
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 10:
          codeIndex = stack.pop() + subrsBias;
          subrCode = subrs[codeIndex];
          if (subrCode) {
            parse2(subrCode);
          }
          break;
        case 11:
          return;
        case 12:
          v = code2[i2];
          i2 += 1;
          switch (v) {
            case 35:
              c1x = x + stack.shift();
              c1y = y + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y + stack.shift();
              c3x = jpx + stack.shift();
              c3y = jpy + stack.shift();
              c4x = c3x + stack.shift();
              c4y = c3y + stack.shift();
              x = c4x + stack.shift();
              y = c4y + stack.shift();
              stack.shift();
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            case 34:
              c1x = x + stack.shift();
              c1y = y;
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y;
              c3x = jpx + stack.shift();
              c3y = c2y;
              c4x = c3x + stack.shift();
              c4y = y;
              x = c4x + stack.shift();
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            case 36:
              c1x = x + stack.shift();
              c1y = y + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y;
              c3x = jpx + stack.shift();
              c3y = c2y;
              c4x = c3x + stack.shift();
              c4y = c3y + stack.shift();
              x = c4x + stack.shift();
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            case 37:
              c1x = x + stack.shift();
              c1y = y + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y + stack.shift();
              c3x = jpx + stack.shift();
              c3y = jpy + stack.shift();
              c4x = c3x + stack.shift();
              c4y = c3y + stack.shift();
              if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                x = c4x + stack.shift();
              } else {
                y = c4y + stack.shift();
              }
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            default:
              console.log("Glyph " + glyph.index + ": unknown operator " + 1200 + v);
              stack.length = 0;
          }
          break;
        case 14:
          if (stack.length > 0 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          if (open) {
            p.closePath();
            open = false;
          }
          break;
        case 18:
          parseStems();
          break;
        case 19:
        case 20:
          parseStems();
          i2 += nStems + 7 >> 3;
          break;
        case 21:
          if (stack.length > 2 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          y += stack.pop();
          x += stack.pop();
          newContour(x, y);
          break;
        case 22:
          if (stack.length > 1 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          x += stack.pop();
          newContour(x, y);
          break;
        case 23:
          parseStems();
          break;
        case 24:
          while (stack.length > 2) {
            c1x = x + stack.shift();
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + stack.shift();
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          x += stack.shift();
          y += stack.shift();
          p.lineTo(x, y);
          break;
        case 25:
          while (stack.length > 6) {
            x += stack.shift();
            y += stack.shift();
            p.lineTo(x, y);
          }
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          x = c2x + stack.shift();
          y = c2y + stack.shift();
          p.curveTo(c1x, c1y, c2x, c2y, x, y);
          break;
        case 26:
          if (stack.length % 2) {
            x += stack.shift();
          }
          while (stack.length > 0) {
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x;
            y = c2y + stack.shift();
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 27:
          if (stack.length % 2) {
            y += stack.shift();
          }
          while (stack.length > 0) {
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y;
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 28:
          b1 = code2[i2];
          b22 = code2[i2 + 1];
          stack.push((b1 << 24 | b22 << 16) >> 16);
          i2 += 2;
          break;
        case 29:
          codeIndex = stack.pop() + font.gsubrsBias;
          subrCode = font.gsubrs[codeIndex];
          if (subrCode) {
            parse2(subrCode);
          }
          break;
        case 30:
          while (stack.length > 0) {
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
            if (stack.length === 0) {
              break;
            }
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            y = c2y + stack.shift();
            x = c2x + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 31:
          while (stack.length > 0) {
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            y = c2y + stack.shift();
            x = c2x + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
            if (stack.length === 0) {
              break;
            }
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        default:
          if (v < 32) {
            console.log("Glyph " + glyph.index + ": unknown operator " + v);
          } else if (v < 247) {
            stack.push(v - 139);
          } else if (v < 251) {
            b1 = code2[i2];
            i2 += 1;
            stack.push((v - 247) * 256 + b1 + 108);
          } else if (v < 255) {
            b1 = code2[i2];
            i2 += 1;
            stack.push(-(v - 251) * 256 - b1 - 108);
          } else {
            b1 = code2[i2];
            b22 = code2[i2 + 1];
            b3 = code2[i2 + 2];
            b42 = code2[i2 + 3];
            i2 += 4;
            stack.push((b1 << 24 | b22 << 16 | b3 << 8 | b42) / 65536);
          }
      }
    }
  }
  parse2(code);
  glyph.advanceWidth = width;
  return p;
}
function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
  var fdSelect = [];
  var fdIndex;
  var parser = new parse.Parser(data, start);
  var format = parser.parseCard8();
  if (format === 0) {
    for (var iGid = 0; iGid < nGlyphs; iGid++) {
      fdIndex = parser.parseCard8();
      if (fdIndex >= fdArrayCount) {
        throw new Error("CFF table CID Font FDSelect has bad FD index value " + fdIndex + " (FD count " + fdArrayCount + ")");
      }
      fdSelect.push(fdIndex);
    }
  } else if (format === 3) {
    var nRanges = parser.parseCard16();
    var first = parser.parseCard16();
    if (first !== 0) {
      throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + first);
    }
    var next;
    for (var iRange = 0; iRange < nRanges; iRange++) {
      fdIndex = parser.parseCard8();
      next = parser.parseCard16();
      if (fdIndex >= fdArrayCount) {
        throw new Error("CFF table CID Font FDSelect has bad FD index value " + fdIndex + " (FD count " + fdArrayCount + ")");
      }
      if (next > nGlyphs) {
        throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + next);
      }
      for (; first < next; first++) {
        fdSelect.push(fdIndex);
      }
      first = next;
    }
    if (next !== nGlyphs) {
      throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + next);
    }
  } else {
    throw new Error("CFF Table CID Font FDSelect table has unsupported format " + format);
  }
  return fdSelect;
}
function parseCFFTable(data, start, font, opt) {
  font.tables.cff = {};
  var header = parseCFFHeader(data, start);
  var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
  var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
  var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
  var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
  font.gsubrs = globalSubrIndex.objects;
  font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);
  var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
  if (topDictArray.length !== 1) {
    throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " + topDictArray.length);
  }
  var topDict = topDictArray[0];
  font.tables.cff.topDict = topDict;
  if (topDict._privateDict) {
    font.defaultWidthX = topDict._privateDict.defaultWidthX;
    font.nominalWidthX = topDict._privateDict.nominalWidthX;
  }
  if (topDict.ros[0] !== void 0 && topDict.ros[1] !== void 0) {
    font.isCIDFont = true;
  }
  if (font.isCIDFont) {
    var fdArrayOffset = topDict.fdArray;
    var fdSelectOffset = topDict.fdSelect;
    if (fdArrayOffset === 0 || fdSelectOffset === 0) {
      throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");
    }
    fdArrayOffset += start;
    var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
    var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
    topDict._fdArray = fdArray;
    fdSelectOffset += start;
    topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
  }
  var privateDictOffset = start + topDict.private[1];
  var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
  font.defaultWidthX = privateDict.defaultWidthX;
  font.nominalWidthX = privateDict.nominalWidthX;
  if (privateDict.subrs !== 0) {
    var subrOffset = privateDictOffset + privateDict.subrs;
    var subrIndex = parseCFFIndex(data, subrOffset);
    font.subrs = subrIndex.objects;
    font.subrsBias = calcCFFSubroutineBias(font.subrs);
  } else {
    font.subrs = [];
    font.subrsBias = 0;
  }
  var charStringsIndex;
  if (opt.lowMemory) {
    charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.offsets.length;
  } else {
    charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;
  }
  var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
  if (topDict.encoding === 0) {
    font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
  } else if (topDict.encoding === 1) {
    font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
  } else {
    font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
  }
  font.encoding = font.encoding || font.cffEncoding;
  font.glyphs = new glyphset.GlyphSet(font);
  if (opt.lowMemory) {
    font._push = function(i3) {
      var charString2 = getCffIndexObject(i3, charStringsIndex.offsets, data, start + topDict.charStrings);
      font.glyphs.push(i3, glyphset.cffGlyphLoader(font, i3, parseCFFCharstring, charString2));
    };
  } else {
    for (var i2 = 0; i2 < font.nGlyphs; i2 += 1) {
      var charString = charStringsIndex.objects[i2];
      font.glyphs.push(i2, glyphset.cffGlyphLoader(font, i2, parseCFFCharstring, charString));
    }
  }
}
function encodeString(s, strings) {
  var sid;
  var i2 = cffStandardStrings.indexOf(s);
  if (i2 >= 0) {
    sid = i2;
  }
  i2 = strings.indexOf(s);
  if (i2 >= 0) {
    sid = i2 + cffStandardStrings.length;
  } else {
    sid = cffStandardStrings.length + strings.length;
    strings.push(s);
  }
  return sid;
}
function makeHeader() {
  return new table.Record("Header", [
    { name: "major", type: "Card8", value: 1 },
    { name: "minor", type: "Card8", value: 0 },
    { name: "hdrSize", type: "Card8", value: 4 },
    { name: "major", type: "Card8", value: 1 }
  ]);
}
function makeNameIndex(fontNames) {
  var t2 = new table.Record("Name INDEX", [
    { name: "names", type: "INDEX", value: [] }
  ]);
  t2.names = [];
  for (var i2 = 0; i2 < fontNames.length; i2 += 1) {
    t2.names.push({ name: "name_" + i2, type: "NAME", value: fontNames[i2] });
  }
  return t2;
}
function makeDict(meta2, attrs, strings) {
  var m = {};
  for (var i2 = 0; i2 < meta2.length; i2 += 1) {
    var entry = meta2[i2];
    var value = attrs[entry.name];
    if (value !== void 0 && !equals(value, entry.value)) {
      if (entry.type === "SID") {
        value = encodeString(value, strings);
      }
      m[entry.op] = { name: entry.name, type: entry.type, value };
    }
  }
  return m;
}
function makeTopDict(attrs, strings) {
  var t2 = new table.Record("Top DICT", [
    { name: "dict", type: "DICT", value: {} }
  ]);
  t2.dict = makeDict(TOP_DICT_META, attrs, strings);
  return t2;
}
function makeTopDictIndex(topDict) {
  var t2 = new table.Record("Top DICT INDEX", [
    { name: "topDicts", type: "INDEX", value: [] }
  ]);
  t2.topDicts = [{ name: "topDict_0", type: "TABLE", value: topDict }];
  return t2;
}
function makeStringIndex(strings) {
  var t2 = new table.Record("String INDEX", [
    { name: "strings", type: "INDEX", value: [] }
  ]);
  t2.strings = [];
  for (var i2 = 0; i2 < strings.length; i2 += 1) {
    t2.strings.push({ name: "string_" + i2, type: "STRING", value: strings[i2] });
  }
  return t2;
}
function makeGlobalSubrIndex() {
  return new table.Record("Global Subr INDEX", [
    { name: "subrs", type: "INDEX", value: [] }
  ]);
}
function makeCharsets(glyphNames, strings) {
  var t2 = new table.Record("Charsets", [
    { name: "format", type: "Card8", value: 0 }
  ]);
  for (var i2 = 0; i2 < glyphNames.length; i2 += 1) {
    var glyphName = glyphNames[i2];
    var glyphSID = encodeString(glyphName, strings);
    t2.fields.push({ name: "glyph_" + i2, type: "SID", value: glyphSID });
  }
  return t2;
}
function glyphToOps(glyph) {
  var ops = [];
  var path = glyph.path;
  ops.push({ name: "width", type: "NUMBER", value: glyph.advanceWidth });
  var x = 0;
  var y = 0;
  for (var i2 = 0; i2 < path.commands.length; i2 += 1) {
    var dx = void 0;
    var dy = void 0;
    var cmd = path.commands[i2];
    if (cmd.type === "Q") {
      var _13 = 1 / 3;
      var _23 = 2 / 3;
      cmd = {
        type: "C",
        x: cmd.x,
        y: cmd.y,
        x1: Math.round(_13 * x + _23 * cmd.x1),
        y1: Math.round(_13 * y + _23 * cmd.y1),
        x2: Math.round(_13 * cmd.x + _23 * cmd.x1),
        y2: Math.round(_13 * cmd.y + _23 * cmd.y1)
      };
    }
    if (cmd.type === "M") {
      dx = Math.round(cmd.x - x);
      dy = Math.round(cmd.y - y);
      ops.push({ name: "dx", type: "NUMBER", value: dx });
      ops.push({ name: "dy", type: "NUMBER", value: dy });
      ops.push({ name: "rmoveto", type: "OP", value: 21 });
      x = Math.round(cmd.x);
      y = Math.round(cmd.y);
    } else if (cmd.type === "L") {
      dx = Math.round(cmd.x - x);
      dy = Math.round(cmd.y - y);
      ops.push({ name: "dx", type: "NUMBER", value: dx });
      ops.push({ name: "dy", type: "NUMBER", value: dy });
      ops.push({ name: "rlineto", type: "OP", value: 5 });
      x = Math.round(cmd.x);
      y = Math.round(cmd.y);
    } else if (cmd.type === "C") {
      var dx1 = Math.round(cmd.x1 - x);
      var dy1 = Math.round(cmd.y1 - y);
      var dx2 = Math.round(cmd.x2 - cmd.x1);
      var dy2 = Math.round(cmd.y2 - cmd.y1);
      dx = Math.round(cmd.x - cmd.x2);
      dy = Math.round(cmd.y - cmd.y2);
      ops.push({ name: "dx1", type: "NUMBER", value: dx1 });
      ops.push({ name: "dy1", type: "NUMBER", value: dy1 });
      ops.push({ name: "dx2", type: "NUMBER", value: dx2 });
      ops.push({ name: "dy2", type: "NUMBER", value: dy2 });
      ops.push({ name: "dx", type: "NUMBER", value: dx });
      ops.push({ name: "dy", type: "NUMBER", value: dy });
      ops.push({ name: "rrcurveto", type: "OP", value: 8 });
      x = Math.round(cmd.x);
      y = Math.round(cmd.y);
    }
  }
  ops.push({ name: "endchar", type: "OP", value: 14 });
  return ops;
}
function makeCharStringsIndex(glyphs) {
  var t2 = new table.Record("CharStrings INDEX", [
    { name: "charStrings", type: "INDEX", value: [] }
  ]);
  for (var i2 = 0; i2 < glyphs.length; i2 += 1) {
    var glyph = glyphs.get(i2);
    var ops = glyphToOps(glyph);
    t2.charStrings.push({ name: glyph.name, type: "CHARSTRING", value: ops });
  }
  return t2;
}
function makePrivateDict(attrs, strings) {
  var t2 = new table.Record("Private DICT", [
    { name: "dict", type: "DICT", value: {} }
  ]);
  t2.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
  return t2;
}
function makeCFFTable(glyphs, options) {
  var t2 = new table.Table("CFF ", [
    { name: "header", type: "RECORD" },
    { name: "nameIndex", type: "RECORD" },
    { name: "topDictIndex", type: "RECORD" },
    { name: "stringIndex", type: "RECORD" },
    { name: "globalSubrIndex", type: "RECORD" },
    { name: "charsets", type: "RECORD" },
    { name: "charStringsIndex", type: "RECORD" },
    { name: "privateDict", type: "RECORD" }
  ]);
  var fontScale = 1 / options.unitsPerEm;
  var attrs = {
    version: options.version,
    fullName: options.fullName,
    familyName: options.familyName,
    weight: options.weightName,
    fontBBox: options.fontBBox || [0, 0, 0, 0],
    fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
    charset: 999,
    encoding: 0,
    charStrings: 999,
    private: [0, 999]
  };
  var privateAttrs = {};
  var glyphNames = [];
  var glyph;
  for (var i2 = 1; i2 < glyphs.length; i2 += 1) {
    glyph = glyphs.get(i2);
    glyphNames.push(glyph.name);
  }
  var strings = [];
  t2.header = makeHeader();
  t2.nameIndex = makeNameIndex([options.postScriptName]);
  var topDict = makeTopDict(attrs, strings);
  t2.topDictIndex = makeTopDictIndex(topDict);
  t2.globalSubrIndex = makeGlobalSubrIndex();
  t2.charsets = makeCharsets(glyphNames, strings);
  t2.charStringsIndex = makeCharStringsIndex(glyphs);
  t2.privateDict = makePrivateDict(privateAttrs, strings);
  t2.stringIndex = makeStringIndex(strings);
  var startOffset = t2.header.sizeOf() + t2.nameIndex.sizeOf() + t2.topDictIndex.sizeOf() + t2.stringIndex.sizeOf() + t2.globalSubrIndex.sizeOf();
  attrs.charset = startOffset;
  attrs.encoding = 0;
  attrs.charStrings = attrs.charset + t2.charsets.sizeOf();
  attrs.private[1] = attrs.charStrings + t2.charStringsIndex.sizeOf();
  topDict = makeTopDict(attrs, strings);
  t2.topDictIndex = makeTopDictIndex(topDict);
  return t2;
}
var cff = { parse: parseCFFTable, make: makeCFFTable };
function parseHeadTable(data, start) {
  var head2 = {};
  var p = new parse.Parser(data, start);
  head2.version = p.parseVersion();
  head2.fontRevision = Math.round(p.parseFixed() * 1e3) / 1e3;
  head2.checkSumAdjustment = p.parseULong();
  head2.magicNumber = p.parseULong();
  check.argument(head2.magicNumber === 1594834165, "Font header has wrong magic number.");
  head2.flags = p.parseUShort();
  head2.unitsPerEm = p.parseUShort();
  head2.created = p.parseLongDateTime();
  head2.modified = p.parseLongDateTime();
  head2.xMin = p.parseShort();
  head2.yMin = p.parseShort();
  head2.xMax = p.parseShort();
  head2.yMax = p.parseShort();
  head2.macStyle = p.parseUShort();
  head2.lowestRecPPEM = p.parseUShort();
  head2.fontDirectionHint = p.parseShort();
  head2.indexToLocFormat = p.parseShort();
  head2.glyphDataFormat = p.parseShort();
  return head2;
}
function makeHeadTable(options) {
  var timestamp = Math.round(new Date().getTime() / 1e3) + 2082844800;
  var createdTimestamp = timestamp;
  if (options.createdTimestamp) {
    createdTimestamp = options.createdTimestamp + 2082844800;
  }
  return new table.Table("head", [
    { name: "version", type: "FIXED", value: 65536 },
    { name: "fontRevision", type: "FIXED", value: 65536 },
    { name: "checkSumAdjustment", type: "ULONG", value: 0 },
    { name: "magicNumber", type: "ULONG", value: 1594834165 },
    { name: "flags", type: "USHORT", value: 0 },
    { name: "unitsPerEm", type: "USHORT", value: 1e3 },
    { name: "created", type: "LONGDATETIME", value: createdTimestamp },
    { name: "modified", type: "LONGDATETIME", value: timestamp },
    { name: "xMin", type: "SHORT", value: 0 },
    { name: "yMin", type: "SHORT", value: 0 },
    { name: "xMax", type: "SHORT", value: 0 },
    { name: "yMax", type: "SHORT", value: 0 },
    { name: "macStyle", type: "USHORT", value: 0 },
    { name: "lowestRecPPEM", type: "USHORT", value: 0 },
    { name: "fontDirectionHint", type: "SHORT", value: 2 },
    { name: "indexToLocFormat", type: "SHORT", value: 0 },
    { name: "glyphDataFormat", type: "SHORT", value: 0 }
  ], options);
}
var head = { parse: parseHeadTable, make: makeHeadTable };
function parseHheaTable(data, start) {
  var hhea2 = {};
  var p = new parse.Parser(data, start);
  hhea2.version = p.parseVersion();
  hhea2.ascender = p.parseShort();
  hhea2.descender = p.parseShort();
  hhea2.lineGap = p.parseShort();
  hhea2.advanceWidthMax = p.parseUShort();
  hhea2.minLeftSideBearing = p.parseShort();
  hhea2.minRightSideBearing = p.parseShort();
  hhea2.xMaxExtent = p.parseShort();
  hhea2.caretSlopeRise = p.parseShort();
  hhea2.caretSlopeRun = p.parseShort();
  hhea2.caretOffset = p.parseShort();
  p.relativeOffset += 8;
  hhea2.metricDataFormat = p.parseShort();
  hhea2.numberOfHMetrics = p.parseUShort();
  return hhea2;
}
function makeHheaTable(options) {
  return new table.Table("hhea", [
    { name: "version", type: "FIXED", value: 65536 },
    { name: "ascender", type: "FWORD", value: 0 },
    { name: "descender", type: "FWORD", value: 0 },
    { name: "lineGap", type: "FWORD", value: 0 },
    { name: "advanceWidthMax", type: "UFWORD", value: 0 },
    { name: "minLeftSideBearing", type: "FWORD", value: 0 },
    { name: "minRightSideBearing", type: "FWORD", value: 0 },
    { name: "xMaxExtent", type: "FWORD", value: 0 },
    { name: "caretSlopeRise", type: "SHORT", value: 1 },
    { name: "caretSlopeRun", type: "SHORT", value: 0 },
    { name: "caretOffset", type: "SHORT", value: 0 },
    { name: "reserved1", type: "SHORT", value: 0 },
    { name: "reserved2", type: "SHORT", value: 0 },
    { name: "reserved3", type: "SHORT", value: 0 },
    { name: "reserved4", type: "SHORT", value: 0 },
    { name: "metricDataFormat", type: "SHORT", value: 0 },
    { name: "numberOfHMetrics", type: "USHORT", value: 0 }
  ], options);
}
var hhea = { parse: parseHheaTable, make: makeHheaTable };
function parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {
  var advanceWidth;
  var leftSideBearing;
  var p = new parse.Parser(data, start);
  for (var i2 = 0; i2 < numGlyphs; i2 += 1) {
    if (i2 < numMetrics) {
      advanceWidth = p.parseUShort();
      leftSideBearing = p.parseShort();
    }
    var glyph = glyphs.get(i2);
    glyph.advanceWidth = advanceWidth;
    glyph.leftSideBearing = leftSideBearing;
  }
}
function parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {
  font._hmtxTableData = {};
  var advanceWidth;
  var leftSideBearing;
  var p = new parse.Parser(data, start);
  for (var i2 = 0; i2 < numGlyphs; i2 += 1) {
    if (i2 < numMetrics) {
      advanceWidth = p.parseUShort();
      leftSideBearing = p.parseShort();
    }
    font._hmtxTableData[i2] = {
      advanceWidth,
      leftSideBearing
    };
  }
}
function parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {
  if (opt.lowMemory) {
    parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs);
  } else {
    parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs);
  }
}
function makeHmtxTable(glyphs) {
  var t2 = new table.Table("hmtx", []);
  for (var i2 = 0; i2 < glyphs.length; i2 += 1) {
    var glyph = glyphs.get(i2);
    var advanceWidth = glyph.advanceWidth || 0;
    var leftSideBearing = glyph.leftSideBearing || 0;
    t2.fields.push({ name: "advanceWidth_" + i2, type: "USHORT", value: advanceWidth });
    t2.fields.push({ name: "leftSideBearing_" + i2, type: "SHORT", value: leftSideBearing });
  }
  return t2;
}
var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };
function makeLtagTable(tags) {
  var result = new table.Table("ltag", [
    { name: "version", type: "ULONG", value: 1 },
    { name: "flags", type: "ULONG", value: 0 },
    { name: "numTags", type: "ULONG", value: tags.length }
  ]);
  var stringPool = "";
  var stringPoolOffset = 12 + tags.length * 4;
  for (var i2 = 0; i2 < tags.length; ++i2) {
    var pos = stringPool.indexOf(tags[i2]);
    if (pos < 0) {
      pos = stringPool.length;
      stringPool += tags[i2];
    }
    result.fields.push({ name: "offset " + i2, type: "USHORT", value: stringPoolOffset + pos });
    result.fields.push({ name: "length " + i2, type: "USHORT", value: tags[i2].length });
  }
  result.fields.push({ name: "stringPool", type: "CHARARRAY", value: stringPool });
  return result;
}
function parseLtagTable(data, start) {
  var p = new parse.Parser(data, start);
  var tableVersion = p.parseULong();
  check.argument(tableVersion === 1, "Unsupported ltag table version.");
  p.skip("uLong", 1);
  var numTags = p.parseULong();
  var tags = [];
  for (var i2 = 0; i2 < numTags; i2++) {
    var tag = "";
    var offset = start + p.parseUShort();
    var length2 = p.parseUShort();
    for (var j2 = offset; j2 < offset + length2; ++j2) {
      tag += String.fromCharCode(data.getInt8(j2));
    }
    tags.push(tag);
  }
  return tags;
}
var ltag = { make: makeLtagTable, parse: parseLtagTable };
function parseMaxpTable(data, start) {
  var maxp2 = {};
  var p = new parse.Parser(data, start);
  maxp2.version = p.parseVersion();
  maxp2.numGlyphs = p.parseUShort();
  if (maxp2.version === 1) {
    maxp2.maxPoints = p.parseUShort();
    maxp2.maxContours = p.parseUShort();
    maxp2.maxCompositePoints = p.parseUShort();
    maxp2.maxCompositeContours = p.parseUShort();
    maxp2.maxZones = p.parseUShort();
    maxp2.maxTwilightPoints = p.parseUShort();
    maxp2.maxStorage = p.parseUShort();
    maxp2.maxFunctionDefs = p.parseUShort();
    maxp2.maxInstructionDefs = p.parseUShort();
    maxp2.maxStackElements = p.parseUShort();
    maxp2.maxSizeOfInstructions = p.parseUShort();
    maxp2.maxComponentElements = p.parseUShort();
    maxp2.maxComponentDepth = p.parseUShort();
  }
  return maxp2;
}
function makeMaxpTable(numGlyphs) {
  return new table.Table("maxp", [
    { name: "version", type: "FIXED", value: 20480 },
    { name: "numGlyphs", type: "USHORT", value: numGlyphs }
  ]);
}
var maxp = { parse: parseMaxpTable, make: makeMaxpTable };
var nameTableNames = [
  "copyright",
  "fontFamily",
  "fontSubfamily",
  "uniqueID",
  "fullName",
  "version",
  "postScriptName",
  "trademark",
  "manufacturer",
  "designer",
  "description",
  "manufacturerURL",
  "designerURL",
  "license",
  "licenseURL",
  "reserved",
  "preferredFamily",
  "preferredSubfamily",
  "compatibleFullName",
  "sampleText",
  "postScriptFindFontName",
  "wwsFamily",
  "wwsSubfamily"
];
var macLanguages = {
  0: "en",
  1: "fr",
  2: "de",
  3: "it",
  4: "nl",
  5: "sv",
  6: "es",
  7: "da",
  8: "pt",
  9: "no",
  10: "he",
  11: "ja",
  12: "ar",
  13: "fi",
  14: "el",
  15: "is",
  16: "mt",
  17: "tr",
  18: "hr",
  19: "zh-Hant",
  20: "ur",
  21: "hi",
  22: "th",
  23: "ko",
  24: "lt",
  25: "pl",
  26: "hu",
  27: "es",
  28: "lv",
  29: "se",
  30: "fo",
  31: "fa",
  32: "ru",
  33: "zh",
  34: "nl-BE",
  35: "ga",
  36: "sq",
  37: "ro",
  38: "cz",
  39: "sk",
  40: "si",
  41: "yi",
  42: "sr",
  43: "mk",
  44: "bg",
  45: "uk",
  46: "be",
  47: "uz",
  48: "kk",
  49: "az-Cyrl",
  50: "az-Arab",
  51: "hy",
  52: "ka",
  53: "mo",
  54: "ky",
  55: "tg",
  56: "tk",
  57: "mn-CN",
  58: "mn",
  59: "ps",
  60: "ks",
  61: "ku",
  62: "sd",
  63: "bo",
  64: "ne",
  65: "sa",
  66: "mr",
  67: "bn",
  68: "as",
  69: "gu",
  70: "pa",
  71: "or",
  72: "ml",
  73: "kn",
  74: "ta",
  75: "te",
  76: "si",
  77: "my",
  78: "km",
  79: "lo",
  80: "vi",
  81: "id",
  82: "tl",
  83: "ms",
  84: "ms-Arab",
  85: "am",
  86: "ti",
  87: "om",
  88: "so",
  89: "sw",
  90: "rw",
  91: "rn",
  92: "ny",
  93: "mg",
  94: "eo",
  128: "cy",
  129: "eu",
  130: "ca",
  131: "la",
  132: "qu",
  133: "gn",
  134: "ay",
  135: "tt",
  136: "ug",
  137: "dz",
  138: "jv",
  139: "su",
  140: "gl",
  141: "af",
  142: "br",
  143: "iu",
  144: "gd",
  145: "gv",
  146: "ga",
  147: "to",
  148: "el-polyton",
  149: "kl",
  150: "az",
  151: "nn"
};
var macLanguageToScript = {
  0: 0,
  1: 0,
  2: 0,
  3: 0,
  4: 0,
  5: 0,
  6: 0,
  7: 0,
  8: 0,
  9: 0,
  10: 5,
  11: 1,
  12: 4,
  13: 0,
  14: 6,
  15: 0,
  16: 0,
  17: 0,
  18: 0,
  19: 2,
  20: 4,
  21: 9,
  22: 21,
  23: 3,
  24: 29,
  25: 29,
  26: 29,
  27: 29,
  28: 29,
  29: 0,
  30: 0,
  31: 4,
  32: 7,
  33: 25,
  34: 0,
  35: 0,
  36: 0,
  37: 0,
  38: 29,
  39: 29,
  40: 0,
  41: 5,
  42: 7,
  43: 7,
  44: 7,
  45: 7,
  46: 7,
  47: 7,
  48: 7,
  49: 7,
  50: 4,
  51: 24,
  52: 23,
  53: 7,
  54: 7,
  55: 7,
  56: 7,
  57: 27,
  58: 7,
  59: 4,
  60: 4,
  61: 4,
  62: 4,
  63: 26,
  64: 9,
  65: 9,
  66: 9,
  67: 13,
  68: 13,
  69: 11,
  70: 10,
  71: 12,
  72: 17,
  73: 16,
  74: 14,
  75: 15,
  76: 18,
  77: 19,
  78: 20,
  79: 22,
  80: 30,
  81: 0,
  82: 0,
  83: 0,
  84: 4,
  85: 28,
  86: 28,
  87: 28,
  88: 0,
  89: 0,
  90: 0,
  91: 0,
  92: 0,
  93: 0,
  94: 0,
  128: 0,
  129: 0,
  130: 0,
  131: 0,
  132: 0,
  133: 0,
  134: 0,
  135: 7,
  136: 4,
  137: 26,
  138: 0,
  139: 0,
  140: 0,
  141: 0,
  142: 0,
  143: 28,
  144: 0,
  145: 0,
  146: 0,
  147: 0,
  148: 6,
  149: 0,
  150: 0,
  151: 0
};
var windowsLanguages = {
  1078: "af",
  1052: "sq",
  1156: "gsw",
  1118: "am",
  5121: "ar-DZ",
  15361: "ar-BH",
  3073: "ar",
  2049: "ar-IQ",
  11265: "ar-JO",
  13313: "ar-KW",
  12289: "ar-LB",
  4097: "ar-LY",
  6145: "ary",
  8193: "ar-OM",
  16385: "ar-QA",
  1025: "ar-SA",
  10241: "ar-SY",
  7169: "aeb",
  14337: "ar-AE",
  9217: "ar-YE",
  1067: "hy",
  1101: "as",
  2092: "az-Cyrl",
  1068: "az",
  1133: "ba",
  1069: "eu",
  1059: "be",
  2117: "bn",
  1093: "bn-IN",
  8218: "bs-Cyrl",
  5146: "bs",
  1150: "br",
  1026: "bg",
  1027: "ca",
  3076: "zh-HK",
  5124: "zh-MO",
  2052: "zh",
  4100: "zh-SG",
  1028: "zh-TW",
  1155: "co",
  1050: "hr",
  4122: "hr-BA",
  1029: "cs",
  1030: "da",
  1164: "prs",
  1125: "dv",
  2067: "nl-BE",
  1043: "nl",
  3081: "en-AU",
  10249: "en-BZ",
  4105: "en-CA",
  9225: "en-029",
  16393: "en-IN",
  6153: "en-IE",
  8201: "en-JM",
  17417: "en-MY",
  5129: "en-NZ",
  13321: "en-PH",
  18441: "en-SG",
  7177: "en-ZA",
  11273: "en-TT",
  2057: "en-GB",
  1033: "en",
  12297: "en-ZW",
  1061: "et",
  1080: "fo",
  1124: "fil",
  1035: "fi",
  2060: "fr-BE",
  3084: "fr-CA",
  1036: "fr",
  5132: "fr-LU",
  6156: "fr-MC",
  4108: "fr-CH",
  1122: "fy",
  1110: "gl",
  1079: "ka",
  3079: "de-AT",
  1031: "de",
  5127: "de-LI",
  4103: "de-LU",
  2055: "de-CH",
  1032: "el",
  1135: "kl",
  1095: "gu",
  1128: "ha",
  1037: "he",
  1081: "hi",
  1038: "hu",
  1039: "is",
  1136: "ig",
  1057: "id",
  1117: "iu",
  2141: "iu-Latn",
  2108: "ga",
  1076: "xh",
  1077: "zu",
  1040: "it",
  2064: "it-CH",
  1041: "ja",
  1099: "kn",
  1087: "kk",
  1107: "km",
  1158: "quc",
  1159: "rw",
  1089: "sw",
  1111: "kok",
  1042: "ko",
  1088: "ky",
  1108: "lo",
  1062: "lv",
  1063: "lt",
  2094: "dsb",
  1134: "lb",
  1071: "mk",
  2110: "ms-BN",
  1086: "ms",
  1100: "ml",
  1082: "mt",
  1153: "mi",
  1146: "arn",
  1102: "mr",
  1148: "moh",
  1104: "mn",
  2128: "mn-CN",
  1121: "ne",
  1044: "nb",
  2068: "nn",
  1154: "oc",
  1096: "or",
  1123: "ps",
  1045: "pl",
  1046: "pt",
  2070: "pt-PT",
  1094: "pa",
  1131: "qu-BO",
  2155: "qu-EC",
  3179: "qu",
  1048: "ro",
  1047: "rm",
  1049: "ru",
  9275: "smn",
  4155: "smj-NO",
  5179: "smj",
  3131: "se-FI",
  1083: "se",
  2107: "se-SE",
  8251: "sms",
  6203: "sma-NO",
  7227: "sms",
  1103: "sa",
  7194: "sr-Cyrl-BA",
  3098: "sr",
  6170: "sr-Latn-BA",
  2074: "sr-Latn",
  1132: "nso",
  1074: "tn",
  1115: "si",
  1051: "sk",
  1060: "sl",
  11274: "es-AR",
  16394: "es-BO",
  13322: "es-CL",
  9226: "es-CO",
  5130: "es-CR",
  7178: "es-DO",
  12298: "es-EC",
  17418: "es-SV",
  4106: "es-GT",
  18442: "es-HN",
  2058: "es-MX",
  19466: "es-NI",
  6154: "es-PA",
  15370: "es-PY",
  10250: "es-PE",
  20490: "es-PR",
  3082: "es",
  1034: "es",
  21514: "es-US",
  14346: "es-UY",
  8202: "es-VE",
  2077: "sv-FI",
  1053: "sv",
  1114: "syr",
  1064: "tg",
  2143: "tzm",
  1097: "ta",
  1092: "tt",
  1098: "te",
  1054: "th",
  1105: "bo",
  1055: "tr",
  1090: "tk",
  1152: "ug",
  1058: "uk",
  1070: "hsb",
  1056: "ur",
  2115: "uz-Cyrl",
  1091: "uz",
  1066: "vi",
  1106: "cy",
  1160: "wo",
  1157: "sah",
  1144: "ii",
  1130: "yo"
};
function getLanguageCode(platformID, languageID, ltag2) {
  switch (platformID) {
    case 0:
      if (languageID === 65535) {
        return "und";
      } else if (ltag2) {
        return ltag2[languageID];
      }
      break;
    case 1:
      return macLanguages[languageID];
    case 3:
      return windowsLanguages[languageID];
  }
  return void 0;
}
var utf16 = "utf-16";
var macScriptEncodings = {
  0: "macintosh",
  1: "x-mac-japanese",
  2: "x-mac-chinesetrad",
  3: "x-mac-korean",
  6: "x-mac-greek",
  7: "x-mac-cyrillic",
  9: "x-mac-devanagai",
  10: "x-mac-gurmukhi",
  11: "x-mac-gujarati",
  12: "x-mac-oriya",
  13: "x-mac-bengali",
  14: "x-mac-tamil",
  15: "x-mac-telugu",
  16: "x-mac-kannada",
  17: "x-mac-malayalam",
  18: "x-mac-sinhalese",
  19: "x-mac-burmese",
  20: "x-mac-khmer",
  21: "x-mac-thai",
  22: "x-mac-lao",
  23: "x-mac-georgian",
  24: "x-mac-armenian",
  25: "x-mac-chinesesimp",
  26: "x-mac-tibetan",
  27: "x-mac-mongolian",
  28: "x-mac-ethiopic",
  29: "x-mac-ce",
  30: "x-mac-vietnamese",
  31: "x-mac-extarabic"
};
var macLanguageEncodings = {
  15: "x-mac-icelandic",
  17: "x-mac-turkish",
  18: "x-mac-croatian",
  24: "x-mac-ce",
  25: "x-mac-ce",
  26: "x-mac-ce",
  27: "x-mac-ce",
  28: "x-mac-ce",
  30: "x-mac-icelandic",
  37: "x-mac-romanian",
  38: "x-mac-ce",
  39: "x-mac-ce",
  40: "x-mac-ce",
  143: "x-mac-inuit",
  146: "x-mac-gaelic"
};
function getEncoding(platformID, encodingID, languageID) {
  switch (platformID) {
    case 0:
      return utf16;
    case 1:
      return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];
    case 3:
      if (encodingID === 1 || encodingID === 10) {
        return utf16;
      }
      break;
  }
  return void 0;
}
function parseNameTable(data, start, ltag2) {
  var name = {};
  var p = new parse.Parser(data, start);
  var format = p.parseUShort();
  var count = p.parseUShort();
  var stringOffset2 = p.offset + p.parseUShort();
  for (var i2 = 0; i2 < count; i2++) {
    var platformID = p.parseUShort();
    var encodingID = p.parseUShort();
    var languageID = p.parseUShort();
    var nameID = p.parseUShort();
    var property = nameTableNames[nameID] || nameID;
    var byteLength = p.parseUShort();
    var offset = p.parseUShort();
    var language = getLanguageCode(platformID, languageID, ltag2);
    var encoding = getEncoding(platformID, encodingID, languageID);
    if (encoding !== void 0 && language !== void 0) {
      var text = void 0;
      if (encoding === utf16) {
        text = decode.UTF16(data, stringOffset2 + offset, byteLength);
      } else {
        text = decode.MACSTRING(data, stringOffset2 + offset, byteLength, encoding);
      }
      if (text) {
        var translations = name[property];
        if (translations === void 0) {
          translations = name[property] = {};
        }
        translations[language] = text;
      }
    }
  }
  var langTagCount = 0;
  if (format === 1) {
    langTagCount = p.parseUShort();
  }
  return name;
}
function reverseDict(dict) {
  var result = {};
  for (var key in dict) {
    result[dict[key]] = parseInt(key);
  }
  return result;
}
function makeNameRecord(platformID, encodingID, languageID, nameID, length2, offset) {
  return new table.Record("NameRecord", [
    { name: "platformID", type: "USHORT", value: platformID },
    { name: "encodingID", type: "USHORT", value: encodingID },
    { name: "languageID", type: "USHORT", value: languageID },
    { name: "nameID", type: "USHORT", value: nameID },
    { name: "length", type: "USHORT", value: length2 },
    { name: "offset", type: "USHORT", value: offset }
  ]);
}
function findSubArray(needle, haystack) {
  var needleLength = needle.length;
  var limit = haystack.length - needleLength + 1;
  loop:
    for (var pos = 0; pos < limit; pos++) {
      for (; pos < limit; pos++) {
        for (var k = 0; k < needleLength; k++) {
          if (haystack[pos + k] !== needle[k]) {
            continue loop;
          }
        }
        return pos;
      }
    }
  return -1;
}
function addStringToPool(s, pool) {
  var offset = findSubArray(s, pool);
  if (offset < 0) {
    offset = pool.length;
    var i2 = 0;
    var len = s.length;
    for (; i2 < len; ++i2) {
      pool.push(s[i2]);
    }
  }
  return offset;
}
function makeNameTable(names, ltag2) {
  var nameID;
  var nameIDs = [];
  var namesWithNumericKeys = {};
  var nameTableIds = reverseDict(nameTableNames);
  for (var key in names) {
    var id = nameTableIds[key];
    if (id === void 0) {
      id = key;
    }
    nameID = parseInt(id);
    if (isNaN(nameID)) {
      throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
    }
    namesWithNumericKeys[nameID] = names[key];
    nameIDs.push(nameID);
  }
  var macLanguageIds = reverseDict(macLanguages);
  var windowsLanguageIds = reverseDict(windowsLanguages);
  var nameRecords = [];
  var stringPool = [];
  for (var i2 = 0; i2 < nameIDs.length; i2++) {
    nameID = nameIDs[i2];
    var translations = namesWithNumericKeys[nameID];
    for (var lang in translations) {
      var text = translations[lang];
      var macPlatform = 1;
      var macLanguage = macLanguageIds[lang];
      var macScript = macLanguageToScript[macLanguage];
      var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
      var macName = encode.MACSTRING(text, macEncoding);
      if (macName === void 0) {
        macPlatform = 0;
        macLanguage = ltag2.indexOf(lang);
        if (macLanguage < 0) {
          macLanguage = ltag2.length;
          ltag2.push(lang);
        }
        macScript = 4;
        macName = encode.UTF16(text);
      }
      var macNameOffset = addStringToPool(macName, stringPool);
      nameRecords.push(makeNameRecord(
        macPlatform,
        macScript,
        macLanguage,
        nameID,
        macName.length,
        macNameOffset
      ));
      var winLanguage = windowsLanguageIds[lang];
      if (winLanguage !== void 0) {
        var winName = encode.UTF16(text);
        var winNameOffset = addStringToPool(winName, stringPool);
        nameRecords.push(makeNameRecord(
          3,
          1,
          winLanguage,
          nameID,
          winName.length,
          winNameOffset
        ));
      }
    }
  }
  nameRecords.sort(function(a2, b3) {
    return a2.platformID - b3.platformID || a2.encodingID - b3.encodingID || a2.languageID - b3.languageID || a2.nameID - b3.nameID;
  });
  var t2 = new table.Table("name", [
    { name: "format", type: "USHORT", value: 0 },
    { name: "count", type: "USHORT", value: nameRecords.length },
    { name: "stringOffset", type: "USHORT", value: 6 + nameRecords.length * 12 }
  ]);
  for (var r = 0; r < nameRecords.length; r++) {
    t2.fields.push({ name: "record_" + r, type: "RECORD", value: nameRecords[r] });
  }
  t2.fields.push({ name: "strings", type: "LITERAL", value: stringPool });
  return t2;
}
var _name = { parse: parseNameTable, make: makeNameTable };
var unicodeRanges = [
  { begin: 0, end: 127 },
  { begin: 128, end: 255 },
  { begin: 256, end: 383 },
  { begin: 384, end: 591 },
  { begin: 592, end: 687 },
  { begin: 688, end: 767 },
  { begin: 768, end: 879 },
  { begin: 880, end: 1023 },
  { begin: 11392, end: 11519 },
  { begin: 1024, end: 1279 },
  { begin: 1328, end: 1423 },
  { begin: 1424, end: 1535 },
  { begin: 42240, end: 42559 },
  { begin: 1536, end: 1791 },
  { begin: 1984, end: 2047 },
  { begin: 2304, end: 2431 },
  { begin: 2432, end: 2559 },
  { begin: 2560, end: 2687 },
  { begin: 2688, end: 2815 },
  { begin: 2816, end: 2943 },
  { begin: 2944, end: 3071 },
  { begin: 3072, end: 3199 },
  { begin: 3200, end: 3327 },
  { begin: 3328, end: 3455 },
  { begin: 3584, end: 3711 },
  { begin: 3712, end: 3839 },
  { begin: 4256, end: 4351 },
  { begin: 6912, end: 7039 },
  { begin: 4352, end: 4607 },
  { begin: 7680, end: 7935 },
  { begin: 7936, end: 8191 },
  { begin: 8192, end: 8303 },
  { begin: 8304, end: 8351 },
  { begin: 8352, end: 8399 },
  { begin: 8400, end: 8447 },
  { begin: 8448, end: 8527 },
  { begin: 8528, end: 8591 },
  { begin: 8592, end: 8703 },
  { begin: 8704, end: 8959 },
  { begin: 8960, end: 9215 },
  { begin: 9216, end: 9279 },
  { begin: 9280, end: 9311 },
  { begin: 9312, end: 9471 },
  { begin: 9472, end: 9599 },
  { begin: 9600, end: 9631 },
  { begin: 9632, end: 9727 },
  { begin: 9728, end: 9983 },
  { begin: 9984, end: 10175 },
  { begin: 12288, end: 12351 },
  { begin: 12352, end: 12447 },
  { begin: 12448, end: 12543 },
  { begin: 12544, end: 12591 },
  { begin: 12592, end: 12687 },
  { begin: 43072, end: 43135 },
  { begin: 12800, end: 13055 },
  { begin: 13056, end: 13311 },
  { begin: 44032, end: 55215 },
  { begin: 55296, end: 57343 },
  { begin: 67840, end: 67871 },
  { begin: 19968, end: 40959 },
  { begin: 57344, end: 63743 },
  { begin: 12736, end: 12783 },
  { begin: 64256, end: 64335 },
  { begin: 64336, end: 65023 },
  { begin: 65056, end: 65071 },
  { begin: 65040, end: 65055 },
  { begin: 65104, end: 65135 },
  { begin: 65136, end: 65279 },
  { begin: 65280, end: 65519 },
  { begin: 65520, end: 65535 },
  { begin: 3840, end: 4095 },
  { begin: 1792, end: 1871 },
  { begin: 1920, end: 1983 },
  { begin: 3456, end: 3583 },
  { begin: 4096, end: 4255 },
  { begin: 4608, end: 4991 },
  { begin: 5024, end: 5119 },
  { begin: 5120, end: 5759 },
  { begin: 5760, end: 5791 },
  { begin: 5792, end: 5887 },
  { begin: 6016, end: 6143 },
  { begin: 6144, end: 6319 },
  { begin: 10240, end: 10495 },
  { begin: 40960, end: 42127 },
  { begin: 5888, end: 5919 },
  { begin: 66304, end: 66351 },
  { begin: 66352, end: 66383 },
  { begin: 66560, end: 66639 },
  { begin: 118784, end: 119039 },
  { begin: 119808, end: 120831 },
  { begin: 1044480, end: 1048573 },
  { begin: 65024, end: 65039 },
  { begin: 917504, end: 917631 },
  { begin: 6400, end: 6479 },
  { begin: 6480, end: 6527 },
  { begin: 6528, end: 6623 },
  { begin: 6656, end: 6687 },
  { begin: 11264, end: 11359 },
  { begin: 11568, end: 11647 },
  { begin: 19904, end: 19967 },
  { begin: 43008, end: 43055 },
  { begin: 65536, end: 65663 },
  { begin: 65856, end: 65935 },
  { begin: 66432, end: 66463 },
  { begin: 66464, end: 66527 },
  { begin: 66640, end: 66687 },
  { begin: 66688, end: 66735 },
  { begin: 67584, end: 67647 },
  { begin: 68096, end: 68191 },
  { begin: 119552, end: 119647 },
  { begin: 73728, end: 74751 },
  { begin: 119648, end: 119679 },
  { begin: 7040, end: 7103 },
  { begin: 7168, end: 7247 },
  { begin: 7248, end: 7295 },
  { begin: 43136, end: 43231 },
  { begin: 43264, end: 43311 },
  { begin: 43312, end: 43359 },
  { begin: 43520, end: 43615 },
  { begin: 65936, end: 65999 },
  { begin: 66e3, end: 66047 },
  { begin: 66208, end: 66271 },
  { begin: 127024, end: 127135 }
];
function getUnicodeRange(unicode) {
  for (var i2 = 0; i2 < unicodeRanges.length; i2 += 1) {
    var range = unicodeRanges[i2];
    if (unicode >= range.begin && unicode < range.end) {
      return i2;
    }
  }
  return -1;
}
function parseOS2Table(data, start) {
  var os22 = {};
  var p = new parse.Parser(data, start);
  os22.version = p.parseUShort();
  os22.xAvgCharWidth = p.parseShort();
  os22.usWeightClass = p.parseUShort();
  os22.usWidthClass = p.parseUShort();
  os22.fsType = p.parseUShort();
  os22.ySubscriptXSize = p.parseShort();
  os22.ySubscriptYSize = p.parseShort();
  os22.ySubscriptXOffset = p.parseShort();
  os22.ySubscriptYOffset = p.parseShort();
  os22.ySuperscriptXSize = p.parseShort();
  os22.ySuperscriptYSize = p.parseShort();
  os22.ySuperscriptXOffset = p.parseShort();
  os22.ySuperscriptYOffset = p.parseShort();
  os22.yStrikeoutSize = p.parseShort();
  os22.yStrikeoutPosition = p.parseShort();
  os22.sFamilyClass = p.parseShort();
  os22.panose = [];
  for (var i2 = 0; i2 < 10; i2++) {
    os22.panose[i2] = p.parseByte();
  }
  os22.ulUnicodeRange1 = p.parseULong();
  os22.ulUnicodeRange2 = p.parseULong();
  os22.ulUnicodeRange3 = p.parseULong();
  os22.ulUnicodeRange4 = p.parseULong();
  os22.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
  os22.fsSelection = p.parseUShort();
  os22.usFirstCharIndex = p.parseUShort();
  os22.usLastCharIndex = p.parseUShort();
  os22.sTypoAscender = p.parseShort();
  os22.sTypoDescender = p.parseShort();
  os22.sTypoLineGap = p.parseShort();
  os22.usWinAscent = p.parseUShort();
  os22.usWinDescent = p.parseUShort();
  if (os22.version >= 1) {
    os22.ulCodePageRange1 = p.parseULong();
    os22.ulCodePageRange2 = p.parseULong();
  }
  if (os22.version >= 2) {
    os22.sxHeight = p.parseShort();
    os22.sCapHeight = p.parseShort();
    os22.usDefaultChar = p.parseUShort();
    os22.usBreakChar = p.parseUShort();
    os22.usMaxContent = p.parseUShort();
  }
  return os22;
}
function makeOS2Table(options) {
  return new table.Table("OS/2", [
    { name: "version", type: "USHORT", value: 3 },
    { name: "xAvgCharWidth", type: "SHORT", value: 0 },
    { name: "usWeightClass", type: "USHORT", value: 0 },
    { name: "usWidthClass", type: "USHORT", value: 0 },
    { name: "fsType", type: "USHORT", value: 0 },
    { name: "ySubscriptXSize", type: "SHORT", value: 650 },
    { name: "ySubscriptYSize", type: "SHORT", value: 699 },
    { name: "ySubscriptXOffset", type: "SHORT", value: 0 },
    { name: "ySubscriptYOffset", type: "SHORT", value: 140 },
    { name: "ySuperscriptXSize", type: "SHORT", value: 650 },
    { name: "ySuperscriptYSize", type: "SHORT", value: 699 },
    { name: "ySuperscriptXOffset", type: "SHORT", value: 0 },
    { name: "ySuperscriptYOffset", type: "SHORT", value: 479 },
    { name: "yStrikeoutSize", type: "SHORT", value: 49 },
    { name: "yStrikeoutPosition", type: "SHORT", value: 258 },
    { name: "sFamilyClass", type: "SHORT", value: 0 },
    { name: "bFamilyType", type: "BYTE", value: 0 },
    { name: "bSerifStyle", type: "BYTE", value: 0 },
    { name: "bWeight", type: "BYTE", value: 0 },
    { name: "bProportion", type: "BYTE", value: 0 },
    { name: "bContrast", type: "BYTE", value: 0 },
    { name: "bStrokeVariation", type: "BYTE", value: 0 },
    { name: "bArmStyle", type: "BYTE", value: 0 },
    { name: "bLetterform", type: "BYTE", value: 0 },
    { name: "bMidline", type: "BYTE", value: 0 },
    { name: "bXHeight", type: "BYTE", value: 0 },
    { name: "ulUnicodeRange1", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange2", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange3", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange4", type: "ULONG", value: 0 },
    { name: "achVendID", type: "CHARARRAY", value: "XXXX" },
    { name: "fsSelection", type: "USHORT", value: 0 },
    { name: "usFirstCharIndex", type: "USHORT", value: 0 },
    { name: "usLastCharIndex", type: "USHORT", value: 0 },
    { name: "sTypoAscender", type: "SHORT", value: 0 },
    { name: "sTypoDescender", type: "SHORT", value: 0 },
    { name: "sTypoLineGap", type: "SHORT", value: 0 },
    { name: "usWinAscent", type: "USHORT", value: 0 },
    { name: "usWinDescent", type: "USHORT", value: 0 },
    { name: "ulCodePageRange1", type: "ULONG", value: 0 },
    { name: "ulCodePageRange2", type: "ULONG", value: 0 },
    { name: "sxHeight", type: "SHORT", value: 0 },
    { name: "sCapHeight", type: "SHORT", value: 0 },
    { name: "usDefaultChar", type: "USHORT", value: 0 },
    { name: "usBreakChar", type: "USHORT", value: 0 },
    { name: "usMaxContext", type: "USHORT", value: 0 }
  ], options);
}
var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges, getUnicodeRange };
function parsePostTable(data, start) {
  var post2 = {};
  var p = new parse.Parser(data, start);
  post2.version = p.parseVersion();
  post2.italicAngle = p.parseFixed();
  post2.underlinePosition = p.parseShort();
  post2.underlineThickness = p.parseShort();
  post2.isFixedPitch = p.parseULong();
  post2.minMemType42 = p.parseULong();
  post2.maxMemType42 = p.parseULong();
  post2.minMemType1 = p.parseULong();
  post2.maxMemType1 = p.parseULong();
  switch (post2.version) {
    case 1:
      post2.names = standardNames.slice();
      break;
    case 2:
      post2.numberOfGlyphs = p.parseUShort();
      post2.glyphNameIndex = new Array(post2.numberOfGlyphs);
      for (var i2 = 0; i2 < post2.numberOfGlyphs; i2++) {
        post2.glyphNameIndex[i2] = p.parseUShort();
      }
      post2.names = [];
      for (var i$1 = 0; i$1 < post2.numberOfGlyphs; i$1++) {
        if (post2.glyphNameIndex[i$1] >= standardNames.length) {
          var nameLength = p.parseChar();
          post2.names.push(p.parseString(nameLength));
        }
      }
      break;
    case 2.5:
      post2.numberOfGlyphs = p.parseUShort();
      post2.offset = new Array(post2.numberOfGlyphs);
      for (var i$2 = 0; i$2 < post2.numberOfGlyphs; i$2++) {
        post2.offset[i$2] = p.parseChar();
      }
      break;
  }
  return post2;
}
function makePostTable() {
  return new table.Table("post", [
    { name: "version", type: "FIXED", value: 196608 },
    { name: "italicAngle", type: "FIXED", value: 0 },
    { name: "underlinePosition", type: "FWORD", value: 0 },
    { name: "underlineThickness", type: "FWORD", value: 0 },
    { name: "isFixedPitch", type: "ULONG", value: 0 },
    { name: "minMemType42", type: "ULONG", value: 0 },
    { name: "maxMemType42", type: "ULONG", value: 0 },
    { name: "minMemType1", type: "ULONG", value: 0 },
    { name: "maxMemType1", type: "ULONG", value: 0 }
  ]);
}
var post = { parse: parsePostTable, make: makePostTable };
var subtableParsers = new Array(9);
subtableParsers[1] = function parseLookup1() {
  var start = this.offset + this.relativeOffset;
  var substFormat = this.parseUShort();
  if (substFormat === 1) {
    return {
      substFormat: 1,
      coverage: this.parsePointer(Parser3.coverage),
      deltaGlyphId: this.parseUShort()
    };
  } else if (substFormat === 2) {
    return {
      substFormat: 2,
      coverage: this.parsePointer(Parser3.coverage),
      substitute: this.parseOffset16List()
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": lookup type 1 format must be 1 or 2.");
};
subtableParsers[2] = function parseLookup2() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Multiple Substitution Subtable identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser3.coverage),
    sequences: this.parseListOfLists()
  };
};
subtableParsers[3] = function parseLookup3() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Alternate Substitution Subtable identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser3.coverage),
    alternateSets: this.parseListOfLists()
  };
};
subtableParsers[4] = function parseLookup4() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB ligature table identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser3.coverage),
    ligatureSets: this.parseListOfLists(function() {
      return {
        ligGlyph: this.parseUShort(),
        components: this.parseUShortList(this.parseUShort() - 1)
      };
    })
  };
};
var lookupRecordDesc = {
  sequenceIndex: Parser3.uShort,
  lookupListIndex: Parser3.uShort
};
subtableParsers[5] = function parseLookup5() {
  var start = this.offset + this.relativeOffset;
  var substFormat = this.parseUShort();
  if (substFormat === 1) {
    return {
      substFormat,
      coverage: this.parsePointer(Parser3.coverage),
      ruleSets: this.parseListOfLists(function() {
        var glyphCount2 = this.parseUShort();
        var substCount2 = this.parseUShort();
        return {
          input: this.parseUShortList(glyphCount2 - 1),
          lookupRecords: this.parseRecordList(substCount2, lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 2) {
    return {
      substFormat,
      coverage: this.parsePointer(Parser3.coverage),
      classDef: this.parsePointer(Parser3.classDef),
      classSets: this.parseListOfLists(function() {
        var glyphCount2 = this.parseUShort();
        var substCount2 = this.parseUShort();
        return {
          classes: this.parseUShortList(glyphCount2 - 1),
          lookupRecords: this.parseRecordList(substCount2, lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 3) {
    var glyphCount = this.parseUShort();
    var substCount = this.parseUShort();
    return {
      substFormat,
      coverages: this.parseList(glyphCount, Parser3.pointer(Parser3.coverage)),
      lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
};
subtableParsers[6] = function parseLookup6() {
  var start = this.offset + this.relativeOffset;
  var substFormat = this.parseUShort();
  if (substFormat === 1) {
    return {
      substFormat: 1,
      coverage: this.parsePointer(Parser3.coverage),
      chainRuleSets: this.parseListOfLists(function() {
        return {
          backtrack: this.parseUShortList(),
          input: this.parseUShortList(this.parseShort() - 1),
          lookahead: this.parseUShortList(),
          lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 2) {
    return {
      substFormat: 2,
      coverage: this.parsePointer(Parser3.coverage),
      backtrackClassDef: this.parsePointer(Parser3.classDef),
      inputClassDef: this.parsePointer(Parser3.classDef),
      lookaheadClassDef: this.parsePointer(Parser3.classDef),
      chainClassSet: this.parseListOfLists(function() {
        return {
          backtrack: this.parseUShortList(),
          input: this.parseUShortList(this.parseShort() - 1),
          lookahead: this.parseUShortList(),
          lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 3) {
    return {
      substFormat: 3,
      backtrackCoverage: this.parseList(Parser3.pointer(Parser3.coverage)),
      inputCoverage: this.parseList(Parser3.pointer(Parser3.coverage)),
      lookaheadCoverage: this.parseList(Parser3.pointer(Parser3.coverage)),
      lookupRecords: this.parseRecordList(lookupRecordDesc)
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
};
subtableParsers[7] = function parseLookup7() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Extension Substitution subtable identifier-format must be 1");
  var extensionLookupType = this.parseUShort();
  var extensionParser = new Parser3(this.data, this.offset + this.parseULong());
  return {
    substFormat: 1,
    lookupType: extensionLookupType,
    extension: subtableParsers[extensionLookupType].call(extensionParser)
  };
};
subtableParsers[8] = function parseLookup8() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser3.coverage),
    backtrackCoverage: this.parseList(Parser3.pointer(Parser3.coverage)),
    lookaheadCoverage: this.parseList(Parser3.pointer(Parser3.coverage)),
    substitutes: this.parseUShortList()
  };
};
function parseGsubTable(data, start) {
  start = start || 0;
  var p = new Parser3(data, start);
  var tableVersion = p.parseVersion(1);
  check.argument(tableVersion === 1 || tableVersion === 1.1, "Unsupported GSUB table version.");
  if (tableVersion === 1) {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers)
    };
  } else {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers),
      variations: p.parseFeatureVariationsList()
    };
  }
}
var subtableMakers = new Array(9);
subtableMakers[1] = function makeLookup1(subtable) {
  if (subtable.substFormat === 1) {
    return new table.Table("substitutionTable", [
      { name: "substFormat", type: "USHORT", value: 1 },
      { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) },
      { name: "deltaGlyphID", type: "USHORT", value: subtable.deltaGlyphId }
    ]);
  } else {
    return new table.Table("substitutionTable", [
      { name: "substFormat", type: "USHORT", value: 2 },
      { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
    ].concat(table.ushortList("substitute", subtable.substitute)));
  }
};
subtableMakers[2] = function makeLookup2(subtable) {
  check.assert(subtable.substFormat === 1, "Lookup type 2 substFormat must be 1.");
  return new table.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
  ].concat(table.tableList("seqSet", subtable.sequences, function(sequenceSet) {
    return new table.Table("sequenceSetTable", table.ushortList("sequence", sequenceSet));
  })));
};
subtableMakers[3] = function makeLookup3(subtable) {
  check.assert(subtable.substFormat === 1, "Lookup type 3 substFormat must be 1.");
  return new table.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
  ].concat(table.tableList("altSet", subtable.alternateSets, function(alternateSet) {
    return new table.Table("alternateSetTable", table.ushortList("alternate", alternateSet));
  })));
};
subtableMakers[4] = function makeLookup4(subtable) {
  check.assert(subtable.substFormat === 1, "Lookup type 4 substFormat must be 1.");
  return new table.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
  ].concat(table.tableList("ligSet", subtable.ligatureSets, function(ligatureSet) {
    return new table.Table("ligatureSetTable", table.tableList("ligature", ligatureSet, function(ligature) {
      return new table.Table(
        "ligatureTable",
        [{ name: "ligGlyph", type: "USHORT", value: ligature.ligGlyph }].concat(table.ushortList("component", ligature.components, ligature.components.length + 1))
      );
    }));
  })));
};
subtableMakers[6] = function makeLookup6(subtable) {
  if (subtable.substFormat === 1) {
    var returnTable = new table.Table("chainContextTable", [
      { name: "substFormat", type: "USHORT", value: subtable.substFormat },
      { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
    ].concat(table.tableList("chainRuleSet", subtable.chainRuleSets, function(chainRuleSet) {
      return new table.Table("chainRuleSetTable", table.tableList("chainRule", chainRuleSet, function(chainRule) {
        var tableData2 = table.ushortList("backtrackGlyph", chainRule.backtrack, chainRule.backtrack.length).concat(table.ushortList("inputGlyph", chainRule.input, chainRule.input.length + 1)).concat(table.ushortList("lookaheadGlyph", chainRule.lookahead, chainRule.lookahead.length)).concat(table.ushortList("substitution", [], chainRule.lookupRecords.length));
        chainRule.lookupRecords.forEach(function(record, i2) {
          tableData2 = tableData2.concat({ name: "sequenceIndex" + i2, type: "USHORT", value: record.sequenceIndex }).concat({ name: "lookupListIndex" + i2, type: "USHORT", value: record.lookupListIndex });
        });
        return new table.Table("chainRuleTable", tableData2);
      }));
    })));
    return returnTable;
  } else if (subtable.substFormat === 2) {
    check.assert(false, "lookup type 6 format 2 is not yet supported.");
  } else if (subtable.substFormat === 3) {
    var tableData = [
      { name: "substFormat", type: "USHORT", value: subtable.substFormat }
    ];
    tableData.push({ name: "backtrackGlyphCount", type: "USHORT", value: subtable.backtrackCoverage.length });
    subtable.backtrackCoverage.forEach(function(coverage, i2) {
      tableData.push({ name: "backtrackCoverage" + i2, type: "TABLE", value: new table.Coverage(coverage) });
    });
    tableData.push({ name: "inputGlyphCount", type: "USHORT", value: subtable.inputCoverage.length });
    subtable.inputCoverage.forEach(function(coverage, i2) {
      tableData.push({ name: "inputCoverage" + i2, type: "TABLE", value: new table.Coverage(coverage) });
    });
    tableData.push({ name: "lookaheadGlyphCount", type: "USHORT", value: subtable.lookaheadCoverage.length });
    subtable.lookaheadCoverage.forEach(function(coverage, i2) {
      tableData.push({ name: "lookaheadCoverage" + i2, type: "TABLE", value: new table.Coverage(coverage) });
    });
    tableData.push({ name: "substitutionCount", type: "USHORT", value: subtable.lookupRecords.length });
    subtable.lookupRecords.forEach(function(record, i2) {
      tableData = tableData.concat({ name: "sequenceIndex" + i2, type: "USHORT", value: record.sequenceIndex }).concat({ name: "lookupListIndex" + i2, type: "USHORT", value: record.lookupListIndex });
    });
    var returnTable$1 = new table.Table("chainContextTable", tableData);
    return returnTable$1;
  }
  check.assert(false, "lookup type 6 format must be 1, 2 or 3.");
};
function makeGsubTable(gsub2) {
  return new table.Table("GSUB", [
    { name: "version", type: "ULONG", value: 65536 },
    { name: "scripts", type: "TABLE", value: new table.ScriptList(gsub2.scripts) },
    { name: "features", type: "TABLE", value: new table.FeatureList(gsub2.features) },
    { name: "lookups", type: "TABLE", value: new table.LookupList(gsub2.lookups, subtableMakers) }
  ]);
}
var gsub = { parse: parseGsubTable, make: makeGsubTable };
function parseMetaTable(data, start) {
  var p = new parse.Parser(data, start);
  var tableVersion = p.parseULong();
  check.argument(tableVersion === 1, "Unsupported META table version.");
  p.parseULong();
  p.parseULong();
  var numDataMaps = p.parseULong();
  var tags = {};
  for (var i2 = 0; i2 < numDataMaps; i2++) {
    var tag = p.parseTag();
    var dataOffset = p.parseULong();
    var dataLength = p.parseULong();
    var text = decode.UTF8(data, start + dataOffset, dataLength);
    tags[tag] = text;
  }
  return tags;
}
function makeMetaTable(tags) {
  var numTags = Object.keys(tags).length;
  var stringPool = "";
  var stringPoolOffset = 16 + numTags * 12;
  var result = new table.Table("meta", [
    { name: "version", type: "ULONG", value: 1 },
    { name: "flags", type: "ULONG", value: 0 },
    { name: "offset", type: "ULONG", value: stringPoolOffset },
    { name: "numTags", type: "ULONG", value: numTags }
  ]);
  for (var tag in tags) {
    var pos = stringPool.length;
    stringPool += tags[tag];
    result.fields.push({ name: "tag " + tag, type: "TAG", value: tag });
    result.fields.push({ name: "offset " + tag, type: "ULONG", value: stringPoolOffset + pos });
    result.fields.push({ name: "length " + tag, type: "ULONG", value: tags[tag].length });
  }
  result.fields.push({ name: "stringPool", type: "CHARARRAY", value: stringPool });
  return result;
}
var meta = { parse: parseMetaTable, make: makeMetaTable };
function log22(v) {
  return Math.log(v) / Math.log(2) | 0;
}
function computeCheckSum(bytes) {
  while (bytes.length % 4 !== 0) {
    bytes.push(0);
  }
  var sum = 0;
  for (var i2 = 0; i2 < bytes.length; i2 += 4) {
    sum += (bytes[i2] << 24) + (bytes[i2 + 1] << 16) + (bytes[i2 + 2] << 8) + bytes[i2 + 3];
  }
  sum %= Math.pow(2, 32);
  return sum;
}
function makeTableRecord(tag, checkSum, offset, length2) {
  return new table.Record("Table Record", [
    { name: "tag", type: "TAG", value: tag !== void 0 ? tag : "" },
    { name: "checkSum", type: "ULONG", value: checkSum !== void 0 ? checkSum : 0 },
    { name: "offset", type: "ULONG", value: offset !== void 0 ? offset : 0 },
    { name: "length", type: "ULONG", value: length2 !== void 0 ? length2 : 0 }
  ]);
}
function makeSfntTable(tables) {
  var sfnt2 = new table.Table("sfnt", [
    { name: "version", type: "TAG", value: "OTTO" },
    { name: "numTables", type: "USHORT", value: 0 },
    { name: "searchRange", type: "USHORT", value: 0 },
    { name: "entrySelector", type: "USHORT", value: 0 },
    { name: "rangeShift", type: "USHORT", value: 0 }
  ]);
  sfnt2.tables = tables;
  sfnt2.numTables = tables.length;
  var highestPowerOf2 = Math.pow(2, log22(sfnt2.numTables));
  sfnt2.searchRange = 16 * highestPowerOf2;
  sfnt2.entrySelector = log22(highestPowerOf2);
  sfnt2.rangeShift = sfnt2.numTables * 16 - sfnt2.searchRange;
  var recordFields = [];
  var tableFields = [];
  var offset = sfnt2.sizeOf() + makeTableRecord().sizeOf() * sfnt2.numTables;
  while (offset % 4 !== 0) {
    offset += 1;
    tableFields.push({ name: "padding", type: "BYTE", value: 0 });
  }
  for (var i2 = 0; i2 < tables.length; i2 += 1) {
    var t2 = tables[i2];
    check.argument(t2.tableName.length === 4, "Table name" + t2.tableName + " is invalid.");
    var tableLength = t2.sizeOf();
    var tableRecord = makeTableRecord(t2.tableName, computeCheckSum(t2.encode()), offset, tableLength);
    recordFields.push({ name: tableRecord.tag + " Table Record", type: "RECORD", value: tableRecord });
    tableFields.push({ name: t2.tableName + " table", type: "RECORD", value: t2 });
    offset += tableLength;
    check.argument(!isNaN(offset), "Something went wrong calculating the offset.");
    while (offset % 4 !== 0) {
      offset += 1;
      tableFields.push({ name: "padding", type: "BYTE", value: 0 });
    }
  }
  recordFields.sort(function(r1, r2) {
    if (r1.value.tag > r2.value.tag) {
      return 1;
    } else {
      return -1;
    }
  });
  sfnt2.fields = sfnt2.fields.concat(recordFields);
  sfnt2.fields = sfnt2.fields.concat(tableFields);
  return sfnt2;
}
function metricsForChar(font, chars, notFoundMetrics) {
  for (var i2 = 0; i2 < chars.length; i2 += 1) {
    var glyphIndex = font.charToGlyphIndex(chars[i2]);
    if (glyphIndex > 0) {
      var glyph = font.glyphs.get(glyphIndex);
      return glyph.getMetrics();
    }
  }
  return notFoundMetrics;
}
function average(vs) {
  var sum = 0;
  for (var i2 = 0; i2 < vs.length; i2 += 1) {
    sum += vs[i2];
  }
  return sum / vs.length;
}
function fontToSfntTable(font) {
  var xMins = [];
  var yMins = [];
  var xMaxs = [];
  var yMaxs = [];
  var advanceWidths = [];
  var leftSideBearings = [];
  var rightSideBearings = [];
  var firstCharIndex;
  var lastCharIndex = 0;
  var ulUnicodeRange1 = 0;
  var ulUnicodeRange2 = 0;
  var ulUnicodeRange3 = 0;
  var ulUnicodeRange4 = 0;
  for (var i2 = 0; i2 < font.glyphs.length; i2 += 1) {
    var glyph = font.glyphs.get(i2);
    var unicode = glyph.unicode | 0;
    if (isNaN(glyph.advanceWidth)) {
      throw new Error("Glyph " + glyph.name + " (" + i2 + "): advanceWidth is not a number.");
    }
    if (firstCharIndex > unicode || firstCharIndex === void 0) {
      if (unicode > 0) {
        firstCharIndex = unicode;
      }
    }
    if (lastCharIndex < unicode) {
      lastCharIndex = unicode;
    }
    var position = os2.getUnicodeRange(unicode);
    if (position < 32) {
      ulUnicodeRange1 |= 1 << position;
    } else if (position < 64) {
      ulUnicodeRange2 |= 1 << position - 32;
    } else if (position < 96) {
      ulUnicodeRange3 |= 1 << position - 64;
    } else if (position < 123) {
      ulUnicodeRange4 |= 1 << position - 96;
    } else {
      throw new Error("Unicode ranges bits > 123 are reserved for internal usage");
    }
    if (glyph.name === ".notdef") {
      continue;
    }
    var metrics = glyph.getMetrics();
    xMins.push(metrics.xMin);
    yMins.push(metrics.yMin);
    xMaxs.push(metrics.xMax);
    yMaxs.push(metrics.yMax);
    leftSideBearings.push(metrics.leftSideBearing);
    rightSideBearings.push(metrics.rightSideBearing);
    advanceWidths.push(glyph.advanceWidth);
  }
  var globals = {
    xMin: Math.min.apply(null, xMins),
    yMin: Math.min.apply(null, yMins),
    xMax: Math.max.apply(null, xMaxs),
    yMax: Math.max.apply(null, yMaxs),
    advanceWidthMax: Math.max.apply(null, advanceWidths),
    advanceWidthAvg: average(advanceWidths),
    minLeftSideBearing: Math.min.apply(null, leftSideBearings),
    maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
    minRightSideBearing: Math.min.apply(null, rightSideBearings)
  };
  globals.ascender = font.ascender;
  globals.descender = font.descender;
  var headTable = head.make({
    flags: 3,
    unitsPerEm: font.unitsPerEm,
    xMin: globals.xMin,
    yMin: globals.yMin,
    xMax: globals.xMax,
    yMax: globals.yMax,
    lowestRecPPEM: 3,
    createdTimestamp: font.createdTimestamp
  });
  var hheaTable = hhea.make({
    ascender: globals.ascender,
    descender: globals.descender,
    advanceWidthMax: globals.advanceWidthMax,
    minLeftSideBearing: globals.minLeftSideBearing,
    minRightSideBearing: globals.minRightSideBearing,
    xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
    numberOfHMetrics: font.glyphs.length
  });
  var maxpTable = maxp.make(font.glyphs.length);
  var os2Table = os2.make(Object.assign({
    xAvgCharWidth: Math.round(globals.advanceWidthAvg),
    usFirstCharIndex: firstCharIndex,
    usLastCharIndex: lastCharIndex,
    ulUnicodeRange1,
    ulUnicodeRange2,
    ulUnicodeRange3,
    ulUnicodeRange4,
    sTypoAscender: globals.ascender,
    sTypoDescender: globals.descender,
    sTypoLineGap: 0,
    usWinAscent: globals.yMax,
    usWinDescent: Math.abs(globals.yMin),
    ulCodePageRange1: 1,
    sxHeight: metricsForChar(font, "xyvw", { yMax: Math.round(globals.ascender / 2) }).yMax,
    sCapHeight: metricsForChar(font, "HIKLEFJMNTZBDPRAGOQSUVWXY", globals).yMax,
    usDefaultChar: font.hasChar(" ") ? 32 : 0,
    usBreakChar: font.hasChar(" ") ? 32 : 0
  }, font.tables.os2));
  var hmtxTable = hmtx.make(font.glyphs);
  var cmapTable = cmap.make(font.glyphs);
  var englishFamilyName = font.getEnglishName("fontFamily");
  var englishStyleName = font.getEnglishName("fontSubfamily");
  var englishFullName = englishFamilyName + " " + englishStyleName;
  var postScriptName = font.getEnglishName("postScriptName");
  if (!postScriptName) {
    postScriptName = englishFamilyName.replace(/\s/g, "") + "-" + englishStyleName;
  }
  var names = {};
  for (var n in font.names) {
    names[n] = font.names[n];
  }
  if (!names.uniqueID) {
    names.uniqueID = { en: font.getEnglishName("manufacturer") + ":" + englishFullName };
  }
  if (!names.postScriptName) {
    names.postScriptName = { en: postScriptName };
  }
  if (!names.preferredFamily) {
    names.preferredFamily = font.names.fontFamily;
  }
  if (!names.preferredSubfamily) {
    names.preferredSubfamily = font.names.fontSubfamily;
  }
  var languageTags = [];
  var nameTable = _name.make(names, languageTags);
  var ltagTable = languageTags.length > 0 ? ltag.make(languageTags) : void 0;
  var postTable = post.make();
  var cffTable = cff.make(font.glyphs, {
    version: font.getEnglishName("version"),
    fullName: englishFullName,
    familyName: englishFamilyName,
    weightName: englishStyleName,
    postScriptName,
    unitsPerEm: font.unitsPerEm,
    fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
  });
  var metaTable = font.metas && Object.keys(font.metas).length > 0 ? meta.make(font.metas) : void 0;
  var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
  if (ltagTable) {
    tables.push(ltagTable);
  }
  if (font.tables.gsub) {
    tables.push(gsub.make(font.tables.gsub));
  }
  if (metaTable) {
    tables.push(metaTable);
  }
  var sfntTable = makeSfntTable(tables);
  var bytes = sfntTable.encode();
  var checkSum = computeCheckSum(bytes);
  var tableFields = sfntTable.fields;
  var checkSumAdjusted = false;
  for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
    if (tableFields[i$1].name === "head table") {
      tableFields[i$1].value.checkSumAdjustment = 2981146554 - checkSum;
      checkSumAdjusted = true;
      break;
    }
  }
  if (!checkSumAdjusted) {
    throw new Error("Could not find head table with checkSum to adjust.");
  }
  return sfntTable;
}
var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum };
function searchTag(arr, tag) {
  var imin = 0;
  var imax = arr.length - 1;
  while (imin <= imax) {
    var imid = imin + imax >>> 1;
    var val = arr[imid].tag;
    if (val === tag) {
      return imid;
    } else if (val < tag) {
      imin = imid + 1;
    } else {
      imax = imid - 1;
    }
  }
  return -imin - 1;
}
function binSearch(arr, value) {
  var imin = 0;
  var imax = arr.length - 1;
  while (imin <= imax) {
    var imid = imin + imax >>> 1;
    var val = arr[imid];
    if (val === value) {
      return imid;
    } else if (val < value) {
      imin = imid + 1;
    } else {
      imax = imid - 1;
    }
  }
  return -imin - 1;
}
function searchRange(ranges, value) {
  var range;
  var imin = 0;
  var imax = ranges.length - 1;
  while (imin <= imax) {
    var imid = imin + imax >>> 1;
    range = ranges[imid];
    var start = range.start;
    if (start === value) {
      return range;
    } else if (start < value) {
      imin = imid + 1;
    } else {
      imax = imid - 1;
    }
  }
  if (imin > 0) {
    range = ranges[imin - 1];
    if (value > range.end) {
      return 0;
    }
    return range;
  }
}
function Layout(font, tableName) {
  this.font = font;
  this.tableName = tableName;
}
Layout.prototype = {
  searchTag,
  binSearch,
  getTable: function(create) {
    var layout = this.font.tables[this.tableName];
    if (!layout && create) {
      layout = this.font.tables[this.tableName] = this.createDefaultTable();
    }
    return layout;
  },
  getScriptNames: function() {
    var layout = this.getTable();
    if (!layout) {
      return [];
    }
    return layout.scripts.map(function(script) {
      return script.tag;
    });
  },
  getDefaultScriptName: function() {
    var layout = this.getTable();
    if (!layout) {
      return;
    }
    var hasLatn = false;
    for (var i2 = 0; i2 < layout.scripts.length; i2++) {
      var name = layout.scripts[i2].tag;
      if (name === "DFLT") {
        return name;
      }
      if (name === "latn") {
        hasLatn = true;
      }
    }
    if (hasLatn) {
      return "latn";
    }
  },
  getScriptTable: function(script, create) {
    var layout = this.getTable(create);
    if (layout) {
      script = script || "DFLT";
      var scripts = layout.scripts;
      var pos = searchTag(layout.scripts, script);
      if (pos >= 0) {
        return scripts[pos].script;
      } else if (create) {
        var scr = {
          tag: script,
          script: {
            defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] },
            langSysRecords: []
          }
        };
        scripts.splice(-1 - pos, 0, scr);
        return scr.script;
      }
    }
  },
  getLangSysTable: function(script, language, create) {
    var scriptTable = this.getScriptTable(script, create);
    if (scriptTable) {
      if (!language || language === "dflt" || language === "DFLT") {
        return scriptTable.defaultLangSys;
      }
      var pos = searchTag(scriptTable.langSysRecords, language);
      if (pos >= 0) {
        return scriptTable.langSysRecords[pos].langSys;
      } else if (create) {
        var langSysRecord = {
          tag: language,
          langSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }
        };
        scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
        return langSysRecord.langSys;
      }
    }
  },
  getFeatureTable: function(script, language, feature, create) {
    var langSysTable2 = this.getLangSysTable(script, language, create);
    if (langSysTable2) {
      var featureRecord;
      var featIndexes = langSysTable2.featureIndexes;
      var allFeatures = this.font.tables[this.tableName].features;
      for (var i2 = 0; i2 < featIndexes.length; i2++) {
        featureRecord = allFeatures[featIndexes[i2]];
        if (featureRecord.tag === feature) {
          return featureRecord.feature;
        }
      }
      if (create) {
        var index = allFeatures.length;
        check.assert(index === 0 || feature >= allFeatures[index - 1].tag, "Features must be added in alphabetical order.");
        featureRecord = {
          tag: feature,
          feature: { params: 0, lookupListIndexes: [] }
        };
        allFeatures.push(featureRecord);
        featIndexes.push(index);
        return featureRecord.feature;
      }
    }
  },
  getLookupTables: function(script, language, feature, lookupType, create) {
    var featureTable = this.getFeatureTable(script, language, feature, create);
    var tables = [];
    if (featureTable) {
      var lookupTable;
      var lookupListIndexes = featureTable.lookupListIndexes;
      var allLookups = this.font.tables[this.tableName].lookups;
      for (var i2 = 0; i2 < lookupListIndexes.length; i2++) {
        lookupTable = allLookups[lookupListIndexes[i2]];
        if (lookupTable.lookupType === lookupType) {
          tables.push(lookupTable);
        }
      }
      if (tables.length === 0 && create) {
        lookupTable = {
          lookupType,
          lookupFlag: 0,
          subtables: [],
          markFilteringSet: void 0
        };
        var index = allLookups.length;
        allLookups.push(lookupTable);
        lookupListIndexes.push(index);
        return [lookupTable];
      }
    }
    return tables;
  },
  getGlyphClass: function(classDefTable, glyphIndex) {
    switch (classDefTable.format) {
      case 1:
        if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
          return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
        }
        return 0;
      case 2:
        var range = searchRange(classDefTable.ranges, glyphIndex);
        return range ? range.classId : 0;
    }
  },
  getCoverageIndex: function(coverageTable, glyphIndex) {
    switch (coverageTable.format) {
      case 1:
        var index = binSearch(coverageTable.glyphs, glyphIndex);
        return index >= 0 ? index : -1;
      case 2:
        var range = searchRange(coverageTable.ranges, glyphIndex);
        return range ? range.index + glyphIndex - range.start : -1;
    }
  },
  expandCoverage: function(coverageTable) {
    if (coverageTable.format === 1) {
      return coverageTable.glyphs;
    } else {
      var glyphs = [];
      var ranges = coverageTable.ranges;
      for (var i2 = 0; i2 < ranges.length; i2++) {
        var range = ranges[i2];
        var start = range.start;
        var end = range.end;
        for (var j2 = start; j2 <= end; j2++) {
          glyphs.push(j2);
        }
      }
      return glyphs;
    }
  }
};
function Position(font) {
  Layout.call(this, font, "gpos");
}
Position.prototype = Layout.prototype;
Position.prototype.init = function() {
  var script = this.getDefaultScriptName();
  this.defaultKerningTables = this.getKerningTables(script);
};
Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
  for (var i2 = 0; i2 < kerningLookups.length; i2++) {
    var subtables = kerningLookups[i2].subtables;
    for (var j2 = 0; j2 < subtables.length; j2++) {
      var subtable = subtables[j2];
      var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);
      if (covIndex < 0) {
        continue;
      }
      switch (subtable.posFormat) {
        case 1:
          var pairSet = subtable.pairSets[covIndex];
          for (var k = 0; k < pairSet.length; k++) {
            var pair = pairSet[k];
            if (pair.secondGlyph === rightIndex) {
              return pair.value1 && pair.value1.xAdvance || 0;
            }
          }
          break;
        case 2:
          var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);
          var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);
          var pair$1 = subtable.classRecords[class1][class2];
          return pair$1.value1 && pair$1.value1.xAdvance || 0;
      }
    }
  }
  return 0;
};
Position.prototype.getKerningTables = function(script, language) {
  if (this.font.tables.gpos) {
    return this.getLookupTables(script, language, "kern", 2);
  }
};
function Substitution(font) {
  Layout.call(this, font, "gsub");
}
function arraysEqual(ar1, ar2) {
  var n = ar1.length;
  if (n !== ar2.length) {
    return false;
  }
  for (var i2 = 0; i2 < n; i2++) {
    if (ar1[i2] !== ar2[i2]) {
      return false;
    }
  }
  return true;
}
function getSubstFormat(lookupTable, format, defaultSubtable) {
  var subtables = lookupTable.subtables;
  for (var i2 = 0; i2 < subtables.length; i2++) {
    var subtable = subtables[i2];
    if (subtable.substFormat === format) {
      return subtable;
    }
  }
  if (defaultSubtable) {
    subtables.push(defaultSubtable);
    return defaultSubtable;
  }
  return void 0;
}
Substitution.prototype = Layout.prototype;
Substitution.prototype.createDefaultTable = function() {
  return {
    version: 1,
    scripts: [{
      tag: "DFLT",
      script: {
        defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] },
        langSysRecords: []
      }
    }],
    features: [],
    lookups: []
  };
};
Substitution.prototype.getSingle = function(feature, script, language) {
  var substitutions = [];
  var lookupTables = this.getLookupTables(script, language, feature, 1);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i2 = 0; i2 < subtables.length; i2++) {
      var subtable = subtables[i2];
      var glyphs = this.expandCoverage(subtable.coverage);
      var j2 = void 0;
      if (subtable.substFormat === 1) {
        var delta = subtable.deltaGlyphId;
        for (j2 = 0; j2 < glyphs.length; j2++) {
          var glyph = glyphs[j2];
          substitutions.push({ sub: glyph, by: glyph + delta });
        }
      } else {
        var substitute = subtable.substitute;
        for (j2 = 0; j2 < glyphs.length; j2++) {
          substitutions.push({ sub: glyphs[j2], by: substitute[j2] });
        }
      }
    }
  }
  return substitutions;
};
Substitution.prototype.getMultiple = function(feature, script, language) {
  var substitutions = [];
  var lookupTables = this.getLookupTables(script, language, feature, 2);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i2 = 0; i2 < subtables.length; i2++) {
      var subtable = subtables[i2];
      var glyphs = this.expandCoverage(subtable.coverage);
      var j2 = void 0;
      for (j2 = 0; j2 < glyphs.length; j2++) {
        var glyph = glyphs[j2];
        var replacements = subtable.sequences[j2];
        substitutions.push({ sub: glyph, by: replacements });
      }
    }
  }
  return substitutions;
};
Substitution.prototype.getAlternates = function(feature, script, language) {
  var alternates = [];
  var lookupTables = this.getLookupTables(script, language, feature, 3);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i2 = 0; i2 < subtables.length; i2++) {
      var subtable = subtables[i2];
      var glyphs = this.expandCoverage(subtable.coverage);
      var alternateSets = subtable.alternateSets;
      for (var j2 = 0; j2 < glyphs.length; j2++) {
        alternates.push({ sub: glyphs[j2], by: alternateSets[j2] });
      }
    }
  }
  return alternates;
};
Substitution.prototype.getLigatures = function(feature, script, language) {
  var ligatures = [];
  var lookupTables = this.getLookupTables(script, language, feature, 4);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i2 = 0; i2 < subtables.length; i2++) {
      var subtable = subtables[i2];
      var glyphs = this.expandCoverage(subtable.coverage);
      var ligatureSets = subtable.ligatureSets;
      for (var j2 = 0; j2 < glyphs.length; j2++) {
        var startGlyph = glyphs[j2];
        var ligSet = ligatureSets[j2];
        for (var k = 0; k < ligSet.length; k++) {
          var lig = ligSet[k];
          ligatures.push({
            sub: [startGlyph].concat(lig.components),
            by: lig.ligGlyph
          });
        }
      }
    }
  }
  return ligatures;
};
Substitution.prototype.addSingle = function(feature, substitution, script, language) {
  var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
  var subtable = getSubstFormat(lookupTable, 2, {
    substFormat: 2,
    coverage: { format: 1, glyphs: [] },
    substitute: []
  });
  check.assert(subtable.coverage.format === 1, "Single: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = substitution.sub;
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos < 0) {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.substitute.splice(pos, 0, 0);
  }
  subtable.substitute[pos] = substitution.by;
};
Substitution.prototype.addMultiple = function(feature, substitution, script, language) {
  check.assert(substitution.by instanceof Array && substitution.by.length > 1, 'Multiple: "by" must be an array of two or more ids');
  var lookupTable = this.getLookupTables(script, language, feature, 2, true)[0];
  var subtable = getSubstFormat(lookupTable, 1, {
    substFormat: 1,
    coverage: { format: 1, glyphs: [] },
    sequences: []
  });
  check.assert(subtable.coverage.format === 1, "Multiple: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = substitution.sub;
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos < 0) {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.sequences.splice(pos, 0, 0);
  }
  subtable.sequences[pos] = substitution.by;
};
Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
  var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
  var subtable = getSubstFormat(lookupTable, 1, {
    substFormat: 1,
    coverage: { format: 1, glyphs: [] },
    alternateSets: []
  });
  check.assert(subtable.coverage.format === 1, "Alternate: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = substitution.sub;
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos < 0) {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.alternateSets.splice(pos, 0, 0);
  }
  subtable.alternateSets[pos] = substitution.by;
};
Substitution.prototype.addLigature = function(feature, ligature, script, language) {
  var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
  var subtable = lookupTable.subtables[0];
  if (!subtable) {
    subtable = {
      substFormat: 1,
      coverage: { format: 1, glyphs: [] },
      ligatureSets: []
    };
    lookupTable.subtables[0] = subtable;
  }
  check.assert(subtable.coverage.format === 1, "Ligature: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = ligature.sub[0];
  var ligComponents = ligature.sub.slice(1);
  var ligatureTable = {
    ligGlyph: ligature.by,
    components: ligComponents
  };
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos >= 0) {
    var ligatureSet = subtable.ligatureSets[pos];
    for (var i2 = 0; i2 < ligatureSet.length; i2++) {
      if (arraysEqual(ligatureSet[i2].components, ligComponents)) {
        return;
      }
    }
    ligatureSet.push(ligatureTable);
  } else {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
  }
};
Substitution.prototype.getFeature = function(feature, script, language) {
  if (/ss\d\d/.test(feature)) {
    return this.getSingle(feature, script, language);
  }
  switch (feature) {
    case "aalt":
    case "salt":
      return this.getSingle(feature, script, language).concat(this.getAlternates(feature, script, language));
    case "dlig":
    case "liga":
    case "rlig":
      return this.getLigatures(feature, script, language);
    case "ccmp":
      return this.getMultiple(feature, script, language).concat(this.getLigatures(feature, script, language));
    case "stch":
      return this.getMultiple(feature, script, language);
  }
  return void 0;
};
Substitution.prototype.add = function(feature, sub2, script, language) {
  if (/ss\d\d/.test(feature)) {
    return this.addSingle(feature, sub2, script, language);
  }
  switch (feature) {
    case "aalt":
    case "salt":
      if (typeof sub2.by === "number") {
        return this.addSingle(feature, sub2, script, language);
      }
      return this.addAlternate(feature, sub2, script, language);
    case "dlig":
    case "liga":
    case "rlig":
      return this.addLigature(feature, sub2, script, language);
    case "ccmp":
      if (sub2.by instanceof Array) {
        return this.addMultiple(feature, sub2, script, language);
      }
      return this.addLigature(feature, sub2, script, language);
  }
  return void 0;
};
function isBrowser() {
  return typeof window !== "undefined";
}
function nodeBufferToArrayBuffer(buffer2) {
  var ab2 = new ArrayBuffer(buffer2.length);
  var view = new Uint8Array(ab2);
  for (var i2 = 0; i2 < buffer2.length; ++i2) {
    view[i2] = buffer2[i2];
  }
  return ab2;
}
function arrayBufferToNodeBuffer(ab2) {
  var buffer2 = new Buffer(ab2.byteLength);
  var view = new Uint8Array(ab2);
  for (var i2 = 0; i2 < buffer2.length; ++i2) {
    buffer2[i2] = view[i2];
  }
  return buffer2;
}
function checkArgument(expression, message) {
  if (!expression) {
    throw message;
  }
}
function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
  var v;
  if ((flag & shortVectorBitMask) > 0) {
    v = p.parseByte();
    if ((flag & sameBitMask) === 0) {
      v = -v;
    }
    v = previousValue + v;
  } else {
    if ((flag & sameBitMask) > 0) {
      v = previousValue;
    } else {
      v = previousValue + p.parseShort();
    }
  }
  return v;
}
function parseGlyph(glyph, data, start) {
  var p = new parse.Parser(data, start);
  glyph.numberOfContours = p.parseShort();
  glyph._xMin = p.parseShort();
  glyph._yMin = p.parseShort();
  glyph._xMax = p.parseShort();
  glyph._yMax = p.parseShort();
  var flags;
  var flag;
  if (glyph.numberOfContours > 0) {
    var endPointIndices = glyph.endPointIndices = [];
    for (var i2 = 0; i2 < glyph.numberOfContours; i2 += 1) {
      endPointIndices.push(p.parseUShort());
    }
    glyph.instructionLength = p.parseUShort();
    glyph.instructions = [];
    for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
      glyph.instructions.push(p.parseByte());
    }
    var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
    flags = [];
    for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
      flag = p.parseByte();
      flags.push(flag);
      if ((flag & 8) > 0) {
        var repeatCount = p.parseByte();
        for (var j2 = 0; j2 < repeatCount; j2 += 1) {
          flags.push(flag);
          i$2 += 1;
        }
      }
    }
    check.argument(flags.length === numberOfCoordinates, "Bad flags.");
    if (endPointIndices.length > 0) {
      var points = [];
      var point;
      if (numberOfCoordinates > 0) {
        for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
          flag = flags[i$3];
          point = {};
          point.onCurve = !!(flag & 1);
          point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
          points.push(point);
        }
        var px = 0;
        for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
          flag = flags[i$4];
          point = points[i$4];
          point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
          px = point.x;
        }
        var py = 0;
        for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
          flag = flags[i$5];
          point = points[i$5];
          point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
          py = point.y;
        }
      }
      glyph.points = points;
    } else {
      glyph.points = [];
    }
  } else if (glyph.numberOfContours === 0) {
    glyph.points = [];
  } else {
    glyph.isComposite = true;
    glyph.points = [];
    glyph.components = [];
    var moreComponents = true;
    while (moreComponents) {
      flags = p.parseUShort();
      var component = {
        glyphIndex: p.parseUShort(),
        xScale: 1,
        scale01: 0,
        scale10: 0,
        yScale: 1,
        dx: 0,
        dy: 0
      };
      if ((flags & 1) > 0) {
        if ((flags & 2) > 0) {
          component.dx = p.parseShort();
          component.dy = p.parseShort();
        } else {
          component.matchedPoints = [p.parseUShort(), p.parseUShort()];
        }
      } else {
        if ((flags & 2) > 0) {
          component.dx = p.parseChar();
          component.dy = p.parseChar();
        } else {
          component.matchedPoints = [p.parseByte(), p.parseByte()];
        }
      }
      if ((flags & 8) > 0) {
        component.xScale = component.yScale = p.parseF2Dot14();
      } else if ((flags & 64) > 0) {
        component.xScale = p.parseF2Dot14();
        component.yScale = p.parseF2Dot14();
      } else if ((flags & 128) > 0) {
        component.xScale = p.parseF2Dot14();
        component.scale01 = p.parseF2Dot14();
        component.scale10 = p.parseF2Dot14();
        component.yScale = p.parseF2Dot14();
      }
      glyph.components.push(component);
      moreComponents = !!(flags & 32);
    }
    if (flags & 256) {
      glyph.instructionLength = p.parseUShort();
      glyph.instructions = [];
      for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
        glyph.instructions.push(p.parseByte());
      }
    }
  }
}
function transformPoints(points, transform) {
  var newPoints = [];
  for (var i2 = 0; i2 < points.length; i2 += 1) {
    var pt = points[i2];
    var newPt = {
      x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
      y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
      onCurve: pt.onCurve,
      lastPointOfContour: pt.lastPointOfContour
    };
    newPoints.push(newPt);
  }
  return newPoints;
}
function getContours(points) {
  var contours = [];
  var currentContour = [];
  for (var i2 = 0; i2 < points.length; i2 += 1) {
    var pt = points[i2];
    currentContour.push(pt);
    if (pt.lastPointOfContour) {
      contours.push(currentContour);
      currentContour = [];
    }
  }
  check.argument(currentContour.length === 0, "There are still points left in the current contour.");
  return contours;
}
function getPath(points) {
  var p = new Path2();
  if (!points) {
    return p;
  }
  var contours = getContours(points);
  for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
    var contour = contours[contourIndex];
    var prev = null;
    var curr = contour[contour.length - 1];
    var next = contour[0];
    if (curr.onCurve) {
      p.moveTo(curr.x, curr.y);
    } else {
      if (next.onCurve) {
        p.moveTo(next.x, next.y);
      } else {
        var start = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
        p.moveTo(start.x, start.y);
      }
    }
    for (var i2 = 0; i2 < contour.length; ++i2) {
      prev = curr;
      curr = next;
      next = contour[(i2 + 1) % contour.length];
      if (curr.onCurve) {
        p.lineTo(curr.x, curr.y);
      } else {
        var prev2 = prev;
        var next2 = next;
        if (!prev.onCurve) {
          prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };
        }
        if (!next.onCurve) {
          next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
        }
        p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
      }
    }
    p.closePath();
  }
  return p;
}
function buildPath(glyphs, glyph) {
  if (glyph.isComposite) {
    for (var j2 = 0; j2 < glyph.components.length; j2 += 1) {
      var component = glyph.components[j2];
      var componentGlyph = glyphs.get(component.glyphIndex);
      componentGlyph.getPath();
      if (componentGlyph.points) {
        var transformedPoints = void 0;
        if (component.matchedPoints === void 0) {
          transformedPoints = transformPoints(componentGlyph.points, component);
        } else {
          if (component.matchedPoints[0] > glyph.points.length - 1 || component.matchedPoints[1] > componentGlyph.points.length - 1) {
            throw Error("Matched points out of range in " + glyph.name);
          }
          var firstPt = glyph.points[component.matchedPoints[0]];
          var secondPt = componentGlyph.points[component.matchedPoints[1]];
          var transform = {
            xScale: component.xScale,
            scale01: component.scale01,
            scale10: component.scale10,
            yScale: component.yScale,
            dx: 0,
            dy: 0
          };
          secondPt = transformPoints([secondPt], transform)[0];
          transform.dx = firstPt.x - secondPt.x;
          transform.dy = firstPt.y - secondPt.y;
          transformedPoints = transformPoints(componentGlyph.points, transform);
        }
        glyph.points = glyph.points.concat(transformedPoints);
      }
    }
  }
  return getPath(glyph.points);
}
function parseGlyfTableAll(data, start, loca2, font) {
  var glyphs = new glyphset.GlyphSet(font);
  for (var i2 = 0; i2 < loca2.length - 1; i2 += 1) {
    var offset = loca2[i2];
    var nextOffset = loca2[i2 + 1];
    if (offset !== nextOffset) {
      glyphs.push(i2, glyphset.ttfGlyphLoader(font, i2, parseGlyph, data, start + offset, buildPath));
    } else {
      glyphs.push(i2, glyphset.glyphLoader(font, i2));
    }
  }
  return glyphs;
}
function parseGlyfTableOnLowMemory(data, start, loca2, font) {
  var glyphs = new glyphset.GlyphSet(font);
  font._push = function(i2) {
    var offset = loca2[i2];
    var nextOffset = loca2[i2 + 1];
    if (offset !== nextOffset) {
      glyphs.push(i2, glyphset.ttfGlyphLoader(font, i2, parseGlyph, data, start + offset, buildPath));
    } else {
      glyphs.push(i2, glyphset.glyphLoader(font, i2));
    }
  };
  return glyphs;
}
function parseGlyfTable(data, start, loca2, font, opt) {
  if (opt.lowMemory) {
    return parseGlyfTableOnLowMemory(data, start, loca2, font);
  } else {
    return parseGlyfTableAll(data, start, loca2, font);
  }
}
var glyf = { getPath, parse: parseGlyfTable };
var instructionTable;
var exec;
var execGlyph;
var execComponent;
function Hinting(font) {
  this.font = font;
  this.getCommands = function(hPoints) {
    return glyf.getPath(hPoints).commands;
  };
  this._fpgmState = this._prepState = void 0;
  this._errorState = 0;
}
function roundOff(v) {
  return v;
}
function roundToGrid(v) {
  return Math.sign(v) * Math.round(Math.abs(v));
}
function roundToDoubleGrid(v) {
  return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
}
function roundToHalfGrid(v) {
  return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
}
function roundUpToGrid(v) {
  return Math.sign(v) * Math.ceil(Math.abs(v));
}
function roundDownToGrid(v) {
  return Math.sign(v) * Math.floor(Math.abs(v));
}
var roundSuper = function(v) {
  var period = this.srPeriod;
  var phase = this.srPhase;
  var threshold = this.srThreshold;
  var sign2 = 1;
  if (v < 0) {
    v = -v;
    sign2 = -1;
  }
  v += threshold - phase;
  v = Math.trunc(v / period) * period;
  v += phase;
  if (v < 0) {
    return phase * sign2;
  }
  return v * sign2;
};
var xUnitVector = {
  x: 1,
  y: 0,
  axis: "x",
  distance: function(p1, p2, o1, o2) {
    return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
  },
  interpolate: function(p, rp1, rp2, pv) {
    var do1;
    var do2;
    var doa1;
    var doa2;
    var dm1;
    var dm2;
    var dt;
    if (!pv || pv === this) {
      do1 = p.xo - rp1.xo;
      do2 = p.xo - rp2.xo;
      dm1 = rp1.x - rp1.xo;
      dm2 = rp2.x - rp2.xo;
      doa1 = Math.abs(do1);
      doa2 = Math.abs(do2);
      dt = doa1 + doa2;
      if (dt === 0) {
        p.x = p.xo + (dm1 + dm2) / 2;
        return;
      }
      p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
      return;
    }
    do1 = pv.distance(p, rp1, true, true);
    do2 = pv.distance(p, rp2, true, true);
    dm1 = pv.distance(rp1, rp1, false, true);
    dm2 = pv.distance(rp2, rp2, false, true);
    doa1 = Math.abs(do1);
    doa2 = Math.abs(do2);
    dt = doa1 + doa2;
    if (dt === 0) {
      xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
      return;
    }
    xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
  },
  normalSlope: Number.NEGATIVE_INFINITY,
  setRelative: function(p, rp, d, pv, org) {
    if (!pv || pv === this) {
      p.x = (org ? rp.xo : rp.x) + d;
      return;
    }
    var rpx = org ? rp.xo : rp.x;
    var rpy = org ? rp.yo : rp.y;
    var rpdx = rpx + d * pv.x;
    var rpdy = rpy + d * pv.y;
    p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
  },
  slope: 0,
  touch: function(p) {
    p.xTouched = true;
  },
  touched: function(p) {
    return p.xTouched;
  },
  untouch: function(p) {
    p.xTouched = false;
  }
};
var yUnitVector = {
  x: 0,
  y: 1,
  axis: "y",
  distance: function(p1, p2, o1, o2) {
    return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
  },
  interpolate: function(p, rp1, rp2, pv) {
    var do1;
    var do2;
    var doa1;
    var doa2;
    var dm1;
    var dm2;
    var dt;
    if (!pv || pv === this) {
      do1 = p.yo - rp1.yo;
      do2 = p.yo - rp2.yo;
      dm1 = rp1.y - rp1.yo;
      dm2 = rp2.y - rp2.yo;
      doa1 = Math.abs(do1);
      doa2 = Math.abs(do2);
      dt = doa1 + doa2;
      if (dt === 0) {
        p.y = p.yo + (dm1 + dm2) / 2;
        return;
      }
      p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
      return;
    }
    do1 = pv.distance(p, rp1, true, true);
    do2 = pv.distance(p, rp2, true, true);
    dm1 = pv.distance(rp1, rp1, false, true);
    dm2 = pv.distance(rp2, rp2, false, true);
    doa1 = Math.abs(do1);
    doa2 = Math.abs(do2);
    dt = doa1 + doa2;
    if (dt === 0) {
      yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
      return;
    }
    yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
  },
  normalSlope: 0,
  setRelative: function(p, rp, d, pv, org) {
    if (!pv || pv === this) {
      p.y = (org ? rp.yo : rp.y) + d;
      return;
    }
    var rpx = org ? rp.xo : rp.x;
    var rpy = org ? rp.yo : rp.y;
    var rpdx = rpx + d * pv.x;
    var rpdy = rpy + d * pv.y;
    p.y = rpdy + pv.normalSlope * (p.x - rpdx);
  },
  slope: Number.POSITIVE_INFINITY,
  touch: function(p) {
    p.yTouched = true;
  },
  touched: function(p) {
    return p.yTouched;
  },
  untouch: function(p) {
    p.yTouched = false;
  }
};
Object.freeze(xUnitVector);
Object.freeze(yUnitVector);
function UnitVector(x, y) {
  this.x = x;
  this.y = y;
  this.axis = void 0;
  this.slope = y / x;
  this.normalSlope = -x / y;
  Object.freeze(this);
}
UnitVector.prototype.distance = function(p1, p2, o1, o2) {
  return this.x * xUnitVector.distance(p1, p2, o1, o2) + this.y * yUnitVector.distance(p1, p2, o1, o2);
};
UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
  var dm1;
  var dm2;
  var do1;
  var do2;
  var doa1;
  var doa2;
  var dt;
  do1 = pv.distance(p, rp1, true, true);
  do2 = pv.distance(p, rp2, true, true);
  dm1 = pv.distance(rp1, rp1, false, true);
  dm2 = pv.distance(rp2, rp2, false, true);
  doa1 = Math.abs(do1);
  doa2 = Math.abs(do2);
  dt = doa1 + doa2;
  if (dt === 0) {
    this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
    return;
  }
  this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
};
UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
  pv = pv || this;
  var rpx = org ? rp.xo : rp.x;
  var rpy = org ? rp.yo : rp.y;
  var rpdx = rpx + d * pv.x;
  var rpdy = rpy + d * pv.y;
  var pvns = pv.normalSlope;
  var fvs = this.slope;
  var px = p.x;
  var py = p.y;
  p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
  p.y = fvs * (p.x - px) + py;
};
UnitVector.prototype.touch = function(p) {
  p.xTouched = true;
  p.yTouched = true;
};
function getUnitVector(x, y) {
  var d = Math.sqrt(x * x + y * y);
  x /= d;
  y /= d;
  if (x === 1 && y === 0) {
    return xUnitVector;
  } else if (x === 0 && y === 1) {
    return yUnitVector;
  } else {
    return new UnitVector(x, y);
  }
}
function HPoint(x, y, lastPointOfContour, onCurve) {
  this.x = this.xo = Math.round(x * 64) / 64;
  this.y = this.yo = Math.round(y * 64) / 64;
  this.lastPointOfContour = lastPointOfContour;
  this.onCurve = onCurve;
  this.prevPointOnContour = void 0;
  this.nextPointOnContour = void 0;
  this.xTouched = false;
  this.yTouched = false;
  Object.preventExtensions(this);
}
HPoint.prototype.nextTouched = function(v) {
  var p = this.nextPointOnContour;
  while (!v.touched(p) && p !== this) {
    p = p.nextPointOnContour;
  }
  return p;
};
HPoint.prototype.prevTouched = function(v) {
  var p = this.prevPointOnContour;
  while (!v.touched(p) && p !== this) {
    p = p.prevPointOnContour;
  }
  return p;
};
var HPZero = Object.freeze(new HPoint(0, 0));
var defaultState = {
  cvCutIn: 17 / 16,
  deltaBase: 9,
  deltaShift: 0.125,
  loop: 1,
  minDis: 1,
  autoFlip: true
};
function State(env, prog) {
  this.env = env;
  this.stack = [];
  this.prog = prog;
  switch (env) {
    case "glyf":
      this.zp0 = this.zp1 = this.zp2 = 1;
      this.rp0 = this.rp1 = this.rp2 = 0;
    case "prep":
      this.fv = this.pv = this.dpv = xUnitVector;
      this.round = roundToGrid;
  }
}
Hinting.prototype.exec = function(glyph, ppem) {
  if (typeof ppem !== "number") {
    throw new Error("Point size is not a number!");
  }
  if (this._errorState > 2) {
    return;
  }
  var font = this.font;
  var prepState = this._prepState;
  if (!prepState || prepState.ppem !== ppem) {
    var fpgmState = this._fpgmState;
    if (!fpgmState) {
      State.prototype = defaultState;
      fpgmState = this._fpgmState = new State("fpgm", font.tables.fpgm);
      fpgmState.funcs = [];
      fpgmState.font = font;
      if (exports.DEBUG) {
        console.log("---EXEC FPGM---");
        fpgmState.step = -1;
      }
      try {
        exec(fpgmState);
      } catch (e) {
        console.log("Hinting error in FPGM:" + e);
        this._errorState = 3;
        return;
      }
    }
    State.prototype = fpgmState;
    prepState = this._prepState = new State("prep", font.tables.prep);
    prepState.ppem = ppem;
    var oCvt = font.tables.cvt;
    if (oCvt) {
      var cvt = prepState.cvt = new Array(oCvt.length);
      var scale = ppem / font.unitsPerEm;
      for (var c = 0; c < oCvt.length; c++) {
        cvt[c] = oCvt[c] * scale;
      }
    } else {
      prepState.cvt = [];
    }
    if (exports.DEBUG) {
      console.log("---EXEC PREP---");
      prepState.step = -1;
    }
    try {
      exec(prepState);
    } catch (e) {
      if (this._errorState < 2) {
        console.log("Hinting error in PREP:" + e);
      }
      this._errorState = 2;
    }
  }
  if (this._errorState > 1) {
    return;
  }
  try {
    return execGlyph(glyph, prepState);
  } catch (e) {
    if (this._errorState < 1) {
      console.log("Hinting error:" + e);
      console.log("Note: further hinting errors are silenced");
    }
    this._errorState = 1;
    return void 0;
  }
};
execGlyph = function(glyph, prepState) {
  var xScale = prepState.ppem / prepState.font.unitsPerEm;
  var yScale = xScale;
  var components = glyph.components;
  var contours;
  var gZone;
  var state;
  State.prototype = prepState;
  if (!components) {
    state = new State("glyf", glyph.instructions);
    if (exports.DEBUG) {
      console.log("---EXEC GLYPH---");
      state.step = -1;
    }
    execComponent(glyph, state, xScale, yScale);
    gZone = state.gZone;
  } else {
    var font = prepState.font;
    gZone = [];
    contours = [];
    for (var i2 = 0; i2 < components.length; i2++) {
      var c = components[i2];
      var cg = font.glyphs.get(c.glyphIndex);
      state = new State("glyf", cg.instructions);
      if (exports.DEBUG) {
        console.log("---EXEC COMP " + i2 + "---");
        state.step = -1;
      }
      execComponent(cg, state, xScale, yScale);
      var dx = Math.round(c.dx * xScale);
      var dy = Math.round(c.dy * yScale);
      var gz = state.gZone;
      var cc = state.contours;
      for (var pi = 0; pi < gz.length; pi++) {
        var p = gz[pi];
        p.xTouched = p.yTouched = false;
        p.xo = p.x = p.x + dx;
        p.yo = p.y = p.y + dy;
      }
      var gLen = gZone.length;
      gZone.push.apply(gZone, gz);
      for (var j2 = 0; j2 < cc.length; j2++) {
        contours.push(cc[j2] + gLen);
      }
    }
    if (glyph.instructions && !state.inhibitGridFit) {
      state = new State("glyf", glyph.instructions);
      state.gZone = state.z0 = state.z1 = state.z2 = gZone;
      state.contours = contours;
      gZone.push(
        new HPoint(0, 0),
        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
      );
      if (exports.DEBUG) {
        console.log("---EXEC COMPOSITE---");
        state.step = -1;
      }
      exec(state);
      gZone.length -= 2;
    }
  }
  return gZone;
};
execComponent = function(glyph, state, xScale, yScale) {
  var points = glyph.points || [];
  var pLen = points.length;
  var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
  var contours = state.contours = [];
  var cp;
  for (var i2 = 0; i2 < pLen; i2++) {
    cp = points[i2];
    gZone[i2] = new HPoint(
      cp.x * xScale,
      cp.y * yScale,
      cp.lastPointOfContour,
      cp.onCurve
    );
  }
  var sp;
  var np;
  for (var i$1 = 0; i$1 < pLen; i$1++) {
    cp = gZone[i$1];
    if (!sp) {
      sp = cp;
      contours.push(i$1);
    }
    if (cp.lastPointOfContour) {
      cp.nextPointOnContour = sp;
      sp.prevPointOnContour = cp;
      sp = void 0;
    } else {
      np = gZone[i$1 + 1];
      cp.nextPointOnContour = np;
      np.prevPointOnContour = cp;
    }
  }
  if (state.inhibitGridFit) {
    return;
  }
  if (exports.DEBUG) {
    console.log("PROCESSING GLYPH", state.stack);
    for (var i$2 = 0; i$2 < pLen; i$2++) {
      console.log(i$2, gZone[i$2].x, gZone[i$2].y);
    }
  }
  gZone.push(
    new HPoint(0, 0),
    new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
  );
  exec(state);
  gZone.length -= 2;
  if (exports.DEBUG) {
    console.log("FINISHED GLYPH", state.stack);
    for (var i$3 = 0; i$3 < pLen; i$3++) {
      console.log(i$3, gZone[i$3].x, gZone[i$3].y);
    }
  }
};
exec = function(state) {
  var prog = state.prog;
  if (!prog) {
    return;
  }
  var pLen = prog.length;
  var ins;
  for (state.ip = 0; state.ip < pLen; state.ip++) {
    if (exports.DEBUG) {
      state.step++;
    }
    ins = instructionTable[prog[state.ip]];
    if (!ins) {
      throw new Error(
        "unknown instruction: 0x" + Number(prog[state.ip]).toString(16)
      );
    }
    ins(state);
  }
};
function initTZone(state) {
  var tZone = state.tZone = new Array(state.gZone.length);
  for (var i2 = 0; i2 < tZone.length; i2++) {
    tZone[i2] = new HPoint(0, 0);
  }
}
function skip(state, handleElse) {
  var prog = state.prog;
  var ip = state.ip;
  var nesting = 1;
  var ins;
  do {
    ins = prog[++ip];
    if (ins === 88) {
      nesting++;
    } else if (ins === 89) {
      nesting--;
    } else if (ins === 64) {
      ip += prog[ip + 1] + 1;
    } else if (ins === 65) {
      ip += 2 * prog[ip + 1] + 1;
    } else if (ins >= 176 && ins <= 183) {
      ip += ins - 176 + 1;
    } else if (ins >= 184 && ins <= 191) {
      ip += (ins - 184 + 1) * 2;
    } else if (handleElse && nesting === 1 && ins === 27) {
      break;
    }
  } while (nesting > 0);
  state.ip = ip;
}
function SVTCA(v, state) {
  if (exports.DEBUG) {
    console.log(state.step, "SVTCA[" + v.axis + "]");
  }
  state.fv = state.pv = state.dpv = v;
}
function SPVTCA(v, state) {
  if (exports.DEBUG) {
    console.log(state.step, "SPVTCA[" + v.axis + "]");
  }
  state.pv = state.dpv = v;
}
function SFVTCA(v, state) {
  if (exports.DEBUG) {
    console.log(state.step, "SFVTCA[" + v.axis + "]");
  }
  state.fv = v;
}
function SPVTL(a2, state) {
  var stack = state.stack;
  var p2i = stack.pop();
  var p1i = stack.pop();
  var p2 = state.z2[p2i];
  var p1 = state.z1[p1i];
  if (exports.DEBUG) {
    console.log("SPVTL[" + a2 + "]", p2i, p1i);
  }
  var dx;
  var dy;
  if (!a2) {
    dx = p1.x - p2.x;
    dy = p1.y - p2.y;
  } else {
    dx = p2.y - p1.y;
    dy = p1.x - p2.x;
  }
  state.pv = state.dpv = getUnitVector(dx, dy);
}
function SFVTL(a2, state) {
  var stack = state.stack;
  var p2i = stack.pop();
  var p1i = stack.pop();
  var p2 = state.z2[p2i];
  var p1 = state.z1[p1i];
  if (exports.DEBUG) {
    console.log("SFVTL[" + a2 + "]", p2i, p1i);
  }
  var dx;
  var dy;
  if (!a2) {
    dx = p1.x - p2.x;
    dy = p1.y - p2.y;
  } else {
    dx = p2.y - p1.y;
    dy = p1.x - p2.x;
  }
  state.fv = getUnitVector(dx, dy);
}
function SPVFS(state) {
  var stack = state.stack;
  var y = stack.pop();
  var x = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SPVFS[]", y, x);
  }
  state.pv = state.dpv = getUnitVector(x, y);
}
function SFVFS(state) {
  var stack = state.stack;
  var y = stack.pop();
  var x = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SPVFS[]", y, x);
  }
  state.fv = getUnitVector(x, y);
}
function GPV(state) {
  var stack = state.stack;
  var pv = state.pv;
  if (exports.DEBUG) {
    console.log(state.step, "GPV[]");
  }
  stack.push(pv.x * 16384);
  stack.push(pv.y * 16384);
}
function GFV(state) {
  var stack = state.stack;
  var fv = state.fv;
  if (exports.DEBUG) {
    console.log(state.step, "GFV[]");
  }
  stack.push(fv.x * 16384);
  stack.push(fv.y * 16384);
}
function SFVTPV(state) {
  state.fv = state.pv;
  if (exports.DEBUG) {
    console.log(state.step, "SFVTPV[]");
  }
}
function ISECT(state) {
  var stack = state.stack;
  var pa0i = stack.pop();
  var pa1i = stack.pop();
  var pb0i = stack.pop();
  var pb1i = stack.pop();
  var pi = stack.pop();
  var z0 = state.z0;
  var z1 = state.z1;
  var pa0 = z0[pa0i];
  var pa1 = z0[pa1i];
  var pb0 = z1[pb0i];
  var pb1 = z1[pb1i];
  var p = state.z2[pi];
  if (exports.DEBUG) {
    console.log("ISECT[], ", pa0i, pa1i, pb0i, pb1i, pi);
  }
  var x1 = pa0.x;
  var y1 = pa0.y;
  var x2 = pa1.x;
  var y2 = pa1.y;
  var x3 = pb0.x;
  var y3 = pb0.y;
  var x4 = pb1.x;
  var y4 = pb1.y;
  var div2 = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  var f1 = x1 * y2 - y1 * x2;
  var f2 = x3 * y4 - y3 * x4;
  p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div2;
  p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div2;
}
function SRP0(state) {
  state.rp0 = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SRP0[]", state.rp0);
  }
}
function SRP1(state) {
  state.rp1 = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SRP1[]", state.rp1);
  }
}
function SRP2(state) {
  state.rp2 = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SRP2[]", state.rp2);
  }
}
function SZP0(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZP0[]", n);
  }
  state.zp0 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z0 = state.tZone;
      break;
    case 1:
      state.z0 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SZP1(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZP1[]", n);
  }
  state.zp1 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z1 = state.tZone;
      break;
    case 1:
      state.z1 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SZP2(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZP2[]", n);
  }
  state.zp2 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z2 = state.tZone;
      break;
    case 1:
      state.z2 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SZPS(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZPS[]", n);
  }
  state.zp0 = state.zp1 = state.zp2 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z0 = state.z1 = state.z2 = state.tZone;
      break;
    case 1:
      state.z0 = state.z1 = state.z2 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SLOOP(state) {
  state.loop = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SLOOP[]", state.loop);
  }
}
function RTG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RTG[]");
  }
  state.round = roundToGrid;
}
function RTHG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RTHG[]");
  }
  state.round = roundToHalfGrid;
}
function SMD(state) {
  var d = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SMD[]", d);
  }
  state.minDis = d / 64;
}
function ELSE(state) {
  if (exports.DEBUG) {
    console.log(state.step, "ELSE[]");
  }
  skip(state, false);
}
function JMPR(state) {
  var o = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "JMPR[]", o);
  }
  state.ip += o - 1;
}
function SCVTCI(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SCVTCI[]", n);
  }
  state.cvCutIn = n / 64;
}
function DUP(state) {
  var stack = state.stack;
  if (exports.DEBUG) {
    console.log(state.step, "DUP[]");
  }
  stack.push(stack[stack.length - 1]);
}
function POP(state) {
  if (exports.DEBUG) {
    console.log(state.step, "POP[]");
  }
  state.stack.pop();
}
function CLEAR(state) {
  if (exports.DEBUG) {
    console.log(state.step, "CLEAR[]");
  }
  state.stack.length = 0;
}
function SWAP(state) {
  var stack = state.stack;
  var a2 = stack.pop();
  var b3 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SWAP[]");
  }
  stack.push(a2);
  stack.push(b3);
}
function DEPTH(state) {
  var stack = state.stack;
  if (exports.DEBUG) {
    console.log(state.step, "DEPTH[]");
  }
  stack.push(stack.length);
}
function LOOPCALL(state) {
  var stack = state.stack;
  var fn = stack.pop();
  var c = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "LOOPCALL[]", fn, c);
  }
  var cip = state.ip;
  var cprog = state.prog;
  state.prog = state.funcs[fn];
  for (var i2 = 0; i2 < c; i2++) {
    exec(state);
    if (exports.DEBUG) {
      console.log(
        ++state.step,
        i2 + 1 < c ? "next loopcall" : "done loopcall",
        i2
      );
    }
  }
  state.ip = cip;
  state.prog = cprog;
}
function CALL(state) {
  var fn = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "CALL[]", fn);
  }
  var cip = state.ip;
  var cprog = state.prog;
  state.prog = state.funcs[fn];
  exec(state);
  state.ip = cip;
  state.prog = cprog;
  if (exports.DEBUG) {
    console.log(++state.step, "returning from", fn);
  }
}
function CINDEX(state) {
  var stack = state.stack;
  var k = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "CINDEX[]", k);
  }
  stack.push(stack[stack.length - k]);
}
function MINDEX(state) {
  var stack = state.stack;
  var k = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MINDEX[]", k);
  }
  stack.push(stack.splice(stack.length - k, 1)[0]);
}
function FDEF(state) {
  if (state.env !== "fpgm") {
    throw new Error("FDEF not allowed here");
  }
  var stack = state.stack;
  var prog = state.prog;
  var ip = state.ip;
  var fn = stack.pop();
  var ipBegin = ip;
  if (exports.DEBUG) {
    console.log(state.step, "FDEF[]", fn);
  }
  while (prog[++ip] !== 45) {
  }
  state.ip = ip;
  state.funcs[fn] = prog.slice(ipBegin + 1, ip);
}
function MDAP(round2, state) {
  var pi = state.stack.pop();
  var p = state.z0[pi];
  var fv = state.fv;
  var pv = state.pv;
  if (exports.DEBUG) {
    console.log(state.step, "MDAP[" + round2 + "]", pi);
  }
  var d = pv.distance(p, HPZero);
  if (round2) {
    d = state.round(d);
  }
  fv.setRelative(p, HPZero, d, pv);
  fv.touch(p);
  state.rp0 = state.rp1 = pi;
}
function IUP(v, state) {
  var z2 = state.z2;
  var pLen = z2.length - 2;
  var cp;
  var pp;
  var np;
  if (exports.DEBUG) {
    console.log(state.step, "IUP[" + v.axis + "]");
  }
  for (var i2 = 0; i2 < pLen; i2++) {
    cp = z2[i2];
    if (v.touched(cp)) {
      continue;
    }
    pp = cp.prevTouched(v);
    if (pp === cp) {
      continue;
    }
    np = cp.nextTouched(v);
    if (pp === np) {
      v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
    }
    v.interpolate(cp, pp, np, v);
  }
}
function SHP(a2, state) {
  var stack = state.stack;
  var rpi = a2 ? state.rp1 : state.rp2;
  var rp = (a2 ? state.z0 : state.z1)[rpi];
  var fv = state.fv;
  var pv = state.pv;
  var loop = state.loop;
  var z2 = state.z2;
  while (loop--) {
    var pi = stack.pop();
    var p = z2[pi];
    var d = pv.distance(rp, rp, false, true);
    fv.setRelative(p, p, d, pv);
    fv.touch(p);
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "SHP[" + (a2 ? "rp1" : "rp2") + "]",
        pi
      );
    }
  }
  state.loop = 1;
}
function SHC(a2, state) {
  var stack = state.stack;
  var rpi = a2 ? state.rp1 : state.rp2;
  var rp = (a2 ? state.z0 : state.z1)[rpi];
  var fv = state.fv;
  var pv = state.pv;
  var ci = stack.pop();
  var sp = state.z2[state.contours[ci]];
  var p = sp;
  if (exports.DEBUG) {
    console.log(state.step, "SHC[" + a2 + "]", ci);
  }
  var d = pv.distance(rp, rp, false, true);
  do {
    if (p !== rp) {
      fv.setRelative(p, p, d, pv);
    }
    p = p.nextPointOnContour;
  } while (p !== sp);
}
function SHZ(a2, state) {
  var stack = state.stack;
  var rpi = a2 ? state.rp1 : state.rp2;
  var rp = (a2 ? state.z0 : state.z1)[rpi];
  var fv = state.fv;
  var pv = state.pv;
  var e = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SHZ[" + a2 + "]", e);
  }
  var z;
  switch (e) {
    case 0:
      z = state.tZone;
      break;
    case 1:
      z = state.gZone;
      break;
    default:
      throw new Error("Invalid zone");
  }
  var p;
  var d = pv.distance(rp, rp, false, true);
  var pLen = z.length - 2;
  for (var i2 = 0; i2 < pLen; i2++) {
    p = z[i2];
    fv.setRelative(p, p, d, pv);
  }
}
function SHPIX(state) {
  var stack = state.stack;
  var loop = state.loop;
  var fv = state.fv;
  var d = stack.pop() / 64;
  var z2 = state.z2;
  while (loop--) {
    var pi = stack.pop();
    var p = z2[pi];
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "SHPIX[]",
        pi,
        d
      );
    }
    fv.setRelative(p, p, d);
    fv.touch(p);
  }
  state.loop = 1;
}
function IP(state) {
  var stack = state.stack;
  var rp1i = state.rp1;
  var rp2i = state.rp2;
  var loop = state.loop;
  var rp1 = state.z0[rp1i];
  var rp2 = state.z1[rp2i];
  var fv = state.fv;
  var pv = state.dpv;
  var z2 = state.z2;
  while (loop--) {
    var pi = stack.pop();
    var p = z2[pi];
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "IP[]",
        pi,
        rp1i,
        "<->",
        rp2i
      );
    }
    fv.interpolate(p, rp1, rp2, pv);
    fv.touch(p);
  }
  state.loop = 1;
}
function MSIRP(a2, state) {
  var stack = state.stack;
  var d = stack.pop() / 64;
  var pi = stack.pop();
  var p = state.z1[pi];
  var rp0 = state.z0[state.rp0];
  var fv = state.fv;
  var pv = state.pv;
  fv.setRelative(p, rp0, d, pv);
  fv.touch(p);
  if (exports.DEBUG) {
    console.log(state.step, "MSIRP[" + a2 + "]", d, pi);
  }
  state.rp1 = state.rp0;
  state.rp2 = pi;
  if (a2) {
    state.rp0 = pi;
  }
}
function ALIGNRP(state) {
  var stack = state.stack;
  var rp0i = state.rp0;
  var rp0 = state.z0[rp0i];
  var loop = state.loop;
  var fv = state.fv;
  var pv = state.pv;
  var z1 = state.z1;
  while (loop--) {
    var pi = stack.pop();
    var p = z1[pi];
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "ALIGNRP[]",
        pi
      );
    }
    fv.setRelative(p, rp0, 0, pv);
    fv.touch(p);
  }
  state.loop = 1;
}
function RTDG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RTDG[]");
  }
  state.round = roundToDoubleGrid;
}
function MIAP(round2, state) {
  var stack = state.stack;
  var n = stack.pop();
  var pi = stack.pop();
  var p = state.z0[pi];
  var fv = state.fv;
  var pv = state.pv;
  var cv = state.cvt[n];
  if (exports.DEBUG) {
    console.log(
      state.step,
      "MIAP[" + round2 + "]",
      n,
      "(",
      cv,
      ")",
      pi
    );
  }
  var d = pv.distance(p, HPZero);
  if (round2) {
    if (Math.abs(d - cv) < state.cvCutIn) {
      d = cv;
    }
    d = state.round(d);
  }
  fv.setRelative(p, HPZero, d, pv);
  if (state.zp0 === 0) {
    p.xo = p.x;
    p.yo = p.y;
  }
  fv.touch(p);
  state.rp0 = state.rp1 = pi;
}
function NPUSHB(state) {
  var prog = state.prog;
  var ip = state.ip;
  var stack = state.stack;
  var n = prog[++ip];
  if (exports.DEBUG) {
    console.log(state.step, "NPUSHB[]", n);
  }
  for (var i2 = 0; i2 < n; i2++) {
    stack.push(prog[++ip]);
  }
  state.ip = ip;
}
function NPUSHW(state) {
  var ip = state.ip;
  var prog = state.prog;
  var stack = state.stack;
  var n = prog[++ip];
  if (exports.DEBUG) {
    console.log(state.step, "NPUSHW[]", n);
  }
  for (var i2 = 0; i2 < n; i2++) {
    var w = prog[++ip] << 8 | prog[++ip];
    if (w & 32768) {
      w = -((w ^ 65535) + 1);
    }
    stack.push(w);
  }
  state.ip = ip;
}
function WS(state) {
  var stack = state.stack;
  var store = state.store;
  if (!store) {
    store = state.store = [];
  }
  var v = stack.pop();
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "WS", v, l);
  }
  store[l] = v;
}
function RS(state) {
  var stack = state.stack;
  var store = state.store;
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "RS", l);
  }
  var v = store && store[l] || 0;
  stack.push(v);
}
function WCVTP(state) {
  var stack = state.stack;
  var v = stack.pop();
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "WCVTP", v, l);
  }
  state.cvt[l] = v / 64;
}
function RCVT(state) {
  var stack = state.stack;
  var cvte = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "RCVT", cvte);
  }
  stack.push(state.cvt[cvte] * 64);
}
function GC(a2, state) {
  var stack = state.stack;
  var pi = stack.pop();
  var p = state.z2[pi];
  if (exports.DEBUG) {
    console.log(state.step, "GC[" + a2 + "]", pi);
  }
  stack.push(state.dpv.distance(p, HPZero, a2, false) * 64);
}
function MD(a2, state) {
  var stack = state.stack;
  var pi2 = stack.pop();
  var pi1 = stack.pop();
  var p2 = state.z1[pi2];
  var p1 = state.z0[pi1];
  var d = state.dpv.distance(p1, p2, a2, a2);
  if (exports.DEBUG) {
    console.log(state.step, "MD[" + a2 + "]", pi2, pi1, "->", d);
  }
  state.stack.push(Math.round(d * 64));
}
function MPPEM(state) {
  if (exports.DEBUG) {
    console.log(state.step, "MPPEM[]");
  }
  state.stack.push(state.ppem);
}
function FLIPON(state) {
  if (exports.DEBUG) {
    console.log(state.step, "FLIPON[]");
  }
  state.autoFlip = true;
}
function LT(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "LT[]", e2, e1);
  }
  stack.push(e1 < e2 ? 1 : 0);
}
function LTEQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "LTEQ[]", e2, e1);
  }
  stack.push(e1 <= e2 ? 1 : 0);
}
function GT(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "GT[]", e2, e1);
  }
  stack.push(e1 > e2 ? 1 : 0);
}
function GTEQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "GTEQ[]", e2, e1);
  }
  stack.push(e1 >= e2 ? 1 : 0);
}
function EQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "EQ[]", e2, e1);
  }
  stack.push(e2 === e1 ? 1 : 0);
}
function NEQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "NEQ[]", e2, e1);
  }
  stack.push(e2 !== e1 ? 1 : 0);
}
function ODD(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ODD[]", n);
  }
  stack.push(Math.trunc(n) % 2 ? 1 : 0);
}
function EVEN(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "EVEN[]", n);
  }
  stack.push(Math.trunc(n) % 2 ? 0 : 1);
}
function IF(state) {
  var test = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "IF[]", test);
  }
  if (!test) {
    skip(state, true);
    if (exports.DEBUG) {
      console.log(state.step, "EIF[]");
    }
  }
}
function EIF(state) {
  if (exports.DEBUG) {
    console.log(state.step, "EIF[]");
  }
}
function AND(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "AND[]", e2, e1);
  }
  stack.push(e2 && e1 ? 1 : 0);
}
function OR(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "OR[]", e2, e1);
  }
  stack.push(e2 || e1 ? 1 : 0);
}
function NOT(state) {
  var stack = state.stack;
  var e = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "NOT[]", e);
  }
  stack.push(e ? 0 : 1);
}
function DELTAP123(b3, state) {
  var stack = state.stack;
  var n = stack.pop();
  var fv = state.fv;
  var pv = state.pv;
  var ppem = state.ppem;
  var base = state.deltaBase + (b3 - 1) * 16;
  var ds = state.deltaShift;
  var z0 = state.z0;
  if (exports.DEBUG) {
    console.log(state.step, "DELTAP[" + b3 + "]", n, stack);
  }
  for (var i2 = 0; i2 < n; i2++) {
    var pi = stack.pop();
    var arg = stack.pop();
    var appem = base + ((arg & 240) >> 4);
    if (appem !== ppem) {
      continue;
    }
    var mag = (arg & 15) - 8;
    if (mag >= 0) {
      mag++;
    }
    if (exports.DEBUG) {
      console.log(state.step, "DELTAPFIX", pi, "by", mag * ds);
    }
    var p = z0[pi];
    fv.setRelative(p, p, mag * ds, pv);
  }
}
function SDB(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SDB[]", n);
  }
  state.deltaBase = n;
}
function SDS(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SDS[]", n);
  }
  state.deltaShift = Math.pow(0.5, n);
}
function ADD(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ADD[]", n2, n1);
  }
  stack.push(n1 + n2);
}
function SUB(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SUB[]", n2, n1);
  }
  stack.push(n1 - n2);
}
function DIV(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "DIV[]", n2, n1);
  }
  stack.push(n1 * 64 / n2);
}
function MUL(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MUL[]", n2, n1);
  }
  stack.push(n1 * n2 / 64);
}
function ABS(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ABS[]", n);
  }
  stack.push(Math.abs(n));
}
function NEG(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "NEG[]", n);
  }
  stack.push(-n);
}
function FLOOR(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "FLOOR[]", n);
  }
  stack.push(Math.floor(n / 64) * 64);
}
function CEILING(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "CEILING[]", n);
  }
  stack.push(Math.ceil(n / 64) * 64);
}
function ROUND(dt, state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ROUND[]");
  }
  stack.push(state.round(n / 64) * 64);
}
function WCVTF(state) {
  var stack = state.stack;
  var v = stack.pop();
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "WCVTF[]", v, l);
  }
  state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
}
function DELTAC123(b3, state) {
  var stack = state.stack;
  var n = stack.pop();
  var ppem = state.ppem;
  var base = state.deltaBase + (b3 - 1) * 16;
  var ds = state.deltaShift;
  if (exports.DEBUG) {
    console.log(state.step, "DELTAC[" + b3 + "]", n, stack);
  }
  for (var i2 = 0; i2 < n; i2++) {
    var c = stack.pop();
    var arg = stack.pop();
    var appem = base + ((arg & 240) >> 4);
    if (appem !== ppem) {
      continue;
    }
    var mag = (arg & 15) - 8;
    if (mag >= 0) {
      mag++;
    }
    var delta = mag * ds;
    if (exports.DEBUG) {
      console.log(state.step, "DELTACFIX", c, "by", delta);
    }
    state.cvt[c] += delta;
  }
}
function SROUND(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SROUND[]", n);
  }
  state.round = roundSuper;
  var period;
  switch (n & 192) {
    case 0:
      period = 0.5;
      break;
    case 64:
      period = 1;
      break;
    case 128:
      period = 2;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  state.srPeriod = period;
  switch (n & 48) {
    case 0:
      state.srPhase = 0;
      break;
    case 16:
      state.srPhase = 0.25 * period;
      break;
    case 32:
      state.srPhase = 0.5 * period;
      break;
    case 48:
      state.srPhase = 0.75 * period;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  n &= 15;
  if (n === 0) {
    state.srThreshold = 0;
  } else {
    state.srThreshold = (n / 8 - 0.5) * period;
  }
}
function S45ROUND(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "S45ROUND[]", n);
  }
  state.round = roundSuper;
  var period;
  switch (n & 192) {
    case 0:
      period = Math.sqrt(2) / 2;
      break;
    case 64:
      period = Math.sqrt(2);
      break;
    case 128:
      period = 2 * Math.sqrt(2);
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  state.srPeriod = period;
  switch (n & 48) {
    case 0:
      state.srPhase = 0;
      break;
    case 16:
      state.srPhase = 0.25 * period;
      break;
    case 32:
      state.srPhase = 0.5 * period;
      break;
    case 48:
      state.srPhase = 0.75 * period;
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  n &= 15;
  if (n === 0) {
    state.srThreshold = 0;
  } else {
    state.srThreshold = (n / 8 - 0.5) * period;
  }
}
function ROFF(state) {
  if (exports.DEBUG) {
    console.log(state.step, "ROFF[]");
  }
  state.round = roundOff;
}
function RUTG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RUTG[]");
  }
  state.round = roundUpToGrid;
}
function RDTG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RDTG[]");
  }
  state.round = roundDownToGrid;
}
function SCANCTRL(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SCANCTRL[]", n);
  }
}
function SDPVTL(a2, state) {
  var stack = state.stack;
  var p2i = stack.pop();
  var p1i = stack.pop();
  var p2 = state.z2[p2i];
  var p1 = state.z1[p1i];
  if (exports.DEBUG) {
    console.log(state.step, "SDPVTL[" + a2 + "]", p2i, p1i);
  }
  var dx;
  var dy;
  if (!a2) {
    dx = p1.x - p2.x;
    dy = p1.y - p2.y;
  } else {
    dx = p2.y - p1.y;
    dy = p1.x - p2.x;
  }
  state.dpv = getUnitVector(dx, dy);
}
function GETINFO(state) {
  var stack = state.stack;
  var sel = stack.pop();
  var r = 0;
  if (exports.DEBUG) {
    console.log(state.step, "GETINFO[]", sel);
  }
  if (sel & 1) {
    r = 35;
  }
  if (sel & 32) {
    r |= 4096;
  }
  stack.push(r);
}
function ROLL(state) {
  var stack = state.stack;
  var a2 = stack.pop();
  var b3 = stack.pop();
  var c = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ROLL[]");
  }
  stack.push(b3);
  stack.push(a2);
  stack.push(c);
}
function MAX(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MAX[]", e2, e1);
  }
  stack.push(Math.max(e1, e2));
}
function MIN(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MIN[]", e2, e1);
  }
  stack.push(Math.min(e1, e2));
}
function SCANTYPE(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SCANTYPE[]", n);
  }
}
function INSTCTRL(state) {
  var s = state.stack.pop();
  var v = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "INSTCTRL[]", s, v);
  }
  switch (s) {
    case 1:
      state.inhibitGridFit = !!v;
      return;
    case 2:
      state.ignoreCvt = !!v;
      return;
    default:
      throw new Error("invalid INSTCTRL[] selector");
  }
}
function PUSHB(n, state) {
  var stack = state.stack;
  var prog = state.prog;
  var ip = state.ip;
  if (exports.DEBUG) {
    console.log(state.step, "PUSHB[" + n + "]");
  }
  for (var i2 = 0; i2 < n; i2++) {
    stack.push(prog[++ip]);
  }
  state.ip = ip;
}
function PUSHW(n, state) {
  var ip = state.ip;
  var prog = state.prog;
  var stack = state.stack;
  if (exports.DEBUG) {
    console.log(state.ip, "PUSHW[" + n + "]");
  }
  for (var i2 = 0; i2 < n; i2++) {
    var w = prog[++ip] << 8 | prog[++ip];
    if (w & 32768) {
      w = -((w ^ 65535) + 1);
    }
    stack.push(w);
  }
  state.ip = ip;
}
function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
  var stack = state.stack;
  var cvte = indirect && stack.pop();
  var pi = stack.pop();
  var rp0i = state.rp0;
  var rp = state.z0[rp0i];
  var p = state.z1[pi];
  var md = state.minDis;
  var fv = state.fv;
  var pv = state.dpv;
  var od;
  var d;
  var sign2;
  var cv;
  d = od = pv.distance(p, rp, true, true);
  sign2 = d >= 0 ? 1 : -1;
  d = Math.abs(d);
  if (indirect) {
    cv = state.cvt[cvte];
    if (ro && Math.abs(d - cv) < state.cvCutIn) {
      d = cv;
    }
  }
  if (keepD && d < md) {
    d = md;
  }
  if (ro) {
    d = state.round(d);
  }
  fv.setRelative(p, rp, sign2 * d, pv);
  fv.touch(p);
  if (exports.DEBUG) {
    console.log(
      state.step,
      (indirect ? "MIRP[" : "MDRP[") + (setRp0 ? "M" : "m") + (keepD ? ">" : "_") + (ro ? "R" : "_") + (dt === 0 ? "Gr" : dt === 1 ? "Bl" : dt === 2 ? "Wh" : "") + "]",
      indirect ? cvte + "(" + state.cvt[cvte] + "," + cv + ")" : "",
      pi,
      "(d =",
      od,
      "->",
      sign2 * d,
      ")"
    );
  }
  state.rp1 = state.rp0;
  state.rp2 = pi;
  if (setRp0) {
    state.rp0 = pi;
  }
}
instructionTable = [
  SVTCA.bind(void 0, yUnitVector),
  SVTCA.bind(void 0, xUnitVector),
  SPVTCA.bind(void 0, yUnitVector),
  SPVTCA.bind(void 0, xUnitVector),
  SFVTCA.bind(void 0, yUnitVector),
  SFVTCA.bind(void 0, xUnitVector),
  SPVTL.bind(void 0, 0),
  SPVTL.bind(void 0, 1),
  SFVTL.bind(void 0, 0),
  SFVTL.bind(void 0, 1),
  SPVFS,
  SFVFS,
  GPV,
  GFV,
  SFVTPV,
  ISECT,
  SRP0,
  SRP1,
  SRP2,
  SZP0,
  SZP1,
  SZP2,
  SZPS,
  SLOOP,
  RTG,
  RTHG,
  SMD,
  ELSE,
  JMPR,
  SCVTCI,
  void 0,
  void 0,
  DUP,
  POP,
  CLEAR,
  SWAP,
  DEPTH,
  CINDEX,
  MINDEX,
  void 0,
  void 0,
  void 0,
  LOOPCALL,
  CALL,
  FDEF,
  void 0,
  MDAP.bind(void 0, 0),
  MDAP.bind(void 0, 1),
  IUP.bind(void 0, yUnitVector),
  IUP.bind(void 0, xUnitVector),
  SHP.bind(void 0, 0),
  SHP.bind(void 0, 1),
  SHC.bind(void 0, 0),
  SHC.bind(void 0, 1),
  SHZ.bind(void 0, 0),
  SHZ.bind(void 0, 1),
  SHPIX,
  IP,
  MSIRP.bind(void 0, 0),
  MSIRP.bind(void 0, 1),
  ALIGNRP,
  RTDG,
  MIAP.bind(void 0, 0),
  MIAP.bind(void 0, 1),
  NPUSHB,
  NPUSHW,
  WS,
  RS,
  WCVTP,
  RCVT,
  GC.bind(void 0, 0),
  GC.bind(void 0, 1),
  void 0,
  MD.bind(void 0, 0),
  MD.bind(void 0, 1),
  MPPEM,
  void 0,
  FLIPON,
  void 0,
  void 0,
  LT,
  LTEQ,
  GT,
  GTEQ,
  EQ,
  NEQ,
  ODD,
  EVEN,
  IF,
  EIF,
  AND,
  OR,
  NOT,
  DELTAP123.bind(void 0, 1),
  SDB,
  SDS,
  ADD,
  SUB,
  DIV,
  MUL,
  ABS,
  NEG,
  FLOOR,
  CEILING,
  ROUND.bind(void 0, 0),
  ROUND.bind(void 0, 1),
  ROUND.bind(void 0, 2),
  ROUND.bind(void 0, 3),
  void 0,
  void 0,
  void 0,
  void 0,
  WCVTF,
  DELTAP123.bind(void 0, 2),
  DELTAP123.bind(void 0, 3),
  DELTAC123.bind(void 0, 1),
  DELTAC123.bind(void 0, 2),
  DELTAC123.bind(void 0, 3),
  SROUND,
  S45ROUND,
  void 0,
  void 0,
  ROFF,
  void 0,
  RUTG,
  RDTG,
  POP,
  POP,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  SCANCTRL,
  SDPVTL.bind(void 0, 0),
  SDPVTL.bind(void 0, 1),
  GETINFO,
  void 0,
  ROLL,
  MAX,
  MIN,
  SCANTYPE,
  INSTCTRL,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  PUSHB.bind(void 0, 1),
  PUSHB.bind(void 0, 2),
  PUSHB.bind(void 0, 3),
  PUSHB.bind(void 0, 4),
  PUSHB.bind(void 0, 5),
  PUSHB.bind(void 0, 6),
  PUSHB.bind(void 0, 7),
  PUSHB.bind(void 0, 8),
  PUSHW.bind(void 0, 1),
  PUSHW.bind(void 0, 2),
  PUSHW.bind(void 0, 3),
  PUSHW.bind(void 0, 4),
  PUSHW.bind(void 0, 5),
  PUSHW.bind(void 0, 6),
  PUSHW.bind(void 0, 7),
  PUSHW.bind(void 0, 8),
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 0),
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 1),
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 2),
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 3),
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 0),
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 1),
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 2),
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 3),
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 0),
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 1),
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 2),
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 3),
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 0),
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 1),
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 2),
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 3),
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 0),
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 1),
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 2),
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 3),
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 0),
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 1),
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 2),
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 3),
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 0),
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 1),
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 2),
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 3),
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 0),
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 1),
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 2),
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 3),
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 0),
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 1),
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 2),
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 3),
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 0),
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 1),
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 2),
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 3),
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 0),
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 1),
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 2),
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 3),
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 0),
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 1),
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 2),
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 3),
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 0),
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 1),
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 2),
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 3),
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 0),
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 1),
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 2),
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 3),
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 0),
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 1),
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 2),
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 3),
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 0),
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 1),
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 2),
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 3)
];
function Token(char) {
  this.char = char;
  this.state = {};
  this.activeState = null;
}
function ContextRange(startIndex, endOffset, contextName) {
  this.contextName = contextName;
  this.startIndex = startIndex;
  this.endOffset = endOffset;
}
function ContextChecker(contextName, checkStart, checkEnd) {
  this.contextName = contextName;
  this.openRange = null;
  this.ranges = [];
  this.checkStart = checkStart;
  this.checkEnd = checkEnd;
}
function ContextParams(context, currentIndex) {
  this.context = context;
  this.index = currentIndex;
  this.length = context.length;
  this.current = context[currentIndex];
  this.backtrack = context.slice(0, currentIndex);
  this.lookahead = context.slice(currentIndex + 1);
}
function Event(eventId) {
  this.eventId = eventId;
  this.subscribers = [];
}
function initializeCoreEvents(events) {
  var this$1 = this;
  var coreEvents = [
    "start",
    "end",
    "next",
    "newToken",
    "contextStart",
    "contextEnd",
    "insertToken",
    "removeToken",
    "removeRange",
    "replaceToken",
    "replaceRange",
    "composeRUD",
    "updateContextsRanges"
  ];
  coreEvents.forEach(function(eventId) {
    Object.defineProperty(this$1.events, eventId, {
      value: new Event(eventId)
    });
  });
  if (!!events) {
    coreEvents.forEach(function(eventId) {
      var event = events[eventId];
      if (typeof event === "function") {
        this$1.events[eventId].subscribe(event);
      }
    });
  }
  var requiresContextUpdate = [
    "insertToken",
    "removeToken",
    "removeRange",
    "replaceToken",
    "replaceRange",
    "composeRUD"
  ];
  requiresContextUpdate.forEach(function(eventId) {
    this$1.events[eventId].subscribe(
      this$1.updateContextsRanges
    );
  });
}
function Tokenizer(events) {
  this.tokens = [];
  this.registeredContexts = {};
  this.contextCheckers = [];
  this.events = {};
  this.registeredModifiers = [];
  initializeCoreEvents.call(this, events);
}
Token.prototype.setState = function(key, value) {
  this.state[key] = value;
  this.activeState = { key, value: this.state[key] };
  return this.activeState;
};
Token.prototype.getState = function(stateId) {
  return this.state[stateId] || null;
};
Tokenizer.prototype.inboundIndex = function(index) {
  return index >= 0 && index < this.tokens.length;
};
Tokenizer.prototype.composeRUD = function(RUDs) {
  var this$1 = this;
  var silent = true;
  var state = RUDs.map(function(RUD) {
    return this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent));
  });
  var hasFAILObject = function(obj) {
    return typeof obj === "object" && obj.hasOwnProperty("FAIL");
  };
  if (state.every(hasFAILObject)) {
    return {
      FAIL: "composeRUD: one or more operations hasn't completed successfully",
      report: state.filter(hasFAILObject)
    };
  }
  this.dispatch("composeRUD", [state.filter(function(op) {
    return !hasFAILObject(op);
  })]);
};
Tokenizer.prototype.replaceRange = function(startIndex, offset, tokens, silent) {
  offset = offset !== null ? offset : this.tokens.length;
  var isTokenType = tokens.every(function(token) {
    return token instanceof Token;
  });
  if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {
    var replaced = this.tokens.splice.apply(
      this.tokens,
      [startIndex, offset].concat(tokens)
    );
    if (!silent) {
      this.dispatch("replaceToken", [startIndex, offset, tokens]);
    }
    return [replaced, tokens];
  } else {
    return { FAIL: "replaceRange: invalid tokens or startIndex." };
  }
};
Tokenizer.prototype.replaceToken = function(index, token, silent) {
  if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {
    var replaced = this.tokens.splice(index, 1, token);
    if (!silent) {
      this.dispatch("replaceToken", [index, token]);
    }
    return [replaced[0], token];
  } else {
    return { FAIL: "replaceToken: invalid token or index." };
  }
};
Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {
  offset = !isNaN(offset) ? offset : this.tokens.length;
  var tokens = this.tokens.splice(startIndex, offset);
  if (!silent) {
    this.dispatch("removeRange", [tokens, startIndex, offset]);
  }
  return tokens;
};
Tokenizer.prototype.removeToken = function(index, silent) {
  if (!isNaN(index) && this.inboundIndex(index)) {
    var token = this.tokens.splice(index, 1);
    if (!silent) {
      this.dispatch("removeToken", [token, index]);
    }
    return token;
  } else {
    return { FAIL: "removeToken: invalid token index." };
  }
};
Tokenizer.prototype.insertToken = function(tokens, index, silent) {
  var tokenType = tokens.every(
    function(token) {
      return token instanceof Token;
    }
  );
  if (tokenType) {
    this.tokens.splice.apply(
      this.tokens,
      [index, 0].concat(tokens)
    );
    if (!silent) {
      this.dispatch("insertToken", [tokens, index]);
    }
    return tokens;
  } else {
    return { FAIL: "insertToken: invalid token(s)." };
  }
};
Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {
  this.events.newToken.subscribe(function(token, contextParams) {
    var conditionParams = [token, contextParams];
    var canApplyModifier = condition === null || condition.apply(this, conditionParams) === true;
    var modifierParams = [token, contextParams];
    if (canApplyModifier) {
      var newStateValue = modifier.apply(this, modifierParams);
      token.setState(modifierId, newStateValue);
    }
  });
  this.registeredModifiers.push(modifierId);
};
Event.prototype.subscribe = function(eventHandler) {
  if (typeof eventHandler === "function") {
    return this.subscribers.push(eventHandler) - 1;
  } else {
    return { FAIL: "invalid '" + this.eventId + "' event handler" };
  }
};
Event.prototype.unsubscribe = function(subsId) {
  this.subscribers.splice(subsId, 1);
};
ContextParams.prototype.setCurrentIndex = function(index) {
  this.index = index;
  this.current = this.context[index];
  this.backtrack = this.context.slice(0, index);
  this.lookahead = this.context.slice(index + 1);
};
ContextParams.prototype.get = function(offset) {
  switch (true) {
    case offset === 0:
      return this.current;
    case (offset < 0 && Math.abs(offset) <= this.backtrack.length):
      return this.backtrack.slice(offset)[0];
    case (offset > 0 && offset <= this.lookahead.length):
      return this.lookahead[offset - 1];
    default:
      return null;
  }
};
Tokenizer.prototype.rangeToText = function(range) {
  if (range instanceof ContextRange) {
    return this.getRangeTokens(range).map(function(token) {
      return token.char;
    }).join("");
  }
};
Tokenizer.prototype.getText = function() {
  return this.tokens.map(function(token) {
    return token.char;
  }).join("");
};
Tokenizer.prototype.getContext = function(contextName) {
  var context = this.registeredContexts[contextName];
  return !!context ? context : null;
};
Tokenizer.prototype.on = function(eventName, eventHandler) {
  var event = this.events[eventName];
  if (!!event) {
    return event.subscribe(eventHandler);
  } else {
    return null;
  }
};
Tokenizer.prototype.dispatch = function(eventName, args) {
  var this$1 = this;
  var event = this.events[eventName];
  if (event instanceof Event) {
    event.subscribers.forEach(function(subscriber) {
      subscriber.apply(this$1, args || []);
    });
  }
};
Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {
  if (!!this.getContext(contextName)) {
    return {
      FAIL: "context name '" + contextName + "' is already registered."
    };
  }
  if (typeof contextStartCheck !== "function") {
    return {
      FAIL: "missing context start check."
    };
  }
  if (typeof contextEndCheck !== "function") {
    return {
      FAIL: "missing context end check."
    };
  }
  var contextCheckers = new ContextChecker(
    contextName,
    contextStartCheck,
    contextEndCheck
  );
  this.registeredContexts[contextName] = contextCheckers;
  this.contextCheckers.push(contextCheckers);
  return contextCheckers;
};
Tokenizer.prototype.getRangeTokens = function(range) {
  var endIndex = range.startIndex + range.endOffset;
  return [].concat(
    this.tokens.slice(range.startIndex, endIndex)
  );
};
Tokenizer.prototype.getContextRanges = function(contextName) {
  var context = this.getContext(contextName);
  if (!!context) {
    return context.ranges;
  } else {
    return { FAIL: "context checker '" + contextName + "' is not registered." };
  }
};
Tokenizer.prototype.resetContextsRanges = function() {
  var registeredContexts = this.registeredContexts;
  for (var contextName in registeredContexts) {
    if (registeredContexts.hasOwnProperty(contextName)) {
      var context = registeredContexts[contextName];
      context.ranges = [];
    }
  }
};
Tokenizer.prototype.updateContextsRanges = function() {
  this.resetContextsRanges();
  var chars = this.tokens.map(function(token) {
    return token.char;
  });
  for (var i2 = 0; i2 < chars.length; i2++) {
    var contextParams = new ContextParams(chars, i2);
    this.runContextCheck(contextParams);
  }
  this.dispatch("updateContextsRanges", [this.registeredContexts]);
};
Tokenizer.prototype.setEndOffset = function(offset, contextName) {
  var startIndex = this.getContext(contextName).openRange.startIndex;
  var range = new ContextRange(startIndex, offset, contextName);
  var ranges = this.getContext(contextName).ranges;
  range.rangeId = contextName + "." + ranges.length;
  ranges.push(range);
  this.getContext(contextName).openRange = null;
  return range;
};
Tokenizer.prototype.runContextCheck = function(contextParams) {
  var this$1 = this;
  var index = contextParams.index;
  this.contextCheckers.forEach(function(contextChecker) {
    var contextName = contextChecker.contextName;
    var openRange = this$1.getContext(contextName).openRange;
    if (!openRange && contextChecker.checkStart(contextParams)) {
      openRange = new ContextRange(index, null, contextName);
      this$1.getContext(contextName).openRange = openRange;
      this$1.dispatch("contextStart", [contextName, index]);
    }
    if (!!openRange && contextChecker.checkEnd(contextParams)) {
      var offset = index - openRange.startIndex + 1;
      var range = this$1.setEndOffset(offset, contextName);
      this$1.dispatch("contextEnd", [contextName, range]);
    }
  });
};
Tokenizer.prototype.tokenize = function(text) {
  this.tokens = [];
  this.resetContextsRanges();
  var chars = Array.from(text);
  this.dispatch("start");
  for (var i2 = 0; i2 < chars.length; i2++) {
    var char = chars[i2];
    var contextParams = new ContextParams(chars, i2);
    this.dispatch("next", [contextParams]);
    this.runContextCheck(contextParams);
    var token = new Token(char);
    this.tokens.push(token);
    this.dispatch("newToken", [token, contextParams]);
  }
  this.dispatch("end", [this.tokens]);
  return this.tokens;
};
function isArabicChar(c) {
  return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(c);
}
function isIsolatedArabicChar(char) {
  return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(char);
}
function isTashkeelArabicChar(char) {
  return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(char);
}
function isLatinChar(c) {
  return /[A-z]/.test(c);
}
function isWhiteSpace(c) {
  return /\s/.test(c);
}
function FeatureQuery(font) {
  this.font = font;
  this.features = {};
}
function SubstitutionAction(action) {
  this.id = action.id;
  this.tag = action.tag;
  this.substitution = action.substitution;
}
function lookupCoverage(glyphIndex, coverage) {
  if (!glyphIndex) {
    return -1;
  }
  switch (coverage.format) {
    case 1:
      return coverage.glyphs.indexOf(glyphIndex);
    case 2:
      var ranges = coverage.ranges;
      for (var i2 = 0; i2 < ranges.length; i2++) {
        var range = ranges[i2];
        if (glyphIndex >= range.start && glyphIndex <= range.end) {
          var offset = glyphIndex - range.start;
          return range.index + offset;
        }
      }
      break;
    default:
      return -1;
  }
  return -1;
}
function singleSubstitutionFormat1(glyphIndex, subtable) {
  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (substituteIndex === -1) {
    return null;
  }
  return glyphIndex + subtable.deltaGlyphId;
}
function singleSubstitutionFormat2(glyphIndex, subtable) {
  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (substituteIndex === -1) {
    return null;
  }
  return subtable.substitute[substituteIndex];
}
function lookupCoverageList(coverageList, contextParams) {
  var lookupList = [];
  for (var i2 = 0; i2 < coverageList.length; i2++) {
    var coverage = coverageList[i2];
    var glyphIndex = contextParams.current;
    glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
    var lookupIndex = lookupCoverage(glyphIndex, coverage);
    if (lookupIndex !== -1) {
      lookupList.push(lookupIndex);
    }
  }
  if (lookupList.length !== coverageList.length) {
    return -1;
  }
  return lookupList;
}
function chainingSubstitutionFormat3(contextParams, subtable) {
  var lookupsCount = subtable.inputCoverage.length + subtable.lookaheadCoverage.length + subtable.backtrackCoverage.length;
  if (contextParams.context.length < lookupsCount) {
    return [];
  }
  var inputLookups = lookupCoverageList(
    subtable.inputCoverage,
    contextParams
  );
  if (inputLookups === -1) {
    return [];
  }
  var lookaheadOffset = subtable.inputCoverage.length - 1;
  if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) {
    return [];
  }
  var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);
  while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {
    lookaheadContext.shift();
  }
  var lookaheadParams = new ContextParams(lookaheadContext, 0);
  var lookaheadLookups = lookupCoverageList(
    subtable.lookaheadCoverage,
    lookaheadParams
  );
  var backtrackContext = [].concat(contextParams.backtrack);
  backtrackContext.reverse();
  while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {
    backtrackContext.shift();
  }
  if (backtrackContext.length < subtable.backtrackCoverage.length) {
    return [];
  }
  var backtrackParams = new ContextParams(backtrackContext, 0);
  var backtrackLookups = lookupCoverageList(
    subtable.backtrackCoverage,
    backtrackParams
  );
  var contextRulesMatch = inputLookups.length === subtable.inputCoverage.length && lookaheadLookups.length === subtable.lookaheadCoverage.length && backtrackLookups.length === subtable.backtrackCoverage.length;
  var substitutions = [];
  if (contextRulesMatch) {
    for (var i2 = 0; i2 < subtable.lookupRecords.length; i2++) {
      var lookupRecord = subtable.lookupRecords[i2];
      var lookupListIndex = lookupRecord.lookupListIndex;
      var lookupTable = this.getLookupByIndex(lookupListIndex);
      for (var s = 0; s < lookupTable.subtables.length; s++) {
        var subtable$1 = lookupTable.subtables[s];
        var lookup = this.getLookupMethod(lookupTable, subtable$1);
        var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);
        if (substitutionType === "12") {
          for (var n = 0; n < inputLookups.length; n++) {
            var glyphIndex = contextParams.get(n);
            var substitution = lookup(glyphIndex);
            if (substitution) {
              substitutions.push(substitution);
            }
          }
        }
      }
    }
  }
  return substitutions;
}
function ligatureSubstitutionFormat1(contextParams, subtable) {
  var glyphIndex = contextParams.current;
  var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (ligSetIndex === -1) {
    return null;
  }
  var ligature;
  var ligatureSet = subtable.ligatureSets[ligSetIndex];
  for (var s = 0; s < ligatureSet.length; s++) {
    ligature = ligatureSet[s];
    for (var l = 0; l < ligature.components.length; l++) {
      var lookaheadItem = contextParams.lookahead[l];
      var component = ligature.components[l];
      if (lookaheadItem !== component) {
        break;
      }
      if (l === ligature.components.length - 1) {
        return ligature;
      }
    }
  }
  return null;
}
function decompositionSubstitutionFormat1(glyphIndex, subtable) {
  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (substituteIndex === -1) {
    return null;
  }
  return subtable.sequences[substituteIndex];
}
FeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function() {
  var scripts = this.font.tables.gsub.scripts;
  for (var s = 0; s < scripts.length; s++) {
    var script = scripts[s];
    if (script.tag === "DFLT") {
      return script.script.defaultLangSys.featureIndexes;
    }
  }
  return [];
};
FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {
  var tables = this.font.tables;
  if (!tables.gsub) {
    return [];
  }
  if (!scriptTag) {
    return this.getDefaultScriptFeaturesIndexes();
  }
  var scripts = this.font.tables.gsub.scripts;
  for (var i2 = 0; i2 < scripts.length; i2++) {
    var script = scripts[i2];
    if (script.tag === scriptTag && script.script.defaultLangSys) {
      return script.script.defaultLangSys.featureIndexes;
    } else {
      var langSysRecords = script.langSysRecords;
      if (!!langSysRecords) {
        for (var j2 = 0; j2 < langSysRecords.length; j2++) {
          var langSysRecord = langSysRecords[j2];
          if (langSysRecord.tag === scriptTag) {
            var langSys = langSysRecord.langSys;
            return langSys.featureIndexes;
          }
        }
      }
    }
  }
  return this.getDefaultScriptFeaturesIndexes();
};
FeatureQuery.prototype.mapTagsToFeatures = function(features, scriptTag) {
  var tags = {};
  for (var i2 = 0; i2 < features.length; i2++) {
    var tag = features[i2].tag;
    var feature = features[i2].feature;
    tags[tag] = feature;
  }
  this.features[scriptTag].tags = tags;
};
FeatureQuery.prototype.getScriptFeatures = function(scriptTag) {
  var features = this.features[scriptTag];
  if (this.features.hasOwnProperty(scriptTag)) {
    return features;
  }
  var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);
  if (!featuresIndexes) {
    return null;
  }
  var gsub2 = this.font.tables.gsub;
  features = featuresIndexes.map(function(index) {
    return gsub2.features[index];
  });
  this.features[scriptTag] = features;
  this.mapTagsToFeatures(features, scriptTag);
  return features;
};
FeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {
  var lookupType = lookupTable.lookupType.toString();
  var substFormat = subtable.substFormat.toString();
  return lookupType + substFormat;
};
FeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {
  var this$1 = this;
  var substitutionType = this.getSubstitutionType(lookupTable, subtable);
  switch (substitutionType) {
    case "11":
      return function(glyphIndex) {
        return singleSubstitutionFormat1.apply(
          this$1,
          [glyphIndex, subtable]
        );
      };
    case "12":
      return function(glyphIndex) {
        return singleSubstitutionFormat2.apply(
          this$1,
          [glyphIndex, subtable]
        );
      };
    case "63":
      return function(contextParams) {
        return chainingSubstitutionFormat3.apply(
          this$1,
          [contextParams, subtable]
        );
      };
    case "41":
      return function(contextParams) {
        return ligatureSubstitutionFormat1.apply(
          this$1,
          [contextParams, subtable]
        );
      };
    case "21":
      return function(glyphIndex) {
        return decompositionSubstitutionFormat1.apply(
          this$1,
          [glyphIndex, subtable]
        );
      };
    default:
      throw new Error(
        "lookupType: " + lookupTable.lookupType + " - substFormat: " + subtable.substFormat + " is not yet supported"
      );
  }
};
FeatureQuery.prototype.lookupFeature = function(query) {
  var contextParams = query.contextParams;
  var currentIndex = contextParams.index;
  var feature = this.getFeature({
    tag: query.tag,
    script: query.script
  });
  if (!feature) {
    return new Error(
      "font '" + this.font.names.fullName.en + "' doesn't support feature '" + query.tag + "' for script '" + query.script + "'."
    );
  }
  var lookups = this.getFeatureLookups(feature);
  var substitutions = [].concat(contextParams.context);
  for (var l = 0; l < lookups.length; l++) {
    var lookupTable = lookups[l];
    var subtables = this.getLookupSubtables(lookupTable);
    for (var s = 0; s < subtables.length; s++) {
      var subtable = subtables[s];
      var substType = this.getSubstitutionType(lookupTable, subtable);
      var lookup = this.getLookupMethod(lookupTable, subtable);
      var substitution = void 0;
      switch (substType) {
        case "11":
          substitution = lookup(contextParams.current);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 11,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "12":
          substitution = lookup(contextParams.current);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 12,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "63":
          substitution = lookup(contextParams);
          if (Array.isArray(substitution) && substitution.length) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 63,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "41":
          substitution = lookup(contextParams);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 41,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "21":
          substitution = lookup(contextParams.current);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 21,
              tag: query.tag,
              substitution
            }));
          }
          break;
      }
      contextParams = new ContextParams(substitutions, currentIndex);
      if (Array.isArray(substitution) && !substitution.length) {
        continue;
      }
      substitution = null;
    }
  }
  return substitutions.length ? substitutions : null;
};
FeatureQuery.prototype.supports = function(query) {
  if (!query.script) {
    return false;
  }
  this.getScriptFeatures(query.script);
  var supportedScript = this.features.hasOwnProperty(query.script);
  if (!query.tag) {
    return supportedScript;
  }
  var supportedFeature = this.features[query.script].some(function(feature) {
    return feature.tag === query.tag;
  });
  return supportedScript && supportedFeature;
};
FeatureQuery.prototype.getLookupSubtables = function(lookupTable) {
  return lookupTable.subtables || null;
};
FeatureQuery.prototype.getLookupByIndex = function(index) {
  var lookups = this.font.tables.gsub.lookups;
  return lookups[index] || null;
};
FeatureQuery.prototype.getFeatureLookups = function(feature) {
  return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));
};
FeatureQuery.prototype.getFeature = function getFeature(query) {
  if (!this.font) {
    return { FAIL: "No font was found" };
  }
  if (!this.features.hasOwnProperty(query.script)) {
    this.getScriptFeatures(query.script);
  }
  var scriptFeatures = this.features[query.script];
  if (!scriptFeatures) {
    return { FAIL: "No feature for script " + query.script };
  }
  if (!scriptFeatures.tags[query.tag]) {
    return null;
  }
  return this.features[query.script].tags[query.tag];
};
function arabicWordStartCheck(contextParams) {
  var char = contextParams.current;
  var prevChar = contextParams.get(-1);
  return prevChar === null && isArabicChar(char) || !isArabicChar(prevChar) && isArabicChar(char);
}
function arabicWordEndCheck(contextParams) {
  var nextChar = contextParams.get(1);
  return nextChar === null || !isArabicChar(nextChar);
}
var arabicWordCheck = {
  startCheck: arabicWordStartCheck,
  endCheck: arabicWordEndCheck
};
function arabicSentenceStartCheck(contextParams) {
  var char = contextParams.current;
  var prevChar = contextParams.get(-1);
  return (isArabicChar(char) || isTashkeelArabicChar(char)) && !isArabicChar(prevChar);
}
function arabicSentenceEndCheck(contextParams) {
  var nextChar = contextParams.get(1);
  switch (true) {
    case nextChar === null:
      return true;
    case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):
      var nextIsWhitespace = isWhiteSpace(nextChar);
      if (!nextIsWhitespace) {
        return true;
      }
      if (nextIsWhitespace) {
        var arabicCharAhead = false;
        arabicCharAhead = contextParams.lookahead.some(
          function(c) {
            return isArabicChar(c) || isTashkeelArabicChar(c);
          }
        );
        if (!arabicCharAhead) {
          return true;
        }
      }
      break;
    default:
      return false;
  }
}
var arabicSentenceCheck = {
  startCheck: arabicSentenceStartCheck,
  endCheck: arabicSentenceEndCheck
};
function singleSubstitutionFormat1$1(action, tokens, index) {
  tokens[index].setState(action.tag, action.substitution);
}
function singleSubstitutionFormat2$1(action, tokens, index) {
  tokens[index].setState(action.tag, action.substitution);
}
function chainingSubstitutionFormat3$1(action, tokens, index) {
  action.substitution.forEach(function(subst, offset) {
    var token = tokens[index + offset];
    token.setState(action.tag, subst);
  });
}
function ligatureSubstitutionFormat1$1(action, tokens, index) {
  var token = tokens[index];
  token.setState(action.tag, action.substitution.ligGlyph);
  var compsCount = action.substitution.components.length;
  for (var i2 = 0; i2 < compsCount; i2++) {
    token = tokens[index + i2 + 1];
    token.setState("deleted", true);
  }
}
var SUBSTITUTIONS = {
  11: singleSubstitutionFormat1$1,
  12: singleSubstitutionFormat2$1,
  63: chainingSubstitutionFormat3$1,
  41: ligatureSubstitutionFormat1$1
};
function applySubstitution(action, tokens, index) {
  if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {
    SUBSTITUTIONS[action.id](action, tokens, index);
  }
}
function willConnectPrev(charContextParams) {
  var backtrack = [].concat(charContextParams.backtrack);
  for (var i2 = backtrack.length - 1; i2 >= 0; i2--) {
    var prevChar = backtrack[i2];
    var isolated = isIsolatedArabicChar(prevChar);
    var tashkeel = isTashkeelArabicChar(prevChar);
    if (!isolated && !tashkeel) {
      return true;
    }
    if (isolated) {
      return false;
    }
  }
  return false;
}
function willConnectNext(charContextParams) {
  if (isIsolatedArabicChar(charContextParams.current)) {
    return false;
  }
  for (var i2 = 0; i2 < charContextParams.lookahead.length; i2++) {
    var nextChar = charContextParams.lookahead[i2];
    var tashkeel = isTashkeelArabicChar(nextChar);
    if (!tashkeel) {
      return true;
    }
  }
  return false;
}
function arabicPresentationForms(range) {
  var this$1 = this;
  var script = "arab";
  var tags = this.featuresTags[script];
  var tokens = this.tokenizer.getRangeTokens(range);
  if (tokens.length === 1) {
    return;
  }
  var contextParams = new ContextParams(
    tokens.map(
      function(token) {
        return token.getState("glyphIndex");
      }
    ),
    0
  );
  var charContextParams = new ContextParams(
    tokens.map(
      function(token) {
        return token.char;
      }
    ),
    0
  );
  tokens.forEach(function(token, index) {
    if (isTashkeelArabicChar(token.char)) {
      return;
    }
    contextParams.setCurrentIndex(index);
    charContextParams.setCurrentIndex(index);
    var CONNECT = 0;
    if (willConnectPrev(charContextParams)) {
      CONNECT |= 1;
    }
    if (willConnectNext(charContextParams)) {
      CONNECT |= 2;
    }
    var tag;
    switch (CONNECT) {
      case 1:
        tag = "fina";
        break;
      case 2:
        tag = "init";
        break;
      case 3:
        tag = "medi";
        break;
    }
    if (tags.indexOf(tag) === -1) {
      return;
    }
    var substitutions = this$1.query.lookupFeature({
      tag,
      script,
      contextParams
    });
    if (substitutions instanceof Error) {
      return console.info(substitutions.message);
    }
    substitutions.forEach(function(action, index2) {
      if (action instanceof SubstitutionAction) {
        applySubstitution(action, tokens, index2);
        contextParams.context[index2] = action.substitution;
      }
    });
  });
}
function getContextParams(tokens, index) {
  var context = tokens.map(function(token) {
    return token.activeState.value;
  });
  return new ContextParams(context, index || 0);
}
function arabicRequiredLigatures(range) {
  var this$1 = this;
  var script = "arab";
  var tokens = this.tokenizer.getRangeTokens(range);
  var contextParams = getContextParams(tokens);
  contextParams.context.forEach(function(glyphIndex, index) {
    contextParams.setCurrentIndex(index);
    var substitutions = this$1.query.lookupFeature({
      tag: "rlig",
      script,
      contextParams
    });
    if (substitutions.length) {
      substitutions.forEach(
        function(action) {
          return applySubstitution(action, tokens, index);
        }
      );
      contextParams = getContextParams(tokens);
    }
  });
}
function latinWordStartCheck(contextParams) {
  var char = contextParams.current;
  var prevChar = contextParams.get(-1);
  return prevChar === null && isLatinChar(char) || !isLatinChar(prevChar) && isLatinChar(char);
}
function latinWordEndCheck(contextParams) {
  var nextChar = contextParams.get(1);
  return nextChar === null || !isLatinChar(nextChar);
}
var latinWordCheck = {
  startCheck: latinWordStartCheck,
  endCheck: latinWordEndCheck
};
function getContextParams$1(tokens, index) {
  var context = tokens.map(function(token) {
    return token.activeState.value;
  });
  return new ContextParams(context, index || 0);
}
function latinLigature(range) {
  var this$1 = this;
  var script = "latn";
  var tokens = this.tokenizer.getRangeTokens(range);
  var contextParams = getContextParams$1(tokens);
  contextParams.context.forEach(function(glyphIndex, index) {
    contextParams.setCurrentIndex(index);
    var substitutions = this$1.query.lookupFeature({
      tag: "liga",
      script,
      contextParams
    });
    if (substitutions.length) {
      substitutions.forEach(
        function(action) {
          return applySubstitution(action, tokens, index);
        }
      );
      contextParams = getContextParams$1(tokens);
    }
  });
}
function Bidi(baseDir) {
  this.baseDir = baseDir || "ltr";
  this.tokenizer = new Tokenizer();
  this.featuresTags = {};
}
Bidi.prototype.setText = function(text) {
  this.text = text;
};
Bidi.prototype.contextChecks = {
  latinWordCheck,
  arabicWordCheck,
  arabicSentenceCheck
};
function registerContextChecker(checkId) {
  var check2 = this.contextChecks[checkId + "Check"];
  return this.tokenizer.registerContextChecker(
    checkId,
    check2.startCheck,
    check2.endCheck
  );
}
function tokenizeText() {
  registerContextChecker.call(this, "latinWord");
  registerContextChecker.call(this, "arabicWord");
  registerContextChecker.call(this, "arabicSentence");
  return this.tokenizer.tokenize(this.text);
}
function reverseArabicSentences() {
  var this$1 = this;
  var ranges = this.tokenizer.getContextRanges("arabicSentence");
  ranges.forEach(function(range) {
    var rangeTokens = this$1.tokenizer.getRangeTokens(range);
    this$1.tokenizer.replaceRange(
      range.startIndex,
      range.endOffset,
      rangeTokens.reverse()
    );
  });
}
Bidi.prototype.registerFeatures = function(script, tags) {
  var this$1 = this;
  var supportedTags = tags.filter(
    function(tag) {
      return this$1.query.supports({ script, tag });
    }
  );
  if (!this.featuresTags.hasOwnProperty(script)) {
    this.featuresTags[script] = supportedTags;
  } else {
    this.featuresTags[script] = this.featuresTags[script].concat(supportedTags);
  }
};
Bidi.prototype.applyFeatures = function(font, features) {
  if (!font) {
    throw new Error(
      "No valid font was provided to apply features"
    );
  }
  if (!this.query) {
    this.query = new FeatureQuery(font);
  }
  for (var f = 0; f < features.length; f++) {
    var feature = features[f];
    if (!this.query.supports({ script: feature.script })) {
      continue;
    }
    this.registerFeatures(feature.script, feature.tags);
  }
};
Bidi.prototype.registerModifier = function(modifierId, condition, modifier) {
  this.tokenizer.registerModifier(modifierId, condition, modifier);
};
function checkGlyphIndexStatus() {
  if (this.tokenizer.registeredModifiers.indexOf("glyphIndex") === -1) {
    throw new Error(
      "glyphIndex modifier is required to apply arabic presentation features."
    );
  }
}
function applyArabicPresentationForms() {
  var this$1 = this;
  var script = "arab";
  if (!this.featuresTags.hasOwnProperty(script)) {
    return;
  }
  checkGlyphIndexStatus.call(this);
  var ranges = this.tokenizer.getContextRanges("arabicWord");
  ranges.forEach(function(range) {
    arabicPresentationForms.call(this$1, range);
  });
}
function applyArabicRequireLigatures() {
  var this$1 = this;
  var script = "arab";
  if (!this.featuresTags.hasOwnProperty(script)) {
    return;
  }
  var tags = this.featuresTags[script];
  if (tags.indexOf("rlig") === -1) {
    return;
  }
  checkGlyphIndexStatus.call(this);
  var ranges = this.tokenizer.getContextRanges("arabicWord");
  ranges.forEach(function(range) {
    arabicRequiredLigatures.call(this$1, range);
  });
}
function applyLatinLigatures() {
  var this$1 = this;
  var script = "latn";
  if (!this.featuresTags.hasOwnProperty(script)) {
    return;
  }
  var tags = this.featuresTags[script];
  if (tags.indexOf("liga") === -1) {
    return;
  }
  checkGlyphIndexStatus.call(this);
  var ranges = this.tokenizer.getContextRanges("latinWord");
  ranges.forEach(function(range) {
    latinLigature.call(this$1, range);
  });
}
Bidi.prototype.checkContextReady = function(contextId) {
  return !!this.tokenizer.getContext(contextId);
};
Bidi.prototype.applyFeaturesToContexts = function() {
  if (this.checkContextReady("arabicWord")) {
    applyArabicPresentationForms.call(this);
    applyArabicRequireLigatures.call(this);
  }
  if (this.checkContextReady("latinWord")) {
    applyLatinLigatures.call(this);
  }
  if (this.checkContextReady("arabicSentence")) {
    reverseArabicSentences.call(this);
  }
};
Bidi.prototype.processText = function(text) {
  if (!this.text || this.text !== text) {
    this.setText(text);
    tokenizeText.call(this);
    this.applyFeaturesToContexts();
  }
};
Bidi.prototype.getBidiText = function(text) {
  this.processText(text);
  return this.tokenizer.getText();
};
Bidi.prototype.getTextGlyphs = function(text) {
  this.processText(text);
  var indexes = [];
  for (var i2 = 0; i2 < this.tokenizer.tokens.length; i2++) {
    var token = this.tokenizer.tokens[i2];
    if (token.state.deleted) {
      continue;
    }
    var index = token.activeState.value;
    indexes.push(Array.isArray(index) ? index[0] : index);
  }
  return indexes;
};
function Font2(options) {
  options = options || {};
  options.tables = options.tables || {};
  if (!options.empty) {
    checkArgument(options.familyName, "When creating a new Font object, familyName is required.");
    checkArgument(options.styleName, "When creating a new Font object, styleName is required.");
    checkArgument(options.unitsPerEm, "When creating a new Font object, unitsPerEm is required.");
    checkArgument(options.ascender, "When creating a new Font object, ascender is required.");
    checkArgument(options.descender <= 0, "When creating a new Font object, negative descender value is required.");
    this.names = {
      fontFamily: { en: options.familyName || " " },
      fontSubfamily: { en: options.styleName || " " },
      fullName: { en: options.fullName || options.familyName + " " + options.styleName },
      postScriptName: { en: options.postScriptName || (options.familyName + options.styleName).replace(/\s/g, "") },
      designer: { en: options.designer || " " },
      designerURL: { en: options.designerURL || " " },
      manufacturer: { en: options.manufacturer || " " },
      manufacturerURL: { en: options.manufacturerURL || " " },
      license: { en: options.license || " " },
      licenseURL: { en: options.licenseURL || " " },
      version: { en: options.version || "Version 0.1" },
      description: { en: options.description || " " },
      copyright: { en: options.copyright || " " },
      trademark: { en: options.trademark || " " }
    };
    this.unitsPerEm = options.unitsPerEm || 1e3;
    this.ascender = options.ascender;
    this.descender = options.descender;
    this.createdTimestamp = options.createdTimestamp;
    this.tables = Object.assign(options.tables, {
      os2: Object.assign({
        usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
        usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
        fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
      }, options.tables.os2)
    });
  }
  this.supported = true;
  this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
  this.encoding = new DefaultEncoding(this);
  this.position = new Position(this);
  this.substitution = new Substitution(this);
  this.tables = this.tables || {};
  this._push = null;
  this._hmtxTableData = {};
  Object.defineProperty(this, "hinting", {
    get: function() {
      if (this._hinting) {
        return this._hinting;
      }
      if (this.outlinesFormat === "truetype") {
        return this._hinting = new Hinting(this);
      }
    }
  });
}
Font2.prototype.hasChar = function(c) {
  return this.encoding.charToGlyphIndex(c) !== null;
};
Font2.prototype.charToGlyphIndex = function(s) {
  return this.encoding.charToGlyphIndex(s);
};
Font2.prototype.charToGlyph = function(c) {
  var glyphIndex = this.charToGlyphIndex(c);
  var glyph = this.glyphs.get(glyphIndex);
  if (!glyph) {
    glyph = this.glyphs.get(0);
  }
  return glyph;
};
Font2.prototype.updateFeatures = function(options) {
  return this.defaultRenderOptions.features.map(function(feature) {
    if (feature.script === "latn") {
      return {
        script: "latn",
        tags: feature.tags.filter(function(tag) {
          return options[tag];
        })
      };
    } else {
      return feature;
    }
  });
};
Font2.prototype.stringToGlyphs = function(s, options) {
  var this$1 = this;
  var bidi = new Bidi();
  var charToGlyphIndexMod = function(token) {
    return this$1.charToGlyphIndex(token.char);
  };
  bidi.registerModifier("glyphIndex", null, charToGlyphIndexMod);
  var features = options ? this.updateFeatures(options.features) : this.defaultRenderOptions.features;
  bidi.applyFeatures(this, features);
  var indexes = bidi.getTextGlyphs(s);
  var length2 = indexes.length;
  var glyphs = new Array(length2);
  var notdef = this.glyphs.get(0);
  for (var i2 = 0; i2 < length2; i2 += 1) {
    glyphs[i2] = this.glyphs.get(indexes[i2]) || notdef;
  }
  return glyphs;
};
Font2.prototype.nameToGlyphIndex = function(name) {
  return this.glyphNames.nameToGlyphIndex(name);
};
Font2.prototype.nameToGlyph = function(name) {
  var glyphIndex = this.nameToGlyphIndex(name);
  var glyph = this.glyphs.get(glyphIndex);
  if (!glyph) {
    glyph = this.glyphs.get(0);
  }
  return glyph;
};
Font2.prototype.glyphIndexToName = function(gid) {
  if (!this.glyphNames.glyphIndexToName) {
    return "";
  }
  return this.glyphNames.glyphIndexToName(gid);
};
Font2.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
  leftGlyph = leftGlyph.index || leftGlyph;
  rightGlyph = rightGlyph.index || rightGlyph;
  var gposKerning = this.position.defaultKerningTables;
  if (gposKerning) {
    return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);
  }
  return this.kerningPairs[leftGlyph + "," + rightGlyph] || 0;
};
Font2.prototype.defaultRenderOptions = {
  kerning: true,
  features: [
    { script: "arab", tags: ["init", "medi", "fina", "rlig"] },
    { script: "latn", tags: ["liga", "rlig"] }
  ]
};
Font2.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 72;
  options = Object.assign({}, this.defaultRenderOptions, options);
  var fontScale = 1 / this.unitsPerEm * fontSize;
  var glyphs = this.stringToGlyphs(text, options);
  var kerningLookups;
  if (options.kerning) {
    var script = options.script || this.position.getDefaultScriptName();
    kerningLookups = this.position.getKerningTables(script, options.language);
  }
  for (var i2 = 0; i2 < glyphs.length; i2 += 1) {
    var glyph = glyphs[i2];
    callback.call(this, glyph, x, y, fontSize, options);
    if (glyph.advanceWidth) {
      x += glyph.advanceWidth * fontScale;
    }
    if (options.kerning && i2 < glyphs.length - 1) {
      var kerningValue = kerningLookups ? this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i2 + 1].index) : this.getKerningValue(glyph, glyphs[i2 + 1]);
      x += kerningValue * fontScale;
    }
    if (options.letterSpacing) {
      x += options.letterSpacing * fontSize;
    } else if (options.tracking) {
      x += options.tracking / 1e3 * fontSize;
    }
  }
  return x;
};
Font2.prototype.getPath = function(text, x, y, fontSize, options) {
  var fullPath = new Path2();
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
    fullPath.extend(glyphPath);
  });
  return fullPath;
};
Font2.prototype.getPaths = function(text, x, y, fontSize, options) {
  var glyphPaths = [];
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
    glyphPaths.push(glyphPath);
  });
  return glyphPaths;
};
Font2.prototype.getAdvanceWidth = function(text, fontSize, options) {
  return this.forEachGlyph(text, 0, 0, fontSize, options, function() {
  });
};
Font2.prototype.draw = function(ctx, text, x, y, fontSize, options) {
  this.getPath(text, x, y, fontSize, options).draw(ctx);
};
Font2.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    glyph.drawPoints(ctx, gX, gY, gFontSize);
  });
};
Font2.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    glyph.drawMetrics(ctx, gX, gY, gFontSize);
  });
};
Font2.prototype.getEnglishName = function(name) {
  var translations = this.names[name];
  if (translations) {
    return translations.en;
  }
};
Font2.prototype.validate = function() {
  var _this = this;
  function assert(predicate, message) {
  }
  function assertNamePresent(name) {
    var englishName = _this.getEnglishName(name);
    assert(englishName && englishName.trim().length > 0);
  }
  assertNamePresent("fontFamily");
  assertNamePresent("weightName");
  assertNamePresent("manufacturer");
  assertNamePresent("copyright");
  assertNamePresent("version");
  assert(this.unitsPerEm > 0);
};
Font2.prototype.toTables = function() {
  return sfnt.fontToTable(this);
};
Font2.prototype.toBuffer = function() {
  console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.");
  return this.toArrayBuffer();
};
Font2.prototype.toArrayBuffer = function() {
  var sfntTable = this.toTables();
  var bytes = sfntTable.encode();
  var buffer2 = new ArrayBuffer(bytes.length);
  var intArray = new Uint8Array(buffer2);
  for (var i2 = 0; i2 < bytes.length; i2++) {
    intArray[i2] = bytes[i2];
  }
  return buffer2;
};
Font2.prototype.download = function(fileName) {
  var familyName = this.getEnglishName("fontFamily");
  var styleName = this.getEnglishName("fontSubfamily");
  fileName = fileName || familyName.replace(/\s/g, "") + "-" + styleName + ".otf";
  var arrayBuffer = this.toArrayBuffer();
  if (isBrowser()) {
    window.URL = window.URL || window.webkitURL;
    if (window.URL) {
      var dataView = new DataView(arrayBuffer);
      var blob = new Blob([dataView], { type: "font/opentype" });
      var link = document.createElement("a");
      link.href = window.URL.createObjectURL(blob);
      link.download = fileName;
      var event = document.createEvent("MouseEvents");
      event.initEvent("click", true, false);
      link.dispatchEvent(event);
    } else {
      console.warn("Font file could not be downloaded. Try using a different browser.");
    }
  } else {
    var fs = require_fs();
    var buffer2 = arrayBufferToNodeBuffer(arrayBuffer);
    fs.writeFileSync(fileName, buffer2);
  }
};
Font2.prototype.fsSelectionValues = {
  ITALIC: 1,
  UNDERSCORE: 2,
  NEGATIVE: 4,
  OUTLINED: 8,
  STRIKEOUT: 16,
  BOLD: 32,
  REGULAR: 64,
  USER_TYPO_METRICS: 128,
  WWS: 256,
  OBLIQUE: 512
};
Font2.prototype.usWidthClasses = {
  ULTRA_CONDENSED: 1,
  EXTRA_CONDENSED: 2,
  CONDENSED: 3,
  SEMI_CONDENSED: 4,
  MEDIUM: 5,
  SEMI_EXPANDED: 6,
  EXPANDED: 7,
  EXTRA_EXPANDED: 8,
  ULTRA_EXPANDED: 9
};
Font2.prototype.usWeightClasses = {
  THIN: 100,
  EXTRA_LIGHT: 200,
  LIGHT: 300,
  NORMAL: 400,
  MEDIUM: 500,
  SEMI_BOLD: 600,
  BOLD: 700,
  EXTRA_BOLD: 800,
  BLACK: 900
};
function addName(name, names) {
  var nameString = JSON.stringify(name);
  var nameID = 256;
  for (var nameKey in names) {
    var n = parseInt(nameKey);
    if (!n || n < 256) {
      continue;
    }
    if (JSON.stringify(names[nameKey]) === nameString) {
      return n;
    }
    if (nameID <= n) {
      nameID = n + 1;
    }
  }
  names[nameID] = name;
  return nameID;
}
function makeFvarAxis(n, axis, names) {
  var nameID = addName(axis.name, names);
  return [
    { name: "tag_" + n, type: "TAG", value: axis.tag },
    { name: "minValue_" + n, type: "FIXED", value: axis.minValue << 16 },
    { name: "defaultValue_" + n, type: "FIXED", value: axis.defaultValue << 16 },
    { name: "maxValue_" + n, type: "FIXED", value: axis.maxValue << 16 },
    { name: "flags_" + n, type: "USHORT", value: 0 },
    { name: "nameID_" + n, type: "USHORT", value: nameID }
  ];
}
function parseFvarAxis(data, start, names) {
  var axis = {};
  var p = new parse.Parser(data, start);
  axis.tag = p.parseTag();
  axis.minValue = p.parseFixed();
  axis.defaultValue = p.parseFixed();
  axis.maxValue = p.parseFixed();
  p.skip("uShort", 1);
  axis.name = names[p.parseUShort()] || {};
  return axis;
}
function makeFvarInstance(n, inst, axes, names) {
  var nameID = addName(inst.name, names);
  var fields = [
    { name: "nameID_" + n, type: "USHORT", value: nameID },
    { name: "flags_" + n, type: "USHORT", value: 0 }
  ];
  for (var i2 = 0; i2 < axes.length; ++i2) {
    var axisTag = axes[i2].tag;
    fields.push({
      name: "axis_" + n + " " + axisTag,
      type: "FIXED",
      value: inst.coordinates[axisTag] << 16
    });
  }
  return fields;
}
function parseFvarInstance(data, start, axes, names) {
  var inst = {};
  var p = new parse.Parser(data, start);
  inst.name = names[p.parseUShort()] || {};
  p.skip("uShort", 1);
  inst.coordinates = {};
  for (var i2 = 0; i2 < axes.length; ++i2) {
    inst.coordinates[axes[i2].tag] = p.parseFixed();
  }
  return inst;
}
function makeFvarTable(fvar2, names) {
  var result = new table.Table("fvar", [
    { name: "version", type: "ULONG", value: 65536 },
    { name: "offsetToData", type: "USHORT", value: 0 },
    { name: "countSizePairs", type: "USHORT", value: 2 },
    { name: "axisCount", type: "USHORT", value: fvar2.axes.length },
    { name: "axisSize", type: "USHORT", value: 20 },
    { name: "instanceCount", type: "USHORT", value: fvar2.instances.length },
    { name: "instanceSize", type: "USHORT", value: 4 + fvar2.axes.length * 4 }
  ]);
  result.offsetToData = result.sizeOf();
  for (var i2 = 0; i2 < fvar2.axes.length; i2++) {
    result.fields = result.fields.concat(makeFvarAxis(i2, fvar2.axes[i2], names));
  }
  for (var j2 = 0; j2 < fvar2.instances.length; j2++) {
    result.fields = result.fields.concat(makeFvarInstance(j2, fvar2.instances[j2], fvar2.axes, names));
  }
  return result;
}
function parseFvarTable(data, start, names) {
  var p = new parse.Parser(data, start);
  var tableVersion = p.parseULong();
  check.argument(tableVersion === 65536, "Unsupported fvar table version.");
  var offsetToData = p.parseOffset16();
  p.skip("uShort", 1);
  var axisCount = p.parseUShort();
  var axisSize = p.parseUShort();
  var instanceCount = p.parseUShort();
  var instanceSize = p.parseUShort();
  var axes = [];
  for (var i2 = 0; i2 < axisCount; i2++) {
    axes.push(parseFvarAxis(data, start + offsetToData + i2 * axisSize, names));
  }
  var instances = [];
  var instanceStart = start + offsetToData + axisCount * axisSize;
  for (var j2 = 0; j2 < instanceCount; j2++) {
    instances.push(parseFvarInstance(data, instanceStart + j2 * instanceSize, axes, names));
  }
  return { axes, instances };
}
var fvar = { make: makeFvarTable, parse: parseFvarTable };
var attachList = function() {
  return {
    coverage: this.parsePointer(Parser3.coverage),
    attachPoints: this.parseList(Parser3.pointer(Parser3.uShortList))
  };
};
var caretValue = function() {
  var format = this.parseUShort();
  check.argument(
    format === 1 || format === 2 || format === 3,
    "Unsupported CaretValue table version."
  );
  if (format === 1) {
    return { coordinate: this.parseShort() };
  } else if (format === 2) {
    return { pointindex: this.parseShort() };
  } else if (format === 3) {
    return { coordinate: this.parseShort() };
  }
};
var ligGlyph = function() {
  return this.parseList(Parser3.pointer(caretValue));
};
var ligCaretList = function() {
  return {
    coverage: this.parsePointer(Parser3.coverage),
    ligGlyphs: this.parseList(Parser3.pointer(ligGlyph))
  };
};
var markGlyphSets = function() {
  this.parseUShort();
  return this.parseList(Parser3.pointer(Parser3.coverage));
};
function parseGDEFTable(data, start) {
  start = start || 0;
  var p = new Parser3(data, start);
  var tableVersion = p.parseVersion(1);
  check.argument(
    tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,
    "Unsupported GDEF table version."
  );
  var gdef2 = {
    version: tableVersion,
    classDef: p.parsePointer(Parser3.classDef),
    attachList: p.parsePointer(attachList),
    ligCaretList: p.parsePointer(ligCaretList),
    markAttachClassDef: p.parsePointer(Parser3.classDef)
  };
  if (tableVersion >= 1.2) {
    gdef2.markGlyphSets = p.parsePointer(markGlyphSets);
  }
  return gdef2;
}
var gdef = { parse: parseGDEFTable };
var subtableParsers$1 = new Array(10);
subtableParsers$1[1] = function parseLookup12() {
  var start = this.offset + this.relativeOffset;
  var posformat = this.parseUShort();
  if (posformat === 1) {
    return {
      posFormat: 1,
      coverage: this.parsePointer(Parser3.coverage),
      value: this.parseValueRecord()
    };
  } else if (posformat === 2) {
    return {
      posFormat: 2,
      coverage: this.parsePointer(Parser3.coverage),
      values: this.parseValueRecordList()
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.");
};
subtableParsers$1[2] = function parseLookup22() {
  var start = this.offset + this.relativeOffset;
  var posFormat = this.parseUShort();
  check.assert(posFormat === 1 || posFormat === 2, "0x" + start.toString(16) + ": GPOS lookup type 2 format must be 1 or 2.");
  var coverage = this.parsePointer(Parser3.coverage);
  var valueFormat1 = this.parseUShort();
  var valueFormat2 = this.parseUShort();
  if (posFormat === 1) {
    return {
      posFormat,
      coverage,
      valueFormat1,
      valueFormat2,
      pairSets: this.parseList(Parser3.pointer(Parser3.list(function() {
        return {
          secondGlyph: this.parseUShort(),
          value1: this.parseValueRecord(valueFormat1),
          value2: this.parseValueRecord(valueFormat2)
        };
      })))
    };
  } else if (posFormat === 2) {
    var classDef1 = this.parsePointer(Parser3.classDef);
    var classDef2 = this.parsePointer(Parser3.classDef);
    var class1Count = this.parseUShort();
    var class2Count = this.parseUShort();
    return {
      posFormat,
      coverage,
      valueFormat1,
      valueFormat2,
      classDef1,
      classDef2,
      class1Count,
      class2Count,
      classRecords: this.parseList(class1Count, Parser3.list(class2Count, function() {
        return {
          value1: this.parseValueRecord(valueFormat1),
          value2: this.parseValueRecord(valueFormat2)
        };
      }))
    };
  }
};
subtableParsers$1[3] = function parseLookup32() {
  return { error: "GPOS Lookup 3 not supported" };
};
subtableParsers$1[4] = function parseLookup42() {
  return { error: "GPOS Lookup 4 not supported" };
};
subtableParsers$1[5] = function parseLookup52() {
  return { error: "GPOS Lookup 5 not supported" };
};
subtableParsers$1[6] = function parseLookup62() {
  return { error: "GPOS Lookup 6 not supported" };
};
subtableParsers$1[7] = function parseLookup72() {
  return { error: "GPOS Lookup 7 not supported" };
};
subtableParsers$1[8] = function parseLookup82() {
  return { error: "GPOS Lookup 8 not supported" };
};
subtableParsers$1[9] = function parseLookup9() {
  return { error: "GPOS Lookup 9 not supported" };
};
function parseGposTable(data, start) {
  start = start || 0;
  var p = new Parser3(data, start);
  var tableVersion = p.parseVersion(1);
  check.argument(tableVersion === 1 || tableVersion === 1.1, "Unsupported GPOS table version " + tableVersion);
  if (tableVersion === 1) {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers$1)
    };
  } else {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers$1),
      variations: p.parseFeatureVariationsList()
    };
  }
}
var subtableMakers$1 = new Array(10);
function makeGposTable(gpos2) {
  return new table.Table("GPOS", [
    { name: "version", type: "ULONG", value: 65536 },
    { name: "scripts", type: "TABLE", value: new table.ScriptList(gpos2.scripts) },
    { name: "features", type: "TABLE", value: new table.FeatureList(gpos2.features) },
    { name: "lookups", type: "TABLE", value: new table.LookupList(gpos2.lookups, subtableMakers$1) }
  ]);
}
var gpos = { parse: parseGposTable, make: makeGposTable };
function parseWindowsKernTable(p) {
  var pairs = {};
  p.skip("uShort");
  var subtableVersion = p.parseUShort();
  check.argument(subtableVersion === 0, "Unsupported kern sub-table version.");
  p.skip("uShort", 2);
  var nPairs = p.parseUShort();
  p.skip("uShort", 3);
  for (var i2 = 0; i2 < nPairs; i2 += 1) {
    var leftIndex = p.parseUShort();
    var rightIndex = p.parseUShort();
    var value = p.parseShort();
    pairs[leftIndex + "," + rightIndex] = value;
  }
  return pairs;
}
function parseMacKernTable(p) {
  var pairs = {};
  p.skip("uShort");
  var nTables = p.parseULong();
  if (nTables > 1) {
    console.warn("Only the first kern subtable is supported.");
  }
  p.skip("uLong");
  var coverage = p.parseUShort();
  var subtableVersion = coverage & 255;
  p.skip("uShort");
  if (subtableVersion === 0) {
    var nPairs = p.parseUShort();
    p.skip("uShort", 3);
    for (var i2 = 0; i2 < nPairs; i2 += 1) {
      var leftIndex = p.parseUShort();
      var rightIndex = p.parseUShort();
      var value = p.parseShort();
      pairs[leftIndex + "," + rightIndex] = value;
    }
  }
  return pairs;
}
function parseKernTable(data, start) {
  var p = new parse.Parser(data, start);
  var tableVersion = p.parseUShort();
  if (tableVersion === 0) {
    return parseWindowsKernTable(p);
  } else if (tableVersion === 1) {
    return parseMacKernTable(p);
  } else {
    throw new Error("Unsupported kern table version (" + tableVersion + ").");
  }
}
var kern = { parse: parseKernTable };
function parseLocaTable(data, start, numGlyphs, shortVersion) {
  var p = new parse.Parser(data, start);
  var parseFn = shortVersion ? p.parseUShort : p.parseULong;
  var glyphOffsets = [];
  for (var i2 = 0; i2 < numGlyphs + 1; i2 += 1) {
    var glyphOffset = parseFn.call(p);
    if (shortVersion) {
      glyphOffset *= 2;
    }
    glyphOffsets.push(glyphOffset);
  }
  return glyphOffsets;
}
var loca = { parse: parseLocaTable };
function loadFromFile(path, callback) {
  var fs = require_fs();
  fs.readFile(path, function(err, buffer2) {
    if (err) {
      return callback(err.message);
    }
    callback(null, nodeBufferToArrayBuffer(buffer2));
  });
}
function loadFromUrl(url, callback) {
  var request = new XMLHttpRequest();
  request.open("get", url, true);
  request.responseType = "arraybuffer";
  request.onload = function() {
    if (request.response) {
      return callback(null, request.response);
    } else {
      return callback("Font could not be loaded: " + request.statusText);
    }
  };
  request.onerror = function() {
    callback("Font could not be loaded");
  };
  request.send();
}
function parseOpenTypeTableEntries(data, numTables) {
  var tableEntries = [];
  var p = 12;
  for (var i2 = 0; i2 < numTables; i2 += 1) {
    var tag = parse.getTag(data, p);
    var checksum = parse.getULong(data, p + 4);
    var offset = parse.getULong(data, p + 8);
    var length2 = parse.getULong(data, p + 12);
    tableEntries.push({ tag, checksum, offset, length: length2, compression: false });
    p += 16;
  }
  return tableEntries;
}
function parseWOFFTableEntries(data, numTables) {
  var tableEntries = [];
  var p = 44;
  for (var i2 = 0; i2 < numTables; i2 += 1) {
    var tag = parse.getTag(data, p);
    var offset = parse.getULong(data, p + 4);
    var compLength = parse.getULong(data, p + 8);
    var origLength = parse.getULong(data, p + 12);
    var compression = void 0;
    if (compLength < origLength) {
      compression = "WOFF";
    } else {
      compression = false;
    }
    tableEntries.push({
      tag,
      offset,
      compression,
      compressedLength: compLength,
      length: origLength
    });
    p += 20;
  }
  return tableEntries;
}
function uncompressTable(data, tableEntry) {
  if (tableEntry.compression === "WOFF") {
    var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
    var outBuffer = new Uint8Array(tableEntry.length);
    tinyInflate(inBuffer, outBuffer);
    if (outBuffer.byteLength !== tableEntry.length) {
      throw new Error("Decompression error: " + tableEntry.tag + " decompressed length doesn't match recorded length");
    }
    var view = new DataView(outBuffer.buffer, 0);
    return { data: view, offset: 0 };
  } else {
    return { data, offset: tableEntry.offset };
  }
}
function parseBuffer(buffer2, opt) {
  opt = opt === void 0 || opt === null ? {} : opt;
  var indexToLocFormat;
  var ltagTable;
  var font = new Font2({ empty: true });
  var data = new DataView(buffer2, 0);
  var numTables;
  var tableEntries = [];
  var signature = parse.getTag(data, 0);
  if (signature === String.fromCharCode(0, 1, 0, 0) || signature === "true" || signature === "typ1") {
    font.outlinesFormat = "truetype";
    numTables = parse.getUShort(data, 4);
    tableEntries = parseOpenTypeTableEntries(data, numTables);
  } else if (signature === "OTTO") {
    font.outlinesFormat = "cff";
    numTables = parse.getUShort(data, 4);
    tableEntries = parseOpenTypeTableEntries(data, numTables);
  } else if (signature === "wOFF") {
    var flavor = parse.getTag(data, 4);
    if (flavor === String.fromCharCode(0, 1, 0, 0)) {
      font.outlinesFormat = "truetype";
    } else if (flavor === "OTTO") {
      font.outlinesFormat = "cff";
    } else {
      throw new Error("Unsupported OpenType flavor " + signature);
    }
    numTables = parse.getUShort(data, 12);
    tableEntries = parseWOFFTableEntries(data, numTables);
  } else {
    throw new Error("Unsupported OpenType signature " + signature);
  }
  var cffTableEntry;
  var fvarTableEntry;
  var glyfTableEntry;
  var gdefTableEntry;
  var gposTableEntry;
  var gsubTableEntry;
  var hmtxTableEntry;
  var kernTableEntry;
  var locaTableEntry;
  var nameTableEntry;
  var metaTableEntry;
  var p;
  for (var i2 = 0; i2 < numTables; i2 += 1) {
    var tableEntry = tableEntries[i2];
    var table2 = void 0;
    switch (tableEntry.tag) {
      case "cmap":
        table2 = uncompressTable(data, tableEntry);
        font.tables.cmap = cmap.parse(table2.data, table2.offset);
        font.encoding = new CmapEncoding(font.tables.cmap);
        break;
      case "cvt ":
        table2 = uncompressTable(data, tableEntry);
        p = new parse.Parser(table2.data, table2.offset);
        font.tables.cvt = p.parseShortList(tableEntry.length / 2);
        break;
      case "fvar":
        fvarTableEntry = tableEntry;
        break;
      case "fpgm":
        table2 = uncompressTable(data, tableEntry);
        p = new parse.Parser(table2.data, table2.offset);
        font.tables.fpgm = p.parseByteList(tableEntry.length);
        break;
      case "head":
        table2 = uncompressTable(data, tableEntry);
        font.tables.head = head.parse(table2.data, table2.offset);
        font.unitsPerEm = font.tables.head.unitsPerEm;
        indexToLocFormat = font.tables.head.indexToLocFormat;
        break;
      case "hhea":
        table2 = uncompressTable(data, tableEntry);
        font.tables.hhea = hhea.parse(table2.data, table2.offset);
        font.ascender = font.tables.hhea.ascender;
        font.descender = font.tables.hhea.descender;
        font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
        break;
      case "hmtx":
        hmtxTableEntry = tableEntry;
        break;
      case "ltag":
        table2 = uncompressTable(data, tableEntry);
        ltagTable = ltag.parse(table2.data, table2.offset);
        break;
      case "maxp":
        table2 = uncompressTable(data, tableEntry);
        font.tables.maxp = maxp.parse(table2.data, table2.offset);
        font.numGlyphs = font.tables.maxp.numGlyphs;
        break;
      case "name":
        nameTableEntry = tableEntry;
        break;
      case "OS/2":
        table2 = uncompressTable(data, tableEntry);
        font.tables.os2 = os2.parse(table2.data, table2.offset);
        break;
      case "post":
        table2 = uncompressTable(data, tableEntry);
        font.tables.post = post.parse(table2.data, table2.offset);
        font.glyphNames = new GlyphNames(font.tables.post);
        break;
      case "prep":
        table2 = uncompressTable(data, tableEntry);
        p = new parse.Parser(table2.data, table2.offset);
        font.tables.prep = p.parseByteList(tableEntry.length);
        break;
      case "glyf":
        glyfTableEntry = tableEntry;
        break;
      case "loca":
        locaTableEntry = tableEntry;
        break;
      case "CFF ":
        cffTableEntry = tableEntry;
        break;
      case "kern":
        kernTableEntry = tableEntry;
        break;
      case "GDEF":
        gdefTableEntry = tableEntry;
        break;
      case "GPOS":
        gposTableEntry = tableEntry;
        break;
      case "GSUB":
        gsubTableEntry = tableEntry;
        break;
      case "meta":
        metaTableEntry = tableEntry;
        break;
    }
  }
  var nameTable = uncompressTable(data, nameTableEntry);
  font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
  font.names = font.tables.name;
  if (glyfTableEntry && locaTableEntry) {
    var shortVersion = indexToLocFormat === 0;
    var locaTable = uncompressTable(data, locaTableEntry);
    var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
    var glyfTable = uncompressTable(data, glyfTableEntry);
    font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt);
  } else if (cffTableEntry) {
    var cffTable = uncompressTable(data, cffTableEntry);
    cff.parse(cffTable.data, cffTable.offset, font, opt);
  } else {
    throw new Error("Font doesn't contain TrueType or CFF outlines.");
  }
  var hmtxTable = uncompressTable(data, hmtxTableEntry);
  hmtx.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt);
  addGlyphNames(font, opt);
  if (kernTableEntry) {
    var kernTable = uncompressTable(data, kernTableEntry);
    font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
  } else {
    font.kerningPairs = {};
  }
  if (gdefTableEntry) {
    var gdefTable = uncompressTable(data, gdefTableEntry);
    font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);
  }
  if (gposTableEntry) {
    var gposTable = uncompressTable(data, gposTableEntry);
    font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
    font.position.init();
  }
  if (gsubTableEntry) {
    var gsubTable = uncompressTable(data, gsubTableEntry);
    font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
  }
  if (fvarTableEntry) {
    var fvarTable = uncompressTable(data, fvarTableEntry);
    font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
  }
  if (metaTableEntry) {
    var metaTable = uncompressTable(data, metaTableEntry);
    font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
    font.metas = font.tables.meta;
  }
  return font;
}
function load(url, callback, opt) {
  opt = opt === void 0 || opt === null ? {} : opt;
  var isNode = typeof window === "undefined";
  var loadFn = isNode && !opt.isUrl ? loadFromFile : loadFromUrl;
  return new Promise(function(resolve, reject) {
    loadFn(url, function(err, arrayBuffer) {
      if (err) {
        if (callback) {
          return callback(err);
        } else {
          reject(err);
        }
      }
      var font;
      try {
        font = parseBuffer(arrayBuffer, opt);
      } catch (e) {
        if (callback) {
          return callback(e, null);
        } else {
          reject(e);
        }
      }
      if (callback) {
        return callback(null, font);
      } else {
        resolve(font);
      }
    });
  });
}
function loadSync(url, opt) {
  var fs = require_fs();
  var buffer2 = fs.readFileSync(url);
  return parseBuffer(nodeBufferToArrayBuffer(buffer2), opt);
}
var opentype = Object.freeze({
  __proto__: null,
  Font: Font2,
  Glyph,
  Path: Path2,
  BoundingBox,
  _parse: parse,
  parse: parseBuffer,
  load,
  loadSync
});

// node_modules/three-stdlib/loaders/TTFLoader.js
var TTFLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.reversed = false;
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer2) {
      try {
        onLoad(parseBuffer(buffer2));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(arraybuffer) {
    function convert(font, reversed) {
      const round2 = Math.round;
      const glyphs = {};
      const scale = 1e5 / ((font.unitsPerEm || 2048) * 72);
      const glyphIndexMap = font.encoding.cmap.glyphIndexMap;
      const unicodes = Object.keys(glyphIndexMap);
      for (let i2 = 0; i2 < unicodes.length; i2++) {
        const unicode = unicodes[i2];
        const glyph = font.glyphs.glyphs[glyphIndexMap[unicode]];
        if (unicode !== void 0) {
          const token = {
            ha: round2(glyph.advanceWidth * scale),
            x_min: round2(glyph.xMin * scale),
            x_max: round2(glyph.xMax * scale),
            o: ""
          };
          if (reversed) {
            glyph.path.commands = reverseCommands(glyph.path.commands);
          }
          glyph.path.commands.forEach(function(command) {
            if (command.type.toLowerCase() === "c") {
              command.type = "b";
            }
            token.o += command.type.toLowerCase() + " ";
            if (command.x !== void 0 && command.y !== void 0) {
              token.o += round2(command.x * scale) + " " + round2(command.y * scale) + " ";
            }
            if (command.x1 !== void 0 && command.y1 !== void 0) {
              token.o += round2(command.x1 * scale) + " " + round2(command.y1 * scale) + " ";
            }
            if (command.x2 !== void 0 && command.y2 !== void 0) {
              token.o += round2(command.x2 * scale) + " " + round2(command.y2 * scale) + " ";
            }
          });
          glyphs[String.fromCodePoint(glyph.unicode)] = token;
        }
      }
      return {
        glyphs,
        familyName: font.getEnglishName("fullName"),
        ascender: round2(font.ascender * scale),
        descender: round2(font.descender * scale),
        underlinePosition: font.tables.post.underlinePosition,
        underlineThickness: font.tables.post.underlineThickness,
        boundingBox: {
          xMin: font.tables.head.xMin,
          xMax: font.tables.head.xMax,
          yMin: font.tables.head.yMin,
          yMax: font.tables.head.yMax
        },
        resolution: 1e3,
        original_font_information: font.tables.name
      };
    }
    function reverseCommands(commands) {
      const paths = [];
      let path;
      commands.forEach(function(c) {
        if (c.type.toLowerCase() === "m") {
          path = [c];
          paths.push(path);
        } else if (c.type.toLowerCase() !== "z") {
          path.push(c);
        }
      });
      const reversed = [];
      paths.forEach(function(p) {
        const result = {
          type: "m",
          x: p[p.length - 1].x,
          y: p[p.length - 1].y
        };
        reversed.push(result);
        for (let i2 = p.length - 1; i2 > 0; i2--) {
          const command = p[i2];
          const result2 = {
            type: command.type
          };
          if (command.x2 !== void 0 && command.y2 !== void 0) {
            result2.x1 = command.x2;
            result2.y1 = command.y2;
            result2.x2 = command.x1;
            result2.y2 = command.y1;
          } else if (command.x1 !== void 0 && command.y1 !== void 0) {
            result2.x1 = command.x1;
            result2.y1 = command.y1;
          }
          result2.x = p[i2 - 1].x;
          result2.y = p[i2 - 1].y;
          reversed.push(result2);
        }
      });
      return reversed;
    }
    return convert(parseBuffer(arraybuffer), this.reversed);
  }
};

// node_modules/three-stdlib/loaders/RGBELoader.js
var RGBELoader = class extends DataTextureLoader {
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
  }
  parse(buffer2) {
    const RGBE_RETURN_FAILURE = -1, rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {
      switch (rgbe_error_code) {
        case rgbe_read_error:
          console.error("THREE.RGBELoader Read Error: " + (msg || ""));
          break;
        case rgbe_write_error:
          console.error("THREE.RGBELoader Write Error: " + (msg || ""));
          break;
        case rgbe_format_error:
          console.error("THREE.RGBELoader Bad File Format: " + (msg || ""));
          break;
        default:
        case rgbe_memory_error:
          console.error("THREE.RGBELoader: Error: " + (msg || ""));
      }
      return RGBE_RETURN_FAILURE;
    }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = "\n", fgets = function(buffer3, lineLimit, consume) {
      const chunkSize = 128;
      lineLimit = !lineLimit ? 1024 : lineLimit;
      let p = buffer3.pos, i2 = -1, len = 0, s = "", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer3.subarray(p, p + chunkSize)));
      while (0 > (i2 = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer3.byteLength) {
        s += chunk;
        len += chunk.length;
        p += chunkSize;
        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer3.subarray(p, p + chunkSize)));
      }
      if (-1 < i2) {
        if (false !== consume)
          buffer3.pos += len + i2 + 1;
        return s + chunk.slice(0, i2);
      }
      return false;
    }, RGBE_ReadHeader = function(buffer3) {
      const magic_token_re = /^#\?(\S+)/, gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, format_re = /^\s*FORMAT=(\S+)\s*$/, dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, header = {
        valid: 0,
        string: "",
        comments: "",
        programtype: "RGBE",
        format: "",
        gamma: 1,
        exposure: 1,
        width: 0,
        height: 0
      };
      let line2, match;
      if (buffer3.pos >= buffer3.byteLength || !(line2 = fgets(buffer3))) {
        return rgbe_error(rgbe_read_error, "no header found");
      }
      if (!(match = line2.match(magic_token_re))) {
        return rgbe_error(rgbe_format_error, "bad initial token");
      }
      header.valid |= RGBE_VALID_PROGRAMTYPE;
      header.programtype = match[1];
      header.string += line2 + "\n";
      while (true) {
        line2 = fgets(buffer3);
        if (false === line2)
          break;
        header.string += line2 + "\n";
        if ("#" === line2.charAt(0)) {
          header.comments += line2 + "\n";
          continue;
        }
        if (match = line2.match(gamma_re)) {
          header.gamma = parseFloat(match[1]);
        }
        if (match = line2.match(exposure_re)) {
          header.exposure = parseFloat(match[1]);
        }
        if (match = line2.match(format_re)) {
          header.valid |= RGBE_VALID_FORMAT;
          header.format = match[1];
        }
        if (match = line2.match(dimensions_re)) {
          header.valid |= RGBE_VALID_DIMENSIONS;
          header.height = parseInt(match[1], 10);
          header.width = parseInt(match[2], 10);
        }
        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS)
          break;
      }
      if (!(header.valid & RGBE_VALID_FORMAT)) {
        return rgbe_error(rgbe_format_error, "missing format specifier");
      }
      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
        return rgbe_error(rgbe_format_error, "missing image size specifier");
      }
      return header;
    }, RGBE_ReadPixels_RLE = function(buffer3, w, h) {
      const scanline_width = w;
      if (scanline_width < 8 || scanline_width > 32767 || 2 !== buffer3[0] || 2 !== buffer3[1] || buffer3[2] & 128) {
        return new Uint8Array(buffer3);
      }
      if (scanline_width !== (buffer3[2] << 8 | buffer3[3])) {
        return rgbe_error(rgbe_format_error, "wrong scanline width");
      }
      const data_rgba = new Uint8Array(4 * w * h);
      if (!data_rgba.length) {
        return rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
      }
      let offset = 0, pos = 0;
      const ptr_end = 4 * scanline_width;
      const rgbeStart = new Uint8Array(4);
      const scanline_buffer = new Uint8Array(ptr_end);
      let num_scanlines = h;
      while (num_scanlines > 0 && pos < buffer3.byteLength) {
        if (pos + 4 > buffer3.byteLength) {
          return rgbe_error(rgbe_read_error);
        }
        rgbeStart[0] = buffer3[pos++];
        rgbeStart[1] = buffer3[pos++];
        rgbeStart[2] = buffer3[pos++];
        rgbeStart[3] = buffer3[pos++];
        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
          return rgbe_error(rgbe_format_error, "bad rgbe scanline format");
        }
        let ptr = 0, count;
        while (ptr < ptr_end && pos < buffer3.byteLength) {
          count = buffer3[pos++];
          const isEncodedRun = count > 128;
          if (isEncodedRun)
            count -= 128;
          if (0 === count || ptr + count > ptr_end) {
            return rgbe_error(rgbe_format_error, "bad scanline data");
          }
          if (isEncodedRun) {
            const byteValue = buffer3[pos++];
            for (let i2 = 0; i2 < count; i2++) {
              scanline_buffer[ptr++] = byteValue;
            }
          } else {
            scanline_buffer.set(buffer3.subarray(pos, pos + count), ptr);
            ptr += count;
            pos += count;
          }
        }
        const l = scanline_width;
        for (let i2 = 0; i2 < l; i2++) {
          let off = 0;
          data_rgba[offset] = scanline_buffer[i2 + off];
          off += scanline_width;
          data_rgba[offset + 1] = scanline_buffer[i2 + off];
          off += scanline_width;
          data_rgba[offset + 2] = scanline_buffer[i2 + off];
          off += scanline_width;
          data_rgba[offset + 3] = scanline_buffer[i2 + off];
          offset += 4;
        }
        num_scanlines--;
      }
      return data_rgba;
    };
    const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e - 128) / 255;
      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
      destArray[destOffset + 3] = 1;
    };
    const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e - 128) / 255;
      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));
      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));
      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));
      destArray[destOffset + 3] = DataUtils.toHalfFloat(1);
    };
    const byteArray = new Uint8Array(buffer2);
    byteArray.pos = 0;
    const rgbe_header_info = RGBE_ReadHeader(byteArray);
    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {
      const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
      if (RGBE_RETURN_FAILURE !== image_rgba_data) {
        let data, type2;
        let numElements;
        switch (this.type) {
          case FloatType:
            numElements = image_rgba_data.length / 4;
            const floatArray = new Float32Array(numElements * 4);
            for (let j2 = 0; j2 < numElements; j2++) {
              RGBEByteToRGBFloat(image_rgba_data, j2 * 4, floatArray, j2 * 4);
            }
            data = floatArray;
            type2 = FloatType;
            break;
          case HalfFloatType:
            numElements = image_rgba_data.length / 4;
            const halfArray = new Uint16Array(numElements * 4);
            for (let j2 = 0; j2 < numElements; j2++) {
              RGBEByteToRGBHalf(image_rgba_data, j2 * 4, halfArray, j2 * 4);
            }
            data = halfArray;
            type2 = HalfFloatType;
            break;
          default:
            console.error("THREE.RGBELoader: unsupported type: ", this.type);
            break;
        }
        return {
          width: w,
          height: h,
          data,
          header: rgbe_header_info.string,
          gamma: rgbe_header_info.gamma,
          exposure: rgbe_header_info.exposure,
          type: type2
        };
      }
    }
    return null;
  }
  setDataType(value) {
    this.type = value;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    function onLoadCallback(texture2, texData) {
      switch (texture2.type) {
        case FloatType:
        case HalfFloatType:
          texture2.encoding = LinearEncoding;
          texture2.minFilter = LinearFilter;
          texture2.magFilter = LinearFilter;
          texture2.generateMipmaps = false;
          texture2.flipY = true;
          break;
      }
      if (onLoad)
        onLoad(texture2, texData);
    }
    return super.load(url, onLoadCallback, onProgress, onError);
  }
};

// node_modules/three-stdlib/loaders/AssimpLoader.js
var AssimpLoader = function(manager) {
  Loader.call(this, manager);
};
AssimpLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: AssimpLoader,
  load: function(url, onLoad, onProgress, onError) {
    var scope2 = this;
    var path = scope2.path === "" ? LoaderUtils.extractUrlBase(url) : scope2.path;
    var loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(buffer2) {
      try {
        onLoad(scope2.parse(buffer2, path));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  },
  parse: function(buffer2, path) {
    var textureLoader = new TextureLoader(this.manager);
    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    var Virtulous = {};
    Virtulous.KeyFrame = function(time, matrix3) {
      this.time = time;
      this.matrix = matrix3.clone();
      this.position = new Vector3();
      this.quaternion = new Quaternion();
      this.scale = new Vector3(1, 1, 1);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
      this.clone = function() {
        var n = new Virtulous.KeyFrame(this.time, this.matrix);
        return n;
      };
      this.lerp = function(nextKey, time2) {
        time2 -= this.time;
        var dist = nextKey.time - this.time;
        var l = time2 / dist;
        var l2 = 1 - l;
        var keypos = this.position;
        var keyrot = this.quaternion;
        var key2pos = nextKey.position;
        var key2rot = nextKey.quaternion;
        Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;
        Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;
        Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;
        Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);
        Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);
        return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);
      };
    };
    Virtulous.KeyFrame.tempAniPos = new Vector3();
    Virtulous.KeyFrame.tempAniQuat = new Quaternion();
    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1);
    Virtulous.KeyFrame.tempAniMatrix = new Matrix4();
    Virtulous.KeyFrameTrack = function() {
      this.keys = [];
      this.target = null;
      this.time = 0;
      this.length = 0;
      this._accelTable = {};
      this.fps = 20;
      this.addKey = function(key) {
        this.keys.push(key);
      };
      this.init = function() {
        this.sortKeys();
        if (this.keys.length > 0)
          this.length = this.keys[this.keys.length - 1].time;
        else
          this.length = 0;
        if (!this.fps)
          return;
        for (let j2 = 0; j2 < this.length * this.fps; j2++) {
          for (let i2 = 0; i2 < this.keys.length; i2++) {
            if (this.keys[i2].time == j2) {
              this._accelTable[j2] = i2;
              break;
            } else if (this.keys[i2].time < j2 / this.fps && this.keys[i2 + 1] && this.keys[i2 + 1].time >= j2 / this.fps) {
              this._accelTable[j2] = i2;
              break;
            }
          }
        }
      };
      this.parseFromThree = function(data) {
        var fps = data.fps;
        this.target = data.node;
        var track = data.hierarchy[0].keys;
        for (let i2 = 0; i2 < track.length; i2++) {
          this.addKey(new Virtulous.KeyFrame(i2 / fps || track[i2].time, track[i2].targets[0].data));
        }
        this.init();
      };
      this.parseFromCollada = function(data) {
        var track = data.keys;
        var fps = this.fps;
        for (let i2 = 0; i2 < track.length; i2++) {
          this.addKey(new Virtulous.KeyFrame(i2 / fps || track[i2].time, track[i2].matrix));
        }
        this.init();
      };
      this.sortKeys = function() {
        this.keys.sort(this.keySortFunc);
      };
      this.keySortFunc = function(a2, b3) {
        return a2.time - b3.time;
      };
      this.clone = function() {
        var t2 = new Virtulous.KeyFrameTrack();
        t2.target = this.target;
        t2.time = this.time;
        t2.length = this.length;
        for (let i2 = 0; i2 < this.keys.length; i2++) {
          t2.addKey(this.keys[i2].clone());
        }
        t2.init();
        return t2;
      };
      this.reTarget = function(root, compareitor) {
        if (!compareitor)
          compareitor = Virtulous.TrackTargetNodeNameCompare;
        this.target = compareitor(root, this.target);
      };
      this.keySearchAccel = function(time) {
        time *= this.fps;
        time = Math.floor(time);
        return this._accelTable[time] || 0;
      };
      this.setTime = function(time) {
        time = Math.abs(time);
        if (this.length)
          time = time % this.length + 0.05;
        var key0 = null;
        var key1 = null;
        for (let i2 = this.keySearchAccel(time); i2 < this.keys.length; i2++) {
          if (this.keys[i2].time == time) {
            key0 = this.keys[i2];
            key1 = this.keys[i2];
            break;
          } else if (this.keys[i2].time < time && this.keys[i2 + 1] && this.keys[i2 + 1].time > time) {
            key0 = this.keys[i2];
            key1 = this.keys[i2 + 1];
            break;
          } else if (this.keys[i2].time < time && i2 == this.keys.length - 1) {
            key0 = this.keys[i2];
            key1 = this.keys[0].clone();
            key1.time += this.length + 0.05;
            break;
          }
        }
        if (key0 && key1 && key0 !== key1) {
          this.target.matrixAutoUpdate = false;
          this.target.matrix.copy(key0.lerp(key1, time));
          this.target.matrixWorldNeedsUpdate = true;
          return;
        }
        if (key0 && key1 && key0 == key1) {
          this.target.matrixAutoUpdate = false;
          this.target.matrix.copy(key0.matrix);
          this.target.matrixWorldNeedsUpdate = true;
          return;
        }
      };
    };
    Virtulous.TrackTargetNodeNameCompare = function(root, target) {
      function find(node, name) {
        if (node.name == name)
          return node;
        for (let i2 = 0; i2 < node.children.length; i2++) {
          var r = find(node.children[i2], name);
          if (r)
            return r;
        }
        return null;
      }
      return find(root, target.name);
    };
    Virtulous.Animation = function() {
      this.tracks = [];
      this.length = 0;
      this.addTrack = function(track) {
        this.tracks.push(track);
        this.length = Math.max(track.length, this.length);
      };
      this.setTime = function(time) {
        this.time = time;
        for (let i2 = 0; i2 < this.tracks.length; i2++)
          this.tracks[i2].setTime(time);
      };
      this.clone = function(target, compareitor) {
        if (!compareitor)
          compareitor = Virtulous.TrackTargetNodeNameCompare;
        var n = new Virtulous.Animation();
        n.target = target;
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          var track = this.tracks[i2].clone();
          track.reTarget(target, compareitor);
          n.addTrack(track);
        }
        return n;
      };
    };
    var ASSBIN_CHUNK_AICAMERA = 4660;
    var ASSBIN_CHUNK_AILIGHT = 4661;
    var ASSBIN_CHUNK_AITEXTURE = 4662;
    var ASSBIN_CHUNK_AIMESH = 4663;
    var ASSBIN_CHUNK_AINODEANIM = 4664;
    var ASSBIN_CHUNK_AISCENE = 4665;
    var ASSBIN_CHUNK_AIBONE = 4666;
    var ASSBIN_CHUNK_AIANIMATION = 4667;
    var ASSBIN_CHUNK_AINODE = 4668;
    var ASSBIN_CHUNK_AIMATERIAL = 4669;
    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 4670;
    var ASSBIN_MESH_HAS_POSITIONS = 1;
    var ASSBIN_MESH_HAS_NORMALS = 2;
    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 4;
    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 256;
    var ASSBIN_MESH_HAS_COLOR_BASE = 65536;
    var AI_MAX_NUMBER_OF_COLOR_SETS = 1;
    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;
    var aiLightSource_DIRECTIONAL = 1;
    var aiLightSource_SPOT = 3;
    var aiTextureType_DIFFUSE = 1;
    var aiTextureType_NORMALS = 6;
    var aiTextureType_OPACITY = 8;
    var aiTextureType_LIGHTMAP = 10;
    var BONESPERVERT = 4;
    function ASSBIN_MESH_HAS_TEXCOORD(n) {
      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;
    }
    function ASSBIN_MESH_HAS_COLOR(n) {
      return ASSBIN_MESH_HAS_COLOR_BASE << n;
    }
    function markBones(scene) {
      for (let i2 in scene.mMeshes) {
        var mesh = scene.mMeshes[i2];
        for (let k in mesh.mBones) {
          var boneNode = scene.findNode(mesh.mBones[k].mName);
          if (boneNode)
            boneNode.isBone = true;
        }
      }
    }
    function cloneTreeToBones(root, scene) {
      var rootBone = new Bone();
      rootBone.matrix.copy(root.matrix);
      rootBone.matrixWorld.copy(root.matrixWorld);
      rootBone.position.copy(root.position);
      rootBone.quaternion.copy(root.quaternion);
      rootBone.scale.copy(root.scale);
      scene.nodeCount++;
      rootBone.name = "bone_" + root.name + scene.nodeCount.toString();
      if (!scene.nodeToBoneMap[root.name])
        scene.nodeToBoneMap[root.name] = [];
      scene.nodeToBoneMap[root.name].push(rootBone);
      for (let i2 in root.children) {
        var child = cloneTreeToBones(root.children[i2], scene);
        rootBone.add(child);
      }
      return rootBone;
    }
    function sortWeights(indexes, weights) {
      var pairs = [];
      for (let i2 = 0; i2 < indexes.length; i2++) {
        pairs.push({
          i: indexes[i2],
          w: weights[i2]
        });
      }
      pairs.sort(function(a2, b3) {
        return b3.w - a2.w;
      });
      while (pairs.length < 4) {
        pairs.push({
          i: 0,
          w: 0
        });
      }
      if (pairs.length > 4)
        pairs.length = 4;
      var sum = 0;
      for (let i2 = 0; i2 < 4; i2++) {
        sum += pairs[i2].w * pairs[i2].w;
      }
      sum = Math.sqrt(sum);
      for (let i2 = 0; i2 < 4; i2++) {
        pairs[i2].w = pairs[i2].w / sum;
        indexes[i2] = pairs[i2].i;
        weights[i2] = pairs[i2].w;
      }
    }
    function findMatchingBone(root, name) {
      if (root.name.indexOf("bone_" + name) == 0)
        return root;
      for (let i2 in root.children) {
        var ret = findMatchingBone(root.children[i2], name);
        if (ret)
          return ret;
      }
      return void 0;
    }
    function aiMesh() {
      this.mPrimitiveTypes = 0;
      this.mNumVertices = 0;
      this.mNumFaces = 0;
      this.mNumBones = 0;
      this.mMaterialIndex = 0;
      this.mVertices = [];
      this.mNormals = [];
      this.mTangents = [];
      this.mBitangents = [];
      this.mColors = [[]];
      this.mTextureCoords = [[]];
      this.mFaces = [];
      this.mBones = [];
      this.hookupSkeletons = function(scene) {
        if (this.mBones.length == 0)
          return;
        var allBones = [];
        var offsetMatrix = [];
        var skeletonRoot = scene.findNode(this.mBones[0].mName);
        while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {
          skeletonRoot = skeletonRoot.mParent;
        }
        var threeSkeletonRoot = skeletonRoot.toTHREE(scene);
        var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);
        this.threeNode.add(threeSkeletonRootBone);
        for (let i2 = 0; i2 < this.mBones.length; i2++) {
          var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i2].mName);
          if (bone) {
            var tbone = bone;
            allBones.push(tbone);
            offsetMatrix.push(this.mBones[i2].mOffsetMatrix.toTHREE());
          } else {
            var skeletonRoot = scene.findNode(this.mBones[i2].mName);
            if (!skeletonRoot)
              return;
            var threeSkeletonRoot = skeletonRoot.toTHREE(scene);
            var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);
            this.threeNode.add(threeSkeletonRootBone);
            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i2].mName);
            var tbone = bone;
            allBones.push(tbone);
            offsetMatrix.push(this.mBones[i2].mOffsetMatrix.toTHREE());
          }
        }
        var skeleton = new Skeleton(allBones, offsetMatrix);
        this.threeNode.bind(skeleton, new Matrix4());
        this.threeNode.material.skinning = true;
      };
      this.toTHREE = function(scene) {
        if (this.threeNode)
          return this.threeNode;
        var geometry = new BufferGeometry();
        var mat;
        if (scene.mMaterials[this.mMaterialIndex])
          mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);
        else
          mat = new MeshLambertMaterial();
        geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1));
        geometry.setAttribute("position", new BufferAttribute(this.mVertexBuffer, 3));
        if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {
          geometry.setAttribute("normal", new BufferAttribute(this.mNormalBuffer, 3));
        }
        if (this.mColorBuffer && this.mColorBuffer.length > 0) {
          geometry.setAttribute("color", new BufferAttribute(this.mColorBuffer, 4));
        }
        if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {
          geometry.setAttribute("uv", new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));
        }
        if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {
          geometry.setAttribute("uv1", new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));
        }
        if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {
          geometry.setAttribute("tangents", new BufferAttribute(this.mTangentBuffer, 3));
        }
        if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {
          geometry.setAttribute("bitangents", new BufferAttribute(this.mBitangentBuffer, 3));
        }
        if (this.mBones.length > 0) {
          var weights = [];
          var bones = [];
          for (let i2 = 0; i2 < this.mBones.length; i2++) {
            for (let j2 = 0; j2 < this.mBones[i2].mWeights.length; j2++) {
              var weight = this.mBones[i2].mWeights[j2];
              if (weight) {
                if (!weights[weight.mVertexId])
                  weights[weight.mVertexId] = [];
                if (!bones[weight.mVertexId])
                  bones[weight.mVertexId] = [];
                weights[weight.mVertexId].push(weight.mWeight);
                bones[weight.mVertexId].push(parseInt(i2));
              }
            }
          }
          for (let i2 in bones) {
            sortWeights(bones[i2], weights[i2]);
          }
          var _weights = [];
          var _bones = [];
          for (let i2 = 0; i2 < weights.length; i2++) {
            for (let j2 = 0; j2 < 4; j2++) {
              if (weights[i2] && bones[i2]) {
                _weights.push(weights[i2][j2]);
                _bones.push(bones[i2][j2]);
              } else {
                _weights.push(0);
                _bones.push(0);
              }
            }
          }
          geometry.setAttribute("skinWeight", new BufferAttribute(new Float32Array(_weights), BONESPERVERT));
          geometry.setAttribute("skinIndex", new BufferAttribute(new Float32Array(_bones), BONESPERVERT));
        }
        var mesh;
        if (this.mBones.length == 0)
          mesh = new Mesh(geometry, mat);
        if (this.mBones.length > 0) {
          mesh = new SkinnedMesh(geometry, mat);
          mesh.normalizeSkinWeights();
        }
        this.threeNode = mesh;
        return mesh;
      };
    }
    function aiFace() {
      this.mNumIndices = 0;
      this.mIndices = [];
    }
    function aiVector3D() {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.toTHREE = function() {
        return new Vector3(this.x, this.y, this.z);
      };
    }
    function aiColor3D() {
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
      this.toTHREE = function() {
        return new Color(this.r, this.g, this.b);
      };
    }
    function aiQuaternion() {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
      this.toTHREE = function() {
        return new Quaternion(this.x, this.y, this.z, this.w);
      };
    }
    function aiVertexWeight() {
      this.mVertexId = 0;
      this.mWeight = 0;
    }
    function aiString() {
      this.data = [];
      this.toString = function() {
        var str = "";
        this.data.forEach(function(i2) {
          str += String.fromCharCode(i2);
        });
        return str.replace(/[^\x20-\x7E]+/g, "");
      };
    }
    function aiVectorKey() {
      this.mTime = 0;
      this.mValue = null;
    }
    function aiQuatKey() {
      this.mTime = 0;
      this.mValue = null;
    }
    function aiNode() {
      this.mName = "";
      this.mTransformation = [];
      this.mNumChildren = 0;
      this.mNumMeshes = 0;
      this.mMeshes = [];
      this.mChildren = [];
      this.toTHREE = function(scene) {
        if (this.threeNode)
          return this.threeNode;
        var o = new Object3D();
        o.name = this.mName;
        o.matrix = this.mTransformation.toTHREE();
        for (let i2 = 0; i2 < this.mChildren.length; i2++) {
          o.add(this.mChildren[i2].toTHREE(scene));
        }
        for (let i2 = 0; i2 < this.mMeshes.length; i2++) {
          o.add(scene.mMeshes[this.mMeshes[i2]].toTHREE(scene));
        }
        this.threeNode = o;
        o.matrix.decompose(o.position, o.quaternion, o.scale);
        return o;
      };
    }
    function aiBone() {
      this.mName = "";
      this.mNumWeights = 0;
      this.mOffsetMatrix = 0;
    }
    function aiMaterialProperty() {
      this.mKey = "";
      this.mSemantic = 0;
      this.mIndex = 0;
      this.mData = [];
      this.mDataLength = 0;
      this.mType = 0;
      this.dataAsColor = function() {
        var array = new Uint8Array(this.mData).buffer;
        var reader = new DataView(array);
        var r = reader.getFloat32(0, true);
        var g2 = reader.getFloat32(4, true);
        var b3 = reader.getFloat32(8, true);
        return new Color(r, g2, b3);
      };
      this.dataAsFloat = function() {
        var array = new Uint8Array(this.mData).buffer;
        var reader = new DataView(array);
        var r = reader.getFloat32(0, true);
        return r;
      };
      this.dataAsBool = function() {
        var array = new Uint8Array(this.mData).buffer;
        var reader = new DataView(array);
        var r = reader.getFloat32(0, true);
        return !!r;
      };
      this.dataAsString = function() {
        var s = new aiString();
        s.data = this.mData;
        return s.toString();
      };
      this.dataAsMap = function() {
        var s = new aiString();
        s.data = this.mData;
        var path2 = s.toString();
        path2 = path2.replace(/\\/g, "/");
        if (path2.indexOf("/") != -1) {
          path2 = path2.substr(path2.lastIndexOf("/") + 1);
        }
        return textureLoader.load(path2);
      };
    }
    var namePropMapping = {
      "?mat.name": "name",
      "$mat.shadingm": "shading",
      "$mat.twosided": "twoSided",
      "$mat.wireframe": "wireframe",
      "$clr.ambient": "ambient",
      "$clr.diffuse": "color",
      "$clr.specular": "specular",
      "$clr.emissive": "emissive",
      "$clr.transparent": "transparent",
      "$clr.reflective": "reflect",
      "$mat.shininess": "shininess",
      "$mat.reflectivity": "reflectivity",
      "$mat.refracti": "refraction",
      "$tex.file": "map"
    };
    var nameTypeMapping = {
      "?mat.name": "string",
      "$mat.shadingm": "bool",
      "$mat.twosided": "bool",
      "$mat.wireframe": "bool",
      "$clr.ambient": "color",
      "$clr.diffuse": "color",
      "$clr.specular": "color",
      "$clr.emissive": "color",
      "$clr.transparent": "color",
      "$clr.reflective": "color",
      "$mat.shininess": "float",
      "$mat.reflectivity": "float",
      "$mat.refracti": "float",
      "$tex.file": "map"
    };
    function aiMaterial() {
      this.mNumAllocated = 0;
      this.mNumProperties = 0;
      this.mProperties = [];
      this.toTHREE = function() {
        var mat = new MeshPhongMaterial();
        for (let i2 = 0; i2 < this.mProperties.length; i2++) {
          if (nameTypeMapping[this.mProperties[i2].mKey] == "float") {
            mat[namePropMapping[this.mProperties[i2].mKey]] = this.mProperties[i2].dataAsFloat();
          }
          if (nameTypeMapping[this.mProperties[i2].mKey] == "color") {
            mat[namePropMapping[this.mProperties[i2].mKey]] = this.mProperties[i2].dataAsColor();
          }
          if (nameTypeMapping[this.mProperties[i2].mKey] == "bool") {
            mat[namePropMapping[this.mProperties[i2].mKey]] = this.mProperties[i2].dataAsBool();
          }
          if (nameTypeMapping[this.mProperties[i2].mKey] == "string") {
            mat[namePropMapping[this.mProperties[i2].mKey]] = this.mProperties[i2].dataAsString();
          }
          if (nameTypeMapping[this.mProperties[i2].mKey] == "map") {
            var prop = this.mProperties[i2];
            if (prop.mSemantic == aiTextureType_DIFFUSE)
              mat.map = this.mProperties[i2].dataAsMap();
            if (prop.mSemantic == aiTextureType_NORMALS)
              mat.normalMap = this.mProperties[i2].dataAsMap();
            if (prop.mSemantic == aiTextureType_LIGHTMAP)
              mat.lightMap = this.mProperties[i2].dataAsMap();
            if (prop.mSemantic == aiTextureType_OPACITY)
              mat.alphaMap = this.mProperties[i2].dataAsMap();
          }
        }
        mat.ambient.r = 0.53;
        mat.ambient.g = 0.53;
        mat.ambient.b = 0.53;
        mat.color.r = 1;
        mat.color.g = 1;
        mat.color.b = 1;
        return mat;
      };
    }
    function veclerp(v12, v2, l) {
      var v = new Vector3();
      var lm1 = 1 - l;
      v.x = v12.x * l + v2.x * lm1;
      v.y = v12.y * l + v2.y * lm1;
      v.z = v12.z * l + v2.z * lm1;
      return v;
    }
    function quatlerp(q1, q2, l) {
      return q1.clone().slerp(q2, 1 - l);
    }
    function sampleTrack(keys, time, lne, lerp) {
      if (keys.length == 1)
        return keys[0].mValue.toTHREE();
      var dist = Infinity;
      var key = null;
      var nextKey = null;
      for (let i2 = 0; i2 < keys.length; i2++) {
        var timeDist = Math.abs(keys[i2].mTime - time);
        if (timeDist < dist && keys[i2].mTime <= time) {
          dist = timeDist;
          key = keys[i2];
          nextKey = keys[i2 + 1];
        }
      }
      if (!key) {
        return null;
      } else if (nextKey) {
        var dT = nextKey.mTime - key.mTime;
        var T = key.mTime - time;
        var l = T / dT;
        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);
      } else {
        nextKey = keys[0].clone();
        nextKey.mTime += lne;
        var dT = nextKey.mTime - key.mTime;
        var T = key.mTime - time;
        var l = T / dT;
        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);
      }
    }
    function aiNodeAnim() {
      this.mNodeName = "";
      this.mNumPositionKeys = 0;
      this.mNumRotationKeys = 0;
      this.mNumScalingKeys = 0;
      this.mPositionKeys = [];
      this.mRotationKeys = [];
      this.mScalingKeys = [];
      this.mPreState = "";
      this.mPostState = "";
      this.init = function(tps) {
        if (!tps)
          tps = 1;
        function t2(t3) {
          t3.mTime /= tps;
        }
        this.mPositionKeys.forEach(t2);
        this.mRotationKeys.forEach(t2);
        this.mScalingKeys.forEach(t2);
      };
      this.sortKeys = function() {
        function comp(a2, b3) {
          return a2.mTime - b3.mTime;
        }
        this.mPositionKeys.sort(comp);
        this.mRotationKeys.sort(comp);
        this.mScalingKeys.sort(comp);
      };
      this.getLength = function() {
        return Math.max(Math.max.apply(null, this.mPositionKeys.map(function(a2) {
          return a2.mTime;
        })), Math.max.apply(null, this.mRotationKeys.map(function(a2) {
          return a2.mTime;
        })), Math.max.apply(null, this.mScalingKeys.map(function(a2) {
          return a2.mTime;
        })));
      };
      this.toTHREE = function(o) {
        this.sortKeys();
        var length2 = this.getLength();
        var track = new Virtulous.KeyFrameTrack();
        for (let i2 = 0; i2 < length2; i2 += 0.05) {
          var matrix3 = new Matrix4();
          var time = i2;
          var pos = sampleTrack(this.mPositionKeys, time, length2, veclerp);
          var scale = sampleTrack(this.mScalingKeys, time, length2, veclerp);
          var rotation = sampleTrack(this.mRotationKeys, time, length2, quatlerp);
          matrix3.compose(pos, rotation, scale);
          var key = new Virtulous.KeyFrame(time, matrix3);
          track.addKey(key);
        }
        track.target = o.findNode(this.mNodeName).toTHREE();
        var tracks = [track];
        if (o.nodeToBoneMap[this.mNodeName]) {
          for (let i2 = 0; i2 < o.nodeToBoneMap[this.mNodeName].length; i2++) {
            var t2 = track.clone();
            t2.target = o.nodeToBoneMap[this.mNodeName][i2];
            tracks.push(t2);
          }
        }
        return tracks;
      };
    }
    function aiAnimation() {
      this.mName = "";
      this.mDuration = 0;
      this.mTicksPerSecond = 0;
      this.mNumChannels = 0;
      this.mChannels = [];
      this.toTHREE = function(root) {
        var animationHandle = new Virtulous.Animation();
        for (let i2 in this.mChannels) {
          this.mChannels[i2].init(this.mTicksPerSecond);
          var tracks = this.mChannels[i2].toTHREE(root);
          for (let j2 in tracks) {
            tracks[j2].init();
            animationHandle.addTrack(tracks[j2]);
          }
        }
        animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function(e) {
          return e.length;
        }));
        return animationHandle;
      };
    }
    function aiTexture() {
      this.mWidth = 0;
      this.mHeight = 0;
      this.texAchFormatHint = [];
      this.pcData = [];
    }
    function aiLight() {
      this.mName = "";
      this.mType = 0;
      this.mAttenuationConstant = 0;
      this.mAttenuationLinear = 0;
      this.mAttenuationQuadratic = 0;
      this.mAngleInnerCone = 0;
      this.mAngleOuterCone = 0;
      this.mColorDiffuse = null;
      this.mColorSpecular = null;
      this.mColorAmbient = null;
    }
    function aiCamera() {
      this.mName = "";
      this.mPosition = null;
      this.mLookAt = null;
      this.mUp = null;
      this.mHorizontalFOV = 0;
      this.mClipPlaneNear = 0;
      this.mClipPlaneFar = 0;
      this.mAspect = 0;
    }
    function aiScene() {
      this.versionMajor = 0;
      this.versionMinor = 0;
      this.versionRevision = 0;
      this.compileFlags = 0;
      this.mFlags = 0;
      this.mNumMeshes = 0;
      this.mNumMaterials = 0;
      this.mNumAnimations = 0;
      this.mNumTextures = 0;
      this.mNumLights = 0;
      this.mNumCameras = 0;
      this.mRootNode = null;
      this.mMeshes = [];
      this.mMaterials = [];
      this.mAnimations = [];
      this.mLights = [];
      this.mCameras = [];
      this.nodeToBoneMap = {};
      this.findNode = function(name, root) {
        if (!root) {
          root = this.mRootNode;
        }
        if (root.mName == name) {
          return root;
        }
        for (let i2 = 0; i2 < root.mChildren.length; i2++) {
          var ret = this.findNode(name, root.mChildren[i2]);
          if (ret)
            return ret;
        }
        return null;
      };
      this.toTHREE = function() {
        this.nodeCount = 0;
        markBones(this);
        var o = this.mRootNode.toTHREE(this);
        for (let i2 in this.mMeshes)
          this.mMeshes[i2].hookupSkeletons(this);
        if (this.mAnimations.length > 0) {
          var a2 = this.mAnimations[0].toTHREE(this);
        }
        return {
          object: o,
          animation: a2
        };
      };
    }
    function aiMatrix4() {
      this.elements = [[], [], [], []];
      this.toTHREE = function() {
        var m = new Matrix4();
        for (let i2 = 0; i2 < 4; ++i2) {
          for (let i22 = 0; i22 < 4; ++i22) {
            m.elements[i2 * 4 + i22] = this.elements[i22][i2];
          }
        }
        return m;
      };
    }
    var littleEndian = true;
    function readFloat(dataview) {
      var val = dataview.getFloat32(dataview.readOffset, littleEndian);
      dataview.readOffset += 4;
      return val;
    }
    function Read_double(dataview) {
      var val = dataview.getFloat64(dataview.readOffset, littleEndian);
      dataview.readOffset += 8;
      return val;
    }
    function Read_uint8_t(dataview) {
      var val = dataview.getUint8(dataview.readOffset);
      dataview.readOffset += 1;
      return val;
    }
    function Read_uint16_t(dataview) {
      var val = dataview.getUint16(dataview.readOffset, littleEndian);
      dataview.readOffset += 2;
      return val;
    }
    function Read_unsigned_int(dataview) {
      var val = dataview.getUint32(dataview.readOffset, littleEndian);
      dataview.readOffset += 4;
      return val;
    }
    function Read_uint32_t(dataview) {
      var val = dataview.getUint32(dataview.readOffset, littleEndian);
      dataview.readOffset += 4;
      return val;
    }
    function Read_aiVector3D(stream) {
      var v = new aiVector3D();
      v.x = readFloat(stream);
      v.y = readFloat(stream);
      v.z = readFloat(stream);
      return v;
    }
    function Read_aiColor3D(stream) {
      var c = new aiColor3D();
      c.r = readFloat(stream);
      c.g = readFloat(stream);
      c.b = readFloat(stream);
      return c;
    }
    function Read_aiQuaternion(stream) {
      var v = new aiQuaternion();
      v.w = readFloat(stream);
      v.x = readFloat(stream);
      v.y = readFloat(stream);
      v.z = readFloat(stream);
      return v;
    }
    function Read_aiString(stream) {
      var s = new aiString();
      var stringlengthbytes = Read_unsigned_int(stream);
      stream.ReadBytes(s.data, 1, stringlengthbytes);
      return s.toString();
    }
    function Read_aiVertexWeight(stream) {
      var w = new aiVertexWeight();
      w.mVertexId = Read_unsigned_int(stream);
      w.mWeight = readFloat(stream);
      return w;
    }
    function Read_aiMatrix4x4(stream) {
      var m = new aiMatrix4();
      for (let i2 = 0; i2 < 4; ++i2) {
        for (let i22 = 0; i22 < 4; ++i22) {
          m.elements[i2][i22] = readFloat(stream);
        }
      }
      return m;
    }
    function Read_aiVectorKey(stream) {
      var v = new aiVectorKey();
      v.mTime = Read_double(stream);
      v.mValue = Read_aiVector3D(stream);
      return v;
    }
    function Read_aiQuatKey(stream) {
      var v = new aiQuatKey();
      v.mTime = Read_double(stream);
      v.mValue = Read_aiQuaternion(stream);
      return v;
    }
    function ReadArray_aiVertexWeight(stream, data, size2) {
      for (let i2 = 0; i2 < size2; i2++)
        data[i2] = Read_aiVertexWeight(stream);
    }
    function ReadArray_aiVectorKey(stream, data, size2) {
      for (let i2 = 0; i2 < size2; i2++)
        data[i2] = Read_aiVectorKey(stream);
    }
    function ReadArray_aiQuatKey(stream, data, size2) {
      for (let i2 = 0; i2 < size2; i2++)
        data[i2] = Read_aiQuatKey(stream);
    }
    function ReadBounds(stream, T, n) {
      return stream.Seek(sizeof(T) * n, aiOrigin_CUR);
    }
    function ai_assert(bool2) {
      if (!bool2)
        throw "asset failed";
    }
    function ReadBinaryNode(stream, parent, depth) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AINODE);
      Read_uint32_t(stream);
      var node = new aiNode();
      node.mParent = parent;
      node.mDepth = depth;
      node.mName = Read_aiString(stream);
      node.mTransformation = Read_aiMatrix4x4(stream);
      node.mNumChildren = Read_unsigned_int(stream);
      node.mNumMeshes = Read_unsigned_int(stream);
      if (node.mNumMeshes) {
        node.mMeshes = [];
        for (let i2 = 0; i2 < node.mNumMeshes; ++i2) {
          node.mMeshes[i2] = Read_unsigned_int(stream);
        }
      }
      if (node.mNumChildren) {
        node.mChildren = [];
        for (let i2 = 0; i2 < node.mNumChildren; ++i2) {
          var node2 = ReadBinaryNode(stream, node, depth++);
          node.mChildren[i2] = node2;
        }
      }
      return node;
    }
    function ReadBinaryBone(stream, b3) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);
      Read_uint32_t(stream);
      b3.mName = Read_aiString(stream);
      b3.mNumWeights = Read_unsigned_int(stream);
      b3.mOffsetMatrix = Read_aiMatrix4x4(stream);
      if (shortened) {
        ReadBounds(stream, b3.mWeights, b3.mNumWeights);
      } else {
        b3.mWeights = [];
        ReadArray_aiVertexWeight(stream, b3.mWeights, b3.mNumWeights);
      }
      return b3;
    }
    function ReadBinaryMesh(stream, mesh) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);
      Read_uint32_t(stream);
      mesh.mPrimitiveTypes = Read_unsigned_int(stream);
      mesh.mNumVertices = Read_unsigned_int(stream);
      mesh.mNumFaces = Read_unsigned_int(stream);
      mesh.mNumBones = Read_unsigned_int(stream);
      mesh.mMaterialIndex = Read_unsigned_int(stream);
      mesh.mNumUVComponents = [];
      var c = Read_unsigned_int(stream);
      if (c & ASSBIN_MESH_HAS_POSITIONS) {
        if (shortened) {
          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);
        } else {
          mesh.mVertices = [];
          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
        }
      }
      if (c & ASSBIN_MESH_HAS_NORMALS) {
        if (shortened) {
          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);
        } else {
          mesh.mNormals = [];
          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
        }
      }
      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {
        if (shortened) {
          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);
          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);
        } else {
          mesh.mTangents = [];
          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
          mesh.mBitangents = [];
          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
        }
      }
      for (let n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {
        if (!(c & ASSBIN_MESH_HAS_COLOR(n)))
          break;
        if (shortened) {
          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);
        } else {
          mesh.mColors[n] = [];
          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);
          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);
        }
      }
      mesh.mTexCoordsBuffers = [];
      for (let n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {
        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(n)))
          break;
        mesh.mNumUVComponents[n] = Read_unsigned_int(stream);
        if (shortened) {
          ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices);
        } else {
          mesh.mTextureCoords[n] = [];
          mesh.mTexCoordsBuffers[n] = [];
          for (let uv2 = 0; uv2 < mesh.mNumVertices; uv2++) {
            mesh.mTexCoordsBuffers[n].push(readFloat(stream));
            mesh.mTexCoordsBuffers[n].push(readFloat(stream));
            readFloat(stream);
          }
        }
      }
      if (shortened) {
        Read_unsigned_int(stream);
      } else {
        mesh.mFaces = [];
        mesh.mIndexArray = [];
        for (let i2 = 0; i2 < mesh.mNumFaces; ++i2) {
          var f = mesh.mFaces[i2] = new aiFace();
          f.mNumIndices = Read_uint16_t(stream);
          f.mIndices = [];
          for (let a2 = 0; a2 < f.mNumIndices; ++a2) {
            if (mesh.mNumVertices < 1 << 16) {
              f.mIndices[a2] = Read_uint16_t(stream);
            } else {
              f.mIndices[a2] = Read_unsigned_int(stream);
            }
          }
          if (f.mNumIndices === 3) {
            mesh.mIndexArray.push(f.mIndices[0]);
            mesh.mIndexArray.push(f.mIndices[1]);
            mesh.mIndexArray.push(f.mIndices[2]);
          } else if (f.mNumIndices === 4) {
            mesh.mIndexArray.push(f.mIndices[0]);
            mesh.mIndexArray.push(f.mIndices[1]);
            mesh.mIndexArray.push(f.mIndices[2]);
            mesh.mIndexArray.push(f.mIndices[2]);
            mesh.mIndexArray.push(f.mIndices[3]);
            mesh.mIndexArray.push(f.mIndices[0]);
          } else {
            throw new Error("Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.");
          }
        }
      }
      if (mesh.mNumBones) {
        mesh.mBones = [];
        for (let a2 = 0; a2 < mesh.mNumBones; ++a2) {
          mesh.mBones[a2] = new aiBone();
          ReadBinaryBone(stream, mesh.mBones[a2]);
        }
      }
    }
    function ReadBinaryMaterialProperty(stream, prop) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);
      Read_uint32_t(stream);
      prop.mKey = Read_aiString(stream);
      prop.mSemantic = Read_unsigned_int(stream);
      prop.mIndex = Read_unsigned_int(stream);
      prop.mDataLength = Read_unsigned_int(stream);
      prop.mType = Read_unsigned_int(stream);
      prop.mData = [];
      stream.ReadBytes(prop.mData, 1, prop.mDataLength);
    }
    function ReadBinaryMaterial(stream, mat) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);
      Read_uint32_t(stream);
      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);
      if (mat.mNumProperties) {
        if (mat.mProperties) {
          delete mat.mProperties;
        }
        mat.mProperties = [];
        for (let i2 = 0; i2 < mat.mNumProperties; ++i2) {
          mat.mProperties[i2] = new aiMaterialProperty();
          ReadBinaryMaterialProperty(stream, mat.mProperties[i2]);
        }
      }
    }
    function ReadBinaryNodeAnim(stream, nd) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);
      Read_uint32_t(stream);
      nd.mNodeName = Read_aiString(stream);
      nd.mNumPositionKeys = Read_unsigned_int(stream);
      nd.mNumRotationKeys = Read_unsigned_int(stream);
      nd.mNumScalingKeys = Read_unsigned_int(stream);
      nd.mPreState = Read_unsigned_int(stream);
      nd.mPostState = Read_unsigned_int(stream);
      if (nd.mNumPositionKeys) {
        if (shortened) {
          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);
        } else {
          nd.mPositionKeys = [];
          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);
        }
      }
      if (nd.mNumRotationKeys) {
        if (shortened) {
          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);
        } else {
          nd.mRotationKeys = [];
          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);
        }
      }
      if (nd.mNumScalingKeys) {
        if (shortened) {
          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);
        } else {
          nd.mScalingKeys = [];
          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);
        }
      }
    }
    function ReadBinaryAnim(stream, anim) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);
      Read_uint32_t(stream);
      anim.mName = Read_aiString(stream);
      anim.mDuration = Read_double(stream);
      anim.mTicksPerSecond = Read_double(stream);
      anim.mNumChannels = Read_unsigned_int(stream);
      if (anim.mNumChannels) {
        anim.mChannels = [];
        for (let a2 = 0; a2 < anim.mNumChannels; ++a2) {
          anim.mChannels[a2] = new aiNodeAnim();
          ReadBinaryNodeAnim(stream, anim.mChannels[a2]);
        }
      }
    }
    function ReadBinaryTexture(stream, tex) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);
      Read_uint32_t(stream);
      tex.mWidth = Read_unsigned_int(stream);
      tex.mHeight = Read_unsigned_int(stream);
      stream.ReadBytes(tex.achFormatHint, 1, 4);
      if (!shortened) {
        if (!tex.mHeight) {
          tex.pcData = [];
          stream.ReadBytes(tex.pcData, 1, tex.mWidth);
        } else {
          tex.pcData = [];
          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);
        }
      }
    }
    function ReadBinaryLight(stream, l) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);
      Read_uint32_t(stream);
      l.mName = Read_aiString(stream);
      l.mType = Read_unsigned_int(stream);
      if (l.mType != aiLightSource_DIRECTIONAL) {
        l.mAttenuationConstant = readFloat(stream);
        l.mAttenuationLinear = readFloat(stream);
        l.mAttenuationQuadratic = readFloat(stream);
      }
      l.mColorDiffuse = Read_aiColor3D(stream);
      l.mColorSpecular = Read_aiColor3D(stream);
      l.mColorAmbient = Read_aiColor3D(stream);
      if (l.mType == aiLightSource_SPOT) {
        l.mAngleInnerCone = readFloat(stream);
        l.mAngleOuterCone = readFloat(stream);
      }
    }
    function ReadBinaryCamera(stream, cam) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);
      Read_uint32_t(stream);
      cam.mName = Read_aiString(stream);
      cam.mPosition = Read_aiVector3D(stream);
      cam.mLookAt = Read_aiVector3D(stream);
      cam.mUp = Read_aiVector3D(stream);
      cam.mHorizontalFOV = readFloat(stream);
      cam.mClipPlaneNear = readFloat(stream);
      cam.mClipPlaneFar = readFloat(stream);
      cam.mAspect = readFloat(stream);
    }
    function ReadBinaryScene(stream, scene) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);
      Read_uint32_t(stream);
      scene.mFlags = Read_unsigned_int(stream);
      scene.mNumMeshes = Read_unsigned_int(stream);
      scene.mNumMaterials = Read_unsigned_int(stream);
      scene.mNumAnimations = Read_unsigned_int(stream);
      scene.mNumTextures = Read_unsigned_int(stream);
      scene.mNumLights = Read_unsigned_int(stream);
      scene.mNumCameras = Read_unsigned_int(stream);
      scene.mRootNode = new aiNode();
      scene.mRootNode = ReadBinaryNode(stream, null, 0);
      if (scene.mNumMeshes) {
        scene.mMeshes = [];
        for (let i2 = 0; i2 < scene.mNumMeshes; ++i2) {
          scene.mMeshes[i2] = new aiMesh();
          ReadBinaryMesh(stream, scene.mMeshes[i2]);
        }
      }
      if (scene.mNumMaterials) {
        scene.mMaterials = [];
        for (let i2 = 0; i2 < scene.mNumMaterials; ++i2) {
          scene.mMaterials[i2] = new aiMaterial();
          ReadBinaryMaterial(stream, scene.mMaterials[i2]);
        }
      }
      if (scene.mNumAnimations) {
        scene.mAnimations = [];
        for (let i2 = 0; i2 < scene.mNumAnimations; ++i2) {
          scene.mAnimations[i2] = new aiAnimation();
          ReadBinaryAnim(stream, scene.mAnimations[i2]);
        }
      }
      if (scene.mNumTextures) {
        scene.mTextures = [];
        for (let i2 = 0; i2 < scene.mNumTextures; ++i2) {
          scene.mTextures[i2] = new aiTexture();
          ReadBinaryTexture(stream, scene.mTextures[i2]);
        }
      }
      if (scene.mNumLights) {
        scene.mLights = [];
        for (let i2 = 0; i2 < scene.mNumLights; ++i2) {
          scene.mLights[i2] = new aiLight();
          ReadBinaryLight(stream, scene.mLights[i2]);
        }
      }
      if (scene.mNumCameras) {
        scene.mCameras = [];
        for (let i2 = 0; i2 < scene.mNumCameras; ++i2) {
          scene.mCameras[i2] = new aiCamera();
          ReadBinaryCamera(stream, scene.mCameras[i2]);
        }
      }
    }
    var aiOrigin_CUR = 0;
    var aiOrigin_BEG = 1;
    function extendStream(stream) {
      stream.readOffset = 0;
      stream.Seek = function(off, ori) {
        if (ori == aiOrigin_CUR) {
          stream.readOffset += off;
        }
        if (ori == aiOrigin_BEG) {
          stream.readOffset = off;
        }
      };
      stream.ReadBytes = function(buff, size2, n) {
        var bytes = size2 * n;
        for (let i2 = 0; i2 < bytes; i2++)
          buff[i2] = Read_uint8_t(this);
      };
      stream.subArray32 = function(start, end) {
        var buff = this.buffer;
        var newbuff = buff.slice(start, end);
        return new Float32Array(newbuff);
      };
      stream.subArrayUint16 = function(start, end) {
        var buff = this.buffer;
        var newbuff = buff.slice(start, end);
        return new Uint16Array(newbuff);
      };
      stream.subArrayUint8 = function(start, end) {
        var buff = this.buffer;
        var newbuff = buff.slice(start, end);
        return new Uint8Array(newbuff);
      };
      stream.subArrayUint32 = function(start, end) {
        var buff = this.buffer;
        var newbuff = buff.slice(start, end);
        return new Uint32Array(newbuff);
      };
    }
    var shortened, compressed;
    function InternReadFile(pFiledata) {
      var pScene = new aiScene();
      var stream = new DataView(pFiledata);
      extendStream(stream);
      stream.Seek(44, aiOrigin_CUR);
      pScene.versionMajor = Read_unsigned_int(stream);
      pScene.versionMinor = Read_unsigned_int(stream);
      pScene.versionRevision = Read_unsigned_int(stream);
      pScene.compileFlags = Read_unsigned_int(stream);
      shortened = Read_uint16_t(stream) > 0;
      compressed = Read_uint16_t(stream) > 0;
      if (shortened)
        throw "Shortened binaries are not supported!";
      stream.Seek(256, aiOrigin_CUR);
      stream.Seek(128, aiOrigin_CUR);
      stream.Seek(64, aiOrigin_CUR);
      if (compressed) {
        var uncompressedSize = Read_uint32_t(stream);
        var compressedSize = stream.FileSize() - stream.Tell();
        var compressedData = [];
        stream.Read(compressedData, 1, compressedSize);
        var uncompressedData = [];
        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize);
        var buff = new ArrayBuffer(uncompressedData);
        ReadBinaryScene(buff, pScene);
      } else {
        ReadBinaryScene(stream, pScene);
      }
      return pScene.toTHREE();
    }
    return InternReadFile(buffer2);
  }
});

// node_modules/three-stdlib/loaders/MDDLoader.js
var MDDLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.load(url, function(data) {
      onLoad(scope2.parse(data));
    }, onProgress, onError);
  }
  parse(data) {
    const view = new DataView(data);
    const totalFrames = view.getUint32(0);
    const totalPoints = view.getUint32(4);
    let offset = 8;
    const times = new Float32Array(totalFrames);
    const values = new Float32Array(totalFrames * totalFrames).fill(0);
    for (let i2 = 0; i2 < totalFrames; i2++) {
      times[i2] = view.getFloat32(offset);
      offset += 4;
      values[totalFrames * i2 + i2] = 1;
    }
    const track = new NumberKeyframeTrack(".morphTargetInfluences", times, values);
    const clip = new AnimationClip("default", times[times.length - 1], [track]);
    const morphTargets = [];
    for (let i2 = 0; i2 < totalFrames; i2++) {
      const morphTarget = new Float32Array(totalPoints * 3);
      for (let j2 = 0; j2 < totalPoints; j2++) {
        const stride = j2 * 3;
        morphTarget[stride + 0] = view.getFloat32(offset);
        offset += 4;
        morphTarget[stride + 1] = view.getFloat32(offset);
        offset += 4;
        morphTarget[stride + 2] = view.getFloat32(offset);
        offset += 4;
      }
      const attribute2 = new BufferAttribute(morphTarget, 3);
      attribute2.name = "morph_" + i2;
      morphTargets.push(attribute2);
    }
    return {
      morphTargets,
      clip
    };
  }
};

// node_modules/three-stdlib/loaders/EXRLoader.js
var EXRLoader = class extends DataTextureLoader {
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
  }
  parse(buffer2) {
    const USHORT_RANGE = 1 << 16;
    const BITMAP_SIZE = USHORT_RANGE >> 3;
    const HUF_ENCBITS = 16;
    const HUF_DECBITS = 14;
    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;
    const HUF_DECSIZE = 1 << HUF_DECBITS;
    const HUF_DECMASK = HUF_DECSIZE - 1;
    const NBITS = 16;
    const A_OFFSET = 1 << NBITS - 1;
    const MOD_MASK = (1 << NBITS) - 1;
    const SHORT_ZEROCODE_RUN = 59;
    const LONG_ZEROCODE_RUN = 63;
    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;
    const ULONG_SIZE = 8;
    const FLOAT32_SIZE = 4;
    const INT32_SIZE = 4;
    const INT16_SIZE = 2;
    const INT8_SIZE = 1;
    const STATIC_HUFFMAN = 0;
    const DEFLATE = 1;
    const UNKNOWN = 0;
    const LOSSY_DCT = 1;
    const RLE = 2;
    const logBase = Math.pow(2.7182818, 2.2);
    function reverseLutFromBitmap(bitmap, lut) {
      var k = 0;
      for (var i2 = 0; i2 < USHORT_RANGE; ++i2) {
        if (i2 == 0 || bitmap[i2 >> 3] & 1 << (i2 & 7)) {
          lut[k++] = i2;
        }
      }
      var n = k - 1;
      while (k < USHORT_RANGE)
        lut[k++] = 0;
      return n;
    }
    function hufClearDecTable(hdec) {
      for (var i2 = 0; i2 < HUF_DECSIZE; i2++) {
        hdec[i2] = {};
        hdec[i2].len = 0;
        hdec[i2].lit = 0;
        hdec[i2].p = null;
      }
    }
    const getBitsReturn = {
      l: 0,
      c: 0,
      lc: 0
    };
    function getBits(nBits, c, lc2, uInt8Array2, inOffset) {
      while (lc2 < nBits) {
        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);
        lc2 += 8;
      }
      lc2 -= nBits;
      getBitsReturn.l = c >> lc2 & (1 << nBits) - 1;
      getBitsReturn.c = c;
      getBitsReturn.lc = lc2;
    }
    const hufTableBuffer = new Array(59);
    function hufCanonicalCodeTable(hcode) {
      for (var i2 = 0; i2 <= 58; ++i2)
        hufTableBuffer[i2] = 0;
      for (var i2 = 0; i2 < HUF_ENCSIZE; ++i2)
        hufTableBuffer[hcode[i2]] += 1;
      var c = 0;
      for (var i2 = 58; i2 > 0; --i2) {
        var nc = c + hufTableBuffer[i2] >> 1;
        hufTableBuffer[i2] = c;
        c = nc;
      }
      for (var i2 = 0; i2 < HUF_ENCSIZE; ++i2) {
        var l = hcode[i2];
        if (l > 0)
          hcode[i2] = l | hufTableBuffer[l]++ << 6;
      }
    }
    function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {
      var p = inOffset;
      var c = 0;
      var lc2 = 0;
      for (; im <= iM; im++) {
        if (p.value - inOffset.value > ni)
          return false;
        getBits(6, c, lc2, uInt8Array2, p);
        var l = getBitsReturn.l;
        c = getBitsReturn.c;
        lc2 = getBitsReturn.lc;
        hcode[im] = l;
        if (l == LONG_ZEROCODE_RUN) {
          if (p.value - inOffset.value > ni) {
            throw "Something wrong with hufUnpackEncTable";
          }
          getBits(8, c, lc2, uInt8Array2, p);
          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
          c = getBitsReturn.c;
          lc2 = getBitsReturn.lc;
          if (im + zerun > iM + 1) {
            throw "Something wrong with hufUnpackEncTable";
          }
          while (zerun--)
            hcode[im++] = 0;
          im--;
        } else if (l >= SHORT_ZEROCODE_RUN) {
          var zerun = l - SHORT_ZEROCODE_RUN + 2;
          if (im + zerun > iM + 1) {
            throw "Something wrong with hufUnpackEncTable";
          }
          while (zerun--)
            hcode[im++] = 0;
          im--;
        }
      }
      hufCanonicalCodeTable(hcode);
    }
    function hufLength(code) {
      return code & 63;
    }
    function hufCode(code) {
      return code >> 6;
    }
    function hufBuildDecTable(hcode, im, iM, hdecod) {
      for (; im <= iM; im++) {
        var c = hufCode(hcode[im]);
        var l = hufLength(hcode[im]);
        if (c >> l) {
          throw "Invalid table entry";
        }
        if (l > HUF_DECBITS) {
          var pl = hdecod[c >> l - HUF_DECBITS];
          if (pl.len) {
            throw "Invalid table entry";
          }
          pl.lit++;
          if (pl.p) {
            var p = pl.p;
            pl.p = new Array(pl.lit);
            for (var i2 = 0; i2 < pl.lit - 1; ++i2) {
              pl.p[i2] = p[i2];
            }
          } else {
            pl.p = new Array(1);
          }
          pl.p[pl.lit - 1] = im;
        } else if (l) {
          var plOffset = 0;
          for (var i2 = 1 << HUF_DECBITS - l; i2 > 0; i2--) {
            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];
            if (pl.len || pl.p) {
              throw "Invalid table entry";
            }
            pl.len = l;
            pl.lit = im;
            plOffset++;
          }
        }
      }
      return true;
    }
    const getCharReturn = {
      c: 0,
      lc: 0
    };
    function getChar(c, lc2, uInt8Array2, inOffset) {
      c = c << 8 | parseUint8Array(uInt8Array2, inOffset);
      lc2 += 8;
      getCharReturn.c = c;
      getCharReturn.lc = lc2;
    }
    const getCodeReturn = {
      c: 0,
      lc: 0
    };
    function getCode(po, rlc, c, lc2, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {
      if (po == rlc) {
        if (lc2 < 8) {
          getChar(c, lc2, uInt8Array2, inOffset);
          c = getCharReturn.c;
          lc2 = getCharReturn.lc;
        }
        lc2 -= 8;
        var cs = c >> lc2;
        var cs = new Uint8Array([cs])[0];
        if (outBufferOffset.value + cs > outBufferEndOffset) {
          return false;
        }
        var s = outBuffer[outBufferOffset.value - 1];
        while (cs-- > 0) {
          outBuffer[outBufferOffset.value++] = s;
        }
      } else if (outBufferOffset.value < outBufferEndOffset) {
        outBuffer[outBufferOffset.value++] = po;
      } else {
        return false;
      }
      getCodeReturn.c = c;
      getCodeReturn.lc = lc2;
    }
    function UInt16(value) {
      return value & 65535;
    }
    function Int16(value) {
      var ref = UInt16(value);
      return ref > 32767 ? ref - 65536 : ref;
    }
    const wdec14Return = {
      a: 0,
      b: 0
    };
    function wdec14(l, h) {
      var ls = Int16(l);
      var hs = Int16(h);
      var hi = hs;
      var ai = ls + (hi & 1) + (hi >> 1);
      var as = ai;
      var bs = ai - hi;
      wdec14Return.a = as;
      wdec14Return.b = bs;
    }
    function wdec16(l, h) {
      var m = UInt16(l);
      var d = UInt16(h);
      var bb = m - (d >> 1) & MOD_MASK;
      var aa = d + bb - A_OFFSET & MOD_MASK;
      wdec14Return.a = aa;
      wdec14Return.b = bb;
    }
    function wav2Decode(buffer3, j2, nx, ox, ny, oy, mx) {
      var w14 = mx < 1 << 14;
      var n = nx > ny ? ny : nx;
      var p = 1;
      var p2;
      while (p <= n)
        p <<= 1;
      p >>= 1;
      p2 = p;
      p >>= 1;
      while (p >= 1) {
        var py = 0;
        var ey = py + oy * (ny - p2);
        var oy1 = oy * p;
        var oy2 = oy * p2;
        var ox1 = ox * p;
        var ox2 = ox * p2;
        var i00, i01, i10, i11;
        for (; py <= ey; py += oy2) {
          var px = py;
          var ex = py + ox * (nx - p2);
          for (; px <= ex; px += ox2) {
            var p01 = px + ox1;
            var p10 = px + oy1;
            var p11 = p10 + ox1;
            if (w14) {
              wdec14(buffer3[px + j2], buffer3[p10 + j2]);
              i00 = wdec14Return.a;
              i10 = wdec14Return.b;
              wdec14(buffer3[p01 + j2], buffer3[p11 + j2]);
              i01 = wdec14Return.a;
              i11 = wdec14Return.b;
              wdec14(i00, i01);
              buffer3[px + j2] = wdec14Return.a;
              buffer3[p01 + j2] = wdec14Return.b;
              wdec14(i10, i11);
              buffer3[p10 + j2] = wdec14Return.a;
              buffer3[p11 + j2] = wdec14Return.b;
            } else {
              wdec16(buffer3[px + j2], buffer3[p10 + j2]);
              i00 = wdec14Return.a;
              i10 = wdec14Return.b;
              wdec16(buffer3[p01 + j2], buffer3[p11 + j2]);
              i01 = wdec14Return.a;
              i11 = wdec14Return.b;
              wdec16(i00, i01);
              buffer3[px + j2] = wdec14Return.a;
              buffer3[p01 + j2] = wdec14Return.b;
              wdec16(i10, i11);
              buffer3[p10 + j2] = wdec14Return.a;
              buffer3[p11 + j2] = wdec14Return.b;
            }
          }
          if (nx & p) {
            var p10 = px + oy1;
            if (w14)
              wdec14(buffer3[px + j2], buffer3[p10 + j2]);
            else
              wdec16(buffer3[px + j2], buffer3[p10 + j2]);
            i00 = wdec14Return.a;
            buffer3[p10 + j2] = wdec14Return.b;
            buffer3[px + j2] = i00;
          }
        }
        if (ny & p) {
          var px = py;
          var ex = py + ox * (nx - p2);
          for (; px <= ex; px += ox2) {
            var p01 = px + ox1;
            if (w14)
              wdec14(buffer3[px + j2], buffer3[p01 + j2]);
            else
              wdec16(buffer3[px + j2], buffer3[p01 + j2]);
            i00 = wdec14Return.a;
            buffer3[p01 + j2] = wdec14Return.b;
            buffer3[px + j2] = i00;
          }
        }
        p2 = p;
        p >>= 1;
      }
      return py;
    }
    function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {
      var c = 0;
      var lc2 = 0;
      var outBufferEndOffset = no;
      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);
      while (inOffset.value < inOffsetEnd) {
        getChar(c, lc2, uInt8Array2, inOffset);
        c = getCharReturn.c;
        lc2 = getCharReturn.lc;
        while (lc2 >= HUF_DECBITS) {
          var index = c >> lc2 - HUF_DECBITS & HUF_DECMASK;
          var pl = decodingTable[index];
          if (pl.len) {
            lc2 -= pl.len;
            getCode(pl.lit, rlc, c, lc2, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);
            c = getCodeReturn.c;
            lc2 = getCodeReturn.lc;
          } else {
            if (!pl.p) {
              throw "hufDecode issues";
            }
            var j2;
            for (j2 = 0; j2 < pl.lit; j2++) {
              var l = hufLength(encodingTable[pl.p[j2]]);
              while (lc2 < l && inOffset.value < inOffsetEnd) {
                getChar(c, lc2, uInt8Array2, inOffset);
                c = getCharReturn.c;
                lc2 = getCharReturn.lc;
              }
              if (lc2 >= l) {
                if (hufCode(encodingTable[pl.p[j2]]) == (c >> lc2 - l & (1 << l) - 1)) {
                  lc2 -= l;
                  getCode(pl.p[j2], rlc, c, lc2, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);
                  c = getCodeReturn.c;
                  lc2 = getCodeReturn.lc;
                  break;
                }
              }
            }
            if (j2 == pl.lit) {
              throw "hufDecode issues";
            }
          }
        }
      }
      var i2 = 8 - ni & 7;
      c >>= i2;
      lc2 -= i2;
      while (lc2 > 0) {
        var pl = decodingTable[c << HUF_DECBITS - lc2 & HUF_DECMASK];
        if (pl.len) {
          lc2 -= pl.len;
          getCode(pl.lit, rlc, c, lc2, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);
          c = getCodeReturn.c;
          lc2 = getCodeReturn.lc;
        } else {
          throw "hufDecode issues";
        }
      }
      return true;
    }
    function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {
      var outOffset = {
        value: 0
      };
      var initialInOffset = inOffset.value;
      var im = parseUint32(inDataView, inOffset);
      var iM = parseUint32(inDataView, inOffset);
      inOffset.value += 4;
      var nBits = parseUint32(inDataView, inOffset);
      inOffset.value += 4;
      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {
        throw "Something wrong with HUF_ENCSIZE";
      }
      var freq = new Array(HUF_ENCSIZE);
      var hdec = new Array(HUF_DECSIZE);
      hufClearDecTable(hdec);
      var ni = nCompressed - (inOffset.value - initialInOffset);
      hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);
      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {
        throw "Something wrong with hufUncompress";
      }
      hufBuildDecTable(freq, im, iM, hdec);
      hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);
    }
    function applyLut(lut, data, nData) {
      for (var i2 = 0; i2 < nData; ++i2) {
        data[i2] = lut[data[i2]];
      }
    }
    function predictor(source) {
      for (var t2 = 1; t2 < source.length; t2++) {
        var d = source[t2 - 1] + source[t2] - 128;
        source[t2] = d;
      }
    }
    function interleaveScalar(source, out) {
      var t1 = 0;
      var t2 = Math.floor((source.length + 1) / 2);
      var s = 0;
      var stop = source.length - 1;
      while (true) {
        if (s > stop)
          break;
        out[s++] = source[t1++];
        if (s > stop)
          break;
        out[s++] = source[t2++];
      }
    }
    function decodeRunLength(source) {
      var size2 = source.byteLength;
      var out = new Array();
      var p = 0;
      var reader = new DataView(source);
      while (size2 > 0) {
        var l = reader.getInt8(p++);
        if (l < 0) {
          var count = -l;
          size2 -= count + 1;
          for (var i2 = 0; i2 < count; i2++) {
            out.push(reader.getUint8(p++));
          }
        } else {
          var count = l;
          size2 -= 2;
          var value = reader.getUint8(p++);
          for (var i2 = 0; i2 < count + 1; i2++) {
            out.push(value);
          }
        }
      }
      return out;
    }
    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {
      var dataView = new DataView(outBuffer.buffer);
      var width = channelData[cscSet.idx[0]].width;
      var height = channelData[cscSet.idx[0]].height;
      var numComp = 3;
      var numFullBlocksX = Math.floor(width / 8);
      var numBlocksX = Math.ceil(width / 8);
      var numBlocksY = Math.ceil(height / 8);
      var leftoverX = width - (numBlocksX - 1) * 8;
      var leftoverY = height - (numBlocksY - 1) * 8;
      var currAcComp = {
        value: 0
      };
      var currDcComp = new Array(numComp);
      var dctData = new Array(numComp);
      var halfZigBlock = new Array(numComp);
      var rowBlock = new Array(numComp);
      var rowOffsets = new Array(numComp);
      for (let comp2 = 0; comp2 < numComp; ++comp2) {
        rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];
        currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;
        dctData[comp2] = new Float32Array(64);
        halfZigBlock[comp2] = new Uint16Array(64);
        rowBlock[comp2] = new Uint16Array(numBlocksX * 64);
      }
      for (let blocky = 0; blocky < numBlocksY; ++blocky) {
        var maxY = 8;
        if (blocky == numBlocksY - 1)
          maxY = leftoverY;
        var maxX = 8;
        for (let blockx = 0; blockx < numBlocksX; ++blockx) {
          if (blockx == numBlocksX - 1)
            maxX = leftoverX;
          for (let comp2 = 0; comp2 < numComp; ++comp2) {
            halfZigBlock[comp2].fill(0);
            halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];
            unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);
            unZigZag(halfZigBlock[comp2], dctData[comp2]);
            dctInverse(dctData[comp2]);
          }
          {
            csc709Inverse(dctData);
          }
          for (let comp2 = 0; comp2 < numComp; ++comp2) {
            convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);
          }
        }
        let offset2 = 0;
        for (let comp2 = 0; comp2 < numComp; ++comp2) {
          const type3 = channelData[cscSet.idx[comp2]].type;
          for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {
            offset2 = rowOffsets[comp2][y2];
            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {
              const src = blockx * 64 + (y2 & 7) * 8;
              dataView.setUint16(offset2 + 0 * INT16_SIZE * type3, rowBlock[comp2][src + 0], true);
              dataView.setUint16(offset2 + 1 * INT16_SIZE * type3, rowBlock[comp2][src + 1], true);
              dataView.setUint16(offset2 + 2 * INT16_SIZE * type3, rowBlock[comp2][src + 2], true);
              dataView.setUint16(offset2 + 3 * INT16_SIZE * type3, rowBlock[comp2][src + 3], true);
              dataView.setUint16(offset2 + 4 * INT16_SIZE * type3, rowBlock[comp2][src + 4], true);
              dataView.setUint16(offset2 + 5 * INT16_SIZE * type3, rowBlock[comp2][src + 5], true);
              dataView.setUint16(offset2 + 6 * INT16_SIZE * type3, rowBlock[comp2][src + 6], true);
              dataView.setUint16(offset2 + 7 * INT16_SIZE * type3, rowBlock[comp2][src + 7], true);
              offset2 += 8 * INT16_SIZE * type3;
            }
          }
          if (numFullBlocksX != numBlocksX) {
            for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {
              const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type3;
              const src = numFullBlocksX * 64 + (y2 & 7) * 8;
              for (let x2 = 0; x2 < maxX; ++x2) {
                dataView.setUint16(offset3 + x2 * INT16_SIZE * type3, rowBlock[comp2][src + x2], true);
              }
            }
          }
        }
      }
      var halfRow = new Uint16Array(width);
      var dataView = new DataView(outBuffer.buffer);
      for (var comp = 0; comp < numComp; ++comp) {
        channelData[cscSet.idx[comp]].decoded = true;
        var type2 = channelData[cscSet.idx[comp]].type;
        if (channelData[comp].type != 2)
          continue;
        for (var y = 0; y < height; ++y) {
          const offset2 = rowOffsets[comp][y];
          for (var x = 0; x < width; ++x) {
            halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type2, true);
          }
          for (var x = 0; x < width; ++x) {
            dataView.setFloat32(offset2 + x * INT16_SIZE * type2, decodeFloat16(halfRow[x]), true);
          }
        }
      }
    }
    function unRleAC(currAcComp, acBuffer, halfZigBlock) {
      var acValue;
      var dctComp = 1;
      while (dctComp < 64) {
        acValue = acBuffer[currAcComp.value];
        if (acValue == 65280) {
          dctComp = 64;
        } else if (acValue >> 8 == 255) {
          dctComp += acValue & 255;
        } else {
          halfZigBlock[dctComp] = acValue;
          dctComp++;
        }
        currAcComp.value++;
      }
    }
    function unZigZag(src, dst) {
      dst[0] = decodeFloat16(src[0]);
      dst[1] = decodeFloat16(src[1]);
      dst[2] = decodeFloat16(src[5]);
      dst[3] = decodeFloat16(src[6]);
      dst[4] = decodeFloat16(src[14]);
      dst[5] = decodeFloat16(src[15]);
      dst[6] = decodeFloat16(src[27]);
      dst[7] = decodeFloat16(src[28]);
      dst[8] = decodeFloat16(src[2]);
      dst[9] = decodeFloat16(src[4]);
      dst[10] = decodeFloat16(src[7]);
      dst[11] = decodeFloat16(src[13]);
      dst[12] = decodeFloat16(src[16]);
      dst[13] = decodeFloat16(src[26]);
      dst[14] = decodeFloat16(src[29]);
      dst[15] = decodeFloat16(src[42]);
      dst[16] = decodeFloat16(src[3]);
      dst[17] = decodeFloat16(src[8]);
      dst[18] = decodeFloat16(src[12]);
      dst[19] = decodeFloat16(src[17]);
      dst[20] = decodeFloat16(src[25]);
      dst[21] = decodeFloat16(src[30]);
      dst[22] = decodeFloat16(src[41]);
      dst[23] = decodeFloat16(src[43]);
      dst[24] = decodeFloat16(src[9]);
      dst[25] = decodeFloat16(src[11]);
      dst[26] = decodeFloat16(src[18]);
      dst[27] = decodeFloat16(src[24]);
      dst[28] = decodeFloat16(src[31]);
      dst[29] = decodeFloat16(src[40]);
      dst[30] = decodeFloat16(src[44]);
      dst[31] = decodeFloat16(src[53]);
      dst[32] = decodeFloat16(src[10]);
      dst[33] = decodeFloat16(src[19]);
      dst[34] = decodeFloat16(src[23]);
      dst[35] = decodeFloat16(src[32]);
      dst[36] = decodeFloat16(src[39]);
      dst[37] = decodeFloat16(src[45]);
      dst[38] = decodeFloat16(src[52]);
      dst[39] = decodeFloat16(src[54]);
      dst[40] = decodeFloat16(src[20]);
      dst[41] = decodeFloat16(src[22]);
      dst[42] = decodeFloat16(src[33]);
      dst[43] = decodeFloat16(src[38]);
      dst[44] = decodeFloat16(src[46]);
      dst[45] = decodeFloat16(src[51]);
      dst[46] = decodeFloat16(src[55]);
      dst[47] = decodeFloat16(src[60]);
      dst[48] = decodeFloat16(src[21]);
      dst[49] = decodeFloat16(src[34]);
      dst[50] = decodeFloat16(src[37]);
      dst[51] = decodeFloat16(src[47]);
      dst[52] = decodeFloat16(src[50]);
      dst[53] = decodeFloat16(src[56]);
      dst[54] = decodeFloat16(src[59]);
      dst[55] = decodeFloat16(src[61]);
      dst[56] = decodeFloat16(src[35]);
      dst[57] = decodeFloat16(src[36]);
      dst[58] = decodeFloat16(src[48]);
      dst[59] = decodeFloat16(src[49]);
      dst[60] = decodeFloat16(src[57]);
      dst[61] = decodeFloat16(src[58]);
      dst[62] = decodeFloat16(src[62]);
      dst[63] = decodeFloat16(src[63]);
    }
    function dctInverse(data) {
      const a2 = 0.5 * Math.cos(3.14159 / 4);
      const b3 = 0.5 * Math.cos(3.14159 / 16);
      const c = 0.5 * Math.cos(3.14159 / 8);
      const d = 0.5 * Math.cos(3 * 3.14159 / 16);
      const e = 0.5 * Math.cos(5 * 3.14159 / 16);
      const f = 0.5 * Math.cos(3 * 3.14159 / 8);
      const g2 = 0.5 * Math.cos(7 * 3.14159 / 16);
      var alpha = new Array(4);
      var beta = new Array(4);
      var theta = new Array(4);
      var gamma = new Array(4);
      for (var row = 0; row < 8; ++row) {
        var rowPtr = row * 8;
        alpha[0] = c * data[rowPtr + 2];
        alpha[1] = f * data[rowPtr + 2];
        alpha[2] = c * data[rowPtr + 6];
        alpha[3] = f * data[rowPtr + 6];
        beta[0] = b3 * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g2 * data[rowPtr + 7];
        beta[1] = d * data[rowPtr + 1] - g2 * data[rowPtr + 3] - b3 * data[rowPtr + 5] - e * data[rowPtr + 7];
        beta[2] = e * data[rowPtr + 1] - b3 * data[rowPtr + 3] + g2 * data[rowPtr + 5] + d * data[rowPtr + 7];
        beta[3] = g2 * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b3 * data[rowPtr + 7];
        theta[0] = a2 * (data[rowPtr + 0] + data[rowPtr + 4]);
        theta[3] = a2 * (data[rowPtr + 0] - data[rowPtr + 4]);
        theta[1] = alpha[0] + alpha[3];
        theta[2] = alpha[1] - alpha[2];
        gamma[0] = theta[0] + theta[1];
        gamma[1] = theta[3] + theta[2];
        gamma[2] = theta[3] - theta[2];
        gamma[3] = theta[0] - theta[1];
        data[rowPtr + 0] = gamma[0] + beta[0];
        data[rowPtr + 1] = gamma[1] + beta[1];
        data[rowPtr + 2] = gamma[2] + beta[2];
        data[rowPtr + 3] = gamma[3] + beta[3];
        data[rowPtr + 4] = gamma[3] - beta[3];
        data[rowPtr + 5] = gamma[2] - beta[2];
        data[rowPtr + 6] = gamma[1] - beta[1];
        data[rowPtr + 7] = gamma[0] - beta[0];
      }
      for (var column = 0; column < 8; ++column) {
        alpha[0] = c * data[16 + column];
        alpha[1] = f * data[16 + column];
        alpha[2] = c * data[48 + column];
        alpha[3] = f * data[48 + column];
        beta[0] = b3 * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g2 * data[56 + column];
        beta[1] = d * data[8 + column] - g2 * data[24 + column] - b3 * data[40 + column] - e * data[56 + column];
        beta[2] = e * data[8 + column] - b3 * data[24 + column] + g2 * data[40 + column] + d * data[56 + column];
        beta[3] = g2 * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b3 * data[56 + column];
        theta[0] = a2 * (data[column] + data[32 + column]);
        theta[3] = a2 * (data[column] - data[32 + column]);
        theta[1] = alpha[0] + alpha[3];
        theta[2] = alpha[1] - alpha[2];
        gamma[0] = theta[0] + theta[1];
        gamma[1] = theta[3] + theta[2];
        gamma[2] = theta[3] - theta[2];
        gamma[3] = theta[0] - theta[1];
        data[0 + column] = gamma[0] + beta[0];
        data[8 + column] = gamma[1] + beta[1];
        data[16 + column] = gamma[2] + beta[2];
        data[24 + column] = gamma[3] + beta[3];
        data[32 + column] = gamma[3] - beta[3];
        data[40 + column] = gamma[2] - beta[2];
        data[48 + column] = gamma[1] - beta[1];
        data[56 + column] = gamma[0] - beta[0];
      }
    }
    function csc709Inverse(data) {
      for (var i2 = 0; i2 < 64; ++i2) {
        var y = data[0][i2];
        var cb2 = data[1][i2];
        var cr = data[2][i2];
        data[0][i2] = y + 1.5747 * cr;
        data[1][i2] = y - 0.1873 * cb2 - 0.4682 * cr;
        data[2][i2] = y + 1.8556 * cb2;
      }
    }
    function convertToHalf(src, dst, idx) {
      for (var i2 = 0; i2 < 64; ++i2) {
        dst[idx + i2] = DataUtils.toHalfFloat(toLinear(src[i2]));
      }
    }
    function toLinear(float2) {
      if (float2 <= 1) {
        return Math.sign(float2) * Math.pow(Math.abs(float2), 2.2);
      } else {
        return Math.sign(float2) * Math.pow(logBase, Math.abs(float2) - 1);
      }
    }
    function uncompressRAW(info) {
      return new DataView(info.array.buffer, info.offset.value, info.size);
    }
    function uncompressRLE(info) {
      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);
      var rawBuffer = new Uint8Array(decodeRunLength(compressed));
      var tmpBuffer = new Uint8Array(rawBuffer.length);
      predictor(rawBuffer);
      interleaveScalar(rawBuffer, tmpBuffer);
      return new DataView(tmpBuffer.buffer);
    }
    function uncompressZIP(info) {
      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);
      var rawBuffer = unzlibSync(compressed);
      var tmpBuffer = new Uint8Array(rawBuffer.length);
      predictor(rawBuffer);
      interleaveScalar(rawBuffer, tmpBuffer);
      return new DataView(tmpBuffer.buffer);
    }
    function uncompressPIZ(info) {
      var inDataView = info.viewer;
      var inOffset = {
        value: info.offset.value
      };
      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));
      var bitmap = new Uint8Array(BITMAP_SIZE);
      var outBufferEnd = 0;
      var pizChannelData = new Array(info.channels);
      for (var i2 = 0; i2 < info.channels; i2++) {
        pizChannelData[i2] = {};
        pizChannelData[i2]["start"] = outBufferEnd;
        pizChannelData[i2]["end"] = pizChannelData[i2]["start"];
        pizChannelData[i2]["nx"] = info.width;
        pizChannelData[i2]["ny"] = info.lines;
        pizChannelData[i2]["size"] = info.type;
        outBufferEnd += pizChannelData[i2].nx * pizChannelData[i2].ny * pizChannelData[i2].size;
      }
      var minNonZero = parseUint16(inDataView, inOffset);
      var maxNonZero = parseUint16(inDataView, inOffset);
      if (maxNonZero >= BITMAP_SIZE) {
        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
      }
      if (minNonZero <= maxNonZero) {
        for (var i2 = 0; i2 < maxNonZero - minNonZero + 1; i2++) {
          bitmap[i2 + minNonZero] = parseUint8(inDataView, inOffset);
        }
      }
      var lut = new Uint16Array(USHORT_RANGE);
      var maxValue = reverseLutFromBitmap(bitmap, lut);
      var length2 = parseUint32(inDataView, inOffset);
      hufUncompress(info.array, inDataView, inOffset, length2, outBuffer, outBufferEnd);
      for (var i2 = 0; i2 < info.channels; ++i2) {
        var cd = pizChannelData[i2];
        for (var j2 = 0; j2 < pizChannelData[i2].size; ++j2) {
          wav2Decode(outBuffer, cd.start + j2, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);
        }
      }
      applyLut(lut, outBuffer, outBufferEnd);
      var tmpOffset2 = 0;
      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);
      for (var y = 0; y < info.lines; y++) {
        for (var c = 0; c < info.channels; c++) {
          var cd = pizChannelData[c];
          var n = cd.nx * cd.size;
          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);
          tmpBuffer.set(cp, tmpOffset2);
          tmpOffset2 += n * INT16_SIZE;
          cd.end += n;
        }
      }
      return new DataView(tmpBuffer.buffer);
    }
    function uncompressPXR(info) {
      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);
      var rawBuffer = unzlibSync(compressed);
      const sz = info.lines * info.channels * info.width;
      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);
      let tmpBufferEnd = 0;
      let writePtr = 0;
      const ptr = new Array(4);
      for (let y = 0; y < info.lines; y++) {
        for (let c = 0; c < info.channels; c++) {
          let pixel = 0;
          switch (info.type) {
            case 1:
              ptr[0] = tmpBufferEnd;
              ptr[1] = ptr[0] + info.width;
              tmpBufferEnd = ptr[1] + info.width;
              for (let j2 = 0; j2 < info.width; ++j2) {
                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];
                pixel += diff;
                tmpBuffer[writePtr] = pixel;
                writePtr++;
              }
              break;
            case 2:
              ptr[0] = tmpBufferEnd;
              ptr[1] = ptr[0] + info.width;
              ptr[2] = ptr[1] + info.width;
              tmpBufferEnd = ptr[2] + info.width;
              for (let j2 = 0; j2 < info.width; ++j2) {
                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;
                pixel += diff;
                tmpBuffer[writePtr] = pixel;
                writePtr++;
              }
              break;
          }
        }
      }
      return new DataView(tmpBuffer.buffer);
    }
    function uncompressDWA(info) {
      var inDataView = info.viewer;
      var inOffset = {
        value: info.offset.value
      };
      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));
      var dwaHeader = {
        version: parseInt64(inDataView, inOffset),
        unknownUncompressedSize: parseInt64(inDataView, inOffset),
        unknownCompressedSize: parseInt64(inDataView, inOffset),
        acCompressedSize: parseInt64(inDataView, inOffset),
        dcCompressedSize: parseInt64(inDataView, inOffset),
        rleCompressedSize: parseInt64(inDataView, inOffset),
        rleUncompressedSize: parseInt64(inDataView, inOffset),
        rleRawSize: parseInt64(inDataView, inOffset),
        totalAcUncompressedCount: parseInt64(inDataView, inOffset),
        totalDcUncompressedCount: parseInt64(inDataView, inOffset),
        acCompression: parseInt64(inDataView, inOffset)
      };
      if (dwaHeader.version < 2) {
        throw "EXRLoader.parse: " + EXRHeader.compression + " version " + dwaHeader.version + " is unsupported";
      }
      var channelRules = new Array();
      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;
      while (ruleSize > 0) {
        var name = parseNullTerminatedString(inDataView.buffer, inOffset);
        var value = parseUint8(inDataView, inOffset);
        var compression = value >> 2 & 3;
        var csc = (value >> 4) - 1;
        var index = new Int8Array([csc])[0];
        var type2 = parseUint8(inDataView, inOffset);
        channelRules.push({
          name,
          index,
          type: type2,
          compression
        });
        ruleSize -= name.length + 3;
      }
      var channels = EXRHeader.channels;
      var channelData = new Array(info.channels);
      for (var i2 = 0; i2 < info.channels; ++i2) {
        var cd = channelData[i2] = {};
        var channel = channels[i2];
        cd.name = channel.name;
        cd.compression = UNKNOWN;
        cd.decoded = false;
        cd.type = channel.pixelType;
        cd.pLinear = channel.pLinear;
        cd.width = info.width;
        cd.height = info.lines;
      }
      var cscSet = {
        idx: new Array(3)
      };
      for (var offset2 = 0; offset2 < info.channels; ++offset2) {
        var cd = channelData[offset2];
        for (var i2 = 0; i2 < channelRules.length; ++i2) {
          var rule = channelRules[i2];
          if (cd.name == rule.name) {
            cd.compression = rule.compression;
            if (rule.index >= 0) {
              cscSet.idx[rule.index] = offset2;
            }
            cd.offset = offset2;
          }
        }
      }
      if (dwaHeader.acCompressedSize > 0) {
        switch (dwaHeader.acCompression) {
          case STATIC_HUFFMAN:
            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);
            hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);
            break;
          case DEFLATE:
            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);
            var data = unzlibSync(compressed);
            var acBuffer = new Uint16Array(data.buffer);
            inOffset.value += dwaHeader.totalAcUncompressedCount;
            break;
        }
      }
      if (dwaHeader.dcCompressedSize > 0) {
        var zlibInfo = {
          array: info.array,
          offset: inOffset,
          size: dwaHeader.dcCompressedSize
        };
        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);
        inOffset.value += dwaHeader.dcCompressedSize;
      }
      if (dwaHeader.rleRawSize > 0) {
        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);
        var data = unzlibSync(compressed);
        var rleBuffer = decodeRunLength(data.buffer);
        inOffset.value += dwaHeader.rleCompressedSize;
      }
      var outBufferEnd = 0;
      var rowOffsets = new Array(channelData.length);
      for (var i2 = 0; i2 < rowOffsets.length; ++i2) {
        rowOffsets[i2] = new Array();
      }
      for (var y = 0; y < info.lines; ++y) {
        for (var chan = 0; chan < channelData.length; ++chan) {
          rowOffsets[chan].push(outBufferEnd);
          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;
        }
      }
      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);
      for (var i2 = 0; i2 < channelData.length; ++i2) {
        var cd = channelData[i2];
        if (cd.decoded)
          continue;
        switch (cd.compression) {
          case RLE:
            var row = 0;
            var rleOffset = 0;
            for (var y = 0; y < info.lines; ++y) {
              var rowOffsetBytes = rowOffsets[i2][row];
              for (var x = 0; x < cd.width; ++x) {
                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {
                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];
                }
                rleOffset++;
              }
              row++;
            }
            break;
          case LOSSY_DCT:
          default:
            throw "EXRLoader.parse: unsupported channel compression";
        }
      }
      return new DataView(outBuffer.buffer);
    }
    function parseNullTerminatedString(buffer3, offset2) {
      var uintBuffer = new Uint8Array(buffer3);
      var endOffset = 0;
      while (uintBuffer[offset2.value + endOffset] != 0) {
        endOffset += 1;
      }
      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));
      offset2.value = offset2.value + endOffset + 1;
      return stringValue;
    }
    function parseFixedLengthString(buffer3, offset2, size2) {
      var stringValue = new TextDecoder().decode(new Uint8Array(buffer3).slice(offset2.value, offset2.value + size2));
      offset2.value = offset2.value + size2;
      return stringValue;
    }
    function parseRational(dataView, offset2) {
      var x = parseInt32(dataView, offset2);
      var y = parseUint32(dataView, offset2);
      return [x, y];
    }
    function parseTimecode(dataView, offset2) {
      var x = parseUint32(dataView, offset2);
      var y = parseUint32(dataView, offset2);
      return [x, y];
    }
    function parseInt32(dataView, offset2) {
      var Int32 = dataView.getInt32(offset2.value, true);
      offset2.value = offset2.value + INT32_SIZE;
      return Int32;
    }
    function parseUint32(dataView, offset2) {
      var Uint32 = dataView.getUint32(offset2.value, true);
      offset2.value = offset2.value + INT32_SIZE;
      return Uint32;
    }
    function parseUint8Array(uInt8Array2, offset2) {
      var Uint8 = uInt8Array2[offset2.value];
      offset2.value = offset2.value + INT8_SIZE;
      return Uint8;
    }
    function parseUint8(dataView, offset2) {
      var Uint8 = dataView.getUint8(offset2.value);
      offset2.value = offset2.value + INT8_SIZE;
      return Uint8;
    }
    const parseInt64 = function(dataView, offset2) {
      let int2;
      if ("getBigInt64" in DataView.prototype) {
        int2 = Number(dataView.getBigInt64(offset2.value, true));
      } else {
        int2 = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);
      }
      offset2.value += ULONG_SIZE;
      return int2;
    };
    function parseFloat32(dataView, offset2) {
      var float2 = dataView.getFloat32(offset2.value, true);
      offset2.value += FLOAT32_SIZE;
      return float2;
    }
    function decodeFloat32(dataView, offset2) {
      return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));
    }
    function decodeFloat16(binary) {
      var exponent = (binary & 31744) >> 10, fraction = binary & 1023;
      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));
    }
    function parseUint16(dataView, offset2) {
      var Uint16 = dataView.getUint16(offset2.value, true);
      offset2.value += INT16_SIZE;
      return Uint16;
    }
    function parseFloat16(buffer3, offset2) {
      return decodeFloat16(parseUint16(buffer3, offset2));
    }
    function parseChlist(dataView, buffer3, offset2, size2) {
      var startOffset = offset2.value;
      var channels = [];
      while (offset2.value < startOffset + size2 - 1) {
        var name = parseNullTerminatedString(buffer3, offset2);
        var pixelType = parseInt32(dataView, offset2);
        var pLinear = parseUint8(dataView, offset2);
        offset2.value += 3;
        var xSampling = parseInt32(dataView, offset2);
        var ySampling = parseInt32(dataView, offset2);
        channels.push({
          name,
          pixelType,
          pLinear,
          xSampling,
          ySampling
        });
      }
      offset2.value += 1;
      return channels;
    }
    function parseChromaticities(dataView, offset2) {
      var redX = parseFloat32(dataView, offset2);
      var redY = parseFloat32(dataView, offset2);
      var greenX = parseFloat32(dataView, offset2);
      var greenY = parseFloat32(dataView, offset2);
      var blueX = parseFloat32(dataView, offset2);
      var blueY = parseFloat32(dataView, offset2);
      var whiteX = parseFloat32(dataView, offset2);
      var whiteY = parseFloat32(dataView, offset2);
      return {
        redX,
        redY,
        greenX,
        greenY,
        blueX,
        blueY,
        whiteX,
        whiteY
      };
    }
    function parseCompression(dataView, offset2) {
      var compressionCodes = ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"];
      var compression = parseUint8(dataView, offset2);
      return compressionCodes[compression];
    }
    function parseBox2i(dataView, offset2) {
      var xMin = parseUint32(dataView, offset2);
      var yMin = parseUint32(dataView, offset2);
      var xMax = parseUint32(dataView, offset2);
      var yMax = parseUint32(dataView, offset2);
      return {
        xMin,
        yMin,
        xMax,
        yMax
      };
    }
    function parseLineOrder(dataView, offset2) {
      var lineOrders = ["INCREASING_Y"];
      var lineOrder = parseUint8(dataView, offset2);
      return lineOrders[lineOrder];
    }
    function parseV2f(dataView, offset2) {
      var x = parseFloat32(dataView, offset2);
      var y = parseFloat32(dataView, offset2);
      return [x, y];
    }
    function parseV3f(dataView, offset2) {
      var x = parseFloat32(dataView, offset2);
      var y = parseFloat32(dataView, offset2);
      var z = parseFloat32(dataView, offset2);
      return [x, y, z];
    }
    function parseValue(dataView, buffer3, offset2, type2, size2) {
      if (type2 === "string" || type2 === "stringvector" || type2 === "iccProfile") {
        return parseFixedLengthString(buffer3, offset2, size2);
      } else if (type2 === "chlist") {
        return parseChlist(dataView, buffer3, offset2, size2);
      } else if (type2 === "chromaticities") {
        return parseChromaticities(dataView, offset2);
      } else if (type2 === "compression") {
        return parseCompression(dataView, offset2);
      } else if (type2 === "box2i") {
        return parseBox2i(dataView, offset2);
      } else if (type2 === "lineOrder") {
        return parseLineOrder(dataView, offset2);
      } else if (type2 === "float") {
        return parseFloat32(dataView, offset2);
      } else if (type2 === "v2f") {
        return parseV2f(dataView, offset2);
      } else if (type2 === "v3f") {
        return parseV3f(dataView, offset2);
      } else if (type2 === "int") {
        return parseInt32(dataView, offset2);
      } else if (type2 === "rational") {
        return parseRational(dataView, offset2);
      } else if (type2 === "timecode") {
        return parseTimecode(dataView, offset2);
      } else if (type2 === "preview") {
        offset2.value += size2;
        return "skipped";
      } else {
        offset2.value += size2;
        return void 0;
      }
    }
    function parseHeader(dataView, buffer3, offset2) {
      const EXRHeader2 = {};
      if (dataView.getUint32(0, true) != 20000630) {
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
      }
      EXRHeader2.version = dataView.getUint8(4);
      const spec = dataView.getUint8(5);
      EXRHeader2.spec = {
        singleTile: !!(spec & 2),
        longName: !!(spec & 4),
        deepFormat: !!(spec & 8),
        multiPart: !!(spec & 16)
      };
      offset2.value = 8;
      var keepReading = true;
      while (keepReading) {
        var attributeName = parseNullTerminatedString(buffer3, offset2);
        if (attributeName == 0) {
          keepReading = false;
        } else {
          var attributeType = parseNullTerminatedString(buffer3, offset2);
          var attributeSize = parseUint32(dataView, offset2);
          var attributeValue = parseValue(dataView, buffer3, offset2, attributeType, attributeSize);
          if (attributeValue === void 0) {
            console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);
          } else {
            EXRHeader2[attributeName] = attributeValue;
          }
        }
      }
      if (spec != 0) {
        console.error("EXRHeader:", EXRHeader2);
        throw "THREE.EXRLoader: provided file is currently unsupported.";
      }
      return EXRHeader2;
    }
    function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {
      const EXRDecoder2 = {
        size: 0,
        viewer: dataView,
        array: uInt8Array2,
        offset: offset2,
        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,
        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,
        channels: EXRHeader2.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: EXRHeader2.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        encoding: null
      };
      switch (EXRHeader2.compression) {
        case "NO_COMPRESSION":
          EXRDecoder2.lines = 1;
          EXRDecoder2.uncompress = uncompressRAW;
          break;
        case "RLE_COMPRESSION":
          EXRDecoder2.lines = 1;
          EXRDecoder2.uncompress = uncompressRLE;
          break;
        case "ZIPS_COMPRESSION":
          EXRDecoder2.lines = 1;
          EXRDecoder2.uncompress = uncompressZIP;
          break;
        case "ZIP_COMPRESSION":
          EXRDecoder2.lines = 16;
          EXRDecoder2.uncompress = uncompressZIP;
          break;
        case "PIZ_COMPRESSION":
          EXRDecoder2.lines = 32;
          EXRDecoder2.uncompress = uncompressPIZ;
          break;
        case "PXR24_COMPRESSION":
          EXRDecoder2.lines = 16;
          EXRDecoder2.uncompress = uncompressPXR;
          break;
        case "DWAA_COMPRESSION":
          EXRDecoder2.lines = 32;
          EXRDecoder2.uncompress = uncompressDWA;
          break;
        case "DWAB_COMPRESSION":
          EXRDecoder2.lines = 256;
          EXRDecoder2.uncompress = uncompressDWA;
          break;
        default:
          throw "EXRLoader.parse: " + EXRHeader2.compression + " is unsupported";
      }
      EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;
      if (EXRDecoder2.type == 1) {
        switch (outputType) {
          case FloatType:
            EXRDecoder2.getter = parseFloat16;
            EXRDecoder2.inputSize = INT16_SIZE;
            break;
          case HalfFloatType:
            EXRDecoder2.getter = parseUint16;
            EXRDecoder2.inputSize = INT16_SIZE;
            break;
        }
      } else if (EXRDecoder2.type == 2) {
        switch (outputType) {
          case FloatType:
            EXRDecoder2.getter = parseFloat32;
            EXRDecoder2.inputSize = FLOAT32_SIZE;
            break;
          case HalfFloatType:
            EXRDecoder2.getter = decodeFloat32;
            EXRDecoder2.inputSize = FLOAT32_SIZE;
        }
      } else {
        throw "EXRLoader.parse: unsupported pixelType " + EXRDecoder2.type + " for " + EXRHeader2.compression + ".";
      }
      EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;
      for (var i2 = 0; i2 < EXRDecoder2.blockCount; i2++)
        parseInt64(dataView, offset2);
      EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;
      const size2 = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;
      switch (outputType) {
        case FloatType:
          EXRDecoder2.byteArray = new Float32Array(size2);
          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)
            EXRDecoder2.byteArray.fill(1, 0, size2);
          break;
        case HalfFloatType:
          EXRDecoder2.byteArray = new Uint16Array(size2);
          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)
            EXRDecoder2.byteArray.fill(15360, 0, size2);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", outputType);
          break;
      }
      EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;
      if (EXRDecoder2.outputChannels == 4) {
        EXRDecoder2.format = RGBAFormat;
        EXRDecoder2.encoding = LinearEncoding;
      } else {
        EXRDecoder2.format = RedFormat;
        EXRDecoder2.encoding = LinearEncoding;
      }
      return EXRDecoder2;
    }
    const bufferDataView = new DataView(buffer2);
    const uInt8Array = new Uint8Array(buffer2);
    const offset = {
      value: 0
    };
    const EXRHeader = parseHeader(bufferDataView, buffer2, offset);
    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);
    const tmpOffset = {
      value: 0
    };
    const channelOffsets = {
      R: 0,
      G: 1,
      B: 2,
      A: 3,
      Y: 0
    };
    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {
      const line2 = parseUint32(bufferDataView, offset);
      EXRDecoder.size = parseUint32(bufferDataView, offset);
      EXRDecoder.lines = line2 + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line2 : EXRDecoder.scanlineBlockSize;
      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;
      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);
      offset.value += EXRDecoder.size;
      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {
        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;
        if (true_y >= EXRDecoder.height)
          break;
        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {
          const cOff = channelOffsets[EXRHeader.channels[channelID].name];
          for (let x = 0; x < EXRDecoder.width; x++) {
            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;
            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;
            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);
          }
        }
      }
    }
    return {
      header: EXRHeader,
      width: EXRDecoder.width,
      height: EXRDecoder.height,
      data: EXRDecoder.byteArray,
      format: EXRDecoder.format,
      encoding: EXRDecoder.encoding,
      type: this.type
    };
  }
  setDataType(value) {
    this.type = value;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    function onLoadCallback(texture2, texData) {
      texture2.encoding = texData.encoding;
      texture2.minFilter = LinearFilter;
      texture2.magFilter = LinearFilter;
      texture2.generateMipmaps = false;
      texture2.flipY = false;
      if (onLoad)
        onLoad(texture2, texData);
    }
    return super.load(url, onLoadCallback, onProgress, onError);
  }
};

// node_modules/three-stdlib/loaders/3MFLoader.js
var ThreeMFLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.availableExtensions = [];
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(buffer2) {
      try {
        onLoad(scope2.parse(buffer2));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(data) {
    const scope2 = this;
    const textureLoader = new TextureLoader(this.manager);
    function loadDocument(data2) {
      let zip = null;
      let file = null;
      let relsName;
      let modelRelsName;
      const modelPartNames = [];
      const texturesPartNames = [];
      let modelRels;
      const modelParts = {};
      const printTicketParts = {};
      const texturesParts = {};
      const otherParts = {};
      try {
        zip = unzipSync(new Uint8Array(data2));
      } catch (e) {
        if (e instanceof ReferenceError) {
          console.error("THREE.3MFLoader: fflate missing and file is compressed.");
          return null;
        }
      }
      for (file in zip) {
        if (file.match(/\_rels\/.rels$/)) {
          relsName = file;
        } else if (file.match(/3D\/_rels\/.*\.model\.rels$/)) {
          modelRelsName = file;
        } else if (file.match(/^3D\/.*\.model$/)) {
          modelPartNames.push(file);
        } else if (file.match(/^3D\/Metadata\/.*\.xml$/))
          ;
        else if (file.match(/^3D\/Textures?\/.*/)) {
          texturesPartNames.push(file);
        } else if (file.match(/^3D\/Other\/.*/))
          ;
      }
      const relsView = zip[relsName];
      const relsFileText = LoaderUtils.decodeText(relsView);
      const rels = parseRelsXml(relsFileText);
      if (modelRelsName) {
        const relsView2 = zip[modelRelsName];
        const relsFileText2 = LoaderUtils.decodeText(relsView2);
        modelRels = parseRelsXml(relsFileText2);
      }
      for (let i2 = 0; i2 < modelPartNames.length; i2++) {
        const modelPart = modelPartNames[i2];
        const view = zip[modelPart];
        const fileText = LoaderUtils.decodeText(view);
        const xmlData = new DOMParser().parseFromString(fileText, "application/xml");
        if (xmlData.documentElement.nodeName.toLowerCase() !== "model") {
          console.error("THREE.3MFLoader: Error loading 3MF - no 3MF document found: ", modelPart);
        }
        const modelNode = xmlData.querySelector("model");
        const extensions = {};
        for (let i3 = 0; i3 < modelNode.attributes.length; i3++) {
          const attr = modelNode.attributes[i3];
          if (attr.name.match(/^xmlns:(.+)$/)) {
            extensions[attr.value] = RegExp.$1;
          }
        }
        const modelData = parseModelNode(modelNode);
        modelData["xml"] = modelNode;
        if (0 < Object.keys(extensions).length) {
          modelData["extensions"] = extensions;
        }
        modelParts[modelPart] = modelData;
      }
      for (let i2 = 0; i2 < texturesPartNames.length; i2++) {
        const texturesPartName = texturesPartNames[i2];
        texturesParts[texturesPartName] = zip[texturesPartName].buffer;
      }
      return {
        rels,
        modelRels,
        model: modelParts,
        printTicket: printTicketParts,
        texture: texturesParts,
        other: otherParts
      };
    }
    function parseRelsXml(relsFileText) {
      const relationships = [];
      const relsXmlData = new DOMParser().parseFromString(relsFileText, "application/xml");
      const relsNodes = relsXmlData.querySelectorAll("Relationship");
      for (let i2 = 0; i2 < relsNodes.length; i2++) {
        const relsNode = relsNodes[i2];
        const relationship = {
          target: relsNode.getAttribute("Target"),
          id: relsNode.getAttribute("Id"),
          type: relsNode.getAttribute("Type")
        };
        relationships.push(relationship);
      }
      return relationships;
    }
    function parseMetadataNodes(metadataNodes) {
      const metadataData = {};
      for (let i2 = 0; i2 < metadataNodes.length; i2++) {
        const metadataNode = metadataNodes[i2];
        const name = metadataNode.getAttribute("name");
        const validNames = ["Title", "Designer", "Description", "Copyright", "LicenseTerms", "Rating", "CreationDate", "ModificationDate"];
        if (0 <= validNames.indexOf(name)) {
          metadataData[name] = metadataNode.textContent;
        }
      }
      return metadataData;
    }
    function parseBasematerialsNode(basematerialsNode) {
      const basematerialsData = {
        id: basematerialsNode.getAttribute("id"),
        basematerials: []
      };
      const basematerialNodes = basematerialsNode.querySelectorAll("base");
      for (let i2 = 0; i2 < basematerialNodes.length; i2++) {
        const basematerialNode = basematerialNodes[i2];
        const basematerialData = parseBasematerialNode(basematerialNode);
        basematerialData.index = i2;
        basematerialsData.basematerials.push(basematerialData);
      }
      return basematerialsData;
    }
    function parseTexture2DNode(texture2DNode) {
      const texture2dData = {
        id: texture2DNode.getAttribute("id"),
        path: texture2DNode.getAttribute("path"),
        contenttype: texture2DNode.getAttribute("contenttype"),
        tilestyleu: texture2DNode.getAttribute("tilestyleu"),
        tilestylev: texture2DNode.getAttribute("tilestylev"),
        filter: texture2DNode.getAttribute("filter")
      };
      return texture2dData;
    }
    function parseTextures2DGroupNode(texture2DGroupNode) {
      const texture2DGroupData = {
        id: texture2DGroupNode.getAttribute("id"),
        texid: texture2DGroupNode.getAttribute("texid"),
        displaypropertiesid: texture2DGroupNode.getAttribute("displaypropertiesid")
      };
      const tex2coordNodes = texture2DGroupNode.querySelectorAll("tex2coord");
      const uvs = [];
      for (let i2 = 0; i2 < tex2coordNodes.length; i2++) {
        const tex2coordNode = tex2coordNodes[i2];
        const u = tex2coordNode.getAttribute("u");
        const v = tex2coordNode.getAttribute("v");
        uvs.push(parseFloat(u), parseFloat(v));
      }
      texture2DGroupData["uvs"] = new Float32Array(uvs);
      return texture2DGroupData;
    }
    function parseColorGroupNode(colorGroupNode) {
      const colorGroupData = {
        id: colorGroupNode.getAttribute("id"),
        displaypropertiesid: colorGroupNode.getAttribute("displaypropertiesid")
      };
      const colorNodes = colorGroupNode.querySelectorAll("color");
      const colors = [];
      const colorObject = new Color();
      for (let i2 = 0; i2 < colorNodes.length; i2++) {
        const colorNode = colorNodes[i2];
        const color2 = colorNode.getAttribute("color");
        colorObject.setStyle(color2.substring(0, 7));
        colorObject.convertSRGBToLinear();
        colors.push(colorObject.r, colorObject.g, colorObject.b);
      }
      colorGroupData["colors"] = new Float32Array(colors);
      return colorGroupData;
    }
    function parseMetallicDisplaypropertiesNode(metallicDisplaypropetiesNode) {
      const metallicDisplaypropertiesData = {
        id: metallicDisplaypropetiesNode.getAttribute("id")
      };
      const metallicNodes = metallicDisplaypropetiesNode.querySelectorAll("pbmetallic");
      const metallicData = [];
      for (let i2 = 0; i2 < metallicNodes.length; i2++) {
        const metallicNode = metallicNodes[i2];
        metallicData.push({
          name: metallicNode.getAttribute("name"),
          metallicness: parseFloat(metallicNode.getAttribute("metallicness")),
          roughness: parseFloat(metallicNode.getAttribute("roughness"))
        });
      }
      metallicDisplaypropertiesData.data = metallicData;
      return metallicDisplaypropertiesData;
    }
    function parseBasematerialNode(basematerialNode) {
      const basematerialData = {};
      basematerialData["name"] = basematerialNode.getAttribute("name");
      basematerialData["displaycolor"] = basematerialNode.getAttribute("displaycolor");
      basematerialData["displaypropertiesid"] = basematerialNode.getAttribute("displaypropertiesid");
      return basematerialData;
    }
    function parseMeshNode(meshNode) {
      const meshData = {};
      const vertices = [];
      const vertexNodes = meshNode.querySelectorAll("vertices vertex");
      for (let i2 = 0; i2 < vertexNodes.length; i2++) {
        const vertexNode = vertexNodes[i2];
        const x = vertexNode.getAttribute("x");
        const y = vertexNode.getAttribute("y");
        const z = vertexNode.getAttribute("z");
        vertices.push(parseFloat(x), parseFloat(y), parseFloat(z));
      }
      meshData["vertices"] = new Float32Array(vertices);
      const triangleProperties = [];
      const triangles = [];
      const triangleNodes = meshNode.querySelectorAll("triangles triangle");
      for (let i2 = 0; i2 < triangleNodes.length; i2++) {
        const triangleNode = triangleNodes[i2];
        const v12 = triangleNode.getAttribute("v1");
        const v2 = triangleNode.getAttribute("v2");
        const v3 = triangleNode.getAttribute("v3");
        const p1 = triangleNode.getAttribute("p1");
        const p2 = triangleNode.getAttribute("p2");
        const p3 = triangleNode.getAttribute("p3");
        const pid = triangleNode.getAttribute("pid");
        const triangleProperty = {};
        triangleProperty["v1"] = parseInt(v12, 10);
        triangleProperty["v2"] = parseInt(v2, 10);
        triangleProperty["v3"] = parseInt(v3, 10);
        triangles.push(triangleProperty["v1"], triangleProperty["v2"], triangleProperty["v3"]);
        if (p1) {
          triangleProperty["p1"] = parseInt(p1, 10);
        }
        if (p2) {
          triangleProperty["p2"] = parseInt(p2, 10);
        }
        if (p3) {
          triangleProperty["p3"] = parseInt(p3, 10);
        }
        if (pid) {
          triangleProperty["pid"] = pid;
        }
        if (0 < Object.keys(triangleProperty).length) {
          triangleProperties.push(triangleProperty);
        }
      }
      meshData["triangleProperties"] = triangleProperties;
      meshData["triangles"] = new Uint32Array(triangles);
      return meshData;
    }
    function parseComponentsNode(componentsNode) {
      const components = [];
      const componentNodes = componentsNode.querySelectorAll("component");
      for (let i2 = 0; i2 < componentNodes.length; i2++) {
        const componentNode = componentNodes[i2];
        const componentData = parseComponentNode(componentNode);
        components.push(componentData);
      }
      return components;
    }
    function parseComponentNode(componentNode) {
      const componentData = {};
      componentData["objectId"] = componentNode.getAttribute("objectid");
      const transform = componentNode.getAttribute("transform");
      if (transform) {
        componentData["transform"] = parseTransform(transform);
      }
      return componentData;
    }
    function parseTransform(transform) {
      const t2 = [];
      transform.split(" ").forEach(function(s) {
        t2.push(parseFloat(s));
      });
      const matrix3 = new Matrix4();
      matrix3.set(t2[0], t2[3], t2[6], t2[9], t2[1], t2[4], t2[7], t2[10], t2[2], t2[5], t2[8], t2[11], 0, 0, 0, 1);
      return matrix3;
    }
    function parseObjectNode(objectNode) {
      const objectData = {
        type: objectNode.getAttribute("type")
      };
      const id = objectNode.getAttribute("id");
      if (id) {
        objectData["id"] = id;
      }
      const pid = objectNode.getAttribute("pid");
      if (pid) {
        objectData["pid"] = pid;
      }
      const pindex = objectNode.getAttribute("pindex");
      if (pindex) {
        objectData["pindex"] = pindex;
      }
      const thumbnail = objectNode.getAttribute("thumbnail");
      if (thumbnail) {
        objectData["thumbnail"] = thumbnail;
      }
      const partnumber = objectNode.getAttribute("partnumber");
      if (partnumber) {
        objectData["partnumber"] = partnumber;
      }
      const name = objectNode.getAttribute("name");
      if (name) {
        objectData["name"] = name;
      }
      const meshNode = objectNode.querySelector("mesh");
      if (meshNode) {
        objectData["mesh"] = parseMeshNode(meshNode);
      }
      const componentsNode = objectNode.querySelector("components");
      if (componentsNode) {
        objectData["components"] = parseComponentsNode(componentsNode);
      }
      return objectData;
    }
    function parseResourcesNode(resourcesNode) {
      const resourcesData = {};
      resourcesData["basematerials"] = {};
      const basematerialsNodes = resourcesNode.querySelectorAll("basematerials");
      for (let i2 = 0; i2 < basematerialsNodes.length; i2++) {
        const basematerialsNode = basematerialsNodes[i2];
        const basematerialsData = parseBasematerialsNode(basematerialsNode);
        resourcesData["basematerials"][basematerialsData["id"]] = basematerialsData;
      }
      resourcesData["texture2d"] = {};
      const textures2DNodes = resourcesNode.querySelectorAll("texture2d");
      for (let i2 = 0; i2 < textures2DNodes.length; i2++) {
        const textures2DNode = textures2DNodes[i2];
        const texture2DData = parseTexture2DNode(textures2DNode);
        resourcesData["texture2d"][texture2DData["id"]] = texture2DData;
      }
      resourcesData["colorgroup"] = {};
      const colorGroupNodes = resourcesNode.querySelectorAll("colorgroup");
      for (let i2 = 0; i2 < colorGroupNodes.length; i2++) {
        const colorGroupNode = colorGroupNodes[i2];
        const colorGroupData = parseColorGroupNode(colorGroupNode);
        resourcesData["colorgroup"][colorGroupData["id"]] = colorGroupData;
      }
      resourcesData["pbmetallicdisplayproperties"] = {};
      const pbmetallicdisplaypropertiesNodes = resourcesNode.querySelectorAll("pbmetallicdisplayproperties");
      for (let i2 = 0; i2 < pbmetallicdisplaypropertiesNodes.length; i2++) {
        const pbmetallicdisplaypropertiesNode = pbmetallicdisplaypropertiesNodes[i2];
        const pbmetallicdisplaypropertiesData = parseMetallicDisplaypropertiesNode(pbmetallicdisplaypropertiesNode);
        resourcesData["pbmetallicdisplayproperties"][pbmetallicdisplaypropertiesData["id"]] = pbmetallicdisplaypropertiesData;
      }
      resourcesData["texture2dgroup"] = {};
      const textures2DGroupNodes = resourcesNode.querySelectorAll("texture2dgroup");
      for (let i2 = 0; i2 < textures2DGroupNodes.length; i2++) {
        const textures2DGroupNode = textures2DGroupNodes[i2];
        const textures2DGroupData = parseTextures2DGroupNode(textures2DGroupNode);
        resourcesData["texture2dgroup"][textures2DGroupData["id"]] = textures2DGroupData;
      }
      resourcesData["object"] = {};
      const objectNodes = resourcesNode.querySelectorAll("object");
      for (let i2 = 0; i2 < objectNodes.length; i2++) {
        const objectNode = objectNodes[i2];
        const objectData = parseObjectNode(objectNode);
        resourcesData["object"][objectData["id"]] = objectData;
      }
      return resourcesData;
    }
    function parseBuildNode(buildNode) {
      const buildData = [];
      const itemNodes = buildNode.querySelectorAll("item");
      for (let i2 = 0; i2 < itemNodes.length; i2++) {
        const itemNode = itemNodes[i2];
        const buildItem = {
          objectId: itemNode.getAttribute("objectid")
        };
        const transform = itemNode.getAttribute("transform");
        if (transform) {
          buildItem["transform"] = parseTransform(transform);
        }
        buildData.push(buildItem);
      }
      return buildData;
    }
    function parseModelNode(modelNode) {
      const modelData = {
        unit: modelNode.getAttribute("unit") || "millimeter"
      };
      const metadataNodes = modelNode.querySelectorAll("metadata");
      if (metadataNodes) {
        modelData["metadata"] = parseMetadataNodes(metadataNodes);
      }
      const resourcesNode = modelNode.querySelector("resources");
      if (resourcesNode) {
        modelData["resources"] = parseResourcesNode(resourcesNode);
      }
      const buildNode = modelNode.querySelector("build");
      if (buildNode) {
        modelData["build"] = parseBuildNode(buildNode);
      }
      return modelData;
    }
    function buildTexture(texture2dgroup, objects2, modelData, textureData) {
      const texid = texture2dgroup.texid;
      const texture2ds = modelData.resources.texture2d;
      const texture2d = texture2ds[texid];
      if (texture2d) {
        const data2 = textureData[texture2d.path];
        const type2 = texture2d.contenttype;
        const blob = new Blob([data2], {
          type: type2
        });
        const sourceURI = URL.createObjectURL(blob);
        const texture2 = textureLoader.load(sourceURI, function() {
          URL.revokeObjectURL(sourceURI);
        });
        texture2.encoding = sRGBEncoding;
        switch (texture2d.tilestyleu) {
          case "wrap":
            texture2.wrapS = RepeatWrapping;
            break;
          case "mirror":
            texture2.wrapS = MirroredRepeatWrapping;
            break;
          case "none":
          case "clamp":
            texture2.wrapS = ClampToEdgeWrapping;
            break;
          default:
            texture2.wrapS = RepeatWrapping;
        }
        switch (texture2d.tilestylev) {
          case "wrap":
            texture2.wrapT = RepeatWrapping;
            break;
          case "mirror":
            texture2.wrapT = MirroredRepeatWrapping;
            break;
          case "none":
          case "clamp":
            texture2.wrapT = ClampToEdgeWrapping;
            break;
          default:
            texture2.wrapT = RepeatWrapping;
        }
        switch (texture2d.filter) {
          case "auto":
            texture2.magFilter = LinearFilter;
            texture2.minFilter = LinearMipmapLinearFilter;
            break;
          case "linear":
            texture2.magFilter = LinearFilter;
            texture2.minFilter = LinearFilter;
            break;
          case "nearest":
            texture2.magFilter = NearestFilter;
            texture2.minFilter = NearestFilter;
            break;
          default:
            texture2.magFilter = LinearFilter;
            texture2.minFilter = LinearMipmapLinearFilter;
        }
        return texture2;
      } else {
        return null;
      }
    }
    function buildBasematerialsMeshes(basematerials, triangleProperties, meshData, objects2, modelData, textureData, objectData) {
      const objectPindex = objectData.pindex;
      const materialMap = {};
      for (let i2 = 0, l = triangleProperties.length; i2 < l; i2++) {
        const triangleProperty = triangleProperties[i2];
        const pindex = triangleProperty.p1 !== void 0 ? triangleProperty.p1 : objectPindex;
        if (materialMap[pindex] === void 0)
          materialMap[pindex] = [];
        materialMap[pindex].push(triangleProperty);
      }
      const keys = Object.keys(materialMap);
      const meshes = [];
      for (let i2 = 0, l = keys.length; i2 < l; i2++) {
        const materialIndex = keys[i2];
        const trianglePropertiesProps = materialMap[materialIndex];
        const basematerialData = basematerials.basematerials[materialIndex];
        const material = getBuild(basematerialData, objects2, modelData, textureData, objectData, buildBasematerial);
        const geometry = new BufferGeometry();
        const positionData = [];
        const vertices = meshData.vertices;
        for (let j2 = 0, jl2 = trianglePropertiesProps.length; j2 < jl2; j2++) {
          const triangleProperty = trianglePropertiesProps[j2];
          positionData.push(vertices[triangleProperty.v1 * 3 + 0]);
          positionData.push(vertices[triangleProperty.v1 * 3 + 1]);
          positionData.push(vertices[triangleProperty.v1 * 3 + 2]);
          positionData.push(vertices[triangleProperty.v2 * 3 + 0]);
          positionData.push(vertices[triangleProperty.v2 * 3 + 1]);
          positionData.push(vertices[triangleProperty.v2 * 3 + 2]);
          positionData.push(vertices[triangleProperty.v3 * 3 + 0]);
          positionData.push(vertices[triangleProperty.v3 * 3 + 1]);
          positionData.push(vertices[triangleProperty.v3 * 3 + 2]);
        }
        geometry.setAttribute("position", new Float32BufferAttribute(positionData, 3));
        const mesh = new Mesh(geometry, material);
        meshes.push(mesh);
      }
      return meshes;
    }
    function buildTexturedMesh(texture2dgroup, triangleProperties, meshData, objects2, modelData, textureData, objectData) {
      const geometry = new BufferGeometry();
      const positionData = [];
      const uvData = [];
      const vertices = meshData.vertices;
      const uvs = texture2dgroup.uvs;
      for (let i2 = 0, l = triangleProperties.length; i2 < l; i2++) {
        const triangleProperty = triangleProperties[i2];
        positionData.push(vertices[triangleProperty.v1 * 3 + 0]);
        positionData.push(vertices[triangleProperty.v1 * 3 + 1]);
        positionData.push(vertices[triangleProperty.v1 * 3 + 2]);
        positionData.push(vertices[triangleProperty.v2 * 3 + 0]);
        positionData.push(vertices[triangleProperty.v2 * 3 + 1]);
        positionData.push(vertices[triangleProperty.v2 * 3 + 2]);
        positionData.push(vertices[triangleProperty.v3 * 3 + 0]);
        positionData.push(vertices[triangleProperty.v3 * 3 + 1]);
        positionData.push(vertices[triangleProperty.v3 * 3 + 2]);
        uvData.push(uvs[triangleProperty.p1 * 2 + 0]);
        uvData.push(uvs[triangleProperty.p1 * 2 + 1]);
        uvData.push(uvs[triangleProperty.p2 * 2 + 0]);
        uvData.push(uvs[triangleProperty.p2 * 2 + 1]);
        uvData.push(uvs[triangleProperty.p3 * 2 + 0]);
        uvData.push(uvs[triangleProperty.p3 * 2 + 1]);
      }
      geometry.setAttribute("position", new Float32BufferAttribute(positionData, 3));
      geometry.setAttribute("uv", new Float32BufferAttribute(uvData, 2));
      const texture2 = getBuild(texture2dgroup, objects2, modelData, textureData, objectData, buildTexture);
      const material = new MeshPhongMaterial({
        map: texture2,
        flatShading: true
      });
      const mesh = new Mesh(geometry, material);
      return mesh;
    }
    function buildVertexColorMesh(colorgroup, triangleProperties, meshData, objects2, modelData, objectData) {
      const geometry = new BufferGeometry();
      const positionData = [];
      const colorData = [];
      const vertices = meshData.vertices;
      const colors = colorgroup.colors;
      for (let i2 = 0, l = triangleProperties.length; i2 < l; i2++) {
        const triangleProperty = triangleProperties[i2];
        const v12 = triangleProperty.v1;
        const v2 = triangleProperty.v2;
        const v3 = triangleProperty.v3;
        positionData.push(vertices[v12 * 3 + 0]);
        positionData.push(vertices[v12 * 3 + 1]);
        positionData.push(vertices[v12 * 3 + 2]);
        positionData.push(vertices[v2 * 3 + 0]);
        positionData.push(vertices[v2 * 3 + 1]);
        positionData.push(vertices[v2 * 3 + 2]);
        positionData.push(vertices[v3 * 3 + 0]);
        positionData.push(vertices[v3 * 3 + 1]);
        positionData.push(vertices[v3 * 3 + 2]);
        const p1 = triangleProperty.p1 !== void 0 ? triangleProperty.p1 : objectData.pindex;
        const p2 = triangleProperty.p2 !== void 0 ? triangleProperty.p2 : p1;
        const p3 = triangleProperty.p3 !== void 0 ? triangleProperty.p3 : p1;
        colorData.push(colors[p1 * 3 + 0]);
        colorData.push(colors[p1 * 3 + 1]);
        colorData.push(colors[p1 * 3 + 2]);
        colorData.push(colors[p2 * 3 + 0]);
        colorData.push(colors[p2 * 3 + 1]);
        colorData.push(colors[p2 * 3 + 2]);
        colorData.push(colors[p3 * 3 + 0]);
        colorData.push(colors[p3 * 3 + 1]);
        colorData.push(colors[p3 * 3 + 2]);
      }
      geometry.setAttribute("position", new Float32BufferAttribute(positionData, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colorData, 3));
      const material = new MeshPhongMaterial({
        vertexColors: true,
        flatShading: true
      });
      const mesh = new Mesh(geometry, material);
      return mesh;
    }
    function buildDefaultMesh(meshData) {
      const geometry = new BufferGeometry();
      geometry.setIndex(new BufferAttribute(meshData["triangles"], 1));
      geometry.setAttribute("position", new BufferAttribute(meshData["vertices"], 3));
      const material = new MeshPhongMaterial({
        color: 11184895,
        flatShading: true
      });
      const mesh = new Mesh(geometry, material);
      return mesh;
    }
    function buildMeshes(resourceMap, meshData, objects2, modelData, textureData, objectData) {
      const keys = Object.keys(resourceMap);
      const meshes = [];
      for (let i2 = 0, il = keys.length; i2 < il; i2++) {
        const resourceId = keys[i2];
        const triangleProperties = resourceMap[resourceId];
        const resourceType = getResourceType(resourceId, modelData);
        switch (resourceType) {
          case "material":
            const basematerials = modelData.resources.basematerials[resourceId];
            const newMeshes = buildBasematerialsMeshes(basematerials, triangleProperties, meshData, objects2, modelData, textureData, objectData);
            for (let j2 = 0, jl2 = newMeshes.length; j2 < jl2; j2++) {
              meshes.push(newMeshes[j2]);
            }
            break;
          case "texture":
            const texture2dgroup = modelData.resources.texture2dgroup[resourceId];
            meshes.push(buildTexturedMesh(texture2dgroup, triangleProperties, meshData, objects2, modelData, textureData, objectData));
            break;
          case "vertexColors":
            const colorgroup = modelData.resources.colorgroup[resourceId];
            meshes.push(buildVertexColorMesh(colorgroup, triangleProperties, meshData, objects2, modelData, objectData));
            break;
          case "default":
            meshes.push(buildDefaultMesh(meshData));
            break;
          default:
            console.error("THREE.3MFLoader: Unsupported resource type.");
        }
      }
      return meshes;
    }
    function getResourceType(pid, modelData) {
      if (modelData.resources.texture2dgroup[pid] !== void 0) {
        return "texture";
      } else if (modelData.resources.basematerials[pid] !== void 0) {
        return "material";
      } else if (modelData.resources.colorgroup[pid] !== void 0) {
        return "vertexColors";
      } else if (pid === "default") {
        return "default";
      } else {
        return void 0;
      }
    }
    function analyzeObject(modelData, meshData, objectData) {
      const resourceMap = {};
      const triangleProperties = meshData["triangleProperties"];
      const objectPid = objectData.pid;
      for (let i2 = 0, l = triangleProperties.length; i2 < l; i2++) {
        const triangleProperty = triangleProperties[i2];
        let pid = triangleProperty.pid !== void 0 ? triangleProperty.pid : objectPid;
        if (pid === void 0)
          pid = "default";
        if (resourceMap[pid] === void 0)
          resourceMap[pid] = [];
        resourceMap[pid].push(triangleProperty);
      }
      return resourceMap;
    }
    function buildGroup(meshData, objects2, modelData, textureData, objectData) {
      const group = new Group();
      const resourceMap = analyzeObject(modelData, meshData, objectData);
      const meshes = buildMeshes(resourceMap, meshData, objects2, modelData, textureData, objectData);
      for (let i2 = 0, l = meshes.length; i2 < l; i2++) {
        group.add(meshes[i2]);
      }
      return group;
    }
    function applyExtensions(extensions, meshData, modelXml) {
      if (!extensions) {
        return;
      }
      const availableExtensions = [];
      const keys = Object.keys(extensions);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const ns = keys[i2];
        for (let j2 = 0; j2 < scope2.availableExtensions.length; j2++) {
          const extension = scope2.availableExtensions[j2];
          if (extension.ns === ns) {
            availableExtensions.push(extension);
          }
        }
      }
      for (let i2 = 0; i2 < availableExtensions.length; i2++) {
        const extension = availableExtensions[i2];
        extension.apply(modelXml, extensions[extension["ns"]], meshData);
      }
    }
    function getBuild(data2, objects2, modelData, textureData, objectData, builder) {
      if (data2.build !== void 0)
        return data2.build;
      data2.build = builder(data2, objects2, modelData, textureData, objectData);
      return data2.build;
    }
    function buildBasematerial(materialData, objects2, modelData) {
      let material;
      const displaypropertiesid = materialData.displaypropertiesid;
      const pbmetallicdisplayproperties = modelData.resources.pbmetallicdisplayproperties;
      if (displaypropertiesid !== null && pbmetallicdisplayproperties[displaypropertiesid] !== void 0) {
        const pbmetallicdisplayproperty = pbmetallicdisplayproperties[displaypropertiesid];
        const metallicData = pbmetallicdisplayproperty.data[materialData.index];
        material = new MeshStandardMaterial({
          flatShading: true,
          roughness: metallicData.roughness,
          metalness: metallicData.metallicness
        });
      } else {
        material = new MeshPhongMaterial({
          flatShading: true
        });
      }
      material.name = materialData.name;
      const displaycolor = materialData.displaycolor;
      const color2 = displaycolor.substring(0, 7);
      material.color.setStyle(color2);
      material.color.convertSRGBToLinear();
      if (displaycolor.length === 9) {
        material.opacity = parseInt(displaycolor.charAt(7) + displaycolor.charAt(8), 16) / 255;
      }
      return material;
    }
    function buildComposite(compositeData, objects2, modelData, textureData) {
      const composite = new Group();
      for (let j2 = 0; j2 < compositeData.length; j2++) {
        const component = compositeData[j2];
        let build2 = objects2[component.objectId];
        if (build2 === void 0) {
          buildObject(component.objectId, objects2, modelData, textureData);
          build2 = objects2[component.objectId];
        }
        const object3D = build2.clone();
        const transform = component.transform;
        if (transform) {
          object3D.applyMatrix4(transform);
        }
        composite.add(object3D);
      }
      return composite;
    }
    function buildObject(objectId, objects2, modelData, textureData) {
      const objectData = modelData["resources"]["object"][objectId];
      if (objectData["mesh"]) {
        const meshData = objectData["mesh"];
        const extensions = modelData["extensions"];
        const modelXml = modelData["xml"];
        applyExtensions(extensions, meshData, modelXml);
        objects2[objectData.id] = getBuild(meshData, objects2, modelData, textureData, objectData, buildGroup);
      } else {
        const compositeData = objectData["components"];
        objects2[objectData.id] = getBuild(compositeData, objects2, modelData, textureData, objectData, buildComposite);
      }
    }
    function buildObjects(data3mf2) {
      const modelsData = data3mf2.model;
      const modelRels = data3mf2.modelRels;
      const objects2 = {};
      const modelsKeys = Object.keys(modelsData);
      const textureData = {};
      if (modelRels) {
        for (let i2 = 0, l = modelRels.length; i2 < l; i2++) {
          const modelRel = modelRels[i2];
          const textureKey = modelRel.target.substring(1);
          if (data3mf2.texture[textureKey]) {
            textureData[modelRel.target] = data3mf2.texture[textureKey];
          }
        }
      }
      for (let i2 = 0; i2 < modelsKeys.length; i2++) {
        const modelsKey = modelsKeys[i2];
        const modelData = modelsData[modelsKey];
        const objectIds = Object.keys(modelData["resources"]["object"]);
        for (let j2 = 0; j2 < objectIds.length; j2++) {
          const objectId = objectIds[j2];
          buildObject(objectId, objects2, modelData, textureData);
        }
      }
      return objects2;
    }
    function fetch3DModelPart(rels) {
      for (let i2 = 0; i2 < rels.length; i2++) {
        const rel = rels[i2];
        const extension = rel.target.split(".").pop();
        if (extension.toLowerCase() === "model")
          return rel;
      }
    }
    function build(objects2, data3mf2) {
      const group = new Group();
      const relationship = fetch3DModelPart(data3mf2["rels"]);
      const buildData = data3mf2.model[relationship["target"].substring(1)]["build"];
      for (let i2 = 0; i2 < buildData.length; i2++) {
        const buildItem = buildData[i2];
        const object3D = objects2[buildItem["objectId"]];
        const transform = buildItem["transform"];
        if (transform) {
          object3D.applyMatrix4(transform);
        }
        group.add(object3D);
      }
      return group;
    }
    const data3mf = loadDocument(data);
    const objects = buildObjects(data3mf);
    return build(objects, data3mf);
  }
  addExtension(extension) {
    this.availableExtensions.push(extension);
  }
};

// node_modules/three-stdlib/loaders/XYZLoader.js
var XYZLoader = class extends Loader {
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope2.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(text) {
    const lines = text.split("\n");
    const vertices = [];
    const colors = [];
    for (let line2 of lines) {
      line2 = line2.trim();
      if (line2.charAt(0) === "#")
        continue;
      const lineValues = line2.split(/\s+/);
      if (lineValues.length === 3) {
        vertices.push(parseFloat(lineValues[0]));
        vertices.push(parseFloat(lineValues[1]));
        vertices.push(parseFloat(lineValues[2]));
      }
      if (lineValues.length === 6) {
        vertices.push(parseFloat(lineValues[0]));
        vertices.push(parseFloat(lineValues[1]));
        vertices.push(parseFloat(lineValues[2]));
        colors.push(parseFloat(lineValues[3]) / 255);
        colors.push(parseFloat(lineValues[4]) / 255);
        colors.push(parseFloat(lineValues[5]) / 255);
      }
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    if (colors.length > 0) {
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    }
    return geometry;
  }
};

// node_modules/three-stdlib/loaders/VTKLoader.js
var VTKLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope2.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(data) {
    function parseASCII(data2) {
      var indices = [];
      var positions = [];
      var colors = [];
      var normals = [];
      var result;
      var patWord = /^[^\d.\s-]+/;
      var pat3Floats = /(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)/g;
      var patConnectivity = /^(\d+)\s+([\s\d]*)/;
      var patPOINTS = /^POINTS /;
      var patPOLYGONS = /^POLYGONS /;
      var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;
      var patPOINT_DATA = /^POINT_DATA[ ]+(\d+)/;
      var patCELL_DATA = /^CELL_DATA[ ]+(\d+)/;
      var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\w+)[ ]+3/;
      var patNORMALS = /^NORMALS[ ]+(\w+)[ ]+(\w+)/;
      var inPointsSection = false;
      var inPolygonsSection = false;
      var inTriangleStripSection = false;
      var inPointDataSection = false;
      var inCellDataSection = false;
      var inColorSection = false;
      var inNormalsSection = false;
      var lines = data2.split("\n");
      for (var i2 in lines) {
        var line2 = lines[i2].trim();
        if (line2.indexOf("DATASET") === 0) {
          var dataset = line2.split(" ")[1];
          if (dataset !== "POLYDATA")
            throw new Error("Unsupported DATASET type: " + dataset);
        } else if (inPointsSection) {
          while ((result = pat3Floats.exec(line2)) !== null) {
            if (patWord.exec(line2) !== null)
              break;
            var x = parseFloat(result[1]);
            var y = parseFloat(result[2]);
            var z = parseFloat(result[3]);
            positions.push(x, y, z);
          }
        } else if (inPolygonsSection) {
          if ((result = patConnectivity.exec(line2)) !== null) {
            var numVertices = parseInt(result[1]);
            var inds = result[2].split(/\s+/);
            if (numVertices >= 3) {
              var i0 = parseInt(inds[0]);
              var i1, i22;
              var k = 1;
              for (var j2 = 0; j2 < numVertices - 2; ++j2) {
                i1 = parseInt(inds[k]);
                i22 = parseInt(inds[k + 1]);
                indices.push(i0, i1, i22);
                k++;
              }
            }
          }
        } else if (inTriangleStripSection) {
          if ((result = patConnectivity.exec(line2)) !== null) {
            var numVertices = parseInt(result[1]);
            var inds = result[2].split(/\s+/);
            if (numVertices >= 3) {
              var i0, i1, i22;
              for (var j2 = 0; j2 < numVertices - 2; j2++) {
                if (j2 % 2 === 1) {
                  i0 = parseInt(inds[j2]);
                  i1 = parseInt(inds[j2 + 2]);
                  i22 = parseInt(inds[j2 + 1]);
                  indices.push(i0, i1, i22);
                } else {
                  i0 = parseInt(inds[j2]);
                  i1 = parseInt(inds[j2 + 1]);
                  i22 = parseInt(inds[j2 + 2]);
                  indices.push(i0, i1, i22);
                }
              }
            }
          }
        } else if (inPointDataSection || inCellDataSection) {
          if (inColorSection) {
            while ((result = pat3Floats.exec(line2)) !== null) {
              if (patWord.exec(line2) !== null)
                break;
              var r = parseFloat(result[1]);
              var g2 = parseFloat(result[2]);
              var b3 = parseFloat(result[3]);
              colors.push(r, g2, b3);
            }
          } else if (inNormalsSection) {
            while ((result = pat3Floats.exec(line2)) !== null) {
              if (patWord.exec(line2) !== null)
                break;
              var nx = parseFloat(result[1]);
              var ny = parseFloat(result[2]);
              var nz = parseFloat(result[3]);
              normals.push(nx, ny, nz);
            }
          }
        }
        if (patPOLYGONS.exec(line2) !== null) {
          inPolygonsSection = true;
          inPointsSection = false;
          inTriangleStripSection = false;
        } else if (patPOINTS.exec(line2) !== null) {
          inPolygonsSection = false;
          inPointsSection = true;
          inTriangleStripSection = false;
        } else if (patTRIANGLE_STRIPS.exec(line2) !== null) {
          inPolygonsSection = false;
          inPointsSection = false;
          inTriangleStripSection = true;
        } else if (patPOINT_DATA.exec(line2) !== null) {
          inPointDataSection = true;
          inPointsSection = false;
          inPolygonsSection = false;
          inTriangleStripSection = false;
        } else if (patCELL_DATA.exec(line2) !== null) {
          inCellDataSection = true;
          inPointsSection = false;
          inPolygonsSection = false;
          inTriangleStripSection = false;
        } else if (patCOLOR_SCALARS.exec(line2) !== null) {
          inColorSection = true;
          inNormalsSection = false;
          inPointsSection = false;
          inPolygonsSection = false;
          inTriangleStripSection = false;
        } else if (patNORMALS.exec(line2) !== null) {
          inNormalsSection = true;
          inColorSection = false;
          inPointsSection = false;
          inPolygonsSection = false;
          inTriangleStripSection = false;
        }
      }
      var geometry = new BufferGeometry();
      geometry.setIndex(indices);
      geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
      if (normals.length === positions.length) {
        geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      }
      if (colors.length !== indices.length) {
        if (colors.length === positions.length) {
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        }
      } else {
        geometry = geometry.toNonIndexed();
        var numTriangles = geometry.attributes.position.count / 3;
        if (colors.length === numTriangles * 3) {
          var newColors = [];
          for (var i2 = 0; i2 < numTriangles; i2++) {
            var r = colors[3 * i2 + 0];
            var g2 = colors[3 * i2 + 1];
            var b3 = colors[3 * i2 + 2];
            newColors.push(r, g2, b3);
            newColors.push(r, g2, b3);
            newColors.push(r, g2, b3);
          }
          geometry.setAttribute("color", new Float32BufferAttribute(newColors, 3));
        }
      }
      return geometry;
    }
    function parseBinary(data2) {
      var count, pointIndex, i2, numberOfPoints, s;
      var buffer2 = new Uint8Array(data2);
      var dataView = new DataView(data2);
      var points = [];
      var normals = [];
      var indices = [];
      var index = 0;
      function findString(buffer3, start) {
        var index2 = start;
        var c = buffer3[index2];
        var s2 = [];
        while (c !== 10) {
          s2.push(String.fromCharCode(c));
          index2++;
          c = buffer3[index2];
        }
        return {
          start,
          end: index2,
          next: index2 + 1,
          parsedString: s2.join("")
        };
      }
      var state, line2;
      while (true) {
        state = findString(buffer2, index);
        line2 = state.parsedString;
        if (line2.indexOf("DATASET") === 0) {
          var dataset = line2.split(" ")[1];
          if (dataset !== "POLYDATA")
            throw new Error("Unsupported DATASET type: " + dataset);
        } else if (line2.indexOf("POINTS") === 0) {
          numberOfPoints = parseInt(line2.split(" ")[1], 10);
          count = numberOfPoints * 4 * 3;
          points = new Float32Array(numberOfPoints * 3);
          pointIndex = state.next;
          for (i2 = 0; i2 < numberOfPoints; i2++) {
            points[3 * i2] = dataView.getFloat32(pointIndex, false);
            points[3 * i2 + 1] = dataView.getFloat32(pointIndex + 4, false);
            points[3 * i2 + 2] = dataView.getFloat32(pointIndex + 8, false);
            pointIndex = pointIndex + 12;
          }
          state.next = state.next + count + 1;
        } else if (line2.indexOf("TRIANGLE_STRIPS") === 0) {
          var numberOfStrips = parseInt(line2.split(" ")[1], 10);
          var size2 = parseInt(line2.split(" ")[2], 10);
          count = size2 * 4;
          indices = new Uint32Array(3 * size2 - 9 * numberOfStrips);
          var indicesIndex = 0;
          pointIndex = state.next;
          for (i2 = 0; i2 < numberOfStrips; i2++) {
            var indexCount = dataView.getInt32(pointIndex, false);
            var strip = [];
            pointIndex += 4;
            for (s = 0; s < indexCount; s++) {
              strip.push(dataView.getInt32(pointIndex, false));
              pointIndex += 4;
            }
            for (var j2 = 0; j2 < indexCount - 2; j2++) {
              if (j2 % 2) {
                indices[indicesIndex++] = strip[j2];
                indices[indicesIndex++] = strip[j2 + 2];
                indices[indicesIndex++] = strip[j2 + 1];
              } else {
                indices[indicesIndex++] = strip[j2];
                indices[indicesIndex++] = strip[j2 + 1];
                indices[indicesIndex++] = strip[j2 + 2];
              }
            }
          }
          state.next = state.next + count + 1;
        } else if (line2.indexOf("POLYGONS") === 0) {
          var numberOfStrips = parseInt(line2.split(" ")[1], 10);
          var size2 = parseInt(line2.split(" ")[2], 10);
          count = size2 * 4;
          indices = new Uint32Array(3 * size2 - 9 * numberOfStrips);
          var indicesIndex = 0;
          pointIndex = state.next;
          for (i2 = 0; i2 < numberOfStrips; i2++) {
            var indexCount = dataView.getInt32(pointIndex, false);
            var strip = [];
            pointIndex += 4;
            for (s = 0; s < indexCount; s++) {
              strip.push(dataView.getInt32(pointIndex, false));
              pointIndex += 4;
            }
            for (var j2 = 1; j2 < indexCount - 1; j2++) {
              indices[indicesIndex++] = strip[0];
              indices[indicesIndex++] = strip[j2];
              indices[indicesIndex++] = strip[j2 + 1];
            }
          }
          state.next = state.next + count + 1;
        } else if (line2.indexOf("POINT_DATA") === 0) {
          numberOfPoints = parseInt(line2.split(" ")[1], 10);
          state = findString(buffer2, state.next);
          count = numberOfPoints * 4 * 3;
          normals = new Float32Array(numberOfPoints * 3);
          pointIndex = state.next;
          for (i2 = 0; i2 < numberOfPoints; i2++) {
            normals[3 * i2] = dataView.getFloat32(pointIndex, false);
            normals[3 * i2 + 1] = dataView.getFloat32(pointIndex + 4, false);
            normals[3 * i2 + 2] = dataView.getFloat32(pointIndex + 8, false);
            pointIndex += 12;
          }
          state.next = state.next + count;
        }
        index = state.next;
        if (index >= buffer2.byteLength) {
          break;
        }
      }
      var geometry = new BufferGeometry();
      geometry.setIndex(new BufferAttribute(indices, 1));
      geometry.setAttribute("position", new BufferAttribute(points, 3));
      if (normals.length === points.length) {
        geometry.setAttribute("normal", new BufferAttribute(normals, 3));
      }
      return geometry;
    }
    function Float32Concat(first, second) {
      const firstLength = first.length, result = new Float32Array(firstLength + second.length);
      result.set(first);
      result.set(second, firstLength);
      return result;
    }
    function Int32Concat(first, second) {
      var firstLength = first.length, result = new Int32Array(firstLength + second.length);
      result.set(first);
      result.set(second, firstLength);
      return result;
    }
    function parseXML(stringFile) {
      function xmlToJson(xml) {
        var obj = {};
        if (xml.nodeType === 1) {
          if (xml.attributes) {
            if (xml.attributes.length > 0) {
              obj["attributes"] = {};
              for (var j3 = 0; j3 < xml.attributes.length; j3++) {
                var attribute2 = xml.attributes.item(j3);
                obj["attributes"][attribute2.nodeName] = attribute2.nodeValue.trim();
              }
            }
          }
        } else if (xml.nodeType === 3) {
          obj = xml.nodeValue.trim();
        }
        if (xml.hasChildNodes()) {
          for (var i3 = 0; i3 < xml.childNodes.length; i3++) {
            var item = xml.childNodes.item(i3);
            var nodeName = item.nodeName;
            if (typeof obj[nodeName] === "undefined") {
              var tmp = xmlToJson(item);
              if (tmp !== "")
                obj[nodeName] = tmp;
            } else {
              if (typeof obj[nodeName].push === "undefined") {
                var old = obj[nodeName];
                obj[nodeName] = [old];
              }
              var tmp = xmlToJson(item);
              if (tmp !== "")
                obj[nodeName].push(tmp);
            }
          }
        }
        return obj;
      }
      function Base64toByteArray(b64) {
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var i3;
        var lookup = [];
        var revLookup = [];
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var len2 = code.length;
        for (i3 = 0; i3 < len2; i3++) {
          lookup[i3] = code[i3];
        }
        for (i3 = 0; i3 < len2; ++i3) {
          revLookup[code.charCodeAt(i3)] = i3;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        var j3, l, tmp, placeHolders, arr2;
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        placeHolders = b64[len2 - 2] === "=" ? 2 : b64[len2 - 1] === "=" ? 1 : 0;
        arr2 = new Arr(len2 * 3 / 4 - placeHolders);
        l = placeHolders > 0 ? len2 - 4 : len2;
        var L = 0;
        for (i3 = 0, j3 = 0; i3 < l; i3 += 4, j3 += 3) {
          tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
          arr2[L++] = (tmp & 16711680) >> 16;
          arr2[L++] = (tmp & 65280) >> 8;
          arr2[L++] = tmp & 255;
        }
        if (placeHolders === 2) {
          tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
          arr2[L++] = tmp & 255;
        } else if (placeHolders === 1) {
          tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
          arr2[L++] = tmp >> 8 & 255;
          arr2[L++] = tmp & 255;
        }
        return arr2;
      }
      function parseDataArray(ele, compressed2) {
        var numBytes = 0;
        if (json.attributes.header_type === "UInt64") {
          numBytes = 8;
        } else if (json.attributes.header_type === "UInt32") {
          numBytes = 4;
        }
        if (ele.attributes.format === "binary" && compressed2) {
          var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;
          if (ele.attributes.type === "Float32") {
            var txt = new Float32Array();
          } else if (ele.attributes.type === "Int64") {
            var txt = new Int32Array();
          }
          rawData = ele["#text"];
          byteData = Base64toByteArray(rawData);
          blocks = byteData[0];
          for (var i3 = 1; i3 < numBytes - 1; i3++) {
            blocks = blocks | byteData[i3] << i3 * numBytes;
          }
          headerSize = (blocks + 3) * numBytes;
          padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;
          headerSize = headerSize + padding;
          dataOffsets = [];
          currentOffset = headerSize;
          dataOffsets.push(currentOffset);
          cSizeStart = 3 * numBytes;
          for (var i3 = 0; i3 < blocks; i3++) {
            var currentBlockSize = byteData[i3 * numBytes + cSizeStart];
            for (var j3 = 1; j3 < numBytes - 1; j3++) {
              currentBlockSize = currentBlockSize | byteData[i3 * numBytes + cSizeStart + j3] << j3 * 8;
            }
            currentOffset = currentOffset + currentBlockSize;
            dataOffsets.push(currentOffset);
          }
          for (var i3 = 0; i3 < dataOffsets.length - 1; i3++) {
            var data2 = unzlibSync(byteData.slice(dataOffsets[i3], dataOffsets[i3 + 1]));
            content = data2.buffer;
            if (ele.attributes.type === "Float32") {
              content = new Float32Array(content);
              txt = Float32Concat(txt, content);
            } else if (ele.attributes.type === "Int64") {
              content = new Int32Array(content);
              txt = Int32Concat(txt, content);
            }
          }
          delete ele["#text"];
          if (ele.attributes.type === "Int64") {
            if (ele.attributes.format === "binary") {
              txt = txt.filter(function(el, idx) {
                if (idx % 2 !== 1)
                  return true;
              });
            }
          }
        } else {
          if (ele.attributes.format === "binary" && !compressed2) {
            var content = Base64toByteArray(ele["#text"]);
            content = content.slice(numBytes).buffer;
          } else {
            if (ele["#text"]) {
              var content = ele["#text"].split(/\s+/).filter(function(el) {
                if (el !== "")
                  return el;
              });
            } else {
              var content = new Int32Array(0).buffer;
            }
          }
          delete ele["#text"];
          if (ele.attributes.type === "Float32") {
            var txt = new Float32Array(content);
          } else if (ele.attributes.type === "Int32") {
            var txt = new Int32Array(content);
          } else if (ele.attributes.type === "Int64") {
            var txt = new Int32Array(content);
            if (ele.attributes.format === "binary") {
              txt = txt.filter(function(el, idx) {
                if (idx % 2 !== 1)
                  return true;
              });
            }
          }
        }
        return txt;
      }
      var dom = null;
      if (window.DOMParser) {
        try {
          dom = new DOMParser().parseFromString(stringFile, "text/xml");
        } catch (e) {
          dom = null;
        }
      } else if (window.ActiveXObject) {
        try {
          dom = new ActiveXObject("Microsoft.XMLDOM");
          dom.async = false;
          if (!dom.loadXML()) {
            throw new Error(dom.parseError.reason + dom.parseError.srcText);
          }
        } catch (e) {
          dom = null;
        }
      } else {
        throw new Error("Cannot parse xml string!");
      }
      var doc = dom.documentElement;
      var json = xmlToJson(doc);
      var points = [];
      var normals = [];
      var indices = [];
      if (json.PolyData) {
        var piece = json.PolyData.Piece;
        var compressed = json.attributes.hasOwnProperty("compressor");
        var sections = ["PointData", "Points", "Strips", "Polys"];
        var sectionIndex = 0, numberOfSections = sections.length;
        while (sectionIndex < numberOfSections) {
          var section = piece[sections[sectionIndex]];
          if (section && section.DataArray) {
            if (Object.prototype.toString.call(section.DataArray) === "[object Array]") {
              var arr = section.DataArray;
            } else {
              var arr = [section.DataArray];
            }
            var dataArrayIndex = 0, numberOfDataArrays = arr.length;
            while (dataArrayIndex < numberOfDataArrays) {
              if ("#text" in arr[dataArrayIndex] && arr[dataArrayIndex]["#text"].length > 0) {
                arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);
              }
              dataArrayIndex++;
            }
            switch (sections[sectionIndex]) {
              case "PointData":
                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);
                var normalsName = section.attributes.Normals;
                if (numberOfPoints > 0) {
                  for (var i2 = 0, len = arr.length; i2 < len; i2++) {
                    if (normalsName === arr[i2].attributes.Name) {
                      var components = arr[i2].attributes.NumberOfComponents;
                      normals = new Float32Array(numberOfPoints * components);
                      normals.set(arr[i2].text, 0);
                    }
                  }
                }
                break;
              case "Points":
                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);
                if (numberOfPoints > 0) {
                  var components = section.DataArray.attributes.NumberOfComponents;
                  points = new Float32Array(numberOfPoints * components);
                  points.set(section.DataArray.text, 0);
                }
                break;
              case "Strips":
                var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);
                if (numberOfStrips > 0) {
                  var connectivity = new Int32Array(section.DataArray[0].text.length);
                  var offset = new Int32Array(section.DataArray[1].text.length);
                  connectivity.set(section.DataArray[0].text, 0);
                  offset.set(section.DataArray[1].text, 0);
                  var size2 = numberOfStrips + connectivity.length;
                  indices = new Uint32Array(3 * size2 - 9 * numberOfStrips);
                  var indicesIndex = 0;
                  for (var i2 = 0, len = numberOfStrips; i2 < len; i2++) {
                    var strip = [];
                    for (var s = 0, len1 = offset[i2], len0 = 0; s < len1 - len0; s++) {
                      strip.push(connectivity[s]);
                      if (i2 > 0)
                        len0 = offset[i2 - 1];
                    }
                    for (var j2 = 0, len1 = offset[i2], len0 = 0; j2 < len1 - len0 - 2; j2++) {
                      if (j2 % 2) {
                        indices[indicesIndex++] = strip[j2];
                        indices[indicesIndex++] = strip[j2 + 2];
                        indices[indicesIndex++] = strip[j2 + 1];
                      } else {
                        indices[indicesIndex++] = strip[j2];
                        indices[indicesIndex++] = strip[j2 + 1];
                        indices[indicesIndex++] = strip[j2 + 2];
                      }
                      if (i2 > 0)
                        len0 = offset[i2 - 1];
                    }
                  }
                }
                break;
              case "Polys":
                var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);
                if (numberOfPolys > 0) {
                  var connectivity = new Int32Array(section.DataArray[0].text.length);
                  var offset = new Int32Array(section.DataArray[1].text.length);
                  connectivity.set(section.DataArray[0].text, 0);
                  offset.set(section.DataArray[1].text, 0);
                  var size2 = numberOfPolys + connectivity.length;
                  indices = new Uint32Array(3 * size2 - 9 * numberOfPolys);
                  var indicesIndex = 0, connectivityIndex = 0;
                  var i2 = 0, len = numberOfPolys, len0 = 0;
                  while (i2 < len) {
                    var poly = [];
                    var s = 0, len1 = offset[i2];
                    while (s < len1 - len0) {
                      poly.push(connectivity[connectivityIndex++]);
                      s++;
                    }
                    var j2 = 1;
                    while (j2 < len1 - len0 - 1) {
                      indices[indicesIndex++] = poly[0];
                      indices[indicesIndex++] = poly[j2];
                      indices[indicesIndex++] = poly[j2 + 1];
                      j2++;
                    }
                    i2++;
                    len0 = offset[i2 - 1];
                  }
                }
                break;
            }
          }
          sectionIndex++;
        }
        var geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.setAttribute("position", new BufferAttribute(points, 3));
        if (normals.length === points.length) {
          geometry.setAttribute("normal", new BufferAttribute(normals, 3));
        }
        return geometry;
      } else {
        throw new Error("Unsupported DATASET type");
      }
    }
    var meta2 = LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split("\n");
    if (meta2[0].indexOf("xml") !== -1) {
      return parseXML(LoaderUtils.decodeText(data));
    } else if (meta2[2].includes("ASCII")) {
      return parseASCII(LoaderUtils.decodeText(data));
    } else {
      return parseBinary(data);
    }
  }
};

// node_modules/three-stdlib/loaders/LUT3dlLoader.js
var LUT3dlLoader = class extends Loader {
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("text");
    loader.load(url, (text) => {
      try {
        onLoad(this.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        this.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(str) {
    str = str.replace(/^#.*?(\n|\r)/gm, "").replace(/^\s*?(\n|\r)/gm, "").trim();
    const lines = str.split(/[\n\r]+/g);
    const gridLines = lines[0].trim().split(/\s+/g).map((e) => parseFloat(e));
    const gridStep = gridLines[1] - gridLines[0];
    const size2 = gridLines.length;
    for (let i2 = 1, l = gridLines.length; i2 < l; i2++) {
      if (gridStep !== gridLines[i2] - gridLines[i2 - 1]) {
        throw new Error("LUT3dlLoader: Inconsistent grid size not supported.");
      }
    }
    const dataArray2 = new Array(size2 * size2 * size2 * 4);
    let index = 0;
    let maxOutputValue = 0;
    for (let i2 = 1, l = lines.length; i2 < l; i2++) {
      const line2 = lines[i2].trim();
      const split = line2.split(/\s/g);
      const r = parseFloat(split[0]);
      const g2 = parseFloat(split[1]);
      const b3 = parseFloat(split[2]);
      maxOutputValue = Math.max(maxOutputValue, r, g2, b3);
      const bLayer = index % size2;
      const gLayer = Math.floor(index / size2) % size2;
      const rLayer = Math.floor(index / (size2 * size2)) % size2;
      const pixelIndex = bLayer * size2 * size2 + gLayer * size2 + rLayer;
      dataArray2[4 * pixelIndex + 0] = r;
      dataArray2[4 * pixelIndex + 1] = g2;
      dataArray2[4 * pixelIndex + 2] = b3;
      dataArray2[4 * pixelIndex + 3] = 1;
      index += 1;
    }
    const bits2 = Math.ceil(Math.log2(maxOutputValue));
    const maxBitValue = Math.pow(2, bits2);
    for (let i2 = 0, l = dataArray2.length; i2 < l; i2 += 4) {
      const r = dataArray2[i2 + 0];
      const g2 = dataArray2[i2 + 1];
      const b3 = dataArray2[i2 + 2];
      dataArray2[i2 + 0] = 255 * r / maxBitValue;
      dataArray2[i2 + 1] = 255 * g2 / maxBitValue;
      dataArray2[i2 + 2] = 255 * b3 / maxBitValue;
    }
    const data = new Uint8Array(dataArray2);
    const texture2 = new DataTexture();
    texture2.image.data = data;
    texture2.image.width = size2;
    texture2.image.height = size2 * size2;
    texture2.format = RGBAFormat;
    texture2.type = UnsignedByteType;
    texture2.magFilter = LinearFilter;
    texture2.minFilter = LinearFilter;
    texture2.wrapS = ClampToEdgeWrapping;
    texture2.wrapT = ClampToEdgeWrapping;
    texture2.generateMipmaps = false;
    const texture3D = new DataTexture3D();
    texture3D.image.data = data;
    texture3D.image.width = size2;
    texture3D.image.height = size2;
    texture3D.image.depth = size2;
    texture3D.format = RGBAFormat;
    texture3D.type = UnsignedByteType;
    texture3D.magFilter = LinearFilter;
    texture3D.minFilter = LinearFilter;
    texture3D.wrapS = ClampToEdgeWrapping;
    texture3D.wrapT = ClampToEdgeWrapping;
    texture3D.wrapR = ClampToEdgeWrapping;
    texture3D.generateMipmaps = false;
    return {
      size: size2,
      texture: texture2,
      texture3D
    };
  }
};

// node_modules/three-stdlib/loaders/DDSLoader.js
var DDSLoader = class extends CompressedTextureLoader {
  constructor(manager) {
    super(manager);
  }
  parse(buffer2, loadMipmaps) {
    const dds = {
      mipmaps: [],
      width: 0,
      height: 0,
      format: null,
      mipmapCount: 1
    };
    const DDS_MAGIC = 542327876;
    const DDSD_MIPMAPCOUNT = 131072;
    const DDSCAPS2_CUBEMAP = 512;
    const DDSCAPS2_CUBEMAP_POSITIVEX = 1024;
    const DDSCAPS2_CUBEMAP_NEGATIVEX = 2048;
    const DDSCAPS2_CUBEMAP_POSITIVEY = 4096;
    const DDSCAPS2_CUBEMAP_NEGATIVEY = 8192;
    const DDSCAPS2_CUBEMAP_POSITIVEZ = 16384;
    const DDSCAPS2_CUBEMAP_NEGATIVEZ = 32768;
    const DDPF_FOURCC = 4;
    function fourCCToInt32(value) {
      return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
    }
    function int32ToFourCC(value) {
      return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);
    }
    function loadARGBMip(buffer3, dataOffset2, width, height) {
      const dataLength = width * height * 4;
      const srcBuffer = new Uint8Array(buffer3, dataOffset2, dataLength);
      const byteArray = new Uint8Array(dataLength);
      let dst = 0;
      let src = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const b3 = srcBuffer[src];
          src++;
          const g2 = srcBuffer[src];
          src++;
          const r = srcBuffer[src];
          src++;
          const a2 = srcBuffer[src];
          src++;
          byteArray[dst] = r;
          dst++;
          byteArray[dst] = g2;
          dst++;
          byteArray[dst] = b3;
          dst++;
          byteArray[dst] = a2;
          dst++;
        }
      }
      return byteArray;
    }
    const FOURCC_DXT1 = fourCCToInt32("DXT1");
    const FOURCC_DXT3 = fourCCToInt32("DXT3");
    const FOURCC_DXT5 = fourCCToInt32("DXT5");
    const FOURCC_ETC1 = fourCCToInt32("ETC1");
    const headerLengthInt = 31;
    const off_magic = 0;
    const off_size = 1;
    const off_flags = 2;
    const off_height = 3;
    const off_width = 4;
    const off_mipmapCount = 7;
    const off_pfFlags = 20;
    const off_pfFourCC = 21;
    const off_RGBBitCount = 22;
    const off_RBitMask = 23;
    const off_GBitMask = 24;
    const off_BBitMask = 25;
    const off_ABitMask = 26;
    const off_caps2 = 28;
    const header = new Int32Array(buffer2, 0, headerLengthInt);
    if (header[off_magic] !== DDS_MAGIC) {
      console.error("THREE.DDSLoader.parse: Invalid magic number in DDS header.");
      return dds;
    }
    if (!header[off_pfFlags] & DDPF_FOURCC) {
      console.error("THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.");
      return dds;
    }
    let blockBytes;
    const fourCC = header[off_pfFourCC];
    let isRGBAUncompressed = false;
    switch (fourCC) {
      case FOURCC_DXT1:
        blockBytes = 8;
        dds.format = RGB_S3TC_DXT1_Format;
        break;
      case FOURCC_DXT3:
        blockBytes = 16;
        dds.format = RGBA_S3TC_DXT3_Format;
        break;
      case FOURCC_DXT5:
        blockBytes = 16;
        dds.format = RGBA_S3TC_DXT5_Format;
        break;
      case FOURCC_ETC1:
        blockBytes = 8;
        dds.format = RGB_ETC1_Format;
        break;
      default:
        if (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 16711680 && header[off_GBitMask] & 65280 && header[off_BBitMask] & 255 && header[off_ABitMask] & 4278190080) {
          isRGBAUncompressed = true;
          blockBytes = 64;
          dds.format = RGBAFormat;
        } else {
          console.error("THREE.DDSLoader.parse: Unsupported FourCC code ", int32ToFourCC(fourCC));
          return dds;
        }
    }
    dds.mipmapCount = 1;
    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
      dds.mipmapCount = Math.max(1, header[off_mipmapCount]);
    }
    const caps2 = header[off_caps2];
    dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;
    if (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {
      console.error("THREE.DDSLoader.parse: Incomplete cubemap faces");
      return dds;
    }
    dds.width = header[off_width];
    dds.height = header[off_height];
    let dataOffset = header[off_size] + 4;
    const faces = dds.isCubemap ? 6 : 1;
    for (let face = 0; face < faces; face++) {
      let width = dds.width;
      let height = dds.height;
      for (let i2 = 0; i2 < dds.mipmapCount; i2++) {
        let byteArray, dataLength;
        if (isRGBAUncompressed) {
          byteArray = loadARGBMip(buffer2, dataOffset, width, height);
          dataLength = byteArray.length;
        } else {
          dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
          byteArray = new Uint8Array(buffer2, dataOffset, dataLength);
        }
        const mipmap = {
          data: byteArray,
          width,
          height
        };
        dds.mipmaps.push(mipmap);
        dataOffset += dataLength;
        width = Math.max(width >> 1, 1);
        height = Math.max(height >> 1, 1);
      }
    }
    return dds;
  }
};

// node_modules/three-stdlib/loaders/PVRLoader.js
var PVRLoader = class extends CompressedTextureLoader {
  constructor(manager) {
    super(manager);
  }
  parse(buffer2, loadMipmaps) {
    const headerLengthInt = 13;
    const header = new Uint32Array(buffer2, 0, headerLengthInt);
    const pvrDatas = {
      buffer: buffer2,
      header,
      loadMipmaps
    };
    if (header[0] === 55727696) {
      return _parseV3(pvrDatas);
    } else if (header[11] === 559044176) {
      return _parseV2(pvrDatas);
    } else {
      console.error("THREE.PVRLoader: Unknown PVR format.");
    }
  }
};
function _parseV3(pvrDatas) {
  const header = pvrDatas.header;
  let bpp, format;
  const metaLen = header[12], pixelFormat = header[2], height = header[6], width = header[7], numFaces = header[10], numMipmaps = header[11];
  switch (pixelFormat) {
    case 0:
      bpp = 2;
      format = RGB_PVRTC_2BPPV1_Format;
      break;
    case 1:
      bpp = 2;
      format = RGBA_PVRTC_2BPPV1_Format;
      break;
    case 2:
      bpp = 4;
      format = RGB_PVRTC_4BPPV1_Format;
      break;
    case 3:
      bpp = 4;
      format = RGBA_PVRTC_4BPPV1_Format;
      break;
    default:
      console.error("THREE.PVRLoader: Unsupported PVR format:", pixelFormat);
  }
  pvrDatas.dataPtr = 52 + metaLen;
  pvrDatas.bpp = bpp;
  pvrDatas.format = format;
  pvrDatas.width = width;
  pvrDatas.height = height;
  pvrDatas.numSurfaces = numFaces;
  pvrDatas.numMipmaps = numMipmaps;
  pvrDatas.isCubemap = numFaces === 6;
  return _extract(pvrDatas);
}
function _parseV2(pvrDatas) {
  const header = pvrDatas.header;
  const headerLength = header[0], height = header[1], width = header[2], numMipmaps = header[3], flags = header[4], bitmaskAlpha = header[10], numSurfs = header[12];
  const TYPE_MASK = 255;
  const PVRTC_2 = 24, PVRTC_4 = 25;
  const formatFlags = flags & TYPE_MASK;
  let bpp, format;
  const _hasAlpha = bitmaskAlpha > 0;
  if (formatFlags === PVRTC_4) {
    format = _hasAlpha ? RGBA_PVRTC_4BPPV1_Format : RGB_PVRTC_4BPPV1_Format;
    bpp = 4;
  } else if (formatFlags === PVRTC_2) {
    format = _hasAlpha ? RGBA_PVRTC_2BPPV1_Format : RGB_PVRTC_2BPPV1_Format;
    bpp = 2;
  } else {
    console.error("THREE.PVRLoader: Unknown PVR format:", formatFlags);
  }
  pvrDatas.dataPtr = headerLength;
  pvrDatas.bpp = bpp;
  pvrDatas.format = format;
  pvrDatas.width = width;
  pvrDatas.height = height;
  pvrDatas.numSurfaces = numSurfs;
  pvrDatas.numMipmaps = numMipmaps + 1;
  pvrDatas.isCubemap = numSurfs === 6;
  return _extract(pvrDatas);
}
function _extract(pvrDatas) {
  const pvr = {
    mipmaps: [],
    width: pvrDatas.width,
    height: pvrDatas.height,
    format: pvrDatas.format,
    mipmapCount: pvrDatas.numMipmaps,
    isCubemap: pvrDatas.isCubemap
  };
  const buffer2 = pvrDatas.buffer;
  let dataOffset = pvrDatas.dataPtr, dataSize = 0, blockSize = 0, blockWidth = 0, blockHeight = 0, widthBlocks = 0, heightBlocks = 0;
  const bpp = pvrDatas.bpp, numSurfs = pvrDatas.numSurfaces;
  if (bpp === 2) {
    blockWidth = 8;
    blockHeight = 4;
  } else {
    blockWidth = 4;
    blockHeight = 4;
  }
  blockSize = blockWidth * blockHeight * bpp / 8;
  pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;
  let mipLevel = 0;
  while (mipLevel < pvrDatas.numMipmaps) {
    const sWidth = pvrDatas.width >> mipLevel, sHeight = pvrDatas.height >> mipLevel;
    widthBlocks = sWidth / blockWidth;
    heightBlocks = sHeight / blockHeight;
    if (widthBlocks < 2)
      widthBlocks = 2;
    if (heightBlocks < 2)
      heightBlocks = 2;
    dataSize = widthBlocks * heightBlocks * blockSize;
    for (let surfIndex = 0; surfIndex < numSurfs; surfIndex++) {
      const byteArray = new Uint8Array(buffer2, dataOffset, dataSize);
      const mipmap = {
        data: byteArray,
        width: sWidth,
        height: sHeight
      };
      pvr.mipmaps[surfIndex * pvrDatas.numMipmaps + mipLevel] = mipmap;
      dataOffset += dataSize;
    }
    mipLevel++;
  }
  return pvr;
}

// node_modules/three-stdlib/loaders/GCodeLoader.js
var GCodeLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.splitLayer = false;
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope2.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(data) {
    let state = {
      x: 0,
      y: 0,
      z: 0,
      e: 0,
      f: 0,
      extruding: false,
      relative: false
    };
    let layers = [];
    let currentLayer = void 0;
    const pathMaterial = new LineBasicMaterial({
      color: 16711680
    });
    pathMaterial.name = "path";
    const extrudingMaterial = new LineBasicMaterial({
      color: 65280
    });
    extrudingMaterial.name = "extruded";
    function newLayer(line2) {
      currentLayer = {
        vertex: [],
        pathVertex: [],
        z: line2.z
      };
      layers.push(currentLayer);
    }
    function addSegment2(p1, p2) {
      if (currentLayer === void 0) {
        newLayer(p1);
      }
      if (state.extruding) {
        currentLayer.vertex.push(p1.x, p1.y, p1.z);
        currentLayer.vertex.push(p2.x, p2.y, p2.z);
      } else {
        currentLayer.pathVertex.push(p1.x, p1.y, p1.z);
        currentLayer.pathVertex.push(p2.x, p2.y, p2.z);
      }
    }
    function delta(v12, v2) {
      return state.relative ? v2 : v2 - v12;
    }
    function absolute(v12, v2) {
      return state.relative ? v12 + v2 : v2;
    }
    let lines = data.replace(/;.+/g, "").split("\n");
    for (let i2 = 0; i2 < lines.length; i2++) {
      let tokens = lines[i2].split(" ");
      let cmd = tokens[0].toUpperCase();
      let args = {};
      tokens.splice(1).forEach(function(token) {
        if (token[0] !== void 0) {
          let key = token[0].toLowerCase();
          let value = parseFloat(token.substring(1));
          args[key] = value;
        }
      });
      if (cmd === "G0" || cmd === "G1") {
        let line2 = {
          x: args.x !== void 0 ? absolute(state.x, args.x) : state.x,
          y: args.y !== void 0 ? absolute(state.y, args.y) : state.y,
          z: args.z !== void 0 ? absolute(state.z, args.z) : state.z,
          e: args.e !== void 0 ? absolute(state.e, args.e) : state.e,
          f: args.f !== void 0 ? absolute(state.f, args.f) : state.f
        };
        if (delta(state.e, line2.e) > 0) {
          line2.extruding = delta(state.e, line2.e) > 0;
          if (currentLayer == void 0 || line2.z != currentLayer.z) {
            newLayer(line2);
          }
        }
        addSegment2(state, line2);
        state = line2;
      } else if (cmd === "G2" || cmd === "G3")
        ;
      else if (cmd === "G90") {
        state.relative = false;
      } else if (cmd === "G91") {
        state.relative = true;
      } else if (cmd === "G92") {
        let line2 = state;
        line2.x = args.x !== void 0 ? args.x : line2.x;
        line2.y = args.y !== void 0 ? args.y : line2.y;
        line2.z = args.z !== void 0 ? args.z : line2.z;
        line2.e = args.e !== void 0 ? args.e : line2.e;
        state = line2;
      } else
        ;
    }
    function addObject(vertex, extruding, i2) {
      let geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute(vertex, 3));
      let segments = new LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial);
      segments.name = "layer" + i2;
      object.add(segments);
    }
    const object = new Group();
    object.name = "gcode";
    if (this.splitLayer) {
      for (let i2 = 0; i2 < layers.length; i2++) {
        let layer = layers[i2];
        addObject(layer.vertex, true, i2);
        addObject(layer.pathVertex, false, i2);
      }
    } else {
      const vertex = [], pathVertex = [];
      for (let i2 = 0; i2 < layers.length; i2++) {
        let layer = layers[i2];
        let layerVertex = layer.vertex;
        let layerPathVertex = layer.pathVertex;
        for (let j2 = 0; j2 < layerVertex.length; j2++) {
          vertex.push(layerVertex[j2]);
        }
        for (let j2 = 0; j2 < layerPathVertex.length; j2++) {
          pathVertex.push(layerPathVertex[j2]);
        }
      }
      addObject(vertex, true, layers.length);
      addObject(pathVertex, false, layers.length);
    }
    object.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));
    return object;
  }
};

// node_modules/three-stdlib/loaders/BasisTextureLoader.js
var _taskCache2 = /* @__PURE__ */ new WeakMap();
var BasisTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.transcoderPath = "";
    this.transcoderBinary = null;
    this.transcoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.workerConfig = null;
  }
  setTranscoderPath(path) {
    this.transcoderPath = path;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  detectSupport(renderer) {
    this.workerConfig = {
      astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
      etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    };
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader2(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setWithCredentials(this.withCredentials);
    const texture2 = new CompressedTexture();
    loader.load(url, (buffer2) => {
      if (_taskCache2.has(buffer2)) {
        const cachedTask = _taskCache2.get(buffer2);
        return cachedTask.promise.then(onLoad).catch(onError);
      }
      this._createTexture([buffer2]).then(function(_texture) {
        texture2.copy(_texture);
        texture2.needsUpdate = true;
        if (onLoad)
          onLoad(texture2);
      }).catch(onError);
    }, onProgress, onError);
    return texture2;
  }
  parseInternalAsync(options) {
    const {
      levels
    } = options;
    const buffers = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < levels.length; i2++) {
      buffers.add(levels[i2].data.buffer);
    }
    return this._createTexture(Array.from(buffers), {
      ...options,
      lowLevel: true
    });
  }
  _createTexture(buffers, config = {}) {
    let worker;
    let taskID;
    const taskConfig = config;
    let taskCost = 0;
    for (let i2 = 0; i2 < buffers.length; i2++) {
      taskCost += buffers[i2].byteLength;
    }
    const texturePending = this._allocateWorker(taskCost).then((_worker) => {
      worker = _worker;
      taskID = this.workerNextTaskID++;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = {
          resolve,
          reject
        };
        worker.postMessage({
          type: "transcode",
          id: taskID,
          buffers,
          taskConfig
        }, buffers);
      });
    }).then((message) => {
      const {
        mipmaps,
        width,
        height,
        format
      } = message;
      const texture2 = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);
      texture2.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
      texture2.magFilter = LinearFilter;
      texture2.generateMipmaps = false;
      texture2.needsUpdate = true;
      return texture2;
    });
    texturePending.catch(() => true).then(() => {
      if (worker && taskID) {
        worker._taskLoad -= taskCost;
        delete worker._callbacks[taskID];
      }
    });
    _taskCache2.set(buffers[0], {
      promise: texturePending
    });
    return texturePending;
  }
  _initTranscoder() {
    if (!this.transcoderPending) {
      const jsLoader = new FileLoader2(this.manager);
      jsLoader.setPath(this.transcoderPath);
      jsLoader.setWithCredentials(this.withCredentials);
      const jsContent = new Promise((resolve, reject) => {
        jsLoader.load("basis_transcoder.js", resolve, void 0, reject);
      });
      const binaryLoader = new FileLoader2(this.manager);
      binaryLoader.setPath(this.transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.withCredentials);
      const binaryContent = new Promise((resolve, reject) => {
        binaryLoader.load("basis_transcoder.wasm", resolve, void 0, reject);
      });
      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn = BasisTextureLoader.BasisWorker.toString();
        const body = ["/* constants */", "let _EngineFormat = " + JSON.stringify(BasisTextureLoader.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(BasisTextureLoader.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(BasisTextureLoader.BasisFormat), "/* basis_transcoder.js */", jsContent2, "/* worker */", fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.transcoderBinary = binaryContent2;
      });
    }
    return this.transcoderPending;
  }
  _allocateWorker(taskCost) {
    return this._initTranscoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskLoad = 0;
        worker2.postMessage({
          type: "init",
          config: this.workerConfig,
          transcoderBinary: this.transcoderBinary
        });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "transcode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.BasisTextureLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a2, b3) {
          return a2._taskLoad > b3._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  dispose() {
    for (let i2 = 0; i2 < this.workerPool.length; i2++) {
      this.workerPool[i2].terminate();
    }
    this.workerPool.length = 0;
    return this;
  }
};
BasisTextureLoader.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
BasisTextureLoader.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
BasisTextureLoader.EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format
};
BasisTextureLoader.BasisWorker = function() {
  let config;
  let transcoderPending;
  let BasisModule;
  const EngineFormat = _EngineFormat;
  const TranscoderFormat = _TranscoderFormat;
  const BasisFormat = _BasisFormat;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config = message.config;
        init(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const {
              width,
              height,
              hasAlpha,
              mipmaps,
              format
            } = message.taskConfig.lowLevel ? transcodeLowLevel(message.taskConfig) : transcode(message.buffers[0]);
            const buffers = [];
            for (let i2 = 0; i2 < mipmaps.length; ++i2) {
              buffers.push(mipmaps[i2].data.buffer);
            }
            self.postMessage({
              type: "transcode",
              id: message.id,
              width,
              height,
              hasAlpha,
              mipmaps,
              format
            }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({
              type: "error",
              id: message.id,
              error: error.message
            });
          }
        });
        break;
    }
  };
  function init(wasmBinary) {
    transcoderPending = new Promise((resolve) => {
      BasisModule = {
        wasmBinary,
        onRuntimeInitialized: resolve
      };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
    });
  }
  function transcodeLowLevel(taskConfig) {
    const {
      basisFormat,
      width,
      height,
      hasAlpha
    } = taskConfig;
    const {
      transcoderFormat,
      engineFormat
    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);
    assert(BasisModule.isFormatSupported(transcoderFormat), "THREE.BasisTextureLoader: Unsupported format.");
    const mipmaps = [];
    if (basisFormat === BasisFormat.ETC1S) {
      const transcoder = new BasisModule.LowLevelETC1SImageTranscoder();
      const {
        endpointCount,
        endpointsData,
        selectorCount,
        selectorsData,
        tablesData
      } = taskConfig.globalData;
      try {
        let ok;
        ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData);
        assert(ok, "THREE.BasisTextureLoader: decodePalettes() failed.");
        ok = transcoder.decodeTables(tablesData);
        assert(ok, "THREE.BasisTextureLoader: decodeTables() failed.");
        for (let i2 = 0; i2 < taskConfig.levels.length; i2++) {
          const level = taskConfig.levels[i2];
          const imageDesc = taskConfig.globalData.imageDescs[i2];
          const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);
          const dst = new Uint8Array(dstByteLength);
          ok = transcoder.transcodeImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength, imageDesc.alphaSliceByteOffset, imageDesc.alphaSliceByteLength, imageDesc.imageFlags, hasAlpha, false, 0, 0);
          assert(ok, "THREE.BasisTextureLoader: transcodeImage() failed for level " + level.index + ".");
          mipmaps.push({
            data: dst,
            width: level.width,
            height: level.height
          });
        }
      } finally {
        transcoder.delete();
      }
    } else {
      for (let i2 = 0; i2 < taskConfig.levels.length; i2++) {
        const level = taskConfig.levels[i2];
        const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);
        const dst = new Uint8Array(dstByteLength);
        const ok = BasisModule.transcodeUASTCImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, 0, level.data.byteLength, 0, hasAlpha, false, 0, 0, -1, -1);
        assert(ok, "THREE.BasisTextureLoader: transcodeUASTCImage() failed for level " + level.index + ".");
        mipmaps.push({
          data: dst,
          width: level.width,
          height: level.height
        });
      }
    }
    return {
      width,
      height,
      hasAlpha,
      mipmaps,
      format: engineFormat
    };
  }
  function transcode(buffer2) {
    const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer2));
    const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
    const width = basisFile.getImageWidth(0, 0);
    const height = basisFile.getImageHeight(0, 0);
    const levels = basisFile.getNumLevels(0);
    const hasAlpha = basisFile.getHasAlpha();
    function cleanup() {
      basisFile.close();
      basisFile.delete();
    }
    const {
      transcoderFormat,
      engineFormat
    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levels) {
      cleanup();
      throw new Error("THREE.BasisTextureLoader:	Invalid texture");
    }
    if (!basisFile.startTranscoding()) {
      cleanup();
      throw new Error("THREE.BasisTextureLoader: .startTranscoding failed");
    }
    const mipmaps = [];
    for (let mip = 0; mip < levels; mip++) {
      const mipWidth = basisFile.getImageWidth(0, mip);
      const mipHeight = basisFile.getImageHeight(0, mip);
      const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat));
      const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha);
      if (!status) {
        cleanup();
        throw new Error("THREE.BasisTextureLoader: .transcodeImage failed.");
      }
      mipmaps.push({
        data: dst,
        width: mipWidth,
        height: mipHeight
      });
    }
    cleanup();
    return {
      width,
      height,
      hasAlpha,
      mipmaps,
      format: engineFormat
    };
  }
  const FORMAT_OPTIONS = [{
    if: "astcSupported",
    basisFormat: [BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
    priorityETC1S: Infinity,
    priorityUASTC: 1,
    needsPowerOfTwo: false
  }, {
    if: "bptcSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
    priorityETC1S: 3,
    priorityUASTC: 2,
    needsPowerOfTwo: false
  }, {
    if: "dxtSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
    priorityETC1S: 4,
    priorityUASTC: 5,
    needsPowerOfTwo: false
  }, {
    if: "etc2Supported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
    priorityETC1S: 1,
    priorityUASTC: 3,
    needsPowerOfTwo: false
  }, {
    if: "etc1Supported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],
    engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],
    priorityETC1S: 2,
    priorityUASTC: 4,
    needsPowerOfTwo: false
  }, {
    if: "pvrtcSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
    priorityETC1S: 5,
    priorityUASTC: 6,
    needsPowerOfTwo: true
  }];
  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b3) {
    return a2.priorityETC1S - b3.priorityETC1S;
  });
  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b3) {
    return a2.priorityUASTC - b3.priorityUASTC;
  });
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    let transcoderFormat;
    let engineFormat;
    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
    for (let i2 = 0; i2 < options.length; i2++) {
      const opt = options[i2];
      if (!config[opt.if])
        continue;
      if (!opt.basisFormat.includes(basisFormat))
        continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height)))
        continue;
      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      return {
        transcoderFormat,
        engineFormat
      };
    }
    console.warn("THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.");
    transcoderFormat = TranscoderFormat.RGBA32;
    engineFormat = EngineFormat.RGBAFormat;
    return {
      transcoderFormat,
      engineFormat
    };
  }
  function assert(ok, message) {
    if (!ok)
      throw new Error(message);
  }
  function getWidthInBlocks(transcoderFormat, width) {
    return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat));
  }
  function getHeightInBlocks(transcoderFormat, height) {
    return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat));
  }
  function getTranscodedImageByteLength(transcoderFormat, width, height) {
    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);
    if (BasisModule.formatIsUncompressed(transcoderFormat)) {
      return width * height * blockByteLength;
    }
    if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {
      const paddedWidth = width + 3 & ~3;
      const paddedHeight = height + 3 & ~3;
      return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8;
    }
    return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength;
  }
  function isPowerOfTwo(value) {
    if (value <= 2)
      return true;
    return (value & value - 1) === 0 && value !== 0;
  }
};

// node_modules/three-stdlib/loaders/TDSLoader.js
var TDSLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.debug = false;
    this.group = null;
    this.position = 0;
    this.materials = [];
    this.meshes = [];
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(data) {
      try {
        onLoad(scope2.parse(data, path));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(arraybuffer, path) {
    this.group = new Group();
    this.position = 0;
    this.materials = [];
    this.meshes = [];
    this.readFile(arraybuffer, path);
    for (let i2 = 0; i2 < this.meshes.length; i2++) {
      this.group.add(this.meshes[i2]);
    }
    return this.group;
  }
  readFile(arraybuffer, path) {
    const data = new DataView(arraybuffer);
    const chunk = this.readChunk(data);
    if (chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC) {
      let next = this.nextChunk(data, chunk);
      while (next !== 0) {
        if (next === M3D_VERSION) {
          const version = this.readDWord(data);
          this.debugMessage("3DS file version: " + version);
        } else if (next === MDATA) {
          this.resetPosition(data);
          this.readMeshData(data, path);
        } else {
          this.debugMessage("Unknown main chunk: " + next.toString(16));
        }
        next = this.nextChunk(data, chunk);
      }
    }
    this.debugMessage("Parsed " + this.meshes.length + " meshes");
  }
  readMeshData(data, path) {
    const chunk = this.readChunk(data);
    let next = this.nextChunk(data, chunk);
    while (next !== 0) {
      if (next === MESH_VERSION) {
        const version = +this.readDWord(data);
        this.debugMessage("Mesh Version: " + version);
      } else if (next === MASTER_SCALE) {
        const scale = this.readFloat(data);
        this.debugMessage("Master scale: " + scale);
        this.group.scale.set(scale, scale, scale);
      } else if (next === NAMED_OBJECT) {
        this.debugMessage("Named Object");
        this.resetPosition(data);
        this.readNamedObject(data);
      } else if (next === MAT_ENTRY) {
        this.debugMessage("Material");
        this.resetPosition(data);
        this.readMaterialEntry(data, path);
      } else {
        this.debugMessage("Unknown MDATA chunk: " + next.toString(16));
      }
      next = this.nextChunk(data, chunk);
    }
  }
  readNamedObject(data) {
    const chunk = this.readChunk(data);
    const name = this.readString(data, 64);
    chunk.cur = this.position;
    let next = this.nextChunk(data, chunk);
    while (next !== 0) {
      if (next === N_TRI_OBJECT) {
        this.resetPosition(data);
        const mesh = this.readMesh(data);
        mesh.name = name;
        this.meshes.push(mesh);
      } else {
        this.debugMessage("Unknown named object chunk: " + next.toString(16));
      }
      next = this.nextChunk(data, chunk);
    }
    this.endChunk(chunk);
  }
  readMaterialEntry(data, path) {
    const chunk = this.readChunk(data);
    let next = this.nextChunk(data, chunk);
    const material = new MeshPhongMaterial();
    while (next !== 0) {
      if (next === MAT_NAME) {
        material.name = this.readString(data, 64);
        this.debugMessage("   Name: " + material.name);
      } else if (next === MAT_WIRE) {
        this.debugMessage("   Wireframe");
        material.wireframe = true;
      } else if (next === MAT_WIRE_SIZE) {
        const value = this.readByte(data);
        material.wireframeLinewidth = value;
        this.debugMessage("   Wireframe Thickness: " + value);
      } else if (next === MAT_TWO_SIDE) {
        material.side = DoubleSide;
        this.debugMessage("   DoubleSided");
      } else if (next === MAT_ADDITIVE) {
        this.debugMessage("   Additive Blending");
        material.blending = AdditiveBlending;
      } else if (next === MAT_DIFFUSE) {
        this.debugMessage("   Diffuse Color");
        material.color = this.readColor(data);
      } else if (next === MAT_SPECULAR) {
        this.debugMessage("   Specular Color");
        material.specular = this.readColor(data);
      } else if (next === MAT_AMBIENT) {
        this.debugMessage("   Ambient color");
        material.color = this.readColor(data);
      } else if (next === MAT_SHININESS) {
        const shininess = this.readPercentage(data);
        material.shininess = shininess * 100;
        this.debugMessage("   Shininess : " + shininess);
      } else if (next === MAT_TRANSPARENCY) {
        const transparency = this.readPercentage(data);
        material.opacity = 1 - transparency;
        this.debugMessage("  Transparency : " + transparency);
        material.transparent = material.opacity < 1 ? true : false;
      } else if (next === MAT_TEXMAP) {
        this.debugMessage("   ColorMap");
        this.resetPosition(data);
        material.map = this.readMap(data, path);
      } else if (next === MAT_BUMPMAP) {
        this.debugMessage("   BumpMap");
        this.resetPosition(data);
        material.bumpMap = this.readMap(data, path);
      } else if (next === MAT_OPACMAP) {
        this.debugMessage("   OpacityMap");
        this.resetPosition(data);
        material.alphaMap = this.readMap(data, path);
      } else if (next === MAT_SPECMAP) {
        this.debugMessage("   SpecularMap");
        this.resetPosition(data);
        material.specularMap = this.readMap(data, path);
      } else {
        this.debugMessage("   Unknown material chunk: " + next.toString(16));
      }
      next = this.nextChunk(data, chunk);
    }
    this.endChunk(chunk);
    this.materials[material.name] = material;
  }
  readMesh(data) {
    const chunk = this.readChunk(data);
    let next = this.nextChunk(data, chunk);
    const geometry = new BufferGeometry();
    const material = new MeshPhongMaterial();
    const mesh = new Mesh(geometry, material);
    mesh.name = "mesh";
    while (next !== 0) {
      if (next === POINT_ARRAY) {
        const points = this.readWord(data);
        this.debugMessage("   Vertex: " + points);
        const vertices = [];
        for (let i2 = 0; i2 < points; i2++) {
          vertices.push(this.readFloat(data));
          vertices.push(this.readFloat(data));
          vertices.push(this.readFloat(data));
        }
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      } else if (next === FACE_ARRAY) {
        this.resetPosition(data);
        this.readFaceArray(data, mesh);
      } else if (next === TEX_VERTS) {
        const texels = this.readWord(data);
        this.debugMessage("   UV: " + texels);
        const uvs = [];
        for (let i2 = 0; i2 < texels; i2++) {
          uvs.push(this.readFloat(data));
          uvs.push(this.readFloat(data));
        }
        geometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      } else if (next === MESH_MATRIX) {
        this.debugMessage("   Tranformation Matrix (TODO)");
        const values = [];
        for (let i2 = 0; i2 < 12; i2++) {
          values[i2] = this.readFloat(data);
        }
        const matrix3 = new Matrix4();
        matrix3.elements[0] = values[0];
        matrix3.elements[1] = values[6];
        matrix3.elements[2] = values[3];
        matrix3.elements[3] = values[9];
        matrix3.elements[4] = values[2];
        matrix3.elements[5] = values[8];
        matrix3.elements[6] = values[5];
        matrix3.elements[7] = values[11];
        matrix3.elements[8] = values[1];
        matrix3.elements[9] = values[7];
        matrix3.elements[10] = values[4];
        matrix3.elements[11] = values[10];
        matrix3.elements[12] = 0;
        matrix3.elements[13] = 0;
        matrix3.elements[14] = 0;
        matrix3.elements[15] = 1;
        matrix3.transpose();
        const inverse2 = new Matrix4();
        inverse2.copy(matrix3).invert();
        geometry.applyMatrix4(inverse2);
        matrix3.decompose(mesh.position, mesh.quaternion, mesh.scale);
      } else {
        this.debugMessage("   Unknown mesh chunk: " + next.toString(16));
      }
      next = this.nextChunk(data, chunk);
    }
    this.endChunk(chunk);
    geometry.computeVertexNormals();
    return mesh;
  }
  readFaceArray(data, mesh) {
    const chunk = this.readChunk(data);
    const faces = this.readWord(data);
    this.debugMessage("   Faces: " + faces);
    const index = [];
    for (let i2 = 0; i2 < faces; ++i2) {
      index.push(this.readWord(data), this.readWord(data), this.readWord(data));
      this.readWord(data);
    }
    mesh.geometry.setIndex(index);
    let materialIndex = 0;
    let start = 0;
    while (this.position < chunk.end) {
      const subchunk = this.readChunk(data);
      if (subchunk.id === MSH_MAT_GROUP) {
        this.debugMessage("      Material Group");
        this.resetPosition(data);
        const group = this.readMaterialGroup(data);
        const count = group.index.length * 3;
        mesh.geometry.addGroup(start, count, materialIndex);
        start += count;
        materialIndex++;
        const material = this.materials[group.name];
        if (Array.isArray(mesh.material) === false)
          mesh.material = [];
        if (material !== void 0) {
          mesh.material.push(material);
        }
      } else {
        this.debugMessage("      Unknown face array chunk: " + subchunk.toString(16));
      }
      this.endChunk(subchunk);
    }
    if (mesh.material.length === 1)
      mesh.material = mesh.material[0];
    this.endChunk(chunk);
  }
  readMap(data, path) {
    const chunk = this.readChunk(data);
    let next = this.nextChunk(data, chunk);
    let texture2 = {};
    const loader = new TextureLoader(this.manager);
    loader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    while (next !== 0) {
      if (next === MAT_MAPNAME) {
        const name = this.readString(data, 128);
        texture2 = loader.load(name);
        this.debugMessage("      File: " + path + name);
      } else if (next === MAT_MAP_UOFFSET) {
        texture2.offset.x = this.readFloat(data);
        this.debugMessage("      OffsetX: " + texture2.offset.x);
      } else if (next === MAT_MAP_VOFFSET) {
        texture2.offset.y = this.readFloat(data);
        this.debugMessage("      OffsetY: " + texture2.offset.y);
      } else if (next === MAT_MAP_USCALE) {
        texture2.repeat.x = this.readFloat(data);
        this.debugMessage("      RepeatX: " + texture2.repeat.x);
      } else if (next === MAT_MAP_VSCALE) {
        texture2.repeat.y = this.readFloat(data);
        this.debugMessage("      RepeatY: " + texture2.repeat.y);
      } else {
        this.debugMessage("      Unknown map chunk: " + next.toString(16));
      }
      next = this.nextChunk(data, chunk);
    }
    this.endChunk(chunk);
    return texture2;
  }
  readMaterialGroup(data) {
    this.readChunk(data);
    const name = this.readString(data, 64);
    const numFaces = this.readWord(data);
    this.debugMessage("         Name: " + name);
    this.debugMessage("         Faces: " + numFaces);
    const index = [];
    for (let i2 = 0; i2 < numFaces; ++i2) {
      index.push(this.readWord(data));
    }
    return {
      name,
      index
    };
  }
  readColor(data) {
    const chunk = this.readChunk(data);
    const color2 = new Color();
    if (chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24) {
      const r = this.readByte(data);
      const g2 = this.readByte(data);
      const b3 = this.readByte(data);
      color2.setRGB(r / 255, g2 / 255, b3 / 255);
      this.debugMessage("      Color: " + color2.r + ", " + color2.g + ", " + color2.b);
    } else if (chunk.id === COLOR_F || chunk.id === LIN_COLOR_F) {
      const r = this.readFloat(data);
      const g2 = this.readFloat(data);
      const b3 = this.readFloat(data);
      color2.setRGB(r, g2, b3);
      this.debugMessage("      Color: " + color2.r + ", " + color2.g + ", " + color2.b);
    } else {
      this.debugMessage("      Unknown color chunk: " + chunk.toString(16));
    }
    this.endChunk(chunk);
    return color2;
  }
  readChunk(data) {
    const chunk = {};
    chunk.cur = this.position;
    chunk.id = this.readWord(data);
    chunk.size = this.readDWord(data);
    chunk.end = chunk.cur + chunk.size;
    chunk.cur += 6;
    return chunk;
  }
  endChunk(chunk) {
    this.position = chunk.end;
  }
  nextChunk(data, chunk) {
    if (chunk.cur >= chunk.end) {
      return 0;
    }
    this.position = chunk.cur;
    try {
      const next = this.readChunk(data);
      chunk.cur += next.size;
      return next.id;
    } catch (e) {
      this.debugMessage("Unable to read chunk at " + this.position);
      return 0;
    }
  }
  resetPosition() {
    this.position -= 6;
  }
  readByte(data) {
    const v = data.getUint8(this.position, true);
    this.position += 1;
    return v;
  }
  readFloat(data) {
    try {
      const v = data.getFloat32(this.position, true);
      this.position += 4;
      return v;
    } catch (e) {
      this.debugMessage(e + " " + this.position + " " + data.byteLength);
    }
  }
  readInt(data) {
    const v = data.getInt32(this.position, true);
    this.position += 4;
    return v;
  }
  readShort(data) {
    const v = data.getInt16(this.position, true);
    this.position += 2;
    return v;
  }
  readDWord(data) {
    const v = data.getUint32(this.position, true);
    this.position += 4;
    return v;
  }
  readWord(data) {
    const v = data.getUint16(this.position, true);
    this.position += 2;
    return v;
  }
  readString(data, maxLength) {
    let s = "";
    for (let i2 = 0; i2 < maxLength; i2++) {
      const c = this.readByte(data);
      if (!c) {
        break;
      }
      s += String.fromCharCode(c);
    }
    return s;
  }
  readPercentage(data) {
    const chunk = this.readChunk(data);
    let value;
    switch (chunk.id) {
      case INT_PERCENTAGE:
        value = this.readShort(data) / 100;
        break;
      case FLOAT_PERCENTAGE:
        value = this.readFloat(data);
        break;
      default:
        this.debugMessage("      Unknown percentage chunk: " + chunk.toString(16));
    }
    this.endChunk(chunk);
    return value;
  }
  debugMessage(message) {
    if (this.debug) {
      console.log(message);
    }
  }
};
var M3DMAGIC = 19789;
var MLIBMAGIC = 15786;
var CMAGIC = 49725;
var M3D_VERSION = 2;
var COLOR_F = 16;
var COLOR_24 = 17;
var LIN_COLOR_24 = 18;
var LIN_COLOR_F = 19;
var INT_PERCENTAGE = 48;
var FLOAT_PERCENTAGE = 49;
var MDATA = 15677;
var MESH_VERSION = 15678;
var MASTER_SCALE = 256;
var MAT_ENTRY = 45055;
var MAT_NAME = 40960;
var MAT_AMBIENT = 40976;
var MAT_DIFFUSE = 40992;
var MAT_SPECULAR = 41008;
var MAT_SHININESS = 41024;
var MAT_TRANSPARENCY = 41040;
var MAT_TWO_SIDE = 41089;
var MAT_ADDITIVE = 41091;
var MAT_WIRE = 41093;
var MAT_WIRE_SIZE = 41095;
var MAT_TEXMAP = 41472;
var MAT_OPACMAP = 41488;
var MAT_BUMPMAP = 41520;
var MAT_SPECMAP = 41476;
var MAT_MAPNAME = 41728;
var MAT_MAP_USCALE = 41812;
var MAT_MAP_VSCALE = 41814;
var MAT_MAP_UOFFSET = 41816;
var MAT_MAP_VOFFSET = 41818;
var NAMED_OBJECT = 16384;
var N_TRI_OBJECT = 16640;
var POINT_ARRAY = 16656;
var FACE_ARRAY = 16672;
var MSH_MAT_GROUP = 16688;
var TEX_VERTS = 16704;
var MESH_MATRIX = 16736;

// node_modules/three-stdlib/loaders/LDrawLoader.js
var FINISH_TYPE_DEFAULT = 0;
var FINISH_TYPE_CHROME = 1;
var FINISH_TYPE_PEARLESCENT = 2;
var FINISH_TYPE_RUBBER = 3;
var FINISH_TYPE_MATTE_METALLIC = 4;
var FINISH_TYPE_METAL = 5;
var FILE_LOCATION_AS_IS = 0;
var FILE_LOCATION_TRY_PARTS = 1;
var FILE_LOCATION_TRY_P = 2;
var FILE_LOCATION_TRY_MODELS = 3;
var FILE_LOCATION_TRY_RELATIVE = 4;
var FILE_LOCATION_TRY_ABSOLUTE = 5;
var FILE_LOCATION_NOT_FOUND = 6;
var MAIN_COLOUR_CODE = "16";
var MAIN_EDGE_COLOUR_CODE = "24";
var _tempVec0 = new Vector3();
var _tempVec1 = new Vector3();
var LDrawConditionalLineMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super({
      uniforms: UniformsUtils.merge([UniformsLib.fog, {
        diffuse: {
          value: new Color()
        },
        opacity: {
          value: 1
        }
      }]),
      vertexShader: `
        attribute vec3 control0;
        attribute vec3 control1;
        attribute vec3 direction;
        varying float discardFlag;

        #include <common>
        #include <color_pars_vertex>
        #include <fog_pars_vertex>
        #include <logdepthbuf_pars_vertex>
        #include <clipping_planes_pars_vertex>

        void main() {
          #include <color_vertex>

          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_Position = projectionMatrix * mvPosition;

          // Transform the line segment ends and control points into camera clip space
          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);
          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);
          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);

          c0.xy /= c0.w;
          c1.xy /= c1.w;
          p0.xy /= p0.w;
          p1.xy /= p1.w;

          // Get the direction of the segment and an orthogonal vector
          vec2 dir = p1.xy - p0.xy;
          vec2 norm = vec2(-dir.y, dir.x);

          // Get control point directions from the line
          vec2 c0dir = c0.xy - p1.xy;
          vec2 c1dir = c1.xy - p1.xy;

          // If the vectors to the controls points are pointed in different directions away
          // from the line segment then the line should not be drawn.
          float d0 = dot(normalize(norm), normalize(c0dir));
          float d1 = dot(normalize(norm), normalize(c1dir));
          discardFlag = float(sign(d0) != sign(d1));

          #include <logdepthbuf_vertex>
          #include <clipping_planes_vertex>
          #include <fog_vertex>
        }
      `,
      fragmentShader: `
        uniform vec3 diffuse;
        uniform float opacity;
        varying float discardFlag;

        #include <common>
        #include <color_pars_fragment>
        #include <fog_pars_fragment>
        #include <logdepthbuf_pars_fragment>
        #include <clipping_planes_pars_fragment>

        void main() {
          if (discardFlag > 0.5) discard;

          #include <clipping_planes_fragment>
          vec3 outgoingLight = vec3(0.0);
          vec4 diffuseColor = vec4(diffuse, opacity);
          #include <logdepthbuf_fragment>
          #include <color_fragment>
          outgoingLight = diffuseColor.rgb; // simple shader
          gl_FragColor = vec4(outgoingLight, diffuseColor.a);
          #include <tonemapping_fragment>
          #include <encodings_fragment>
          #include <fog_fragment>
          #include <premultiplied_alpha_fragment>
        }
      `
    });
    Object.defineProperties(this, {
      opacity: {
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(value) {
          this.uniforms.opacity.value = value;
        }
      },
      color: {
        get: function() {
          return this.uniforms.diffuse.value;
        }
      }
    });
    this.setValues(parameters);
    this.isLDrawConditionalLineMaterial = true;
  }
};
var ConditionalLineSegments = class extends LineSegments {
  constructor(geometry, material) {
    super(geometry, material);
    this.isConditionalLine = true;
  }
};
function generateFaceNormals(faces) {
  for (let i2 = 0, l = faces.length; i2 < l; i2++) {
    const face = faces[i2];
    const vertices = face.vertices;
    const v0 = vertices[0];
    const v12 = vertices[1];
    const v2 = vertices[2];
    _tempVec0.subVectors(v12, v0);
    _tempVec1.subVectors(v2, v12);
    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();
  }
}
var _ray = new Ray();
function smoothNormals(faces, lineSegments, checkSubSegments = false) {
  const hashMultiplier = (1 + 1e-10) * 100;
  function hashVertex(v) {
    const x = ~~(v.x * hashMultiplier);
    const y = ~~(v.y * hashMultiplier);
    const z = ~~(v.z * hashMultiplier);
    return `${x},${y},${z}`;
  }
  function hashEdge(v0, v12) {
    return `${hashVertex(v0)}_${hashVertex(v12)}`;
  }
  function toNormalizedRay(v0, v12, targetRay) {
    targetRay.direction.subVectors(v12, v0).normalize();
    const scalar = v0.dot(targetRay.direction);
    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);
    return targetRay;
  }
  function hashRay(ray) {
    return hashEdge(ray.origin, ray.direction);
  }
  const hardEdges = /* @__PURE__ */ new Set();
  const hardEdgeRays = /* @__PURE__ */ new Map();
  const halfEdgeList = {};
  const normals = [];
  for (let i2 = 0, l = lineSegments.length; i2 < l; i2++) {
    const ls = lineSegments[i2];
    const vertices = ls.vertices;
    const v0 = vertices[0];
    const v12 = vertices[1];
    hardEdges.add(hashEdge(v0, v12));
    hardEdges.add(hashEdge(v12, v0));
    if (checkSubSegments) {
      const ray = toNormalizedRay(v0, v12, new Ray());
      const rh1 = hashRay(ray);
      if (!hardEdgeRays.has(rh1)) {
        toNormalizedRay(v12, v0, ray);
        const rh2 = hashRay(ray);
        const info2 = {
          ray,
          distances: []
        };
        hardEdgeRays.set(rh1, info2);
        hardEdgeRays.set(rh2, info2);
      }
      const info = hardEdgeRays.get(rh1);
      let d0 = info.ray.direction.dot(v0);
      let d1 = info.ray.direction.dot(v12);
      if (d0 > d1) {
        [d0, d1] = [d1, d0];
      }
      info.distances.push(d0, d1);
    }
  }
  for (let i2 = 0, l = faces.length; i2 < l; i2++) {
    const tri = faces[i2];
    const vertices = tri.vertices;
    const vertCount = vertices.length;
    for (let i22 = 0; i22 < vertCount; i22++) {
      const index = i22;
      const next = (i22 + 1) % vertCount;
      const v0 = vertices[index];
      const v12 = vertices[next];
      const hash = hashEdge(v0, v12);
      if (hardEdges.has(hash)) {
        continue;
      }
      if (checkSubSegments) {
        toNormalizedRay(v0, v12, _ray);
        const rayHash = hashRay(_ray);
        if (hardEdgeRays.has(rayHash)) {
          const info2 = hardEdgeRays.get(rayHash);
          const {
            ray,
            distances
          } = info2;
          let d0 = ray.direction.dot(v0);
          let d1 = ray.direction.dot(v12);
          if (d0 > d1) {
            [d0, d1] = [d1, d0];
          }
          let found = false;
          for (let i3 = 0, l2 = distances.length; i3 < l2; i3 += 2) {
            if (d0 >= distances[i3] && d1 <= distances[i3 + 1]) {
              found = true;
              break;
            }
          }
          if (found) {
            continue;
          }
        }
      }
      const info = {
        index,
        tri
      };
      halfEdgeList[hash] = info;
    }
  }
  while (true) {
    let halfEdge = null;
    for (const key in halfEdgeList) {
      halfEdge = halfEdgeList[key];
      break;
    }
    if (halfEdge === null) {
      break;
    }
    const queue = [halfEdge];
    while (queue.length > 0) {
      const tri = queue.pop().tri;
      const vertices = tri.vertices;
      const vertNormals = tri.normals;
      const faceNormal = tri.faceNormal;
      const vertCount = vertices.length;
      for (let i2 = 0; i2 < vertCount; i2++) {
        const index = i2;
        const next = (i2 + 1) % vertCount;
        const v0 = vertices[index];
        const v12 = vertices[next];
        const hash = hashEdge(v0, v12);
        delete halfEdgeList[hash];
        const reverseHash = hashEdge(v12, v0);
        const otherInfo = halfEdgeList[reverseHash];
        if (otherInfo) {
          const otherTri = otherInfo.tri;
          const otherIndex = otherInfo.index;
          const otherNormals = otherTri.normals;
          const otherVertCount = otherNormals.length;
          const otherFaceNormal = otherTri.faceNormal;
          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {
            continue;
          }
          if (reverseHash in halfEdgeList) {
            queue.push(otherInfo);
            delete halfEdgeList[reverseHash];
          }
          const otherNext = (otherIndex + 1) % otherVertCount;
          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {
            otherNormals[otherNext].norm.add(vertNormals[index].norm);
            vertNormals[index].norm = otherNormals[otherNext].norm;
          }
          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];
          if (sharedNormal1 === null) {
            sharedNormal1 = {
              norm: new Vector3()
            };
            normals.push(sharedNormal1.norm);
          }
          if (vertNormals[index] === null) {
            vertNormals[index] = sharedNormal1;
            sharedNormal1.norm.add(faceNormal);
          }
          if (otherNormals[otherNext] === null) {
            otherNormals[otherNext] = sharedNormal1;
            sharedNormal1.norm.add(otherFaceNormal);
          }
          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {
            otherNormals[otherIndex].norm.add(vertNormals[next].norm);
            vertNormals[next].norm = otherNormals[otherIndex].norm;
          }
          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];
          if (sharedNormal2 === null) {
            sharedNormal2 = {
              norm: new Vector3()
            };
            normals.push(sharedNormal2.norm);
          }
          if (vertNormals[next] === null) {
            vertNormals[next] = sharedNormal2;
            sharedNormal2.norm.add(faceNormal);
          }
          if (otherNormals[otherIndex] === null) {
            otherNormals[otherIndex] = sharedNormal2;
            sharedNormal2.norm.add(otherFaceNormal);
          }
        }
      }
    }
  }
  for (let i2 = 0, l = normals.length; i2 < l; i2++) {
    normals[i2].normalize();
  }
}
function isPartType(type2) {
  return type2 === "Part" || type2 === "Unofficial_Part";
}
function isPrimitiveType(type2) {
  return /primitive/i.test(type2) || type2 === "Subpart";
}
var LineParser = class {
  constructor(line2, lineNumber) {
    this.line = line2;
    this.lineLength = line2.length;
    this.currentCharIndex = 0;
    this.currentChar = " ";
    this.lineNumber = lineNumber;
  }
  seekNonSpace() {
    while (this.currentCharIndex < this.lineLength) {
      this.currentChar = this.line.charAt(this.currentCharIndex);
      if (this.currentChar !== " " && this.currentChar !== "	") {
        return;
      }
      this.currentCharIndex++;
    }
  }
  getToken() {
    const pos0 = this.currentCharIndex++;
    while (this.currentCharIndex < this.lineLength) {
      this.currentChar = this.line.charAt(this.currentCharIndex);
      if (this.currentChar === " " || this.currentChar === "	") {
        break;
      }
      this.currentCharIndex++;
    }
    const pos1 = this.currentCharIndex;
    this.seekNonSpace();
    return this.line.substring(pos0, pos1);
  }
  getVector() {
    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));
  }
  getRemainingString() {
    return this.line.substring(this.currentCharIndex, this.lineLength);
  }
  isAtTheEnd() {
    return this.currentCharIndex >= this.lineLength;
  }
  setToEnd() {
    this.currentCharIndex = this.lineLength;
  }
  getLineNumberString() {
    return this.lineNumber >= 0 ? " at line " + this.lineNumber : "";
  }
};
var LDrawParsedCache = class {
  constructor(loader) {
    this.loader = loader;
    this._cache = {};
  }
  cloneResult(original) {
    const result = {};
    result.faces = original.faces.map((face) => {
      return {
        colorCode: face.colorCode,
        material: face.material,
        vertices: face.vertices.map((v) => v.clone()),
        normals: face.normals.map(() => null),
        faceNormal: null
      };
    });
    result.conditionalSegments = original.conditionalSegments.map((face) => {
      return {
        colorCode: face.colorCode,
        material: face.material,
        vertices: face.vertices.map((v) => v.clone()),
        controlPoints: face.controlPoints.map((v) => v.clone())
      };
    });
    result.lineSegments = original.lineSegments.map((face) => {
      return {
        colorCode: face.colorCode,
        material: face.material,
        vertices: face.vertices.map((v) => v.clone())
      };
    });
    result.type = original.type;
    result.category = original.category;
    result.keywords = original.keywords;
    result.subobjects = original.subobjects;
    result.totalFaces = original.totalFaces;
    result.startingConstructionStep = original.startingConstructionStep;
    result.materials = original.materials;
    result.group = null;
    return result;
  }
  async fetchData(fileName) {
    let triedLowerCase = false;
    let locationState = FILE_LOCATION_AS_IS;
    while (locationState !== FILE_LOCATION_NOT_FOUND) {
      let subobjectURL = fileName;
      switch (locationState) {
        case FILE_LOCATION_AS_IS:
          locationState = locationState + 1;
          break;
        case FILE_LOCATION_TRY_PARTS:
          subobjectURL = "parts/" + subobjectURL;
          locationState = locationState + 1;
          break;
        case FILE_LOCATION_TRY_P:
          subobjectURL = "p/" + subobjectURL;
          locationState = locationState + 1;
          break;
        case FILE_LOCATION_TRY_MODELS:
          subobjectURL = "models/" + subobjectURL;
          locationState = locationState + 1;
          break;
        case FILE_LOCATION_TRY_RELATIVE:
          subobjectURL = fileName.substring(0, fileName.lastIndexOf("/") + 1) + subobjectURL;
          locationState = locationState + 1;
          break;
        case FILE_LOCATION_TRY_ABSOLUTE:
          if (triedLowerCase) {
            locationState = FILE_LOCATION_NOT_FOUND;
          } else {
            fileName = fileName.toLowerCase();
            subobjectURL = fileName;
            triedLowerCase = true;
            locationState = FILE_LOCATION_AS_IS;
          }
          break;
      }
      const loader = this.loader;
      const fileLoader = new FileLoader2(loader.manager);
      fileLoader.setPath(loader.partsLibraryPath);
      fileLoader.setRequestHeader(loader.requestHeader);
      fileLoader.setWithCredentials(loader.withCredentials);
      try {
        const text = await fileLoader.loadAsync(subobjectURL);
        return text;
      } catch {
        continue;
      }
    }
    throw new Error('LDrawLoader: Subobject "' + fileName + '" could not be loaded.');
  }
  parse(text, fileName = null) {
    const loader = this.loader;
    const faces = [];
    const lineSegments = [];
    const conditionalSegments = [];
    const subobjects = [];
    const materials = {};
    const getLocalMaterial = (colorCode) => {
      return materials[colorCode] || null;
    };
    let type2 = "Model";
    let category = null;
    let keywords = null;
    let totalFaces = 0;
    if (text.indexOf("\r\n") !== -1) {
      text = text.replace(/\r\n/g, "\n");
    }
    const lines = text.split("\n");
    const numLines = lines.length;
    let parsingEmbeddedFiles = false;
    let currentEmbeddedFileName = null;
    let currentEmbeddedText = null;
    let bfcCertified = false;
    let bfcCCW = true;
    let bfcInverted = false;
    let bfcCull = true;
    let startingConstructionStep = false;
    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {
      const line2 = lines[lineIndex];
      if (line2.length === 0)
        continue;
      if (parsingEmbeddedFiles) {
        if (line2.startsWith("0 FILE ")) {
          this.setData(currentEmbeddedFileName, currentEmbeddedText);
          currentEmbeddedFileName = line2.substring(7);
          currentEmbeddedText = "";
        } else {
          currentEmbeddedText += line2 + "\n";
        }
        continue;
      }
      const lp = new LineParser(line2, lineIndex + 1);
      lp.seekNonSpace();
      if (lp.isAtTheEnd()) {
        continue;
      }
      const lineType = lp.getToken();
      let material;
      let colorCode;
      let segment;
      let ccw;
      let doubleSided;
      let v0, v12, v2, v3, c0, c1;
      switch (lineType) {
        case "0":
          const meta2 = lp.getToken();
          if (meta2) {
            switch (meta2) {
              case "!LDRAW_ORG":
                type2 = lp.getToken();
                break;
              case "!COLOUR":
                material = loader.parseColorMetaDirective(lp);
                if (material) {
                  materials[material.userData.code] = material;
                } else {
                  console.warn("LDrawLoader: Error parsing material" + lp.getLineNumberString());
                }
                break;
              case "!CATEGORY":
                category = lp.getToken();
                break;
              case "!KEYWORDS":
                const newKeywords = lp.getRemainingString().split(",");
                if (newKeywords.length > 0) {
                  if (!keywords) {
                    keywords = [];
                  }
                  newKeywords.forEach(function(keyword) {
                    keywords.push(keyword.trim());
                  });
                }
                break;
              case "FILE":
                if (lineIndex > 0) {
                  parsingEmbeddedFiles = true;
                  currentEmbeddedFileName = lp.getRemainingString();
                  currentEmbeddedText = "";
                  bfcCertified = false;
                  bfcCCW = true;
                }
                break;
              case "BFC":
                while (!lp.isAtTheEnd()) {
                  const token = lp.getToken();
                  switch (token) {
                    case "CERTIFY":
                    case "NOCERTIFY":
                      bfcCertified = token === "CERTIFY";
                      bfcCCW = true;
                      break;
                    case "CW":
                    case "CCW":
                      bfcCCW = token === "CCW";
                      break;
                    case "INVERTNEXT":
                      bfcInverted = true;
                      break;
                    case "CLIP":
                    case "NOCLIP":
                      bfcCull = token === "CLIP";
                      break;
                    default:
                      console.warn('THREE.LDrawLoader: BFC directive "' + token + '" is unknown.');
                      break;
                  }
                }
                break;
              case "STEP":
                startingConstructionStep = true;
                break;
            }
          }
          break;
        case "1":
          colorCode = lp.getToken();
          material = getLocalMaterial(colorCode);
          const posX = parseFloat(lp.getToken());
          const posY = parseFloat(lp.getToken());
          const posZ = parseFloat(lp.getToken());
          const m0 = parseFloat(lp.getToken());
          const m1 = parseFloat(lp.getToken());
          const m2 = parseFloat(lp.getToken());
          const m3 = parseFloat(lp.getToken());
          const m4 = parseFloat(lp.getToken());
          const m5 = parseFloat(lp.getToken());
          const m6 = parseFloat(lp.getToken());
          const m7 = parseFloat(lp.getToken());
          const m8 = parseFloat(lp.getToken());
          const matrix3 = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);
          let fileName2 = lp.getRemainingString().trim().replace(/\\/g, "/");
          if (loader.fileMap[fileName2]) {
            fileName2 = loader.fileMap[fileName2];
          } else {
            if (fileName2.startsWith("s/")) {
              fileName2 = "parts/" + fileName2;
            } else if (fileName2.startsWith("48/")) {
              fileName2 = "p/" + fileName2;
            }
          }
          subobjects.push({
            material,
            colorCode,
            matrix: matrix3,
            fileName: fileName2,
            inverted: bfcInverted,
            startingConstructionStep
          });
          bfcInverted = false;
          break;
        case "2":
          colorCode = lp.getToken();
          material = getLocalMaterial(colorCode);
          v0 = lp.getVector();
          v12 = lp.getVector();
          segment = {
            material,
            colorCode,
            vertices: [v0, v12]
          };
          lineSegments.push(segment);
          break;
        case "5":
          colorCode = lp.getToken();
          material = getLocalMaterial(colorCode);
          v0 = lp.getVector();
          v12 = lp.getVector();
          c0 = lp.getVector();
          c1 = lp.getVector();
          segment = {
            material,
            colorCode,
            vertices: [v0, v12],
            controlPoints: [c0, c1]
          };
          conditionalSegments.push(segment);
          break;
        case "3":
          colorCode = lp.getToken();
          material = getLocalMaterial(colorCode);
          ccw = bfcCCW;
          doubleSided = !bfcCertified || !bfcCull;
          if (ccw === true) {
            v0 = lp.getVector();
            v12 = lp.getVector();
            v2 = lp.getVector();
          } else {
            v2 = lp.getVector();
            v12 = lp.getVector();
            v0 = lp.getVector();
          }
          faces.push({
            material,
            colorCode,
            faceNormal: null,
            vertices: [v0, v12, v2],
            normals: [null, null, null]
          });
          totalFaces++;
          if (doubleSided === true) {
            faces.push({
              material,
              colorCode,
              faceNormal: null,
              vertices: [v2, v12, v0],
              normals: [null, null, null]
            });
            totalFaces++;
          }
          break;
        case "4":
          colorCode = lp.getToken();
          material = getLocalMaterial(colorCode);
          ccw = bfcCCW;
          doubleSided = !bfcCertified || !bfcCull;
          if (ccw === true) {
            v0 = lp.getVector();
            v12 = lp.getVector();
            v2 = lp.getVector();
            v3 = lp.getVector();
          } else {
            v3 = lp.getVector();
            v2 = lp.getVector();
            v12 = lp.getVector();
            v0 = lp.getVector();
          }
          faces.push({
            material,
            colorCode,
            faceNormal: null,
            vertices: [v0, v12, v2, v3],
            normals: [null, null, null, null]
          });
          totalFaces += 2;
          if (doubleSided === true) {
            faces.push({
              material,
              colorCode,
              faceNormal: null,
              vertices: [v3, v2, v12, v0],
              normals: [null, null, null, null]
            });
            totalFaces += 2;
          }
          break;
        default:
          throw new Error('LDrawLoader: Unknown line type "' + lineType + '"' + lp.getLineNumberString() + ".");
      }
    }
    if (parsingEmbeddedFiles) {
      this.setData(currentEmbeddedFileName, currentEmbeddedText);
    }
    return {
      faces,
      conditionalSegments,
      lineSegments,
      type: type2,
      category,
      keywords,
      subobjects,
      totalFaces,
      startingConstructionStep,
      materials,
      fileName,
      group: null
    };
  }
  getData(fileName, clone = true) {
    const key = fileName.toLowerCase();
    const result = this._cache[key];
    if (result === null || result instanceof Promise) {
      return null;
    }
    if (clone) {
      return this.cloneResult(result);
    } else {
      return result;
    }
  }
  async ensureDataLoaded(fileName) {
    const key = fileName.toLowerCase();
    if (!(key in this._cache)) {
      this._cache[key] = this.fetchData(fileName).then((text) => {
        const info = this.parse(text, fileName);
        this._cache[key] = info;
        return info;
      });
    }
    await this._cache[key];
  }
  setData(fileName, text) {
    const key = fileName.toLowerCase();
    this._cache[key] = this.parse(text, fileName);
  }
};
function getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {
  const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;
  if (isPassthrough) {
    colorCode = parentColorCode;
  }
  return materialHierarchy[colorCode] || null;
}
var LDrawPartsGeometryCache = class {
  constructor(loader) {
    this.loader = loader;
    this.parseCache = new LDrawParsedCache(loader);
    this._cache = {};
  }
  async processIntoMesh(info) {
    const loader = this.loader;
    const parseCache = this.parseCache;
    const faceMaterials = /* @__PURE__ */ new Set();
    const processInfoSubobjects = async (info2, subobject = null) => {
      const subobjects = info2.subobjects;
      const promises = [];
      for (let i2 = 0, l = subobjects.length; i2 < l; i2++) {
        const subobject2 = subobjects[i2];
        const promise = parseCache.ensureDataLoaded(subobject2.fileName).then(() => {
          const subobjectInfo = parseCache.getData(subobject2.fileName, false);
          if (!isPrimitiveType(subobjectInfo.type)) {
            return this.loadModel(subobject2.fileName).catch((error) => {
              console.warn(error);
              return null;
            });
          }
          return processInfoSubobjects(parseCache.getData(subobject2.fileName), subobject2);
        });
        promises.push(promise);
      }
      const group2 = new Group();
      group2.userData.category = info2.category;
      group2.userData.keywords = info2.keywords;
      info2.group = group2;
      const subobjectInfos = await Promise.all(promises);
      for (let i2 = 0, l = subobjectInfos.length; i2 < l; i2++) {
        const subobject2 = info2.subobjects[i2];
        const subobjectInfo = subobjectInfos[i2];
        if (subobjectInfo === null) {
          continue;
        }
        if (subobjectInfo.isGroup) {
          const subobjectGroup = subobjectInfo;
          subobject2.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);
          subobjectGroup.userData.startingConstructionStep = subobject2.startingConstructionStep;
          subobjectGroup.name = subobject2.fileName;
          loader.applyMaterialsToMesh(subobjectGroup, subobject2.colorCode, info2.materials);
          group2.add(subobjectGroup);
          continue;
        }
        if (subobjectInfo.group.children.length) {
          group2.add(subobjectInfo.group);
        }
        const parentLineSegments = info2.lineSegments;
        const parentConditionalSegments = info2.conditionalSegments;
        const parentFaces = info2.faces;
        const lineSegments = subobjectInfo.lineSegments;
        const conditionalSegments = subobjectInfo.conditionalSegments;
        const faces = subobjectInfo.faces;
        const matrix3 = subobject2.matrix;
        const inverted = subobject2.inverted;
        const matrixScaleInverted = matrix3.determinant() < 0;
        const colorCode = subobject2.colorCode;
        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;
        for (let i3 = 0, l2 = lineSegments.length; i3 < l2; i3++) {
          const ls = lineSegments[i3];
          const vertices = ls.vertices;
          vertices[0].applyMatrix4(matrix3);
          vertices[1].applyMatrix4(matrix3);
          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;
          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info2.materials, true);
          parentLineSegments.push(ls);
        }
        for (let i3 = 0, l2 = conditionalSegments.length; i3 < l2; i3++) {
          const os = conditionalSegments[i3];
          const vertices = os.vertices;
          const controlPoints = os.controlPoints;
          vertices[0].applyMatrix4(matrix3);
          vertices[1].applyMatrix4(matrix3);
          controlPoints[0].applyMatrix4(matrix3);
          controlPoints[1].applyMatrix4(matrix3);
          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;
          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info2.materials, true);
          parentConditionalSegments.push(os);
        }
        for (let i3 = 0, l2 = faces.length; i3 < l2; i3++) {
          const tri = faces[i3];
          const vertices = tri.vertices;
          for (let i4 = 0, l3 = vertices.length; i4 < l3; i4++) {
            vertices[i4].applyMatrix4(matrix3);
          }
          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;
          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info2.materials, false);
          faceMaterials.add(tri.colorCode);
          if (matrixScaleInverted !== inverted) {
            vertices.reverse();
          }
          parentFaces.push(tri);
        }
        info2.totalFaces += subobjectInfo.totalFaces;
      }
      if (subobject) {
        loader.applyMaterialsToMesh(group2, subobject.colorCode, info2.materials);
      }
      return info2;
    };
    for (let i2 = 0, l = info.faces; i2 < l; i2++) {
      faceMaterials.add(info.faces[i2].colorCode);
    }
    await processInfoSubobjects(info);
    if (loader.smoothNormals) {
      const checkSubSegments = faceMaterials.size > 1;
      generateFaceNormals(info.faces);
      smoothNormals(info.faces, info.lineSegments, checkSubSegments);
    }
    const group = info.group;
    if (info.faces.length > 0) {
      group.add(createObject(info.faces, 3, false, info.totalFaces));
    }
    if (info.lineSegments.length > 0) {
      group.add(createObject(info.lineSegments, 2));
    }
    if (info.conditionalSegments.length > 0) {
      group.add(createObject(info.conditionalSegments, 2, true));
    }
    return group;
  }
  hasCachedModel(fileName) {
    return fileName !== null && fileName.toLowerCase() in this._cache;
  }
  async getCachedModel(fileName) {
    if (fileName !== null && this.hasCachedModel(fileName)) {
      const key = fileName.toLowerCase();
      const group = await this._cache[key];
      return group.clone();
    } else {
      return null;
    }
  }
  async loadModel(fileName) {
    const parseCache = this.parseCache;
    const key = fileName.toLowerCase();
    if (this.hasCachedModel(fileName)) {
      return this.getCachedModel(fileName);
    } else {
      await parseCache.ensureDataLoaded(fileName);
      const info = parseCache.getData(fileName);
      const promise = this.processIntoMesh(info);
      if (this.hasCachedModel(fileName)) {
        return this.getCachedModel(fileName);
      }
      if (isPartType(info.type)) {
        this._cache[key] = promise;
      }
      const group = await promise;
      return group.clone();
    }
  }
  async parseModel(text) {
    const parseCache = this.parseCache;
    const info = parseCache.parse(text);
    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {
      return this.getCachedModel(info.fileName);
    }
    return this.processIntoMesh(info);
  }
};
function sortByMaterial(a2, b3) {
  if (a2.colorCode === b3.colorCode) {
    return 0;
  }
  if (a2.colorCode < b3.colorCode) {
    return -1;
  }
  return 1;
}
function createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {
  elements.sort(sortByMaterial);
  if (totalElements === null) {
    totalElements = elements.length;
  }
  const positions = new Float32Array(elementSize * totalElements * 3);
  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;
  const materials = [];
  const quadArray = new Array(6);
  const bufferGeometry = new BufferGeometry();
  let prevMaterial = null;
  let index0 = 0;
  let numGroupVerts = 0;
  let offset = 0;
  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {
    const elem = elements[iElem];
    let vertices = elem.vertices;
    if (vertices.length === 4) {
      quadArray[0] = vertices[0];
      quadArray[1] = vertices[1];
      quadArray[2] = vertices[2];
      quadArray[3] = vertices[0];
      quadArray[4] = vertices[2];
      quadArray[5] = vertices[3];
      vertices = quadArray;
    }
    for (let j2 = 0, l = vertices.length; j2 < l; j2++) {
      const v = vertices[j2];
      const index = offset + j2 * 3;
      positions[index + 0] = v.x;
      positions[index + 1] = v.y;
      positions[index + 2] = v.z;
    }
    if (elementSize === 3) {
      if (!elem.faceNormal) {
        const v0 = vertices[0];
        const v12 = vertices[1];
        const v2 = vertices[2];
        _tempVec0.subVectors(v12, v0);
        _tempVec1.subVectors(v2, v12);
        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();
      }
      let elemNormals = elem.normals;
      if (elemNormals.length === 4) {
        quadArray[0] = elemNormals[0];
        quadArray[1] = elemNormals[1];
        quadArray[2] = elemNormals[2];
        quadArray[3] = elemNormals[0];
        quadArray[4] = elemNormals[2];
        quadArray[5] = elemNormals[3];
        elemNormals = quadArray;
      }
      for (let j2 = 0, l = elemNormals.length; j2 < l; j2++) {
        let n = elem.faceNormal;
        if (elemNormals[j2]) {
          n = elemNormals[j2].norm;
        }
        const index = offset + j2 * 3;
        normals[index + 0] = n.x;
        normals[index + 1] = n.y;
        normals[index + 2] = n.z;
      }
    }
    if (prevMaterial !== elem.colorCode) {
      if (prevMaterial !== null) {
        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);
      }
      const material = elem.material;
      if (material !== null) {
        if (elementSize === 3) {
          materials.push(material);
        } else if (elementSize === 2) {
          if (material !== null) {
            if (isConditionalSegments) {
              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);
            } else {
              materials.push(material.userData.edgeMaterial);
            }
          } else {
            materials.push(null);
          }
        }
      } else {
        materials.push(elem.colorCode);
      }
      prevMaterial = elem.colorCode;
      index0 = offset / 3;
      numGroupVerts = vertices.length;
    } else {
      numGroupVerts += vertices.length;
    }
    offset += 3 * vertices.length;
  }
  if (numGroupVerts > 0) {
    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);
  }
  bufferGeometry.setAttribute("position", new BufferAttribute(positions, 3));
  if (normals !== null) {
    bufferGeometry.setAttribute("normal", new BufferAttribute(normals, 3));
  }
  let object3d = null;
  if (elementSize === 2) {
    if (isConditionalSegments) {
      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);
    } else {
      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);
    }
  } else if (elementSize === 3) {
    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);
  }
  if (isConditionalSegments) {
    object3d.isConditionalLine = true;
    const controlArray0 = new Float32Array(elements.length * 3 * 2);
    const controlArray1 = new Float32Array(elements.length * 3 * 2);
    const directionArray = new Float32Array(elements.length * 3 * 2);
    for (let i2 = 0, l = elements.length; i2 < l; i2++) {
      const os = elements[i2];
      const vertices = os.vertices;
      const controlPoints = os.controlPoints;
      const c0 = controlPoints[0];
      const c1 = controlPoints[1];
      const v0 = vertices[0];
      const v12 = vertices[1];
      const index = i2 * 3 * 2;
      controlArray0[index + 0] = c0.x;
      controlArray0[index + 1] = c0.y;
      controlArray0[index + 2] = c0.z;
      controlArray0[index + 3] = c0.x;
      controlArray0[index + 4] = c0.y;
      controlArray0[index + 5] = c0.z;
      controlArray1[index + 0] = c1.x;
      controlArray1[index + 1] = c1.y;
      controlArray1[index + 2] = c1.z;
      controlArray1[index + 3] = c1.x;
      controlArray1[index + 4] = c1.y;
      controlArray1[index + 5] = c1.z;
      directionArray[index + 0] = v12.x - v0.x;
      directionArray[index + 1] = v12.y - v0.y;
      directionArray[index + 2] = v12.z - v0.z;
      directionArray[index + 3] = v12.x - v0.x;
      directionArray[index + 4] = v12.y - v0.y;
      directionArray[index + 5] = v12.z - v0.z;
    }
    bufferGeometry.setAttribute("control0", new BufferAttribute(controlArray0, 3, false));
    bufferGeometry.setAttribute("control1", new BufferAttribute(controlArray1, 3, false));
    bufferGeometry.setAttribute("direction", new BufferAttribute(directionArray, 3, false));
  }
  return object3d;
}
var LDrawLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.materials = [];
    this.materialLibrary = {};
    this.partsCache = new LDrawPartsGeometryCache(this);
    this.fileMap = {};
    this.setMaterials([]);
    this.smoothNormals = true;
    this.partsLibraryPath = "";
  }
  setPartsLibraryPath(path) {
    this.partsLibraryPath = path;
    return this;
  }
  async preloadMaterials(url) {
    const fileLoader = new FileLoader2(this.manager);
    fileLoader.setPath(this.path);
    fileLoader.setRequestHeader(this.requestHeader);
    fileLoader.setWithCredentials(this.withCredentials);
    const text = await fileLoader.loadAsync(url);
    const colorLineRegex = /^0 !COLOUR/;
    const lines = text.split(/[\n\r]/g);
    const materials = [];
    for (let i2 = 0, l = lines.length; i2 < l; i2++) {
      const line2 = lines[i2];
      if (colorLineRegex.test(line2)) {
        const directive = line2.replace(colorLineRegex, "");
        const material = this.parseColorMetaDirective(new LineParser(directive));
        materials.push(material);
      }
    }
    this.setMaterials(materials);
  }
  load(url, onLoad, onProgress, onError) {
    const fileLoader = new FileLoader2(this.manager);
    fileLoader.setPath(this.path);
    fileLoader.setRequestHeader(this.requestHeader);
    fileLoader.setWithCredentials(this.withCredentials);
    fileLoader.load(url, (text) => {
      this.partsCache.parseModel(text, this.materialLibrary).then((group) => {
        this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);
        this.computeConstructionSteps(group);
        onLoad(group);
      }).catch(onError);
    }, onProgress, onError);
  }
  parse(text, onLoad) {
    this.partsCache.parseModel(text, this.materialLibrary).then((group) => {
      this.computeConstructionSteps(group);
      onLoad(group);
    });
  }
  setMaterials(materials) {
    this.materialLibrary = {};
    this.materials = [];
    for (let i2 = 0, l = materials.length; i2 < l; i2++) {
      this.addMaterial(materials[i2]);
    }
    this.addMaterial(this.parseColorMetaDirective(new LineParser("Main_Colour CODE 16 VALUE #FF8080 EDGE #333333")));
    this.addMaterial(this.parseColorMetaDirective(new LineParser("Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333")));
    return this;
  }
  setFileMap(fileMap) {
    this.fileMap = fileMap;
    return this;
  }
  addMaterial(material) {
    const matLib = this.materialLibrary;
    if (!matLib[material.userData.code]) {
      this.materials.push(material);
      matLib[material.userData.code] = material;
    }
    return this;
  }
  getMaterial(colorCode) {
    if (colorCode.startsWith("0x2")) {
      const color2 = colorCode.substring(3);
      return this.parseColorMetaDirective(new LineParser("Direct_Color_" + color2 + " CODE -1 VALUE #" + color2 + " EDGE #" + color2));
    }
    return this.materialLibrary[colorCode] || null;
  }
  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {
    const loader = this;
    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;
    group.traverse((c) => {
      if (c.isMesh || c.isLineSegments) {
        if (Array.isArray(c.material)) {
          for (let i2 = 0, l = c.material.length; i2 < l; i2++) {
            if (!c.material[i2].isMaterial) {
              c.material[i2] = getMaterial2(c, c.material[i2]);
            }
          }
        } else if (!c.material.isMaterial) {
          c.material = getMaterial2(c, c.material);
        }
      }
    });
    function getMaterial2(c, colorCode) {
      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {
        return colorCode;
      }
      const forEdge = c.isLineSegments || c.isConditionalLine;
      const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;
      if (isPassthrough) {
        colorCode = parentColorCode;
      }
      let material = null;
      if (colorCode in materialHierarchy) {
        material = materialHierarchy[colorCode];
      } else if (finalMaterialPass) {
        material = loader.getMaterial(colorCode);
        if (material === null) {
          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`);
        }
      } else {
        return colorCode;
      }
      if (c.isLineSegments) {
        material = material.userData.edgeMaterial;
        if (c.isConditionalLine) {
          material = material.userData.conditionalEdgeMaterial;
        }
      }
      return material;
    }
  }
  getMainMaterial() {
    return this.getMaterial(MAIN_COLOUR_CODE);
  }
  getMainEdgeMaterial() {
    return this.getMaterial(MAIN_EDGE_COLOUR_CODE);
  }
  parseColorMetaDirective(lineParser) {
    let code = null;
    let color2 = 16711935;
    let edgeColor = 16711935;
    let alpha = 1;
    let isTransparent = false;
    let luminance = 0;
    let finishType = FINISH_TYPE_DEFAULT;
    let edgeMaterial = null;
    const name = lineParser.getToken();
    if (!name) {
      throw new Error('LDrawLoader: Material name was expected after "!COLOUR tag' + lineParser.getLineNumberString() + ".");
    }
    let token = null;
    while (true) {
      token = lineParser.getToken();
      if (!token) {
        break;
      }
      switch (token.toUpperCase()) {
        case "CODE":
          code = lineParser.getToken();
          break;
        case "VALUE":
          color2 = lineParser.getToken();
          if (color2.startsWith("0x")) {
            color2 = "#" + color2.substring(2);
          } else if (!color2.startsWith("#")) {
            throw new Error("LDrawLoader: Invalid color while parsing material" + lineParser.getLineNumberString() + ".");
          }
          break;
        case "EDGE":
          edgeColor = lineParser.getToken();
          if (edgeColor.startsWith("0x")) {
            edgeColor = "#" + edgeColor.substring(2);
          } else if (!edgeColor.startsWith("#")) {
            edgeMaterial = this.getMaterial(edgeColor);
            if (!edgeMaterial) {
              throw new Error("LDrawLoader: Invalid edge color while parsing material" + lineParser.getLineNumberString() + ".");
            }
            edgeMaterial = edgeMaterial.userData.edgeMaterial;
          }
          break;
        case "ALPHA":
          alpha = parseInt(lineParser.getToken());
          if (isNaN(alpha)) {
            throw new Error("LDrawLoader: Invalid alpha value in material definition" + lineParser.getLineNumberString() + ".");
          }
          alpha = Math.max(0, Math.min(1, alpha / 255));
          if (alpha < 1) {
            isTransparent = true;
          }
          break;
        case "LUMINANCE":
          luminance = parseInt(lineParser.getToken());
          if (isNaN(luminance)) {
            throw new Error("LDrawLoader: Invalid luminance value in material definition" + LineParser.getLineNumberString() + ".");
          }
          luminance = Math.max(0, Math.min(1, luminance / 255));
          break;
        case "CHROME":
          finishType = FINISH_TYPE_CHROME;
          break;
        case "PEARLESCENT":
          finishType = FINISH_TYPE_PEARLESCENT;
          break;
        case "RUBBER":
          finishType = FINISH_TYPE_RUBBER;
          break;
        case "MATTE_METALLIC":
          finishType = FINISH_TYPE_MATTE_METALLIC;
          break;
        case "METAL":
          finishType = FINISH_TYPE_METAL;
          break;
        case "MATERIAL":
          lineParser.setToEnd();
          break;
        default:
          throw new Error('LDrawLoader: Unknown token "' + token + '" while parsing material' + lineParser.getLineNumberString() + ".");
      }
    }
    let material = null;
    switch (finishType) {
      case FINISH_TYPE_DEFAULT:
        material = new MeshStandardMaterial({
          color: color2,
          roughness: 0.3,
          metalness: 0
        });
        break;
      case FINISH_TYPE_PEARLESCENT:
        material = new MeshStandardMaterial({
          color: color2,
          roughness: 0.3,
          metalness: 0.25
        });
        break;
      case FINISH_TYPE_CHROME:
        material = new MeshStandardMaterial({
          color: color2,
          roughness: 0,
          metalness: 1
        });
        break;
      case FINISH_TYPE_RUBBER:
        material = new MeshStandardMaterial({
          color: color2,
          roughness: 0.9,
          metalness: 0
        });
        break;
      case FINISH_TYPE_MATTE_METALLIC:
        material = new MeshStandardMaterial({
          color: color2,
          roughness: 0.8,
          metalness: 0.4
        });
        break;
      case FINISH_TYPE_METAL:
        material = new MeshStandardMaterial({
          color: color2,
          roughness: 0.2,
          metalness: 0.85
        });
        break;
    }
    material.transparent = isTransparent;
    material.premultipliedAlpha = true;
    material.opacity = alpha;
    material.depthWrite = !isTransparent;
    material.polygonOffset = true;
    material.polygonOffsetFactor = 1;
    if (luminance !== 0) {
      material.emissive.set(material.color).multiplyScalar(luminance);
    }
    if (!edgeMaterial) {
      edgeMaterial = new LineBasicMaterial({
        color: edgeColor,
        transparent: isTransparent,
        opacity: alpha,
        depthWrite: !isTransparent
      });
      edgeMaterial.userData.code = code;
      edgeMaterial.name = name + " - Edge";
      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({
        fog: true,
        transparent: isTransparent,
        depthWrite: !isTransparent,
        color: edgeColor,
        opacity: alpha
      });
    }
    material.userData.code = code;
    material.name = name;
    material.userData.edgeMaterial = edgeMaterial;
    this.addMaterial(material);
    return material;
  }
  computeConstructionSteps(model) {
    let stepNumber = 0;
    model.traverse((c) => {
      if (c.isGroup) {
        if (c.userData.startingConstructionStep) {
          stepNumber++;
        }
        c.userData.constructionStep = stepNumber;
      }
    });
    model.userData.numConstructionSteps = stepNumber + 1;
  }
};

// node_modules/three-stdlib/loaders/lwo/LWO3Parser.js
function LWO3Parser(IFFParser2) {
  this.IFF = IFFParser2;
}
LWO3Parser.prototype = {
  constructor: LWO3Parser,
  parseBlock: function() {
    this.IFF.debugger.offset = this.IFF.reader.offset;
    this.IFF.debugger.closeForms();
    var blockID = this.IFF.reader.getIDTag();
    var length2 = this.IFF.reader.getUint32();
    this.IFF.debugger.dataOffset = this.IFF.reader.offset;
    this.IFF.debugger.length = length2;
    switch (blockID) {
      case "FORM":
        this.IFF.parseForm(length2);
        break;
      case "ICON":
      case "VMPA":
      case "BBOX":
      case "NORM":
      case "PRE ":
      case "POST":
      case "KEY ":
      case "SPAN":
      case "TIME":
      case "CLRS":
      case "CLRA":
      case "FILT":
      case "DITH":
      case "CONT":
      case "BRIT":
      case "SATR":
      case "HUE ":
      case "GAMM":
      case "NEGA":
      case "IFLT":
      case "PFLT":
      case "PROJ":
      case "AXIS":
      case "AAST":
      case "PIXB":
      case "STCK":
      case "VALU":
      case "PNAM":
      case "INAM":
      case "GRST":
      case "GREN":
      case "GRPT":
      case "FKEY":
      case "IKEY":
      case "CSYS":
      case "OPAQ":
      case "CMAP":
      case "NLOC":
      case "NZOM":
      case "NVER":
      case "NSRV":
      case "NCRD":
      case "NMOD":
      case "NSEL":
      case "NPRW":
      case "NPLA":
      case "VERS":
      case "ENUM":
      case "TAG ":
      case "CGMD":
      case "CGTY":
      case "CGST":
      case "CGEN":
      case "CGTS":
      case "CGTE":
      case "OSMP":
      case "OMDE":
      case "OUTR":
      case "FLAG":
      case "TRNL":
      case "SHRP":
      case "RFOP":
      case "RSAN":
      case "TROP":
      case "RBLR":
      case "TBLR":
      case "CLRH":
      case "CLRF":
      case "ADTR":
      case "GLOW":
      case "LINE":
      case "ALPH":
      case "VCOL":
      case "ENAB":
        this.IFF.debugger.skipped = true;
        this.IFF.reader.skip(length2);
        break;
      case "IPIX":
      case "IMIP":
      case "IMOD":
      case "AMOD":
      case "IINV":
      case "INCR":
      case "IAXS":
      case "IFOT":
      case "ITIM":
      case "IWRL":
      case "IUTI":
      case "IINX":
      case "IINY":
      case "IINZ":
      case "IREF":
        if (length2 === 4)
          this.IFF.currentNode[blockID] = this.IFF.reader.getInt32();
        else
          this.IFF.reader.skip(length2);
        break;
      case "OTAG":
        this.IFF.parseObjectTag();
        break;
      case "LAYR":
        this.IFF.parseLayer(length2);
        break;
      case "PNTS":
        this.IFF.parsePoints(length2);
        break;
      case "VMAP":
        this.IFF.parseVertexMapping(length2);
        break;
      case "POLS":
        this.IFF.parsePolygonList(length2);
        break;
      case "TAGS":
        this.IFF.parseTagStrings(length2);
        break;
      case "PTAG":
        this.IFF.parsePolygonTagMapping(length2);
        break;
      case "VMAD":
        this.IFF.parseVertexMapping(length2, true);
        break;
      case "DESC":
        this.IFF.currentForm.description = this.IFF.reader.getString();
        break;
      case "TEXT":
      case "CMNT":
      case "NCOM":
        this.IFF.currentForm.comment = this.IFF.reader.getString();
        break;
      case "NAME":
        this.IFF.currentForm.channelName = this.IFF.reader.getString();
        break;
      case "WRAP":
        this.IFF.currentForm.wrap = {
          w: this.IFF.reader.getUint16(),
          h: this.IFF.reader.getUint16()
        };
        break;
      case "IMAG":
        var index = this.IFF.reader.getVariableLengthIndex();
        this.IFF.currentForm.imageIndex = index;
        break;
      case "OREF":
        this.IFF.currentForm.referenceObject = this.IFF.reader.getString();
        break;
      case "ROID":
        this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();
        break;
      case "SSHN":
        this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();
        break;
      case "AOVN":
        this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();
        break;
      case "NSTA":
        this.IFF.currentForm.disabled = this.IFF.reader.getUint16();
        break;
      case "NRNM":
        this.IFF.currentForm.realName = this.IFF.reader.getString();
        break;
      case "NNME":
        this.IFF.currentForm.refName = this.IFF.reader.getString();
        this.IFF.currentSurface.nodes[this.IFF.currentForm.refName] = this.IFF.currentForm;
        break;
      case "INME":
        if (!this.IFF.currentForm.nodeName)
          this.IFF.currentForm.nodeName = [];
        this.IFF.currentForm.nodeName.push(this.IFF.reader.getString());
        break;
      case "IINN":
        if (!this.IFF.currentForm.inputNodeName)
          this.IFF.currentForm.inputNodeName = [];
        this.IFF.currentForm.inputNodeName.push(this.IFF.reader.getString());
        break;
      case "IINM":
        if (!this.IFF.currentForm.inputName)
          this.IFF.currentForm.inputName = [];
        this.IFF.currentForm.inputName.push(this.IFF.reader.getString());
        break;
      case "IONM":
        if (!this.IFF.currentForm.inputOutputName)
          this.IFF.currentForm.inputOutputName = [];
        this.IFF.currentForm.inputOutputName.push(this.IFF.reader.getString());
        break;
      case "FNAM":
        this.IFF.currentForm.fileName = this.IFF.reader.getString();
        break;
      case "CHAN":
        if (length2 === 4)
          this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();
        else
          this.IFF.reader.skip(length2);
        break;
      case "SMAN":
        var maxSmoothingAngle = this.IFF.reader.getFloat32();
        this.IFF.currentSurface.attributes.smooth = maxSmoothingAngle < 0 ? false : true;
        break;
      case "COLR":
        this.IFF.currentSurface.attributes.Color = {
          value: this.IFF.reader.getFloat32Array(3)
        };
        this.IFF.reader.skip(2);
        break;
      case "LUMI":
        this.IFF.currentSurface.attributes.Luminosity = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "SPEC":
        this.IFF.currentSurface.attributes.Specular = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "DIFF":
        this.IFF.currentSurface.attributes.Diffuse = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "REFL":
        this.IFF.currentSurface.attributes.Reflection = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "GLOS":
        this.IFF.currentSurface.attributes.Glossiness = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "TRAN":
        this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "BUMP":
        this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "SIDE":
        this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();
        break;
      case "RIMG":
        this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();
        break;
      case "RIND":
        this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "TIMG":
        this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();
        break;
      case "IMAP":
        this.IFF.currentSurface.attributes.imageMapIndex = this.IFF.reader.getUint32();
        break;
      case "IUVI":
        this.IFF.currentNode.UVChannel = this.IFF.reader.getString(length2);
        break;
      case "IUTL":
        this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();
        break;
      case "IVTL":
        this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();
        break;
      default:
        this.IFF.parseUnknownCHUNK(blockID, length2);
    }
    if (blockID != "FORM") {
      this.IFF.debugger.node = 1;
      this.IFF.debugger.nodeID = blockID;
      this.IFF.debugger.log();
    }
    if (this.IFF.reader.offset >= this.IFF.currentFormEnd) {
      this.IFF.currentForm = this.IFF.parentForm;
    }
  }
};

// node_modules/three-stdlib/loaders/lwo/LWO2Parser.js
function LWO2Parser(IFFParser2) {
  this.IFF = IFFParser2;
}
LWO2Parser.prototype = {
  constructor: LWO2Parser,
  parseBlock: function() {
    this.IFF.debugger.offset = this.IFF.reader.offset;
    this.IFF.debugger.closeForms();
    var blockID = this.IFF.reader.getIDTag();
    var length2 = this.IFF.reader.getUint32();
    if (length2 > this.IFF.reader.dv.byteLength - this.IFF.reader.offset) {
      this.IFF.reader.offset -= 4;
      length2 = this.IFF.reader.getUint16();
    }
    this.IFF.debugger.dataOffset = this.IFF.reader.offset;
    this.IFF.debugger.length = length2;
    switch (blockID) {
      case "FORM":
        this.IFF.parseForm(length2);
        break;
      case "ICON":
      case "VMPA":
      case "BBOX":
      case "NORM":
      case "PRE ":
      case "POST":
      case "KEY ":
      case "SPAN":
      case "TIME":
      case "CLRS":
      case "CLRA":
      case "FILT":
      case "DITH":
      case "CONT":
      case "BRIT":
      case "SATR":
      case "HUE ":
      case "GAMM":
      case "NEGA":
      case "IFLT":
      case "PFLT":
      case "PROJ":
      case "AXIS":
      case "AAST":
      case "PIXB":
      case "AUVO":
      case "STCK":
      case "PROC":
      case "VALU":
      case "FUNC":
      case "PNAM":
      case "INAM":
      case "GRST":
      case "GREN":
      case "GRPT":
      case "FKEY":
      case "IKEY":
      case "CSYS":
      case "OPAQ":
      case "CMAP":
      case "NLOC":
      case "NZOM":
      case "NVER":
      case "NSRV":
      case "NVSK":
      case "NCRD":
      case "WRPW":
      case "WRPH":
      case "NMOD":
      case "NPRW":
      case "NPLA":
      case "NODS":
      case "VERS":
      case "ENUM":
      case "TAG ":
      case "OPAC":
      case "CGMD":
      case "CGTY":
      case "CGST":
      case "CGEN":
      case "CGTS":
      case "CGTE":
      case "OSMP":
      case "OMDE":
      case "OUTR":
      case "FLAG":
      case "TRNL":
      case "GLOW":
      case "GVAL":
      case "SHRP":
      case "RFOP":
      case "RSAN":
      case "TROP":
      case "RBLR":
      case "TBLR":
      case "CLRH":
      case "CLRF":
      case "ADTR":
      case "LINE":
      case "ALPH":
      case "VCOL":
      case "ENAB":
        this.IFF.debugger.skipped = true;
        this.IFF.reader.skip(length2);
        break;
      case "SURF":
        this.IFF.parseSurfaceLwo2(length2);
        break;
      case "CLIP":
        this.IFF.parseClipLwo2(length2);
        break;
      case "IPIX":
      case "IMIP":
      case "IMOD":
      case "AMOD":
      case "IINV":
      case "INCR":
      case "IAXS":
      case "IFOT":
      case "ITIM":
      case "IWRL":
      case "IUTI":
      case "IINX":
      case "IINY":
      case "IINZ":
      case "IREF":
        if (length2 === 4)
          this.IFF.currentNode[blockID] = this.IFF.reader.getInt32();
        else
          this.IFF.reader.skip(length2);
        break;
      case "OTAG":
        this.IFF.parseObjectTag();
        break;
      case "LAYR":
        this.IFF.parseLayer(length2);
        break;
      case "PNTS":
        this.IFF.parsePoints(length2);
        break;
      case "VMAP":
        this.IFF.parseVertexMapping(length2);
        break;
      case "AUVU":
      case "AUVN":
        this.IFF.reader.skip(length2 - 1);
        this.IFF.reader.getVariableLengthIndex();
        break;
      case "POLS":
        this.IFF.parsePolygonList(length2);
        break;
      case "TAGS":
        this.IFF.parseTagStrings(length2);
        break;
      case "PTAG":
        this.IFF.parsePolygonTagMapping(length2);
        break;
      case "VMAD":
        this.IFF.parseVertexMapping(length2, true);
        break;
      case "DESC":
        this.IFF.currentForm.description = this.IFF.reader.getString();
        break;
      case "TEXT":
      case "CMNT":
      case "NCOM":
        this.IFF.currentForm.comment = this.IFF.reader.getString();
        break;
      case "NAME":
        this.IFF.currentForm.channelName = this.IFF.reader.getString();
        break;
      case "WRAP":
        this.IFF.currentForm.wrap = {
          w: this.IFF.reader.getUint16(),
          h: this.IFF.reader.getUint16()
        };
        break;
      case "IMAG":
        var index = this.IFF.reader.getVariableLengthIndex();
        this.IFF.currentForm.imageIndex = index;
        break;
      case "OREF":
        this.IFF.currentForm.referenceObject = this.IFF.reader.getString();
        break;
      case "ROID":
        this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();
        break;
      case "SSHN":
        this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();
        break;
      case "AOVN":
        this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();
        break;
      case "NSTA":
        this.IFF.currentForm.disabled = this.IFF.reader.getUint16();
        break;
      case "NRNM":
        this.IFF.currentForm.realName = this.IFF.reader.getString();
        break;
      case "NNME":
        this.IFF.currentForm.refName = this.IFF.reader.getString();
        this.IFF.currentSurface.nodes[this.IFF.currentForm.refName] = this.IFF.currentForm;
        break;
      case "INME":
        if (!this.IFF.currentForm.nodeName)
          this.IFF.currentForm.nodeName = [];
        this.IFF.currentForm.nodeName.push(this.IFF.reader.getString());
        break;
      case "IINN":
        if (!this.IFF.currentForm.inputNodeName)
          this.IFF.currentForm.inputNodeName = [];
        this.IFF.currentForm.inputNodeName.push(this.IFF.reader.getString());
        break;
      case "IINM":
        if (!this.IFF.currentForm.inputName)
          this.IFF.currentForm.inputName = [];
        this.IFF.currentForm.inputName.push(this.IFF.reader.getString());
        break;
      case "IONM":
        if (!this.IFF.currentForm.inputOutputName)
          this.IFF.currentForm.inputOutputName = [];
        this.IFF.currentForm.inputOutputName.push(this.IFF.reader.getString());
        break;
      case "FNAM":
        this.IFF.currentForm.fileName = this.IFF.reader.getString();
        break;
      case "CHAN":
        if (length2 === 4)
          this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();
        else
          this.IFF.reader.skip(length2);
        break;
      case "SMAN":
        var maxSmoothingAngle = this.IFF.reader.getFloat32();
        this.IFF.currentSurface.attributes.smooth = maxSmoothingAngle < 0 ? false : true;
        break;
      case "COLR":
        this.IFF.currentSurface.attributes.Color = {
          value: this.IFF.reader.getFloat32Array(3)
        };
        this.IFF.reader.skip(2);
        break;
      case "LUMI":
        this.IFF.currentSurface.attributes.Luminosity = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "SPEC":
        this.IFF.currentSurface.attributes.Specular = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "DIFF":
        this.IFF.currentSurface.attributes.Diffuse = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "REFL":
        this.IFF.currentSurface.attributes.Reflection = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "GLOS":
        this.IFF.currentSurface.attributes.Glossiness = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "TRAN":
        this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "BUMP":
        this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "SIDE":
        this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();
        break;
      case "RIMG":
        this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();
        break;
      case "RIND":
        this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "TIMG":
        this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();
        break;
      case "IMAP":
        this.IFF.reader.skip(2);
        break;
      case "TMAP":
        this.IFF.debugger.skipped = true;
        this.IFF.reader.skip(length2);
        break;
      case "IUVI":
        this.IFF.currentNode.UVChannel = this.IFF.reader.getString(length2);
        break;
      case "IUTL":
        this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();
        break;
      case "IVTL":
        this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();
        break;
      case "BLOK":
        break;
      default:
        this.IFF.parseUnknownCHUNK(blockID, length2);
    }
    if (blockID != "FORM") {
      this.IFF.debugger.node = 1;
      this.IFF.debugger.nodeID = blockID;
      this.IFF.debugger.log();
    }
    if (this.IFF.reader.offset >= this.IFF.currentFormEnd) {
      this.IFF.currentForm = this.IFF.parentForm;
    }
  }
};

// node_modules/three-stdlib/loaders/lwo/IFFParser.js
function IFFParser() {
  this.debugger = new Debugger();
}
IFFParser.prototype = {
  constructor: IFFParser,
  parse: function(buffer2) {
    this.reader = new DataViewReader(buffer2);
    this.tree = {
      materials: {},
      layers: [],
      tags: [],
      textures: []
    };
    this.currentLayer = this.tree;
    this.currentForm = this.tree;
    this.parseTopForm();
    if (this.tree.format === void 0)
      return;
    if (this.tree.format === "LWO2") {
      this.parser = new LWO2Parser(this);
      while (!this.reader.endOfFile())
        this.parser.parseBlock();
    } else if (this.tree.format === "LWO3") {
      this.parser = new LWO3Parser(this);
      while (!this.reader.endOfFile())
        this.parser.parseBlock();
    }
    this.debugger.offset = this.reader.offset;
    this.debugger.closeForms();
    return this.tree;
  },
  parseTopForm() {
    this.debugger.offset = this.reader.offset;
    var topForm = this.reader.getIDTag();
    if (topForm !== "FORM") {
      console.warn("LWOLoader: Top-level FORM missing.");
      return;
    }
    var length2 = this.reader.getUint32();
    this.debugger.dataOffset = this.reader.offset;
    this.debugger.length = length2;
    var type2 = this.reader.getIDTag();
    if (type2 === "LWO2") {
      this.tree.format = type2;
    } else if (type2 === "LWO3") {
      this.tree.format = type2;
    }
    this.debugger.node = 0;
    this.debugger.nodeID = type2;
    this.debugger.log();
    return;
  },
  parseForm(length2) {
    var type2 = this.reader.getIDTag();
    switch (type2) {
      case "ISEQ":
      case "ANIM":
      case "STCC":
      case "VPVL":
      case "VPRM":
      case "NROT":
      case "WRPW":
      case "WRPH":
      case "FUNC":
      case "FALL":
      case "OPAC":
      case "GRAD":
      case "ENVS":
      case "VMOP":
      case "VMBG":
      case "OMAX":
      case "STEX":
      case "CKBG":
      case "CKEY":
      case "VMLA":
      case "VMLB":
        this.debugger.skipped = true;
        this.skipForm(length2);
        break;
      case "META":
      case "NNDS":
      case "NODS":
      case "NDTA":
      case "ADAT":
      case "AOVS":
      case "BLOK":
      case "IBGC":
      case "IOPC":
      case "IIMG":
      case "TXTR":
        this.debugger.length = 4;
        this.debugger.skipped = true;
        break;
      case "IFAL":
      case "ISCL":
      case "IPOS":
      case "IROT":
      case "IBMP":
      case "IUTD":
      case "IVTD":
        this.parseTextureNodeAttribute(type2);
        break;
      case "ENVL":
        this.parseEnvelope(length2);
        break;
      case "CLIP":
        if (this.tree.format === "LWO2") {
          this.parseForm(length2);
        } else {
          this.parseClip(length2);
        }
        break;
      case "STIL":
        this.parseImage();
        break;
      case "XREF":
        this.reader.skip(8);
        this.currentForm.referenceTexture = {
          index: this.reader.getUint32(),
          refName: this.reader.getString()
        };
        break;
      case "IMST":
        this.parseImageStateForm(length2);
        break;
      case "SURF":
        this.parseSurfaceForm(length2);
        break;
      case "VALU":
        this.parseValueForm(length2);
        break;
      case "NTAG":
        this.parseSubNode(length2);
        break;
      case "ATTR":
      case "SATR":
        this.setupForm("attributes", length2);
        break;
      case "NCON":
        this.parseConnections(length2);
        break;
      case "SSHA":
        this.parentForm = this.currentForm;
        this.currentForm = this.currentSurface;
        this.setupForm("surfaceShader", length2);
        break;
      case "SSHD":
        this.setupForm("surfaceShaderData", length2);
        break;
      case "ENTR":
        this.parseEntryForm(length2);
        break;
      case "IMAP":
        this.parseImageMap(length2);
        break;
      case "TAMP":
        this.parseXVAL("amplitude", length2);
        break;
      case "TMAP":
        this.setupForm("textureMap", length2);
        break;
      case "CNTR":
        this.parseXVAL3("center", length2);
        break;
      case "SIZE":
        this.parseXVAL3("scale", length2);
        break;
      case "ROTA":
        this.parseXVAL3("rotation", length2);
        break;
      default:
        this.parseUnknownForm(type2, length2);
    }
    this.debugger.node = 0;
    this.debugger.nodeID = type2;
    this.debugger.log();
  },
  setupForm(type2, length2) {
    if (!this.currentForm)
      this.currentForm = this.currentNode;
    this.currentFormEnd = this.reader.offset + length2;
    this.parentForm = this.currentForm;
    if (!this.currentForm[type2]) {
      this.currentForm[type2] = {};
      this.currentForm = this.currentForm[type2];
    } else {
      console.warn("LWOLoader: form already exists on parent: ", type2, this.currentForm);
      this.currentForm = this.currentForm[type2];
    }
  },
  skipForm(length2) {
    this.reader.skip(length2 - 4);
  },
  parseUnknownForm(type2, length2) {
    console.warn("LWOLoader: unknown FORM encountered: " + type2, length2);
    printBuffer(this.reader.dv.buffer, this.reader.offset, length2 - 4);
    this.reader.skip(length2 - 4);
  },
  parseSurfaceForm(length2) {
    this.reader.skip(8);
    var name = this.reader.getString();
    var surface = {
      attributes: {},
      connections: {},
      name,
      inputName: name,
      nodes: {},
      source: this.reader.getString()
    };
    this.tree.materials[name] = surface;
    this.currentSurface = surface;
    this.parentForm = this.tree.materials;
    this.currentForm = surface;
    this.currentFormEnd = this.reader.offset + length2;
  },
  parseSurfaceLwo2(length2) {
    var name = this.reader.getString();
    var surface = {
      attributes: {},
      connections: {},
      name,
      nodes: {},
      source: this.reader.getString()
    };
    this.tree.materials[name] = surface;
    this.currentSurface = surface;
    this.parentForm = this.tree.materials;
    this.currentForm = surface;
    this.currentFormEnd = this.reader.offset + length2;
  },
  parseSubNode(length2) {
    this.reader.skip(8);
    var name = this.reader.getString();
    var node = {
      name
    };
    this.currentForm = node;
    this.currentNode = node;
    this.currentFormEnd = this.reader.offset + length2;
  },
  parseConnections(length2) {
    this.currentFormEnd = this.reader.offset + length2;
    this.parentForm = this.currentForm;
    this.currentForm = this.currentSurface.connections;
  },
  parseEntryForm(length2) {
    this.reader.skip(8);
    var name = this.reader.getString();
    this.currentForm = this.currentNode.attributes;
    this.setupForm(name, length2);
  },
  parseValueForm() {
    this.reader.skip(8);
    var valueType = this.reader.getString();
    if (valueType === "double") {
      this.currentForm.value = this.reader.getUint64();
    } else if (valueType === "int") {
      this.currentForm.value = this.reader.getUint32();
    } else if (valueType === "vparam") {
      this.reader.skip(24);
      this.currentForm.value = this.reader.getFloat64();
    } else if (valueType === "vparam3") {
      this.reader.skip(24);
      this.currentForm.value = this.reader.getFloat64Array(3);
    }
  },
  parseImageStateForm() {
    this.reader.skip(8);
    this.currentForm.mipMapLevel = this.reader.getFloat32();
  },
  parseImageMap(length2) {
    this.currentFormEnd = this.reader.offset + length2;
    this.parentForm = this.currentForm;
    if (!this.currentForm.maps)
      this.currentForm.maps = [];
    var map = {};
    this.currentForm.maps.push(map);
    this.currentForm = map;
    this.reader.skip(10);
  },
  parseTextureNodeAttribute(type2) {
    this.reader.skip(28);
    this.reader.skip(20);
    switch (type2) {
      case "ISCL":
        this.currentNode.scale = this.reader.getFloat32Array(3);
        break;
      case "IPOS":
        this.currentNode.position = this.reader.getFloat32Array(3);
        break;
      case "IROT":
        this.currentNode.rotation = this.reader.getFloat32Array(3);
        break;
      case "IFAL":
        this.currentNode.falloff = this.reader.getFloat32Array(3);
        break;
      case "IBMP":
        this.currentNode.amplitude = this.reader.getFloat32();
        break;
      case "IUTD":
        this.currentNode.uTiles = this.reader.getFloat32();
        break;
      case "IVTD":
        this.currentNode.vTiles = this.reader.getFloat32();
        break;
    }
    this.reader.skip(2);
  },
  parseEnvelope(length2) {
    this.reader.skip(length2 - 4);
  },
  parseClip(length2) {
    var tag = this.reader.getIDTag();
    if (tag === "FORM") {
      this.reader.skip(16);
      this.currentNode.fileName = this.reader.getString();
      return;
    }
    this.reader.setOffset(this.reader.offset - 4);
    this.currentFormEnd = this.reader.offset + length2;
    this.parentForm = this.currentForm;
    this.reader.skip(8);
    var texture2 = {
      index: this.reader.getUint32()
    };
    this.tree.textures.push(texture2);
    this.currentForm = texture2;
  },
  parseClipLwo2(length2) {
    var texture2 = {
      index: this.reader.getUint32(),
      fileName: ""
    };
    while (true) {
      var tag = this.reader.getIDTag();
      var n_length = this.reader.getUint16();
      if (tag === "STIL") {
        texture2.fileName = this.reader.getString();
        break;
      }
      if (n_length >= length2) {
        break;
      }
    }
    this.tree.textures.push(texture2);
    this.currentForm = texture2;
  },
  parseImage() {
    this.reader.skip(8);
    this.currentForm.fileName = this.reader.getString();
  },
  parseXVAL(type2, length2) {
    var endOffset = this.reader.offset + length2 - 4;
    this.reader.skip(8);
    this.currentForm[type2] = this.reader.getFloat32();
    this.reader.setOffset(endOffset);
  },
  parseXVAL3(type2, length2) {
    var endOffset = this.reader.offset + length2 - 4;
    this.reader.skip(8);
    this.currentForm[type2] = {
      x: this.reader.getFloat32(),
      y: this.reader.getFloat32(),
      z: this.reader.getFloat32()
    };
    this.reader.setOffset(endOffset);
  },
  parseObjectTag() {
    if (!this.tree.objectTags)
      this.tree.objectTags = {};
    this.tree.objectTags[this.reader.getIDTag()] = {
      tagString: this.reader.getString()
    };
  },
  parseLayer(length2) {
    var layer = {
      number: this.reader.getUint16(),
      flags: this.reader.getUint16(),
      pivot: this.reader.getFloat32Array(3),
      name: this.reader.getString()
    };
    this.tree.layers.push(layer);
    this.currentLayer = layer;
    var parsedLength = 16 + stringOffset(this.currentLayer.name);
    this.currentLayer.parent = parsedLength < length2 ? this.reader.getUint16() : -1;
  },
  parsePoints(length2) {
    this.currentPoints = [];
    for (let i2 = 0; i2 < length2 / 4; i2 += 3) {
      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());
    }
  },
  parseVertexMapping(length2, discontinuous) {
    var finalOffset = this.reader.offset + length2;
    var channelName = this.reader.getString();
    if (this.reader.offset === finalOffset) {
      this.currentForm.UVChannel = channelName;
      return;
    }
    this.reader.setOffset(this.reader.offset - stringOffset(channelName));
    var type2 = this.reader.getIDTag();
    this.reader.getUint16();
    var name = this.reader.getString();
    var remainingLength = length2 - 6 - stringOffset(name);
    switch (type2) {
      case "TXUV":
        this.parseUVMapping(name, finalOffset, discontinuous);
        break;
      case "MORF":
      case "SPOT":
        this.parseMorphTargets(name, finalOffset, type2);
        break;
      case "APSL":
      case "NORM":
      case "WGHT":
      case "MNVW":
      case "PICK":
      case "RGB ":
      case "RGBA":
        this.reader.skip(remainingLength);
        break;
      default:
        console.warn("LWOLoader: unknown vertex map type: " + type2);
        this.reader.skip(remainingLength);
    }
  },
  parseUVMapping(name, finalOffset, discontinuous) {
    var uvIndices = [];
    var polyIndices = [];
    var uvs = [];
    while (this.reader.offset < finalOffset) {
      uvIndices.push(this.reader.getVariableLengthIndex());
      if (discontinuous)
        polyIndices.push(this.reader.getVariableLengthIndex());
      uvs.push(this.reader.getFloat32(), this.reader.getFloat32());
    }
    if (discontinuous) {
      if (!this.currentLayer.discontinuousUVs)
        this.currentLayer.discontinuousUVs = {};
      this.currentLayer.discontinuousUVs[name] = {
        uvIndices,
        polyIndices,
        uvs
      };
    } else {
      if (!this.currentLayer.uvs)
        this.currentLayer.uvs = {};
      this.currentLayer.uvs[name] = {
        uvIndices,
        uvs
      };
    }
  },
  parseMorphTargets(name, finalOffset, type2) {
    var indices = [];
    var points = [];
    type2 = type2 === "MORF" ? "relative" : "absolute";
    while (this.reader.offset < finalOffset) {
      indices.push(this.reader.getVariableLengthIndex());
      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());
    }
    if (!this.currentLayer.morphTargets)
      this.currentLayer.morphTargets = {};
    this.currentLayer.morphTargets[name] = {
      indices,
      points,
      type: type2
    };
  },
  parsePolygonList(length2) {
    var finalOffset = this.reader.offset + length2;
    var type2 = this.reader.getIDTag();
    var indices = [];
    var polygonDimensions = [];
    while (this.reader.offset < finalOffset) {
      var numverts = this.reader.getUint16();
      numverts = numverts & 1023;
      polygonDimensions.push(numverts);
      for (let j2 = 0; j2 < numverts; j2++)
        indices.push(this.reader.getVariableLengthIndex());
    }
    var geometryData = {
      type: type2,
      vertexIndices: indices,
      polygonDimensions,
      points: this.currentPoints
    };
    if (polygonDimensions[0] === 1)
      geometryData.type = "points";
    else if (polygonDimensions[0] === 2)
      geometryData.type = "lines";
    this.currentLayer.geometry = geometryData;
  },
  parseTagStrings(length2) {
    this.tree.tags = this.reader.getStringArray(length2);
  },
  parsePolygonTagMapping(length2) {
    var finalOffset = this.reader.offset + length2;
    var type2 = this.reader.getIDTag();
    if (type2 === "SURF") {
      this.parseMaterialIndices(finalOffset);
    } else {
      this.reader.skip(length2 - 4);
    }
  },
  parseMaterialIndices(finalOffset) {
    this.currentLayer.geometry.materialIndices = [];
    while (this.reader.offset < finalOffset) {
      var polygonIndex = this.reader.getVariableLengthIndex();
      var materialIndex = this.reader.getUint16();
      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);
    }
  },
  parseUnknownCHUNK(blockID, length2) {
    console.warn("LWOLoader: unknown chunk type: " + blockID + " length: " + length2);
    var data = this.reader.getString(length2);
    this.currentForm[blockID] = data;
  }
};
function DataViewReader(buffer2) {
  this.dv = new DataView(buffer2);
  this.offset = 0;
}
DataViewReader.prototype = {
  constructor: DataViewReader,
  size: function() {
    return this.dv.buffer.byteLength;
  },
  setOffset(offset) {
    if (offset > 0 && offset < this.dv.buffer.byteLength) {
      this.offset = offset;
    } else {
      console.error("LWOLoader: invalid buffer offset");
    }
  },
  endOfFile: function() {
    if (this.offset >= this.size())
      return true;
    return false;
  },
  skip: function(length2) {
    this.offset += length2;
  },
  getUint8: function() {
    var value = this.dv.getUint8(this.offset);
    this.offset += 1;
    return value;
  },
  getUint16: function() {
    var value = this.dv.getUint16(this.offset);
    this.offset += 2;
    return value;
  },
  getInt32: function() {
    var value = this.dv.getInt32(this.offset, false);
    this.offset += 4;
    return value;
  },
  getUint32: function() {
    var value = this.dv.getUint32(this.offset, false);
    this.offset += 4;
    return value;
  },
  getUint64: function() {
    var low, high;
    high = this.getUint32();
    low = this.getUint32();
    return high * 4294967296 + low;
  },
  getFloat32: function() {
    var value = this.dv.getFloat32(this.offset, false);
    this.offset += 4;
    return value;
  },
  getFloat32Array: function(size2) {
    var a2 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a2.push(this.getFloat32());
    }
    return a2;
  },
  getFloat64: function() {
    var value = this.dv.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  },
  getFloat64Array: function(size2) {
    var a2 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a2.push(this.getFloat64());
    }
    return a2;
  },
  getVariableLengthIndex() {
    var firstByte = this.getUint8();
    if (firstByte === 255) {
      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();
    }
    return firstByte * 256 + this.getUint8();
  },
  getIDTag() {
    return this.getString(4);
  },
  getString: function(size2) {
    if (size2 === 0)
      return;
    var a2 = [];
    if (size2) {
      for (let i2 = 0; i2 < size2; i2++) {
        a2[i2] = this.getUint8();
      }
    } else {
      var currentChar;
      var len = 0;
      while (currentChar !== 0) {
        currentChar = this.getUint8();
        if (currentChar !== 0)
          a2.push(currentChar);
        len++;
      }
      if (!isEven(len + 1))
        this.getUint8();
    }
    return LoaderUtils.decodeText(new Uint8Array(a2));
  },
  getStringArray: function(size2) {
    var a2 = this.getString(size2);
    a2 = a2.split("\0");
    return a2.filter(Boolean);
  }
};
function Debugger() {
  this.active = false;
  this.depth = 0;
  this.formList = [];
}
Debugger.prototype = {
  constructor: Debugger,
  enable: function() {
    this.active = true;
  },
  log: function() {
    if (!this.active)
      return;
    var nodeType;
    switch (this.node) {
      case 0:
        nodeType = "FORM";
        break;
      case 1:
        nodeType = "CHK";
        break;
      case 2:
        nodeType = "S-CHK";
        break;
    }
    console.log("| ".repeat(this.depth) + nodeType, this.nodeID, `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`, this.node == 0 ? " {" : "", this.skipped ? "SKIPPED" : "", this.node == 0 && this.skipped ? "}" : "");
    if (this.node == 0 && !this.skipped) {
      this.depth += 1;
      this.formList.push(this.dataOffset + this.length);
    }
    this.skipped = false;
  },
  closeForms: function() {
    if (!this.active)
      return;
    for (let i2 = this.formList.length - 1; i2 >= 0; i2--) {
      if (this.offset >= this.formList[i2]) {
        this.depth -= 1;
        console.log("| ".repeat(this.depth) + "}");
        this.formList.splice(-1, 1);
      }
    }
  }
};
function isEven(num) {
  return num % 2;
}
function stringOffset(string) {
  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);
}
function printBuffer(buffer2, from, to) {
  console.log(LoaderUtils.decodeText(new Uint8Array(buffer2, from, to)));
}

// node_modules/three-stdlib/loaders/SVGLoader.js
var SVGLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.defaultDPI = 90;
    this.defaultUnit = "px";
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope2.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(text) {
    const scope2 = this;
    function parseNode(node, style) {
      if (node.nodeType !== 1)
        return;
      const transform = getNodeTransform(node);
      let traverseChildNodes = true;
      let path = null;
      switch (node.nodeName) {
        case "svg":
          break;
        case "style":
          parseCSSStylesheet(node);
          break;
        case "g":
          style = parseStyle(node, style);
          break;
        case "path":
          style = parseStyle(node, style);
          if (node.hasAttribute("d"))
            path = parsePathNode(node);
          break;
        case "rect":
          style = parseStyle(node, style);
          path = parseRectNode(node);
          break;
        case "polygon":
          style = parseStyle(node, style);
          path = parsePolygonNode(node);
          break;
        case "polyline":
          style = parseStyle(node, style);
          path = parsePolylineNode(node);
          break;
        case "circle":
          style = parseStyle(node, style);
          path = parseCircleNode(node);
          break;
        case "ellipse":
          style = parseStyle(node, style);
          path = parseEllipseNode(node);
          break;
        case "line":
          style = parseStyle(node, style);
          path = parseLineNode(node);
          break;
        case "defs":
          traverseChildNodes = false;
          break;
        case "use":
          style = parseStyle(node, style);
          const usedNodeId = node.href.baseVal.substring(1);
          const usedNode = node.viewportElement.getElementById(usedNodeId);
          if (usedNode) {
            parseNode(usedNode, style);
          } else {
            console.warn("SVGLoader: 'use node' references non-existent node id: " + usedNodeId);
          }
          break;
      }
      if (path) {
        if (style.fill !== void 0 && style.fill !== "none") {
          path.color.setStyle(style.fill);
        }
        transformPath(path, currentTransform);
        paths.push(path);
        path.userData = {
          node,
          style
        };
      }
      if (traverseChildNodes) {
        const nodes = node.childNodes;
        for (let i2 = 0; i2 < nodes.length; i2++) {
          parseNode(nodes[i2], style);
        }
      }
      if (transform) {
        transformStack.pop();
        if (transformStack.length > 0) {
          currentTransform.copy(transformStack[transformStack.length - 1]);
        } else {
          currentTransform.identity();
        }
      }
    }
    function parsePathNode(node) {
      const path = new ShapePath();
      const point = new Vector2();
      const control = new Vector2();
      const firstPoint = new Vector2();
      let isFirstPoint = true;
      let doSetFirstPoint = false;
      const d = node.getAttribute("d");
      const commands = d.match(/[a-df-z][^a-df-z]*/gi);
      for (let i2 = 0, l = commands.length; i2 < l; i2++) {
        const command = commands[i2];
        const type2 = command.charAt(0);
        const data2 = command.substr(1).trim();
        if (isFirstPoint === true) {
          doSetFirstPoint = true;
          isFirstPoint = false;
        }
        let numbers;
        switch (type2) {
          case "M":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2 += 2) {
              point.x = numbers[j2 + 0];
              point.y = numbers[j2 + 1];
              control.x = point.x;
              control.y = point.y;
              if (j2 === 0) {
                path.moveTo(point.x, point.y);
              } else {
                path.lineTo(point.x, point.y);
              }
              if (j2 === 0)
                firstPoint.copy(point);
            }
            break;
          case "H":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2++) {
              point.x = numbers[j2];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "V":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2++) {
              point.y = numbers[j2];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "L":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2 += 2) {
              point.x = numbers[j2 + 0];
              point.y = numbers[j2 + 1];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "C":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2 += 6) {
              path.bezierCurveTo(numbers[j2 + 0], numbers[j2 + 1], numbers[j2 + 2], numbers[j2 + 3], numbers[j2 + 4], numbers[j2 + 5]);
              control.x = numbers[j2 + 2];
              control.y = numbers[j2 + 3];
              point.x = numbers[j2 + 4];
              point.y = numbers[j2 + 5];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "S":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2 += 4) {
              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j2 + 0], numbers[j2 + 1], numbers[j2 + 2], numbers[j2 + 3]);
              control.x = numbers[j2 + 0];
              control.y = numbers[j2 + 1];
              point.x = numbers[j2 + 2];
              point.y = numbers[j2 + 3];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "Q":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2 += 4) {
              path.quadraticCurveTo(numbers[j2 + 0], numbers[j2 + 1], numbers[j2 + 2], numbers[j2 + 3]);
              control.x = numbers[j2 + 0];
              control.y = numbers[j2 + 1];
              point.x = numbers[j2 + 2];
              point.y = numbers[j2 + 3];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "T":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2 += 2) {
              const rx = getReflection(point.x, control.x);
              const ry = getReflection(point.y, control.y);
              path.quadraticCurveTo(rx, ry, numbers[j2 + 0], numbers[j2 + 1]);
              control.x = rx;
              control.y = ry;
              point.x = numbers[j2 + 0];
              point.y = numbers[j2 + 1];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "A":
            numbers = parseFloats(data2, [3, 4], 7);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2 += 7) {
              if (numbers[j2 + 5] == point.x && numbers[j2 + 6] == point.y)
                continue;
              const start = point.clone();
              point.x = numbers[j2 + 5];
              point.y = numbers[j2 + 6];
              control.x = point.x;
              control.y = point.y;
              parseArcCommand(path, numbers[j2], numbers[j2 + 1], numbers[j2 + 2], numbers[j2 + 3], numbers[j2 + 4], start, point);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "m":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2 += 2) {
              point.x += numbers[j2 + 0];
              point.y += numbers[j2 + 1];
              control.x = point.x;
              control.y = point.y;
              if (j2 === 0) {
                path.moveTo(point.x, point.y);
              } else {
                path.lineTo(point.x, point.y);
              }
              if (j2 === 0)
                firstPoint.copy(point);
            }
            break;
          case "h":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2++) {
              point.x += numbers[j2];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "v":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2++) {
              point.y += numbers[j2];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "l":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2 += 2) {
              point.x += numbers[j2 + 0];
              point.y += numbers[j2 + 1];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "c":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2 += 6) {
              path.bezierCurveTo(point.x + numbers[j2 + 0], point.y + numbers[j2 + 1], point.x + numbers[j2 + 2], point.y + numbers[j2 + 3], point.x + numbers[j2 + 4], point.y + numbers[j2 + 5]);
              control.x = point.x + numbers[j2 + 2];
              control.y = point.y + numbers[j2 + 3];
              point.x += numbers[j2 + 4];
              point.y += numbers[j2 + 5];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "s":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2 += 4) {
              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j2 + 0], point.y + numbers[j2 + 1], point.x + numbers[j2 + 2], point.y + numbers[j2 + 3]);
              control.x = point.x + numbers[j2 + 0];
              control.y = point.y + numbers[j2 + 1];
              point.x += numbers[j2 + 2];
              point.y += numbers[j2 + 3];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "q":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2 += 4) {
              path.quadraticCurveTo(point.x + numbers[j2 + 0], point.y + numbers[j2 + 1], point.x + numbers[j2 + 2], point.y + numbers[j2 + 3]);
              control.x = point.x + numbers[j2 + 0];
              control.y = point.y + numbers[j2 + 1];
              point.x += numbers[j2 + 2];
              point.y += numbers[j2 + 3];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "t":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2 += 2) {
              const rx = getReflection(point.x, control.x);
              const ry = getReflection(point.y, control.y);
              path.quadraticCurveTo(rx, ry, point.x + numbers[j2 + 0], point.y + numbers[j2 + 1]);
              control.x = rx;
              control.y = ry;
              point.x = point.x + numbers[j2 + 0];
              point.y = point.y + numbers[j2 + 1];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "a":
            numbers = parseFloats(data2, [3, 4], 7);
            for (let j2 = 0, jl2 = numbers.length; j2 < jl2; j2 += 7) {
              if (numbers[j2 + 5] == 0 && numbers[j2 + 6] == 0)
                continue;
              const start = point.clone();
              point.x += numbers[j2 + 5];
              point.y += numbers[j2 + 6];
              control.x = point.x;
              control.y = point.y;
              parseArcCommand(path, numbers[j2], numbers[j2 + 1], numbers[j2 + 2], numbers[j2 + 3], numbers[j2 + 4], start, point);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "Z":
          case "z":
            path.currentPath.autoClose = true;
            if (path.currentPath.curves.length > 0) {
              point.copy(firstPoint);
              path.currentPath.currentPoint.copy(point);
              isFirstPoint = true;
            }
            break;
          default:
            console.warn(command);
        }
        doSetFirstPoint = false;
      }
      return path;
    }
    function parseCSSStylesheet(node) {
      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length)
        return;
      for (let i2 = 0; i2 < node.sheet.cssRules.length; i2++) {
        const stylesheet = node.sheet.cssRules[i2];
        if (stylesheet.type !== 1)
          continue;
        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i3) => i3.trim());
        for (let j2 = 0; j2 < selectorList.length; j2++) {
          stylesheets[selectorList[j2]] = Object.assign(stylesheets[selectorList[j2]] || {}, stylesheet.style);
        }
      }
    }
    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {
      if (rx == 0 || ry == 0) {
        path.lineTo(end.x, end.y);
        return;
      }
      x_axis_rotation = x_axis_rotation * Math.PI / 180;
      rx = Math.abs(rx);
      ry = Math.abs(ry);
      const dx2 = (start.x - end.x) / 2;
      const dy2 = (start.y - end.y) / 2;
      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;
      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;
      let rxs = rx * rx;
      let rys = ry * ry;
      const x1ps = x1p * x1p;
      const y1ps = y1p * y1p;
      const cr = x1ps / rxs + y1ps / rys;
      if (cr > 1) {
        const s = Math.sqrt(cr);
        rx = s * rx;
        ry = s * ry;
        rxs = rx * rx;
        rys = ry * ry;
      }
      const dq = rxs * y1ps + rys * x1ps;
      const pq = (rxs * rys - dq) / dq;
      let q = Math.sqrt(Math.max(0, pq));
      if (large_arc_flag === sweep_flag)
        q = -q;
      const cxp = q * rx * y1p / ry;
      const cyp = -q * ry * x1p / rx;
      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;
      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;
      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);
      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);
      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);
    }
    function svgAngle(ux, uy, vx, vy) {
      const dot2 = ux * vx + uy * vy;
      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);
      let ang = Math.acos(Math.max(-1, Math.min(1, dot2 / len)));
      if (ux * vy - uy * vx < 0)
        ang = -ang;
      return ang;
    }
    function parseRectNode(node) {
      const x = parseFloatWithUnits(node.getAttribute("x") || 0);
      const y = parseFloatWithUnits(node.getAttribute("y") || 0);
      const rx = parseFloatWithUnits(node.getAttribute("rx") || node.getAttribute("ry") || 0);
      const ry = parseFloatWithUnits(node.getAttribute("ry") || node.getAttribute("rx") || 0);
      const w = parseFloatWithUnits(node.getAttribute("width"));
      const h = parseFloatWithUnits(node.getAttribute("height"));
      const bci = 1 - 0.551915024494;
      const path = new ShapePath();
      path.moveTo(x + rx, y);
      path.lineTo(x + w - rx, y);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);
      }
      path.lineTo(x + w, y + h - ry);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);
      }
      path.lineTo(x + rx, y + h);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);
      }
      path.lineTo(x, y + ry);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);
      }
      return path;
    }
    function parsePolygonNode(node) {
      function iterator(match, a2, b3) {
        const x = parseFloatWithUnits(a2);
        const y = parseFloatWithUnits(b3);
        if (index === 0) {
          path.moveTo(x, y);
        } else {
          path.lineTo(x, y);
        }
        index++;
      }
      const regex = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g;
      const path = new ShapePath();
      let index = 0;
      node.getAttribute("points").replace(regex, iterator);
      path.currentPath.autoClose = true;
      return path;
    }
    function parsePolylineNode(node) {
      function iterator(match, a2, b3) {
        const x = parseFloatWithUnits(a2);
        const y = parseFloatWithUnits(b3);
        if (index === 0) {
          path.moveTo(x, y);
        } else {
          path.lineTo(x, y);
        }
        index++;
      }
      const regex = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g;
      const path = new ShapePath();
      let index = 0;
      node.getAttribute("points").replace(regex, iterator);
      path.currentPath.autoClose = false;
      return path;
    }
    function parseCircleNode(node) {
      const x = parseFloatWithUnits(node.getAttribute("cx") || 0);
      const y = parseFloatWithUnits(node.getAttribute("cy") || 0);
      const r = parseFloatWithUnits(node.getAttribute("r") || 0);
      const subpath = new Path();
      subpath.absarc(x, y, r, 0, Math.PI * 2);
      const path = new ShapePath();
      path.subPaths.push(subpath);
      return path;
    }
    function parseEllipseNode(node) {
      const x = parseFloatWithUnits(node.getAttribute("cx") || 0);
      const y = parseFloatWithUnits(node.getAttribute("cy") || 0);
      const rx = parseFloatWithUnits(node.getAttribute("rx") || 0);
      const ry = parseFloatWithUnits(node.getAttribute("ry") || 0);
      const subpath = new Path();
      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);
      const path = new ShapePath();
      path.subPaths.push(subpath);
      return path;
    }
    function parseLineNode(node) {
      const x1 = parseFloatWithUnits(node.getAttribute("x1") || 0);
      const y1 = parseFloatWithUnits(node.getAttribute("y1") || 0);
      const x2 = parseFloatWithUnits(node.getAttribute("x2") || 0);
      const y2 = parseFloatWithUnits(node.getAttribute("y2") || 0);
      const path = new ShapePath();
      path.moveTo(x1, y1);
      path.lineTo(x2, y2);
      path.currentPath.autoClose = false;
      return path;
    }
    function parseStyle(node, style) {
      style = Object.assign({}, style);
      let stylesheetStyles = {};
      if (node.hasAttribute("class")) {
        const classSelectors = node.getAttribute("class").split(/\s/).filter(Boolean).map((i2) => i2.trim());
        for (let i2 = 0; i2 < classSelectors.length; i2++) {
          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["." + classSelectors[i2]]);
        }
      }
      if (node.hasAttribute("id")) {
        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["#" + node.getAttribute("id")]);
      }
      function addStyle(svgName, jsName, adjustFunction) {
        if (adjustFunction === void 0) {
          adjustFunction = function copy(v) {
            if (v.startsWith("url"))
              console.warn("SVGLoader: url access in attributes is not implemented.");
            return v;
          };
        }
        if (node.hasAttribute(svgName))
          style[jsName] = adjustFunction(node.getAttribute(svgName));
        if (stylesheetStyles[svgName])
          style[jsName] = adjustFunction(stylesheetStyles[svgName]);
        if (node.style && node.style[svgName] !== "")
          style[jsName] = adjustFunction(node.style[svgName]);
      }
      function clamp2(v) {
        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));
      }
      function positive(v) {
        return Math.max(0, parseFloatWithUnits(v));
      }
      addStyle("fill", "fill");
      addStyle("fill-opacity", "fillOpacity", clamp2);
      addStyle("fill-rule", "fillRule");
      addStyle("opacity", "opacity", clamp2);
      addStyle("stroke", "stroke");
      addStyle("stroke-opacity", "strokeOpacity", clamp2);
      addStyle("stroke-width", "strokeWidth", positive);
      addStyle("stroke-linejoin", "strokeLineJoin");
      addStyle("stroke-linecap", "strokeLineCap");
      addStyle("stroke-miterlimit", "strokeMiterLimit", positive);
      addStyle("visibility", "visibility");
      return style;
    }
    function getReflection(a2, b3) {
      return a2 - (b3 - a2);
    }
    function parseFloats(input, flags, stride) {
      if (typeof input !== "string") {
        throw new TypeError("Invalid input: " + typeof input);
      }
      const RE = {
        SEPARATOR: /[ \t\r\n\,.\-+]/,
        WHITESPACE: /[ \t\r\n]/,
        DIGIT: /[\d]/,
        SIGN: /[-+]/,
        POINT: /\./,
        COMMA: /,/,
        EXP: /e/i,
        FLAGS: /[01]/
      };
      const SEP = 0;
      const INT = 1;
      const FLOAT = 2;
      const EXP = 3;
      let state = SEP;
      let seenComma = true;
      let number = "", exponent = "";
      const result = [];
      function throwSyntaxError(current2, i2, partial) {
        const error = new SyntaxError('Unexpected character "' + current2 + '" at index ' + i2 + ".");
        error.partial = partial;
        throw error;
      }
      function newNumber() {
        if (number !== "") {
          if (exponent === "")
            result.push(Number(number));
          else
            result.push(Number(number) * Math.pow(10, Number(exponent)));
        }
        number = "";
        exponent = "";
      }
      let current;
      const length2 = input.length;
      for (let i2 = 0; i2 < length2; i2++) {
        current = input[i2];
        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {
          state = INT;
          number = current;
          newNumber();
          continue;
        }
        if (state === SEP) {
          if (RE.WHITESPACE.test(current)) {
            continue;
          }
          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {
            state = INT;
            number = current;
            continue;
          }
          if (RE.POINT.test(current)) {
            state = FLOAT;
            number = current;
            continue;
          }
          if (RE.COMMA.test(current)) {
            if (seenComma) {
              throwSyntaxError(current, i2, result);
            }
            seenComma = true;
          }
        }
        if (state === INT) {
          if (RE.DIGIT.test(current)) {
            number += current;
            continue;
          }
          if (RE.POINT.test(current)) {
            number += current;
            state = FLOAT;
            continue;
          }
          if (RE.EXP.test(current)) {
            state = EXP;
            continue;
          }
          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {
            throwSyntaxError(current, i2, result);
          }
        }
        if (state === FLOAT) {
          if (RE.DIGIT.test(current)) {
            number += current;
            continue;
          }
          if (RE.EXP.test(current)) {
            state = EXP;
            continue;
          }
          if (RE.POINT.test(current) && number[number.length - 1] === ".") {
            throwSyntaxError(current, i2, result);
          }
        }
        if (state === EXP) {
          if (RE.DIGIT.test(current)) {
            exponent += current;
            continue;
          }
          if (RE.SIGN.test(current)) {
            if (exponent === "") {
              exponent += current;
              continue;
            }
            if (exponent.length === 1 && RE.SIGN.test(exponent)) {
              throwSyntaxError(current, i2, result);
            }
          }
        }
        if (RE.WHITESPACE.test(current)) {
          newNumber();
          state = SEP;
          seenComma = false;
        } else if (RE.COMMA.test(current)) {
          newNumber();
          state = SEP;
          seenComma = true;
        } else if (RE.SIGN.test(current)) {
          newNumber();
          state = INT;
          number = current;
        } else if (RE.POINT.test(current)) {
          newNumber();
          state = FLOAT;
          number = current;
        } else {
          throwSyntaxError(current, i2, result);
        }
      }
      newNumber();
      return result;
    }
    const units = ["mm", "cm", "in", "pt", "pc", "px"];
    const unitConversion = {
      mm: {
        mm: 1,
        cm: 0.1,
        in: 1 / 25.4,
        pt: 72 / 25.4,
        pc: 6 / 25.4,
        px: -1
      },
      cm: {
        mm: 10,
        cm: 1,
        in: 1 / 2.54,
        pt: 72 / 2.54,
        pc: 6 / 2.54,
        px: -1
      },
      in: {
        mm: 25.4,
        cm: 2.54,
        in: 1,
        pt: 72,
        pc: 6,
        px: -1
      },
      pt: {
        mm: 25.4 / 72,
        cm: 2.54 / 72,
        in: 1 / 72,
        pt: 1,
        pc: 6 / 72,
        px: -1
      },
      pc: {
        mm: 25.4 / 6,
        cm: 2.54 / 6,
        in: 1 / 6,
        pt: 72 / 6,
        pc: 1,
        px: -1
      },
      px: {
        px: 1
      }
    };
    function parseFloatWithUnits(string) {
      let theUnit = "px";
      if (typeof string === "string" || string instanceof String) {
        for (let i2 = 0, n = units.length; i2 < n; i2++) {
          const u = units[i2];
          if (string.endsWith(u)) {
            theUnit = u;
            string = string.substring(0, string.length - u.length);
            break;
          }
        }
      }
      let scale = void 0;
      if (theUnit === "px" && scope2.defaultUnit !== "px") {
        scale = unitConversion["in"][scope2.defaultUnit] / scope2.defaultDPI;
      } else {
        scale = unitConversion[theUnit][scope2.defaultUnit];
        if (scale < 0) {
          scale = unitConversion[theUnit]["in"] * scope2.defaultDPI;
        }
      }
      return scale * parseFloat(string);
    }
    function getNodeTransform(node) {
      if (!(node.hasAttribute("transform") || node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y")))) {
        return null;
      }
      const transform = parseNodeTransform(node);
      if (transformStack.length > 0) {
        transform.premultiply(transformStack[transformStack.length - 1]);
      }
      currentTransform.copy(transform);
      transformStack.push(transform);
      return transform;
    }
    function parseNodeTransform(node) {
      const transform = new Matrix3();
      const currentTransform2 = tempTransform0;
      if (node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y"))) {
        const tx = parseFloatWithUnits(node.getAttribute("x"));
        const ty = parseFloatWithUnits(node.getAttribute("y"));
        transform.translate(tx, ty);
      }
      if (node.hasAttribute("transform")) {
        const transformsTexts = node.getAttribute("transform").split(")");
        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {
          const transformText = transformsTexts[tIndex].trim();
          if (transformText === "")
            continue;
          const openParPos = transformText.indexOf("(");
          const closeParPos = transformText.length;
          if (openParPos > 0 && openParPos < closeParPos) {
            const transformType = transformText.substr(0, openParPos);
            const array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));
            currentTransform2.identity();
            switch (transformType) {
              case "translate":
                if (array.length >= 1) {
                  const tx = array[0];
                  let ty = tx;
                  if (array.length >= 2) {
                    ty = array[1];
                  }
                  currentTransform2.translate(tx, ty);
                }
                break;
              case "rotate":
                if (array.length >= 1) {
                  let angle = 0;
                  let cx = 0;
                  let cy = 0;
                  angle = -array[0] * Math.PI / 180;
                  if (array.length >= 3) {
                    cx = array[1];
                    cy = array[2];
                  }
                  tempTransform1.identity().translate(-cx, -cy);
                  tempTransform2.identity().rotate(angle);
                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);
                  tempTransform1.identity().translate(cx, cy);
                  currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);
                }
                break;
              case "scale":
                if (array.length >= 1) {
                  const scaleX = array[0];
                  let scaleY = scaleX;
                  if (array.length >= 2) {
                    scaleY = array[1];
                  }
                  currentTransform2.scale(scaleX, scaleY);
                }
                break;
              case "skewX":
                if (array.length === 1) {
                  currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
                }
                break;
              case "skewY":
                if (array.length === 1) {
                  currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);
                }
                break;
              case "matrix":
                if (array.length === 6) {
                  currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);
                }
                break;
            }
          }
          transform.premultiply(currentTransform2);
        }
      }
      return transform;
    }
    function transformPath(path, m) {
      function transfVec2(v2) {
        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);
        v2.set(tempV3.x, tempV3.y);
      }
      const isRotated = isTransformRotated(m);
      const subPaths = path.subPaths;
      for (let i2 = 0, n = subPaths.length; i2 < n; i2++) {
        const subPath = subPaths[i2];
        const curves = subPath.curves;
        for (let j2 = 0; j2 < curves.length; j2++) {
          const curve = curves[j2];
          if (curve.isLineCurve) {
            transfVec2(curve.v1);
            transfVec2(curve.v2);
          } else if (curve.isCubicBezierCurve) {
            transfVec2(curve.v0);
            transfVec2(curve.v1);
            transfVec2(curve.v2);
            transfVec2(curve.v3);
          } else if (curve.isQuadraticBezierCurve) {
            transfVec2(curve.v0);
            transfVec2(curve.v1);
            transfVec2(curve.v2);
          } else if (curve.isEllipseCurve) {
            if (isRotated) {
              console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.");
            }
            tempV2.set(curve.aX, curve.aY);
            transfVec2(tempV2);
            curve.aX = tempV2.x;
            curve.aY = tempV2.y;
            curve.xRadius *= getTransformScaleX(m);
            curve.yRadius *= getTransformScaleY(m);
          }
        }
      }
    }
    function isTransformRotated(m) {
      return m.elements[1] !== 0 || m.elements[3] !== 0;
    }
    function getTransformScaleX(m) {
      const te2 = m.elements;
      return Math.sqrt(te2[0] * te2[0] + te2[1] * te2[1]);
    }
    function getTransformScaleY(m) {
      const te2 = m.elements;
      return Math.sqrt(te2[3] * te2[3] + te2[4] * te2[4]);
    }
    const paths = [];
    const stylesheets = {};
    const transformStack = [];
    const tempTransform0 = new Matrix3();
    const tempTransform1 = new Matrix3();
    const tempTransform2 = new Matrix3();
    const tempTransform3 = new Matrix3();
    const tempV2 = new Vector2();
    const tempV3 = new Vector3();
    const currentTransform = new Matrix3();
    const xml = new DOMParser().parseFromString(text, "image/svg+xml");
    parseNode(xml.documentElement, {
      fill: "#000",
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeLineJoin: "miter",
      strokeLineCap: "butt",
      strokeMiterLimit: 4
    });
    const data = {
      paths,
      xml: xml.documentElement
    };
    return data;
  }
  static createShapes(shapePath) {
    const BIGNUMBER = 999999999;
    const IntersectionLocationType = {
      ORIGIN: 0,
      DESTINATION: 1,
      BETWEEN: 2,
      LEFT: 3,
      RIGHT: 4,
      BEHIND: 5,
      BEYOND: 6
    };
    const classifyResult = {
      loc: IntersectionLocationType.ORIGIN,
      t: 0
    };
    function findEdgeIntersection(a0, a1, b0, b1) {
      const x1 = a0.x;
      const x2 = a1.x;
      const x3 = b0.x;
      const x4 = b1.x;
      const y1 = a0.y;
      const y2 = a1.y;
      const y3 = b0.y;
      const y4 = b1.y;
      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      const t1 = nom1 / denom;
      const t2 = nom2 / denom;
      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {
        return null;
      } else if (nom1 === 0 && denom === 0) {
        for (let i2 = 0; i2 < 2; i2++) {
          classifyPoint(i2 === 0 ? b0 : b1, a0, a1);
          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
            const point = i2 === 0 ? b0 : b1;
            return {
              x: point.x,
              y: point.y,
              t: classifyResult.t
            };
          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {
            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);
            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);
            return {
              x,
              y,
              t: classifyResult.t
            };
          }
        }
        return null;
      } else {
        for (let i2 = 0; i2 < 2; i2++) {
          classifyPoint(i2 === 0 ? b0 : b1, a0, a1);
          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
            const point = i2 === 0 ? b0 : b1;
            return {
              x: point.x,
              y: point.y,
              t: classifyResult.t
            };
          }
        }
        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);
        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);
        return {
          x,
          y,
          t: t1
        };
      }
    }
    function classifyPoint(p, edgeStart, edgeEnd) {
      const ax = edgeEnd.x - edgeStart.x;
      const ay = edgeEnd.y - edgeStart.y;
      const bx = p.x - edgeStart.x;
      const by = p.y - edgeStart.y;
      const sa = ax * by - bx * ay;
      if (p.x === edgeStart.x && p.y === edgeStart.y) {
        classifyResult.loc = IntersectionLocationType.ORIGIN;
        classifyResult.t = 0;
        return;
      }
      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {
        classifyResult.loc = IntersectionLocationType.DESTINATION;
        classifyResult.t = 1;
        return;
      }
      if (sa < -Number.EPSILON) {
        classifyResult.loc = IntersectionLocationType.LEFT;
        return;
      }
      if (sa > Number.EPSILON) {
        classifyResult.loc = IntersectionLocationType.RIGHT;
        return;
      }
      if (ax * bx < 0 || ay * by < 0) {
        classifyResult.loc = IntersectionLocationType.BEHIND;
        return;
      }
      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {
        classifyResult.loc = IntersectionLocationType.BEYOND;
        return;
      }
      let t2;
      if (ax !== 0) {
        t2 = bx / ax;
      } else {
        t2 = by / ay;
      }
      classifyResult.loc = IntersectionLocationType.BETWEEN;
      classifyResult.t = t2;
    }
    function getIntersections(path1, path2) {
      const intersectionsRaw = [];
      const intersections = [];
      for (let index = 1; index < path1.length; index++) {
        const path1EdgeStart = path1[index - 1];
        const path1EdgeEnd = path1[index];
        for (let index2 = 1; index2 < path2.length; index2++) {
          const path2EdgeStart = path2[index2 - 1];
          const path2EdgeEnd = path2[index2];
          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);
          if (intersection !== null && intersectionsRaw.find((i2) => i2.t <= intersection.t + Number.EPSILON && i2.t >= intersection.t - Number.EPSILON) === void 0) {
            intersectionsRaw.push(intersection);
            intersections.push(new Vector2(intersection.x, intersection.y));
          }
        }
      }
      return intersections;
    }
    function getScanlineIntersections(scanline, boundingBox, paths) {
      const center = new Vector2();
      boundingBox.getCenter(center);
      const allIntersections = [];
      paths.forEach((path) => {
        if (path.boundingBox.containsPoint(center)) {
          const intersections = getIntersections(scanline, path.points);
          intersections.forEach((p) => {
            allIntersections.push({
              identifier: path.identifier,
              isCW: path.isCW,
              point: p
            });
          });
        }
      });
      allIntersections.sort((i1, i2) => {
        return i1.point.x - i2.point.x;
      });
      return allIntersections;
    }
    function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {
      if (_fillRule === null || _fillRule === void 0 || _fillRule === "") {
        _fillRule = "nonzero";
      }
      const centerBoundingBox = new Vector2();
      simplePath.boundingBox.getCenter(centerBoundingBox);
      const scanline = [new Vector2(scanlineMinX2, centerBoundingBox.y), new Vector2(scanlineMaxX2, centerBoundingBox.y)];
      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);
      scanlineIntersections.sort((i1, i22) => {
        return i1.point.x - i22.point.x;
      });
      const baseIntersections = [];
      const otherIntersections = [];
      scanlineIntersections.forEach((i3) => {
        if (i3.identifier === simplePath.identifier) {
          baseIntersections.push(i3);
        } else {
          otherIntersections.push(i3);
        }
      });
      const firstXOfPath = baseIntersections[0].point.x;
      const stack = [];
      let i2 = 0;
      while (i2 < otherIntersections.length && otherIntersections[i2].point.x < firstXOfPath) {
        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i2].identifier) {
          stack.pop();
        } else {
          stack.push(otherIntersections[i2].identifier);
        }
        i2++;
      }
      stack.push(simplePath.identifier);
      if (_fillRule === "evenodd") {
        const isHole = stack.length % 2 === 0 ? true : false;
        const isHoleFor = stack[stack.length - 2];
        return {
          identifier: simplePath.identifier,
          isHole,
          for: isHoleFor
        };
      } else if (_fillRule === "nonzero") {
        let isHole = true;
        let isHoleFor = null;
        let lastCWValue = null;
        for (let i3 = 0; i3 < stack.length; i3++) {
          const identifier2 = stack[i3];
          if (isHole) {
            lastCWValue = allPaths[identifier2].isCW;
            isHole = false;
            isHoleFor = identifier2;
          } else if (lastCWValue !== allPaths[identifier2].isCW) {
            lastCWValue = allPaths[identifier2].isCW;
            isHole = true;
          }
        }
        return {
          identifier: simplePath.identifier,
          isHole,
          for: isHoleFor
        };
      } else {
        console.warn('fill-rule: "' + _fillRule + '" is currently not implemented.');
      }
    }
    let identifier = 0;
    let scanlineMinX = BIGNUMBER;
    let scanlineMaxX = -BIGNUMBER;
    let simplePaths = shapePath.subPaths.map((p) => {
      const points = p.getPoints();
      let maxY = -BIGNUMBER;
      let minY = BIGNUMBER;
      let maxX = -BIGNUMBER;
      let minX = BIGNUMBER;
      for (let i2 = 0; i2 < points.length; i2++) {
        const p2 = points[i2];
        if (p2.y > maxY) {
          maxY = p2.y;
        }
        if (p2.y < minY) {
          minY = p2.y;
        }
        if (p2.x > maxX) {
          maxX = p2.x;
        }
        if (p2.x < minX) {
          minX = p2.x;
        }
      }
      if (scanlineMaxX <= maxX) {
        scanlineMaxX = maxX + 1;
      }
      if (scanlineMinX >= minX) {
        scanlineMinX = minX - 1;
      }
      return {
        curves: p.curves,
        points,
        isCW: ShapeUtils.isClockWise(points),
        identifier: identifier++,
        boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY))
      };
    });
    simplePaths = simplePaths.filter((sp) => sp.points.length > 1);
    const isAHole = simplePaths.map((p) => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule));
    const shapesToReturn = [];
    simplePaths.forEach((p) => {
      const amIAHole = isAHole[p.identifier];
      if (!amIAHole.isHole) {
        const shape = new Shape();
        shape.curves = p.curves;
        const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier);
        holes.forEach((h) => {
          const hole = simplePaths[h.identifier];
          const path = new Path();
          path.curves = hole.curves;
          shape.holes.push(path);
        });
        shapesToReturn.push(shape);
      }
    });
    return shapesToReturn;
  }
  static getStrokeStyle(width, color2, lineJoin, lineCap, miterLimit) {
    width = width !== void 0 ? width : 1;
    color2 = color2 !== void 0 ? color2 : "#000";
    lineJoin = lineJoin !== void 0 ? lineJoin : "miter";
    lineCap = lineCap !== void 0 ? lineCap : "butt";
    miterLimit = miterLimit !== void 0 ? miterLimit : 4;
    return {
      strokeColor: color2,
      strokeWidth: width,
      strokeLineJoin: lineJoin,
      strokeLineCap: lineCap,
      strokeMiterLimit: miterLimit
    };
  }
  static pointsToStroke(points, style, arcDivisions, minDistance) {
    const vertices = [];
    const normals = [];
    const uvs = [];
    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {
      return null;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    geometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    return geometry;
  }
  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {
    const tempV2_1 = new Vector2();
    const tempV2_2 = new Vector2();
    const tempV2_3 = new Vector2();
    const tempV2_4 = new Vector2();
    const tempV2_5 = new Vector2();
    const tempV2_6 = new Vector2();
    const tempV2_7 = new Vector2();
    const lastPointL = new Vector2();
    const lastPointR = new Vector2();
    const point0L = new Vector2();
    const point0R = new Vector2();
    const currentPointL = new Vector2();
    const currentPointR = new Vector2();
    const nextPointL = new Vector2();
    const nextPointR = new Vector2();
    const innerPoint = new Vector2();
    const outerPoint = new Vector2();
    arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;
    minDistance = minDistance !== void 0 ? minDistance : 1e-3;
    vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;
    points = removeDuplicatedPoints(points);
    const numPoints = points.length;
    if (numPoints < 2)
      return 0;
    const isClosed = points[0].equals(points[numPoints - 1]);
    let currentPoint;
    let previousPoint = points[0];
    let nextPoint;
    const strokeWidth2 = style.strokeWidth / 2;
    const deltaU = 1 / (numPoints - 1);
    let u0 = 0, u1;
    let innerSideModified;
    let joinIsOnLeftSide;
    let isMiter;
    let initialJoinIsOnLeftSide = false;
    let numVertices = 0;
    let currentCoordinate = vertexOffset * 3;
    let currentCoordinateUV = vertexOffset * 2;
    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);
    lastPointL.copy(points[0]).sub(tempV2_1);
    lastPointR.copy(points[0]).add(tempV2_1);
    point0L.copy(lastPointL);
    point0R.copy(lastPointR);
    for (let iPoint = 1; iPoint < numPoints; iPoint++) {
      currentPoint = points[iPoint];
      if (iPoint === numPoints - 1) {
        if (isClosed) {
          nextPoint = points[1];
        } else {
          nextPoint = void 0;
        }
      } else {
        nextPoint = points[iPoint + 1];
      }
      const normal1 = tempV2_1;
      getNormal(previousPoint, currentPoint, normal1);
      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);
      currentPointL.copy(currentPoint).sub(tempV2_3);
      currentPointR.copy(currentPoint).add(tempV2_3);
      u1 = u0 + deltaU;
      innerSideModified = false;
      if (nextPoint !== void 0) {
        getNormal(currentPoint, nextPoint, tempV2_2);
        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);
        nextPointL.copy(currentPoint).sub(tempV2_3);
        nextPointR.copy(currentPoint).add(tempV2_3);
        joinIsOnLeftSide = true;
        tempV2_3.subVectors(nextPoint, previousPoint);
        if (normal1.dot(tempV2_3) < 0) {
          joinIsOnLeftSide = false;
        }
        if (iPoint === 1)
          initialJoinIsOnLeftSide = joinIsOnLeftSide;
        tempV2_3.subVectors(nextPoint, currentPoint);
        tempV2_3.normalize();
        const dot2 = Math.abs(normal1.dot(tempV2_3));
        if (dot2 !== 0) {
          const miterSide = strokeWidth2 / dot2;
          tempV2_3.multiplyScalar(-miterSide);
          tempV2_4.subVectors(currentPoint, previousPoint);
          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);
          innerPoint.copy(tempV2_5).negate();
          const miterLength2 = tempV2_5.length();
          const segmentLengthPrev = tempV2_4.length();
          tempV2_4.divideScalar(segmentLengthPrev);
          tempV2_6.subVectors(nextPoint, currentPoint);
          const segmentLengthNext = tempV2_6.length();
          tempV2_6.divideScalar(segmentLengthNext);
          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {
            innerSideModified = true;
          }
          outerPoint.copy(tempV2_5).add(currentPoint);
          innerPoint.add(currentPoint);
          isMiter = false;
          if (innerSideModified) {
            if (joinIsOnLeftSide) {
              nextPointR.copy(innerPoint);
              currentPointR.copy(innerPoint);
            } else {
              nextPointL.copy(innerPoint);
              currentPointL.copy(innerPoint);
            }
          } else {
            makeSegmentTriangles();
          }
          switch (style.strokeLineJoin) {
            case "bevel":
              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
              break;
            case "round":
              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
              if (joinIsOnLeftSide) {
                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);
              } else {
                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);
              }
              break;
            case "miter":
            case "miter-clip":
            default:
              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;
              if (miterFraction < 1) {
                if (style.strokeLineJoin !== "miter-clip") {
                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
                  break;
                } else {
                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
                  if (joinIsOnLeftSide) {
                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);
                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);
                    addVertex(currentPointL, u1, 0);
                    addVertex(tempV2_6, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_6, u1, 0);
                    addVertex(tempV2_7, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_7, u1, 0);
                    addVertex(nextPointL, u1, 0);
                  } else {
                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);
                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);
                    addVertex(currentPointR, u1, 1);
                    addVertex(tempV2_6, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_6, u1, 1);
                    addVertex(tempV2_7, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_7, u1, 1);
                    addVertex(nextPointR, u1, 1);
                  }
                }
              } else {
                if (innerSideModified) {
                  if (joinIsOnLeftSide) {
                    addVertex(lastPointR, u0, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(outerPoint, u1, 0);
                    addVertex(lastPointR, u0, 1);
                    addVertex(outerPoint, u1, 0);
                    addVertex(innerPoint, u1, 1);
                  } else {
                    addVertex(lastPointR, u0, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(outerPoint, u1, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(innerPoint, u1, 0);
                    addVertex(outerPoint, u1, 1);
                  }
                  if (joinIsOnLeftSide) {
                    nextPointL.copy(outerPoint);
                  } else {
                    nextPointR.copy(outerPoint);
                  }
                } else {
                  if (joinIsOnLeftSide) {
                    addVertex(currentPointL, u1, 0);
                    addVertex(outerPoint, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(outerPoint, u1, 0);
                    addVertex(nextPointL, u1, 0);
                  } else {
                    addVertex(currentPointR, u1, 1);
                    addVertex(outerPoint, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(outerPoint, u1, 1);
                    addVertex(nextPointR, u1, 1);
                  }
                }
                isMiter = true;
              }
              break;
          }
        } else {
          makeSegmentTriangles();
        }
      } else {
        makeSegmentTriangles();
      }
      if (!isClosed && iPoint === numPoints - 1) {
        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);
      }
      u0 = u1;
      previousPoint = currentPoint;
      lastPointL.copy(nextPointL);
      lastPointR.copy(nextPointR);
    }
    if (!isClosed) {
      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);
    } else if (innerSideModified && vertices) {
      let lastOuter = outerPoint;
      let lastInner = innerPoint;
      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {
        lastOuter = innerPoint;
        lastInner = outerPoint;
      }
      if (joinIsOnLeftSide) {
        if (isMiter || initialJoinIsOnLeftSide) {
          lastInner.toArray(vertices, 0 * 3);
          lastInner.toArray(vertices, 3 * 3);
          if (isMiter) {
            lastOuter.toArray(vertices, 1 * 3);
          }
        }
      } else {
        if (isMiter || !initialJoinIsOnLeftSide) {
          lastInner.toArray(vertices, 1 * 3);
          lastInner.toArray(vertices, 3 * 3);
          if (isMiter) {
            lastOuter.toArray(vertices, 0 * 3);
          }
        }
      }
    }
    return numVertices;
    function getNormal(p1, p2, result) {
      result.subVectors(p2, p1);
      return result.set(-result.y, result.x).normalize();
    }
    function addVertex(position, u, v) {
      if (vertices) {
        vertices[currentCoordinate] = position.x;
        vertices[currentCoordinate + 1] = position.y;
        vertices[currentCoordinate + 2] = 0;
        if (normals) {
          normals[currentCoordinate] = 0;
          normals[currentCoordinate + 1] = 0;
          normals[currentCoordinate + 2] = 1;
        }
        currentCoordinate += 3;
        if (uvs) {
          uvs[currentCoordinateUV] = u;
          uvs[currentCoordinateUV + 1] = v;
          currentCoordinateUV += 2;
        }
      }
      numVertices += 3;
    }
    function makeCircularSector(center, p1, p2, u, v) {
      tempV2_1.copy(p1).sub(center).normalize();
      tempV2_2.copy(p2).sub(center).normalize();
      let angle = Math.PI;
      const dot2 = tempV2_1.dot(tempV2_2);
      if (Math.abs(dot2) < 1)
        angle = Math.abs(Math.acos(dot2));
      angle /= arcDivisions;
      tempV2_3.copy(p1);
      for (let i2 = 0, il = arcDivisions - 1; i2 < il; i2++) {
        tempV2_4.copy(tempV2_3).rotateAround(center, angle);
        addVertex(tempV2_3, u, v);
        addVertex(tempV2_4, u, v);
        addVertex(center, u, 0.5);
        tempV2_3.copy(tempV2_4);
      }
      addVertex(tempV2_4, u, v);
      addVertex(p2, u, v);
      addVertex(center, u, 0.5);
    }
    function makeSegmentTriangles() {
      addVertex(lastPointR, u0, 1);
      addVertex(lastPointL, u0, 0);
      addVertex(currentPointL, u1, 0);
      addVertex(lastPointR, u0, 1);
      addVertex(currentPointL, u1, 1);
      addVertex(currentPointR, u1, 0);
    }
    function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {
      if (innerSideModified2) {
        if (joinIsOnLeftSide2) {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointL, u1, 0);
          addVertex(lastPointR, u0, 1);
          addVertex(currentPointL, u1, 0);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPointL, u, 0);
          addVertex(nextPointL, u, 0);
          addVertex(innerPoint, u, 0.5);
        } else {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(currentPointR, u, 1);
          addVertex(nextPointR, u, 0);
          addVertex(innerPoint, u, 0.5);
        }
      } else {
        if (joinIsOnLeftSide2) {
          addVertex(currentPointL, u, 0);
          addVertex(nextPointL, u, 0);
          addVertex(currentPoint, u, 0.5);
        } else {
          addVertex(currentPointR, u, 1);
          addVertex(nextPointR, u, 0);
          addVertex(currentPoint, u, 0.5);
        }
      }
    }
    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {
      if (innerSideModified2) {
        if (joinIsOnLeftSide2) {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointL, u1, 0);
          addVertex(lastPointR, u0, 1);
          addVertex(currentPointL, u1, 0);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPointL, u0, 0);
          addVertex(currentPoint, u1, 0.5);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPoint, u1, 0.5);
          addVertex(nextPointL, u0, 0);
          addVertex(innerPoint, u1, 1);
        } else {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(currentPointR, u0, 1);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPoint, u1, 0.5);
          addVertex(currentPoint, u1, 0.5);
          addVertex(innerPoint, u1, 0);
          addVertex(nextPointR, u0, 1);
        }
      }
    }
    function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {
      switch (style.strokeLineCap) {
        case "round":
          if (start) {
            makeCircularSector(center, p2, p1, u, 0.5);
          } else {
            makeCircularSector(center, p1, p2, u, 0.5);
          }
          break;
        case "square":
          if (start) {
            tempV2_1.subVectors(p1, center);
            tempV2_2.set(tempV2_1.y, -tempV2_1.x);
            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);
            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);
            if (joinIsOnLeftSide2) {
              tempV2_3.toArray(vertices, 1 * 3);
              tempV2_4.toArray(vertices, 0 * 3);
              tempV2_4.toArray(vertices, 3 * 3);
            } else {
              tempV2_3.toArray(vertices, 1 * 3);
              tempV2_3.toArray(vertices, 3 * 3);
              tempV2_4.toArray(vertices, 0 * 3);
            }
          } else {
            tempV2_1.subVectors(p2, center);
            tempV2_2.set(tempV2_1.y, -tempV2_1.x);
            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);
            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);
            const vl = vertices.length;
            if (joinIsOnLeftSide2) {
              tempV2_3.toArray(vertices, vl - 1 * 3);
              tempV2_4.toArray(vertices, vl - 2 * 3);
              tempV2_4.toArray(vertices, vl - 4 * 3);
            } else {
              tempV2_3.toArray(vertices, vl - 2 * 3);
              tempV2_4.toArray(vertices, vl - 1 * 3);
              tempV2_4.toArray(vertices, vl - 4 * 3);
            }
          }
          break;
      }
    }
    function removeDuplicatedPoints(points2) {
      let dupPoints = false;
      for (let i2 = 1, n = points2.length - 1; i2 < n; i2++) {
        if (points2[i2].distanceTo(points2[i2 + 1]) < minDistance) {
          dupPoints = true;
          break;
        }
      }
      if (!dupPoints)
        return points2;
      const newPoints = [];
      newPoints.push(points2[0]);
      for (let i2 = 1, n = points2.length - 1; i2 < n; i2++) {
        if (points2[i2].distanceTo(points2[i2 + 1]) >= minDistance) {
          newPoints.push(points2[i2]);
        }
      }
      newPoints.push(points2[points2.length - 1]);
      return newPoints;
    }
  }
};

// node_modules/three-stdlib/loaders/3DMLoader.js
var _taskCache3 = /* @__PURE__ */ new WeakMap();
var Rhino3dmLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.libraryPath = "";
    this.libraryPending = null;
    this.libraryBinary = null;
    this.libraryConfig = {};
    this.url = "";
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.workerConfig = {};
    this.materials = [];
  }
  setLibraryPath(path) {
    this.libraryPath = path;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    this.url = url;
    loader.load(url, (buffer2) => {
      if (_taskCache3.has(buffer2)) {
        const cachedTask = _taskCache3.get(buffer2);
        return cachedTask.promise.then(onLoad).catch(onError);
      }
      this.decodeObjects(buffer2, url).then(onLoad).catch(onError);
    }, onProgress, onError);
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((worker) => worker._taskLoad));
  }
  decodeObjects(buffer2, url) {
    let worker;
    let taskID;
    const taskCost = buffer2.byteLength;
    const objectPending = this._getWorker(taskCost).then((_worker) => {
      worker = _worker;
      taskID = this.workerNextTaskID++;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = {
          resolve,
          reject
        };
        worker.postMessage({
          type: "decode",
          id: taskID,
          buffer: buffer2
        }, [buffer2]);
      });
    }).then((message) => this._createGeometry(message.data));
    objectPending.catch(() => true).then(() => {
      if (worker && taskID) {
        this._releaseTask(worker, taskID);
      }
    });
    _taskCache3.set(buffer2, {
      url,
      promise: objectPending
    });
    return objectPending;
  }
  parse(data, onLoad, onError) {
    this.decodeObjects(data, "").then(onLoad).catch(onError);
  }
  _compareMaterials(material) {
    const mat = {};
    mat.name = material.name;
    mat.color = {};
    mat.color.r = material.color.r;
    mat.color.g = material.color.g;
    mat.color.b = material.color.b;
    mat.type = material.type;
    for (let i2 = 0; i2 < this.materials.length; i2++) {
      const m = this.materials[i2];
      const _mat = {};
      _mat.name = m.name;
      _mat.color = {};
      _mat.color.r = m.color.r;
      _mat.color.g = m.color.g;
      _mat.color.b = m.color.b;
      _mat.type = m.type;
      if (JSON.stringify(mat) === JSON.stringify(_mat)) {
        return m;
      }
    }
    this.materials.push(material);
    return material;
  }
  _createMaterial(material) {
    if (material === void 0) {
      return new MeshStandardMaterial({
        color: new Color(1, 1, 1),
        metalness: 0.8,
        name: "default",
        side: 2
      });
    }
    const _diffuseColor = material.diffuseColor;
    const diffusecolor = new Color(_diffuseColor.r / 255, _diffuseColor.g / 255, _diffuseColor.b / 255);
    if (_diffuseColor.r === 0 && _diffuseColor.g === 0 && _diffuseColor.b === 0) {
      diffusecolor.r = 1;
      diffusecolor.g = 1;
      diffusecolor.b = 1;
    }
    const mat = new MeshStandardMaterial({
      color: diffusecolor,
      name: material.name,
      side: 2,
      transparent: material.transparency > 0 ? true : false,
      opacity: 1 - material.transparency
    });
    const textureLoader = new TextureLoader();
    for (let i2 = 0; i2 < material.textures.length; i2++) {
      const texture2 = material.textures[i2];
      if (texture2.image !== null) {
        const map = textureLoader.load(texture2.image);
        switch (texture2.type) {
          case "Diffuse":
            mat.map = map;
            break;
          case "Bump":
            mat.bumpMap = map;
            break;
          case "Transparency":
            mat.alphaMap = map;
            mat.transparent = true;
            break;
          case "Emap":
            mat.envMap = map;
            break;
        }
      }
    }
    return mat;
  }
  _createGeometry(data) {
    const object = new Object3D();
    const instanceDefinitionObjects = [];
    const instanceDefinitions = [];
    const instanceReferences = [];
    object.userData["layers"] = data.layers;
    object.userData["groups"] = data.groups;
    object.userData["settings"] = data.settings;
    object.userData["objectType"] = "File3dm";
    object.userData["materials"] = null;
    object.name = this.url;
    let objects = data.objects;
    const materials = data.materials;
    for (let i2 = 0; i2 < objects.length; i2++) {
      const obj = objects[i2];
      const attributes = obj.attributes;
      switch (obj.objectType) {
        case "InstanceDefinition":
          instanceDefinitions.push(obj);
          break;
        case "InstanceReference":
          instanceReferences.push(obj);
          break;
        default:
          let _object;
          if (attributes.materialIndex >= 0) {
            const rMaterial = materials[attributes.materialIndex];
            let material = this._createMaterial(rMaterial);
            material = this._compareMaterials(material);
            _object = this._createObject(obj, material);
          } else {
            const material = this._createMaterial();
            _object = this._createObject(obj, material);
          }
          if (_object === void 0) {
            continue;
          }
          const layer = data.layers[attributes.layerIndex];
          _object.visible = layer ? data.layers[attributes.layerIndex].visible : true;
          if (attributes.isInstanceDefinitionObject) {
            instanceDefinitionObjects.push(_object);
          } else {
            object.add(_object);
          }
          break;
      }
    }
    for (let i2 = 0; i2 < instanceDefinitions.length; i2++) {
      const iDef = instanceDefinitions[i2];
      objects = [];
      for (let j2 = 0; j2 < iDef.attributes.objectIds.length; j2++) {
        const objId = iDef.attributes.objectIds[j2];
        for (let p = 0; p < instanceDefinitionObjects.length; p++) {
          const idoId = instanceDefinitionObjects[p].userData.attributes.id;
          if (objId === idoId) {
            objects.push(instanceDefinitionObjects[p]);
          }
        }
      }
      for (let j2 = 0; j2 < instanceReferences.length; j2++) {
        const iRef = instanceReferences[j2];
        if (iRef.geometry.parentIdefId === iDef.attributes.id) {
          const iRefObject = new Object3D();
          const xf = iRef.geometry.xform.array;
          const matrix3 = new Matrix4();
          matrix3.set(xf[0], xf[1], xf[2], xf[3], xf[4], xf[5], xf[6], xf[7], xf[8], xf[9], xf[10], xf[11], xf[12], xf[13], xf[14], xf[15]);
          iRefObject.applyMatrix4(matrix3);
          for (let p = 0; p < objects.length; p++) {
            iRefObject.add(objects[p].clone(true));
          }
          object.add(iRefObject);
        }
      }
    }
    object.userData["materials"] = this.materials;
    return object;
  }
  _createObject(obj, mat) {
    const loader = new BufferGeometryLoader();
    const attributes = obj.attributes;
    let geometry, material, _color, color2;
    switch (obj.objectType) {
      case "Point":
      case "PointSet":
        geometry = loader.parse(obj.geometry);
        if (geometry.attributes.hasOwnProperty("color")) {
          material = new PointsMaterial({
            vertexColors: true,
            sizeAttenuation: false,
            size: 2
          });
        } else {
          _color = attributes.drawColor;
          color2 = new Color(_color.r / 255, _color.g / 255, _color.b / 255);
          material = new PointsMaterial({
            color: color2,
            sizeAttenuation: false,
            size: 2
          });
        }
        material = this._compareMaterials(material);
        const points = new Points(geometry, material);
        points.userData["attributes"] = attributes;
        points.userData["objectType"] = obj.objectType;
        if (attributes.name) {
          points.name = attributes.name;
        }
        return points;
      case "Mesh":
      case "Extrusion":
      case "SubD":
      case "Brep":
        if (obj.geometry === null)
          return;
        geometry = loader.parse(obj.geometry);
        if (geometry.attributes.hasOwnProperty("color")) {
          mat.vertexColors = true;
        }
        if (mat === null) {
          mat = this._createMaterial();
          mat = this._compareMaterials(mat);
        }
        const mesh = new Mesh(geometry, mat);
        mesh.castShadow = attributes.castsShadows;
        mesh.receiveShadow = attributes.receivesShadows;
        mesh.userData["attributes"] = attributes;
        mesh.userData["objectType"] = obj.objectType;
        if (attributes.name) {
          mesh.name = attributes.name;
        }
        return mesh;
      case "Curve":
        geometry = loader.parse(obj.geometry);
        _color = attributes.drawColor;
        color2 = new Color(_color.r / 255, _color.g / 255, _color.b / 255);
        material = new LineBasicMaterial({
          color: color2
        });
        material = this._compareMaterials(material);
        const lines = new Line(geometry, material);
        lines.userData["attributes"] = attributes;
        lines.userData["objectType"] = obj.objectType;
        if (attributes.name) {
          lines.name = attributes.name;
        }
        return lines;
      case "TextDot":
        geometry = obj.geometry;
        const ctx = document.createElement("canvas").getContext("2d");
        const font = `${geometry.fontHeight}px ${geometry.fontFace}`;
        ctx.font = font;
        const width = ctx.measureText(geometry.text).width + 10;
        const height = geometry.fontHeight + 10;
        const r = window.devicePixelRatio;
        ctx.canvas.width = width * r;
        ctx.canvas.height = height * r;
        ctx.canvas.style.width = width + "px";
        ctx.canvas.style.height = height + "px";
        ctx.setTransform(r, 0, 0, r, 0, 0);
        ctx.font = font;
        ctx.textBaseline = "middle";
        ctx.textAlign = "center";
        color2 = attributes.drawColor;
        ctx.fillStyle = `rgba(${color2.r},${color2.g},${color2.b},${color2.a})`;
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = "white";
        ctx.fillText(geometry.text, width / 2, height / 2);
        const texture2 = new CanvasTexture(ctx.canvas);
        texture2.minFilter = LinearFilter;
        texture2.wrapS = ClampToEdgeWrapping;
        texture2.wrapT = ClampToEdgeWrapping;
        material = new SpriteMaterial({
          map: texture2,
          depthTest: false
        });
        const sprite = new Sprite(material);
        sprite.position.set(geometry.point[0], geometry.point[1], geometry.point[2]);
        sprite.scale.set(width / 10, height / 10, 1);
        sprite.userData["attributes"] = attributes;
        sprite.userData["objectType"] = obj.objectType;
        if (attributes.name) {
          sprite.name = attributes.name;
        }
        return sprite;
      case "Light":
        geometry = obj.geometry;
        let light;
        if (geometry.isDirectionalLight) {
          light = new DirectionalLight();
          light.castShadow = attributes.castsShadows;
          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);
          light.target.position.set(geometry.direction[0], geometry.direction[1], geometry.direction[2]);
          light.shadow.normalBias = 0.1;
        } else if (geometry.isPointLight) {
          light = new PointLight();
          light.castShadow = attributes.castsShadows;
          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);
          light.shadow.normalBias = 0.1;
        } else if (geometry.isRectangularLight) {
          light = new RectAreaLight();
          const width2 = Math.abs(geometry.width[2]);
          const height2 = Math.abs(geometry.length[0]);
          light.position.set(geometry.location[0] - height2 / 2, geometry.location[1], geometry.location[2] - width2 / 2);
          light.height = height2;
          light.width = width2;
          light.lookAt(new Vector3(geometry.direction[0], geometry.direction[1], geometry.direction[2]));
        } else if (geometry.isSpotLight) {
          light = new SpotLight();
          light.castShadow = attributes.castsShadows;
          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);
          light.target.position.set(geometry.direction[0], geometry.direction[1], geometry.direction[2]);
          light.angle = geometry.spotAngleRadians;
          light.shadow.normalBias = 0.1;
        } else if (geometry.isLinearLight) {
          console.warn("THREE.3DMLoader:  No conversion exists for linear lights.");
          return;
        }
        if (light) {
          light.intensity = geometry.intensity;
          _color = geometry.diffuse;
          color2 = new Color(_color.r / 255, _color.g / 255, _color.b / 255);
          light.color = color2;
          light.userData["attributes"] = attributes;
          light.userData["objectType"] = obj.objectType;
        }
        return light;
    }
  }
  _initLibrary() {
    if (!this.libraryPending) {
      const jsLoader = new FileLoader2(this.manager);
      jsLoader.setPath(this.libraryPath);
      const jsContent = new Promise((resolve, reject) => {
        jsLoader.load("rhino3dm.js", resolve, void 0, reject);
      });
      const binaryLoader = new FileLoader2(this.manager);
      binaryLoader.setPath(this.libraryPath);
      binaryLoader.setResponseType("arraybuffer");
      const binaryContent = new Promise((resolve, reject) => {
        binaryLoader.load("rhino3dm.wasm", resolve, void 0, reject);
      });
      this.libraryPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        this.libraryConfig.wasmBinary = binaryContent2;
        const fn = Rhino3dmWorker.toString();
        const body = ["/* rhino3dm.js */", jsContent2, "/* worker */", fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
      });
    }
    return this.libraryPending;
  }
  _getWorker(taskCost) {
    return this._initLibrary().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskCosts = {};
        worker2._taskLoad = 0;
        worker2.postMessage({
          type: "init",
          libraryConfig: this.libraryConfig
        });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "decode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.Rhino3dmLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a2, b3) {
          return a2._taskLoad > b3._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  _releaseTask(worker, taskID) {
    worker._taskLoad -= worker._taskCosts[taskID];
    delete worker._callbacks[taskID];
    delete worker._taskCosts[taskID];
  }
  dispose() {
    for (let i2 = 0; i2 < this.workerPool.length; ++i2) {
      this.workerPool[i2].terminate();
    }
    this.workerPool.length = 0;
    return this;
  }
};
function Rhino3dmWorker() {
  let libraryPending;
  let libraryConfig;
  let rhino;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        libraryConfig = message.libraryConfig;
        const wasmBinary = libraryConfig.wasmBinary;
        let RhinoModule;
        libraryPending = new Promise(function(resolve) {
          RhinoModule = {
            wasmBinary,
            onRuntimeInitialized: resolve
          };
          rhino3dm(RhinoModule);
        }).then(() => {
          rhino = RhinoModule;
        });
        break;
      case "decode":
        const buffer2 = message.buffer;
        libraryPending.then(() => {
          const data = decodeObjects(rhino, buffer2);
          self.postMessage({
            type: "decode",
            id: message.id,
            data
          });
        });
        break;
    }
  };
  function decodeObjects(rhino2, buffer2) {
    const arr = new Uint8Array(buffer2);
    const doc = rhino2.File3dm.fromByteArray(arr);
    const objects = [];
    const materials = [];
    const layers = [];
    const views = [];
    const namedViews = [];
    const groups = [];
    const objs = doc.objects();
    const cnt = objs.count;
    for (let i2 = 0; i2 < cnt; i2++) {
      const _object = objs.get(i2);
      const object = extractObjectData(_object, doc);
      _object.delete();
      if (object) {
        objects.push(object);
      }
    }
    for (let i2 = 0; i2 < doc.instanceDefinitions().count(); i2++) {
      const idef = doc.instanceDefinitions().get(i2);
      const idefAttributes = extractProperties(idef);
      idefAttributes.objectIds = idef.getObjectIds();
      objects.push({
        geometry: null,
        attributes: idefAttributes,
        objectType: "InstanceDefinition"
      });
    }
    const textureTypes = [
      rhino2.TextureType.Diffuse,
      rhino2.TextureType.Bump,
      rhino2.TextureType.Transparency,
      rhino2.TextureType.Opacity,
      rhino2.TextureType.Emap
    ];
    const pbrTextureTypes = [rhino2.TextureType.PBR_BaseColor, rhino2.TextureType.PBR_Subsurface, rhino2.TextureType.PBR_SubsurfaceScattering, rhino2.TextureType.PBR_SubsurfaceScatteringRadius, rhino2.TextureType.PBR_Metallic, rhino2.TextureType.PBR_Specular, rhino2.TextureType.PBR_SpecularTint, rhino2.TextureType.PBR_Roughness, rhino2.TextureType.PBR_Anisotropic, rhino2.TextureType.PBR_Anisotropic_Rotation, rhino2.TextureType.PBR_Sheen, rhino2.TextureType.PBR_SheenTint, rhino2.TextureType.PBR_Clearcoat, rhino2.TextureType.PBR_ClearcoatBump, rhino2.TextureType.PBR_ClearcoatRoughness, rhino2.TextureType.PBR_OpacityIor, rhino2.TextureType.PBR_OpacityRoughness, rhino2.TextureType.PBR_Emission, rhino2.TextureType.PBR_AmbientOcclusion, rhino2.TextureType.PBR_Displacement];
    for (let i2 = 0; i2 < doc.materials().count(); i2++) {
      const _material = doc.materials().get(i2);
      const _pbrMaterial = _material.physicallyBased();
      let material = extractProperties(_material);
      const textures = [];
      for (let j2 = 0; j2 < textureTypes.length; j2++) {
        const _texture = _material.getTexture(textureTypes[j2]);
        if (_texture) {
          let textureType = textureTypes[j2].constructor.name;
          textureType = textureType.substring(12, textureType.length);
          const texture2 = {
            type: textureType
          };
          const image = doc.getEmbeddedFileAsBase64(_texture.fileName);
          if (image) {
            texture2.image = "data:image/png;base64," + image;
          } else {
            console.warn(`THREE.3DMLoader: Image for ${textureType} texture not embedded in file.`);
            texture2.image = null;
          }
          textures.push(texture2);
          _texture.delete();
        }
      }
      material.textures = textures;
      if (_pbrMaterial.supported) {
        console.log("pbr true");
        for (let j2 = 0; j2 < pbrTextureTypes.length; j2++) {
          const _texture = _material.getTexture(textureTypes[j2]);
          if (_texture) {
            const image = doc.getEmbeddedFileAsBase64(_texture.fileName);
            let textureType = textureTypes[j2].constructor.name;
            textureType = textureType.substring(12, textureType.length);
            const texture2 = {
              type: textureType,
              image: "data:image/png;base64," + image
            };
            textures.push(texture2);
            _texture.delete();
          }
        }
        const pbMaterialProperties = extractProperties(_material.physicallyBased());
        material = Object.assign(pbMaterialProperties, material);
      }
      materials.push(material);
      _material.delete();
      _pbrMaterial.delete();
    }
    for (let i2 = 0; i2 < doc.layers().count(); i2++) {
      const _layer = doc.layers().get(i2);
      const layer = extractProperties(_layer);
      layers.push(layer);
      _layer.delete();
    }
    for (let i2 = 0; i2 < doc.views().count(); i2++) {
      const _view = doc.views().get(i2);
      const view = extractProperties(_view);
      views.push(view);
      _view.delete();
    }
    for (let i2 = 0; i2 < doc.namedViews().count(); i2++) {
      const _namedView = doc.namedViews().get(i2);
      const namedView = extractProperties(_namedView);
      namedViews.push(namedView);
      _namedView.delete();
    }
    for (let i2 = 0; i2 < doc.groups().count(); i2++) {
      const _group = doc.groups().get(i2);
      const group = extractProperties(_group);
      groups.push(group);
      _group.delete();
    }
    const settings = extractProperties(doc.settings());
    doc.delete();
    return {
      objects,
      materials,
      layers,
      views,
      namedViews,
      groups,
      settings
    };
  }
  function extractObjectData(object, doc) {
    const _geometry = object.geometry();
    const _attributes = object.attributes();
    let objectType = _geometry.objectType;
    let geometry, attributes, position, data, mesh;
    switch (objectType) {
      case rhino.ObjectType.Curve:
        const pts = curveToPoints(_geometry, 100);
        position = {};
        attributes = {};
        data = {};
        position.itemSize = 3;
        position.type = "Float32Array";
        position.array = [];
        for (let j2 = 0; j2 < pts.length; j2++) {
          position.array.push(pts[j2][0]);
          position.array.push(pts[j2][1]);
          position.array.push(pts[j2][2]);
        }
        attributes.position = position;
        data.attributes = attributes;
        geometry = {
          data
        };
        break;
      case rhino.ObjectType.Point:
        const pt = _geometry.location;
        position = {};
        const color2 = {};
        attributes = {};
        data = {};
        position.itemSize = 3;
        position.type = "Float32Array";
        position.array = [pt[0], pt[1], pt[2]];
        const _color = _attributes.drawColor(doc);
        color2.itemSize = 3;
        color2.type = "Float32Array";
        color2.array = [_color.r / 255, _color.g / 255, _color.b / 255];
        attributes.position = position;
        attributes.color = color2;
        data.attributes = attributes;
        geometry = {
          data
        };
        break;
      case rhino.ObjectType.PointSet:
      case rhino.ObjectType.Mesh:
        geometry = _geometry.toThreejsJSON();
        break;
      case rhino.ObjectType.Brep:
        const faces = _geometry.faces();
        mesh = new rhino.Mesh();
        for (let faceIndex = 0; faceIndex < faces.count; faceIndex++) {
          const face = faces.get(faceIndex);
          const _mesh2 = face.getMesh(rhino.MeshType.Any);
          if (_mesh2) {
            mesh.append(_mesh2);
            _mesh2.delete();
          }
          face.delete();
        }
        if (mesh.faces().count > 0) {
          mesh.compact();
          geometry = mesh.toThreejsJSON();
          faces.delete();
        }
        mesh.delete();
        break;
      case rhino.ObjectType.Extrusion:
        mesh = _geometry.getMesh(rhino.MeshType.Any);
        if (mesh) {
          geometry = mesh.toThreejsJSON();
          mesh.delete();
        }
        break;
      case rhino.ObjectType.TextDot:
        geometry = extractProperties(_geometry);
        break;
      case rhino.ObjectType.Light:
        geometry = extractProperties(_geometry);
        break;
      case rhino.ObjectType.InstanceReference:
        geometry = extractProperties(_geometry);
        geometry.xform = extractProperties(_geometry.xform);
        geometry.xform.array = _geometry.xform.toFloatArray(true);
        break;
      case rhino.ObjectType.SubD:
        _geometry.subdivide(3);
        mesh = rhino.Mesh.createFromSubDControlNet(_geometry);
        if (mesh) {
          geometry = mesh.toThreejsJSON();
          mesh.delete();
        }
        break;
      default:
        console.warn(`THREE.3DMLoader: TODO: Implement ${objectType.constructor.name}`);
        break;
    }
    if (geometry) {
      attributes = extractProperties(_attributes);
      attributes.geometry = extractProperties(_geometry);
      if (_attributes.groupCount > 0) {
        attributes.groupIds = _attributes.getGroupList();
      }
      if (_attributes.userStringCount > 0) {
        attributes.userStrings = _attributes.getUserStrings();
      }
      if (_geometry.userStringCount > 0) {
        attributes.geometry.userStrings = _geometry.getUserStrings();
      }
      attributes.drawColor = _attributes.drawColor(doc);
      objectType = objectType.constructor.name;
      objectType = objectType.substring(11, objectType.length);
      return {
        geometry,
        attributes,
        objectType
      };
    } else {
      console.warn(`THREE.3DMLoader: ${objectType.constructor.name} has no associated mesh geometry.`);
    }
  }
  function extractProperties(object) {
    const result = {};
    for (const property in object) {
      const value = object[property];
      if (typeof value !== "function") {
        if (typeof value === "object" && value !== null && value.hasOwnProperty("constructor")) {
          result[property] = {
            name: value.constructor.name,
            value: value.value
          };
        } else {
          result[property] = value;
        }
      }
    }
    return result;
  }
  function curveToPoints(curve, pointLimit) {
    let pointCount = pointLimit;
    let rc = [];
    const ts = [];
    if (curve instanceof rhino.LineCurve) {
      return [curve.pointAtStart, curve.pointAtEnd];
    }
    if (curve instanceof rhino.PolylineCurve) {
      pointCount = curve.pointCount;
      for (let i2 = 0; i2 < pointCount; i2++) {
        rc.push(curve.point(i2));
      }
      return rc;
    }
    if (curve instanceof rhino.PolyCurve) {
      const segmentCount = curve.segmentCount;
      for (let i2 = 0; i2 < segmentCount; i2++) {
        const segment = curve.segmentCurve(i2);
        const segmentArray = curveToPoints(segment, pointCount);
        rc = rc.concat(segmentArray);
        segment.delete();
      }
      return rc;
    }
    if (curve instanceof rhino.ArcCurve) {
      pointCount = Math.floor(curve.angleDegrees / 5);
      pointCount = pointCount < 2 ? 2 : pointCount;
    }
    if (curve instanceof rhino.NurbsCurve && curve.degree === 1) {
      const pLine = curve.tryGetPolyline();
      for (let i2 = 0; i2 < pLine.count; i2++) {
        rc.push(pLine.get(i2));
      }
      pLine.delete();
      return rc;
    }
    const domain = curve.domain;
    const divisions = pointCount - 1;
    for (let j2 = 0; j2 < pointCount; j2++) {
      const t2 = domain[0] + j2 / divisions * (domain[1] - domain[0]);
      if (t2 === domain[0] || t2 === domain[1]) {
        ts.push(t2);
        continue;
      }
      const tan2 = curve.tangentAt(t2);
      const prevTan = curve.tangentAt(ts.slice(-1)[0]);
      const tS = tan2[0] * tan2[0] + tan2[1] * tan2[1] + tan2[2] * tan2[2];
      const ptS = prevTan[0] * prevTan[0] + prevTan[1] * prevTan[1] + prevTan[2] * prevTan[2];
      const denominator = Math.sqrt(tS * ptS);
      let angle;
      if (denominator === 0) {
        angle = Math.PI / 2;
      } else {
        const theta = (tan2.x * prevTan.x + tan2.y * prevTan.y + tan2.z * prevTan.z) / denominator;
        angle = Math.acos(Math.max(-1, Math.min(1, theta)));
      }
      if (angle < 0.1)
        continue;
      ts.push(t2);
    }
    rc = ts.map((t2) => curve.pointAt(t2));
    return rc;
  }
}

// node_modules/three-stdlib/loaders/OBJLoader.js
var _object_pattern = /^[og]\s*(.+)?/;
var _material_library_pattern = /^mtllib /;
var _material_use_pattern = /^usemtl /;
var _map_use_pattern = /^usemap /;
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _ab = new Vector3();
var _cb = new Vector3();
function ParserState() {
  const state = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: function(name, fromDeclaration) {
      if (this.object && this.object.fromDeclaration === false) {
        this.object.name = name;
        this.object.fromDeclaration = fromDeclaration !== false;
        return;
      }
      const previousMaterial = this.object && typeof this.object.currentMaterial === "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
      this.object = {
        name: name || "",
        fromDeclaration: fromDeclaration !== false,
        geometry: {
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          hasUVIndices: false
        },
        materials: [],
        smooth: true,
        startMaterial: function(name2, libraries) {
          const previous = this._finalize(false);
          if (previous && (previous.inherited || previous.groupCount <= 0)) {
            this.materials.splice(previous.index, 1);
          }
          const material = {
            index: this.materials.length,
            name: name2 || "",
            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
            smooth: previous !== void 0 ? previous.smooth : this.smooth,
            groupStart: previous !== void 0 ? previous.groupEnd : 0,
            groupEnd: -1,
            groupCount: -1,
            inherited: false,
            clone: function(index) {
              const cloned = {
                index: typeof index === "number" ? index : this.index,
                name: this.name,
                mtllib: this.mtllib,
                smooth: this.smooth,
                groupStart: 0,
                groupEnd: -1,
                groupCount: -1,
                inherited: false
              };
              cloned.clone = this.clone.bind(cloned);
              return cloned;
            }
          };
          this.materials.push(material);
          return material;
        },
        currentMaterial: function() {
          if (this.materials.length > 0) {
            return this.materials[this.materials.length - 1];
          }
          return void 0;
        },
        _finalize: function(end) {
          const lastMultiMaterial = this.currentMaterial();
          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
            lastMultiMaterial.inherited = false;
          }
          if (end && this.materials.length > 1) {
            for (let mi = this.materials.length - 1; mi >= 0; mi--) {
              if (this.materials[mi].groupCount <= 0) {
                this.materials.splice(mi, 1);
              }
            }
          }
          if (end && this.materials.length === 0) {
            this.materials.push({
              name: "",
              smooth: this.smooth
            });
          }
          return lastMultiMaterial;
        }
      };
      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
        const declared = previousMaterial.clone(0);
        declared.inherited = true;
        this.object.materials.push(declared);
      }
      this.objects.push(this.object);
    },
    finalize: function() {
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
    },
    parseVertexIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseNormalIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseUVIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 2) * 2;
    },
    addVertex: function(a2, b3, c) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a2 + 0], src[a2 + 1], src[a2 + 2]);
      dst.push(src[b3 + 0], src[b3 + 1], src[b3 + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addVertexPoint: function(a2) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a2 + 0], src[a2 + 1], src[a2 + 2]);
    },
    addVertexLine: function(a2) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a2 + 0], src[a2 + 1], src[a2 + 2]);
    },
    addNormal: function(a2, b3, c) {
      const src = this.normals;
      const dst = this.object.geometry.normals;
      dst.push(src[a2 + 0], src[a2 + 1], src[a2 + 2]);
      dst.push(src[b3 + 0], src[b3 + 1], src[b3 + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addFaceNormal: function(a2, b3, c) {
      const src = this.vertices;
      const dst = this.object.geometry.normals;
      _vA.fromArray(src, a2);
      _vB.fromArray(src, b3);
      _vC.fromArray(src, c);
      _cb.subVectors(_vC, _vB);
      _ab.subVectors(_vA, _vB);
      _cb.cross(_ab);
      _cb.normalize();
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
    },
    addColor: function(a2, b3, c) {
      const src = this.colors;
      const dst = this.object.geometry.colors;
      if (src[a2] !== void 0)
        dst.push(src[a2 + 0], src[a2 + 1], src[a2 + 2]);
      if (src[b3] !== void 0)
        dst.push(src[b3 + 0], src[b3 + 1], src[b3 + 2]);
      if (src[c] !== void 0)
        dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addUV: function(a2, b3, c) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a2 + 0], src[a2 + 1]);
      dst.push(src[b3 + 0], src[b3 + 1]);
      dst.push(src[c + 0], src[c + 1]);
    },
    addDefaultUV: function() {
      const dst = this.object.geometry.uvs;
      dst.push(0, 0);
      dst.push(0, 0);
      dst.push(0, 0);
    },
    addUVLine: function(a2) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a2 + 0], src[a2 + 1]);
    },
    addFace: function(a2, b3, c, ua, ub, uc, na, nb, nc) {
      const vLen = this.vertices.length;
      let ia = this.parseVertexIndex(a2, vLen);
      let ib = this.parseVertexIndex(b3, vLen);
      let ic = this.parseVertexIndex(c, vLen);
      this.addVertex(ia, ib, ic);
      this.addColor(ia, ib, ic);
      if (na !== void 0 && na !== "") {
        const nLen = this.normals.length;
        ia = this.parseNormalIndex(na, nLen);
        ib = this.parseNormalIndex(nb, nLen);
        ic = this.parseNormalIndex(nc, nLen);
        this.addNormal(ia, ib, ic);
      } else {
        this.addFaceNormal(ia, ib, ic);
      }
      if (ua !== void 0 && ua !== "") {
        const uvLen = this.uvs.length;
        ia = this.parseUVIndex(ua, uvLen);
        ib = this.parseUVIndex(ub, uvLen);
        ic = this.parseUVIndex(uc, uvLen);
        this.addUV(ia, ib, ic);
        this.object.geometry.hasUVIndices = true;
      } else {
        this.addDefaultUV();
      }
    },
    addPointGeometry: function(vertices) {
      this.object.geometry.type = "Points";
      const vLen = this.vertices.length;
      for (let vi = 0, l = vertices.length; vi < l; vi++) {
        const index = this.parseVertexIndex(vertices[vi], vLen);
        this.addVertexPoint(index);
        this.addColor(index);
      }
    },
    addLineGeometry: function(vertices, uvs) {
      this.object.geometry.type = "Line";
      const vLen = this.vertices.length;
      const uvLen = this.uvs.length;
      for (let vi = 0, l = vertices.length; vi < l; vi++) {
        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
      }
      for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {
        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
      }
    }
  };
  state.startObject("", false);
  return state;
}
var OBJLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.materials = null;
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope2.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  setMaterials(materials) {
    this.materials = materials;
    return this;
  }
  parse(text) {
    const state = new ParserState();
    if (text.indexOf("\r\n") !== -1) {
      text = text.replace(/\r\n/g, "\n");
    }
    if (text.indexOf("\\\n") !== -1) {
      text = text.replace(/\\\n/g, "");
    }
    const lines = text.split("\n");
    let line2 = "", lineFirstChar = "";
    let lineLength = 0;
    let result = [];
    const trimLeft = typeof "".trimLeft === "function";
    for (let i2 = 0, l = lines.length; i2 < l; i2++) {
      line2 = lines[i2];
      line2 = trimLeft ? line2.trimLeft() : line2.trim();
      lineLength = line2.length;
      if (lineLength === 0)
        continue;
      lineFirstChar = line2.charAt(0);
      if (lineFirstChar === "#")
        continue;
      if (lineFirstChar === "v") {
        const data = line2.split(/\s+/);
        switch (data[0]) {
          case "v":
            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
            if (data.length >= 7) {
              state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
            } else {
              state.colors.push(void 0, void 0, void 0);
            }
            break;
          case "vn":
            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
            break;
          case "vt":
            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
            break;
        }
      } else if (lineFirstChar === "f") {
        const lineData = line2.substr(1).trim();
        const vertexData = lineData.split(/\s+/);
        const faceVertices = [];
        for (let j2 = 0, jl2 = vertexData.length; j2 < jl2; j2++) {
          const vertex = vertexData[j2];
          if (vertex.length > 0) {
            const vertexParts = vertex.split("/");
            faceVertices.push(vertexParts);
          }
        }
        const v12 = faceVertices[0];
        for (let j2 = 1, jl2 = faceVertices.length - 1; j2 < jl2; j2++) {
          const v2 = faceVertices[j2];
          const v3 = faceVertices[j2 + 1];
          state.addFace(v12[0], v2[0], v3[0], v12[1], v2[1], v3[1], v12[2], v2[2], v3[2]);
        }
      } else if (lineFirstChar === "l") {
        const lineParts = line2.substring(1).trim().split(" ");
        let lineVertices = [];
        const lineUVs = [];
        if (line2.indexOf("/") === -1) {
          lineVertices = lineParts;
        } else {
          for (let li = 0, llen = lineParts.length; li < llen; li++) {
            const parts = lineParts[li].split("/");
            if (parts[0] !== "")
              lineVertices.push(parts[0]);
            if (parts[1] !== "")
              lineUVs.push(parts[1]);
          }
        }
        state.addLineGeometry(lineVertices, lineUVs);
      } else if (lineFirstChar === "p") {
        const lineData = line2.substr(1).trim();
        const pointData = lineData.split(" ");
        state.addPointGeometry(pointData);
      } else if ((result = _object_pattern.exec(line2)) !== null) {
        const name = (" " + result[0].substr(1).trim()).substr(1);
        state.startObject(name);
      } else if (_material_use_pattern.test(line2)) {
        state.object.startMaterial(line2.substring(7).trim(), state.materialLibraries);
      } else if (_material_library_pattern.test(line2)) {
        state.materialLibraries.push(line2.substring(7).trim());
      } else if (_map_use_pattern.test(line2)) {
        console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
      } else if (lineFirstChar === "s") {
        result = line2.split(" ");
        if (result.length > 1) {
          const value = result[1].trim().toLowerCase();
          state.object.smooth = value !== "0" && value !== "off";
        } else {
          state.object.smooth = true;
        }
        const material = state.object.currentMaterial();
        if (material)
          material.smooth = state.object.smooth;
      } else {
        if (line2 === "\0")
          continue;
        console.warn('THREE.OBJLoader: Unexpected line: "' + line2 + '"');
      }
    }
    state.finalize();
    const container = new Group();
    container.materialLibraries = [].concat(state.materialLibraries);
    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);
    if (hasPrimitives === true) {
      for (let i2 = 0, l = state.objects.length; i2 < l; i2++) {
        const object = state.objects[i2];
        const geometry = object.geometry;
        const materials = object.materials;
        const isLine = geometry.type === "Line";
        const isPoints = geometry.type === "Points";
        let hasVertexColors = false;
        if (geometry.vertices.length === 0)
          continue;
        const buffergeometry = new BufferGeometry();
        buffergeometry.setAttribute("position", new Float32BufferAttribute(geometry.vertices, 3));
        if (geometry.normals.length > 0) {
          buffergeometry.setAttribute("normal", new Float32BufferAttribute(geometry.normals, 3));
        }
        if (geometry.colors.length > 0) {
          hasVertexColors = true;
          buffergeometry.setAttribute("color", new Float32BufferAttribute(geometry.colors, 3));
        }
        if (geometry.hasUVIndices === true) {
          buffergeometry.setAttribute("uv", new Float32BufferAttribute(geometry.uvs, 2));
        }
        const createdMaterials = [];
        for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
          const sourceMaterial = materials[mi];
          const materialHash = sourceMaterial.name + "_" + sourceMaterial.smooth + "_" + hasVertexColors;
          let material = state.materials[materialHash];
          if (this.materials !== null) {
            material = this.materials.create(sourceMaterial.name);
            if (isLine && material && !(material instanceof LineBasicMaterial)) {
              const materialLine = new LineBasicMaterial();
              Material.prototype.copy.call(materialLine, material);
              materialLine.color.copy(material.color);
              material = materialLine;
            } else if (isPoints && material && !(material instanceof PointsMaterial)) {
              const materialPoints = new PointsMaterial({
                size: 10,
                sizeAttenuation: false
              });
              Material.prototype.copy.call(materialPoints, material);
              materialPoints.color.copy(material.color);
              materialPoints.map = material.map;
              material = materialPoints;
            }
          }
          if (material === void 0) {
            if (isLine) {
              material = new LineBasicMaterial();
            } else if (isPoints) {
              material = new PointsMaterial({
                size: 1,
                sizeAttenuation: false
              });
            } else {
              material = new MeshPhongMaterial();
            }
            material.name = sourceMaterial.name;
            material.flatShading = sourceMaterial.smooth ? false : true;
            material.vertexColors = hasVertexColors;
            state.materials[materialHash] = material;
          }
          createdMaterials.push(material);
        }
        let mesh;
        if (createdMaterials.length > 1) {
          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
            const sourceMaterial = materials[mi];
            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
          }
          if (isLine) {
            mesh = new LineSegments(buffergeometry, createdMaterials);
          } else if (isPoints) {
            mesh = new Points(buffergeometry, createdMaterials);
          } else {
            mesh = new Mesh(buffergeometry, createdMaterials);
          }
        } else {
          if (isLine) {
            mesh = new LineSegments(buffergeometry, createdMaterials[0]);
          } else if (isPoints) {
            mesh = new Points(buffergeometry, createdMaterials[0]);
          } else {
            mesh = new Mesh(buffergeometry, createdMaterials[0]);
          }
        }
        mesh.name = object.name;
        container.add(mesh);
      }
    } else {
      if (state.vertices.length > 0) {
        const material = new PointsMaterial({
          size: 1,
          sizeAttenuation: false
        });
        const buffergeometry = new BufferGeometry();
        buffergeometry.setAttribute("position", new Float32BufferAttribute(state.vertices, 3));
        if (state.colors.length > 0 && state.colors[0] !== void 0) {
          buffergeometry.setAttribute("color", new Float32BufferAttribute(state.colors, 3));
          material.vertexColors = true;
        }
        const points = new Points(buffergeometry, material);
        container.add(points);
      }
    }
    return container;
  }
};

// node_modules/three-stdlib/loaders/AMFLoader.js
var AMFLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope2.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(data) {
    function loadDocument(data2) {
      let view = new DataView(data2);
      const magic = String.fromCharCode(view.getUint8(0), view.getUint8(1));
      if (magic === "PK") {
        let zip = null;
        let file = null;
        console.log("THREE.AMFLoader: Loading Zip");
        try {
          zip = unzipSync(new Uint8Array(data2));
        } catch (e) {
          if (e instanceof ReferenceError) {
            console.log("THREE.AMFLoader: fflate missing and file is compressed.");
            return null;
          }
        }
        for (file in zip) {
          if (file.toLowerCase().substr(-4) === ".amf") {
            break;
          }
        }
        console.log("THREE.AMFLoader: Trying to load file asset: " + file);
        view = new DataView(zip[file].buffer);
      }
      const fileText = LoaderUtils.decodeText(view);
      const xmlData2 = new DOMParser().parseFromString(fileText, "application/xml");
      if (xmlData2.documentElement.nodeName.toLowerCase() !== "amf") {
        console.log("THREE.AMFLoader: Error loading AMF - no AMF document found.");
        return null;
      }
      return xmlData2;
    }
    function loadDocumentScale(node) {
      let scale = 1;
      let unit = "millimeter";
      if (node.documentElement.attributes.unit !== void 0) {
        unit = node.documentElement.attributes.unit.value.toLowerCase();
      }
      const scaleUnits = {
        millimeter: 1,
        inch: 25.4,
        feet: 304.8,
        meter: 1e3,
        micron: 1e-3
      };
      if (scaleUnits[unit] !== void 0) {
        scale = scaleUnits[unit];
      }
      console.log("THREE.AMFLoader: Unit scale: " + scale);
      return scale;
    }
    function loadMaterials(node) {
      let matName = "AMF Material";
      const matId = node.attributes.id.textContent;
      let color2 = {
        r: 1,
        g: 1,
        b: 1,
        a: 1
      };
      let loadedMaterial = null;
      for (let i3 = 0; i3 < node.childNodes.length; i3++) {
        const matChildEl = node.childNodes[i3];
        if (matChildEl.nodeName === "metadata" && matChildEl.attributes.type !== void 0) {
          if (matChildEl.attributes.type.value === "name") {
            matName = matChildEl.textContent;
          }
        } else if (matChildEl.nodeName === "color") {
          color2 = loadColor(matChildEl);
        }
      }
      loadedMaterial = new MeshPhongMaterial({
        flatShading: true,
        color: new Color(color2.r, color2.g, color2.b),
        name: matName
      });
      if (color2.a !== 1) {
        loadedMaterial.transparent = true;
        loadedMaterial.opacity = color2.a;
      }
      return {
        id: matId,
        material: loadedMaterial
      };
    }
    function loadColor(node) {
      const color2 = {
        r: 1,
        g: 1,
        b: 1,
        a: 1
      };
      for (let i3 = 0; i3 < node.childNodes.length; i3++) {
        const matColor = node.childNodes[i3];
        if (matColor.nodeName === "r") {
          color2.r = matColor.textContent;
        } else if (matColor.nodeName === "g") {
          color2.g = matColor.textContent;
        } else if (matColor.nodeName === "b") {
          color2.b = matColor.textContent;
        } else if (matColor.nodeName === "a") {
          color2.a = matColor.textContent;
        }
      }
      return color2;
    }
    function loadMeshVolume(node) {
      const volume = {
        name: "",
        triangles: [],
        materialid: null
      };
      let currVolumeNode = node.firstElementChild;
      if (node.attributes.materialid !== void 0) {
        volume.materialId = node.attributes.materialid.nodeValue;
      }
      while (currVolumeNode) {
        if (currVolumeNode.nodeName === "metadata") {
          if (currVolumeNode.attributes.type !== void 0) {
            if (currVolumeNode.attributes.type.value === "name") {
              volume.name = currVolumeNode.textContent;
            }
          }
        } else if (currVolumeNode.nodeName === "triangle") {
          const v12 = currVolumeNode.getElementsByTagName("v1")[0].textContent;
          const v2 = currVolumeNode.getElementsByTagName("v2")[0].textContent;
          const v3 = currVolumeNode.getElementsByTagName("v3")[0].textContent;
          volume.triangles.push(v12, v2, v3);
        }
        currVolumeNode = currVolumeNode.nextElementSibling;
      }
      return volume;
    }
    function loadMeshVertices(node) {
      const vertArray = [];
      const normalArray = [];
      let currVerticesNode = node.firstElementChild;
      while (currVerticesNode) {
        if (currVerticesNode.nodeName === "vertex") {
          let vNode = currVerticesNode.firstElementChild;
          while (vNode) {
            if (vNode.nodeName === "coordinates") {
              const x = vNode.getElementsByTagName("x")[0].textContent;
              const y = vNode.getElementsByTagName("y")[0].textContent;
              const z = vNode.getElementsByTagName("z")[0].textContent;
              vertArray.push(x, y, z);
            } else if (vNode.nodeName === "normal") {
              const nx = vNode.getElementsByTagName("nx")[0].textContent;
              const ny = vNode.getElementsByTagName("ny")[0].textContent;
              const nz = vNode.getElementsByTagName("nz")[0].textContent;
              normalArray.push(nx, ny, nz);
            }
            vNode = vNode.nextElementSibling;
          }
        }
        currVerticesNode = currVerticesNode.nextElementSibling;
      }
      return {
        vertices: vertArray,
        normals: normalArray
      };
    }
    function loadObject(node) {
      const objId = node.attributes.id.textContent;
      const loadedObject = {
        name: "amfobject",
        meshes: []
      };
      let currColor = null;
      let currObjNode = node.firstElementChild;
      while (currObjNode) {
        if (currObjNode.nodeName === "metadata") {
          if (currObjNode.attributes.type !== void 0) {
            if (currObjNode.attributes.type.value === "name") {
              loadedObject.name = currObjNode.textContent;
            }
          }
        } else if (currObjNode.nodeName === "color") {
          currColor = loadColor(currObjNode);
        } else if (currObjNode.nodeName === "mesh") {
          let currMeshNode = currObjNode.firstElementChild;
          const mesh = {
            vertices: [],
            normals: [],
            volumes: [],
            color: currColor
          };
          while (currMeshNode) {
            if (currMeshNode.nodeName === "vertices") {
              const loadedVertices = loadMeshVertices(currMeshNode);
              mesh.normals = mesh.normals.concat(loadedVertices.normals);
              mesh.vertices = mesh.vertices.concat(loadedVertices.vertices);
            } else if (currMeshNode.nodeName === "volume") {
              mesh.volumes.push(loadMeshVolume(currMeshNode));
            }
            currMeshNode = currMeshNode.nextElementSibling;
          }
          loadedObject.meshes.push(mesh);
        }
        currObjNode = currObjNode.nextElementSibling;
      }
      return {
        id: objId,
        obj: loadedObject
      };
    }
    const xmlData = loadDocument(data);
    let amfName = "";
    let amfAuthor = "";
    const amfScale = loadDocumentScale(xmlData);
    const amfMaterials = {};
    const amfObjects = {};
    const childNodes = xmlData.documentElement.childNodes;
    let i2, j2;
    for (i2 = 0; i2 < childNodes.length; i2++) {
      const child = childNodes[i2];
      if (child.nodeName === "metadata") {
        if (child.attributes.type !== void 0) {
          if (child.attributes.type.value === "name") {
            amfName = child.textContent;
          } else if (child.attributes.type.value === "author") {
            amfAuthor = child.textContent;
          }
        }
      } else if (child.nodeName === "material") {
        const loadedMaterial = loadMaterials(child);
        amfMaterials[loadedMaterial.id] = loadedMaterial.material;
      } else if (child.nodeName === "object") {
        const loadedObject = loadObject(child);
        amfObjects[loadedObject.id] = loadedObject.obj;
      }
    }
    const sceneObject = new Group();
    const defaultMaterial = new MeshPhongMaterial({
      color: 11184895,
      flatShading: true
    });
    sceneObject.name = amfName;
    sceneObject.userData.author = amfAuthor;
    sceneObject.userData.loader = "AMF";
    for (const id in amfObjects) {
      const part = amfObjects[id];
      const meshes = part.meshes;
      const newObject = new Group();
      newObject.name = part.name || "";
      for (i2 = 0; i2 < meshes.length; i2++) {
        let objDefaultMaterial = defaultMaterial;
        const mesh = meshes[i2];
        const vertices = new Float32BufferAttribute(mesh.vertices, 3);
        let normals = null;
        if (mesh.normals.length) {
          normals = new Float32BufferAttribute(mesh.normals, 3);
        }
        if (mesh.color) {
          const color2 = mesh.color;
          objDefaultMaterial = defaultMaterial.clone();
          objDefaultMaterial.color = new Color(color2.r, color2.g, color2.b);
          if (color2.a !== 1) {
            objDefaultMaterial.transparent = true;
            objDefaultMaterial.opacity = color2.a;
          }
        }
        const volumes = mesh.volumes;
        for (j2 = 0; j2 < volumes.length; j2++) {
          const volume = volumes[j2];
          const newGeometry = new BufferGeometry();
          let material = objDefaultMaterial;
          newGeometry.setIndex(volume.triangles);
          newGeometry.setAttribute("position", vertices.clone());
          if (normals) {
            newGeometry.setAttribute("normal", normals.clone());
          }
          if (amfMaterials[volume.materialId] !== void 0) {
            material = amfMaterials[volume.materialId];
          }
          newGeometry.scale(amfScale, amfScale, amfScale);
          newObject.add(new Mesh(newGeometry, material.clone()));
        }
      }
      sceneObject.add(newObject);
    }
    return sceneObject;
  }
};

// node_modules/three-stdlib/loaders/MMDLoader.js
var MMDLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.loader = new FileLoader2(this.manager);
    this.parser = null;
    this.meshBuilder = new MeshBuilder(this.manager);
    this.animationBuilder = new AnimationBuilder();
  }
  setAnimationPath(animationPath) {
    this.animationPath = animationPath;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const builder = this.meshBuilder.setCrossOrigin(this.crossOrigin);
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      resourcePath = this.path;
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    const modelExtension = this._extractExtension(url).toLowerCase();
    if (modelExtension !== "pmd" && modelExtension !== "pmx") {
      if (onError)
        onError(new Error("THREE.MMDLoader: Unknown model file extension ." + modelExtension + "."));
      return;
    }
    this[modelExtension === "pmd" ? "loadPMD" : "loadPMX"](url, function(data) {
      onLoad(builder.build(data, resourcePath, onProgress, onError));
    }, onProgress, onError);
  }
  loadAnimation(url, object, onLoad, onProgress, onError) {
    const builder = this.animationBuilder;
    this.loadVMD(url, function(vmd) {
      onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object));
    }, onProgress, onError);
  }
  loadWithAnimation(modelUrl, vmdUrl, onLoad, onProgress, onError) {
    const scope2 = this;
    this.load(modelUrl, function(mesh) {
      scope2.loadAnimation(vmdUrl, mesh, function(animation) {
        onLoad({
          mesh,
          animation
        });
      }, onProgress, onError);
    }, onProgress, onError);
  }
  loadPMD(url, onLoad, onProgress, onError) {
    const parser = this._getParser();
    this.loader.setMimeType(void 0).setPath(this.path).setResponseType("arraybuffer").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function(buffer2) {
      onLoad(parser.parsePmd(buffer2, true));
    }, onProgress, onError);
  }
  loadPMX(url, onLoad, onProgress, onError) {
    const parser = this._getParser();
    this.loader.setMimeType(void 0).setPath(this.path).setResponseType("arraybuffer").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function(buffer2) {
      onLoad(parser.parsePmx(buffer2, true));
    }, onProgress, onError);
  }
  loadVMD(url, onLoad, onProgress, onError) {
    const urls = Array.isArray(url) ? url : [url];
    const vmds = [];
    const vmdNum = urls.length;
    const parser = this._getParser();
    this.loader.setMimeType(void 0).setPath(this.animationPath).setResponseType("arraybuffer").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);
    for (let i2 = 0, il = urls.length; i2 < il; i2++) {
      this.loader.load(urls[i2], function(buffer2) {
        vmds.push(parser.parseVmd(buffer2, true));
        if (vmds.length === vmdNum)
          onLoad(parser.mergeVmds(vmds));
      }, onProgress, onError);
    }
  }
  loadVPD(url, isUnicode, onLoad, onProgress, onError) {
    const parser = this._getParser();
    this.loader.setMimeType(isUnicode ? void 0 : "text/plain; charset=shift_jis").setPath(this.animationPath).setResponseType("text").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function(text) {
      onLoad(parser.parseVpd(text, true));
    }, onProgress, onError);
  }
  _extractExtension(url) {
    const index = url.lastIndexOf(".");
    return index < 0 ? "" : url.slice(index + 1);
  }
  _getParser() {
    if (this.parser === null) {
      this.parser = new Parser();
    }
    return this.parser;
  }
};
var DEFAULT_TOON_TEXTURES = ["data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII="];
var MeshBuilder = class {
  constructor(manager) {
    this.crossOrigin = "anonymous";
    this.geometryBuilder = new GeometryBuilder();
    this.materialBuilder = new MaterialBuilder(manager);
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  build(data, resourcePath, onProgress, onError) {
    const geometry = this.geometryBuilder.build(data);
    const material = this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(resourcePath).build(data, geometry, onProgress, onError);
    const mesh = new SkinnedMesh(geometry, material);
    const skeleton = new Skeleton(initBones(mesh));
    mesh.bind(skeleton);
    return mesh;
  }
};
function initBones(mesh) {
  const geometry = mesh.geometry;
  const bones = [];
  if (geometry && geometry.bones !== void 0) {
    for (let i2 = 0, il = geometry.bones.length; i2 < il; i2++) {
      const gbone = geometry.bones[i2];
      const bone = new Bone();
      bones.push(bone);
      bone.name = gbone.name;
      bone.position.fromArray(gbone.pos);
      bone.quaternion.fromArray(gbone.rotq);
      if (gbone.scl !== void 0)
        bone.scale.fromArray(gbone.scl);
    }
    for (let i2 = 0, il = geometry.bones.length; i2 < il; i2++) {
      const gbone = geometry.bones[i2];
      if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== void 0) {
        bones[gbone.parent].add(bones[i2]);
      } else {
        mesh.add(bones[i2]);
      }
    }
  }
  mesh.updateMatrixWorld(true);
  return bones;
}
var GeometryBuilder = class {
  build(data) {
    const positions = [];
    const uvs = [];
    const normals = [];
    const indices = [];
    const groups = [];
    const bones = [];
    const skinIndices = [];
    const skinWeights = [];
    const morphTargets = [];
    const morphPositions = [];
    const iks = [];
    const grants = [];
    const rigidBodies = [];
    const constraints = [];
    let offset = 0;
    const boneTypeTable = {};
    for (let i2 = 0; i2 < data.metadata.vertexCount; i2++) {
      const v = data.vertices[i2];
      for (let j2 = 0, jl2 = v.position.length; j2 < jl2; j2++) {
        positions.push(v.position[j2]);
      }
      for (let j2 = 0, jl2 = v.normal.length; j2 < jl2; j2++) {
        normals.push(v.normal[j2]);
      }
      for (let j2 = 0, jl2 = v.uv.length; j2 < jl2; j2++) {
        uvs.push(v.uv[j2]);
      }
      for (let j2 = 0; j2 < 4; j2++) {
        skinIndices.push(v.skinIndices.length - 1 >= j2 ? v.skinIndices[j2] : 0);
      }
      for (let j2 = 0; j2 < 4; j2++) {
        skinWeights.push(v.skinWeights.length - 1 >= j2 ? v.skinWeights[j2] : 0);
      }
    }
    for (let i2 = 0; i2 < data.metadata.faceCount; i2++) {
      const face = data.faces[i2];
      for (let j2 = 0, jl2 = face.indices.length; j2 < jl2; j2++) {
        indices.push(face.indices[j2]);
      }
    }
    for (let i2 = 0; i2 < data.metadata.materialCount; i2++) {
      const material = data.materials[i2];
      groups.push({
        offset: offset * 3,
        count: material.faceCount * 3
      });
      offset += material.faceCount;
    }
    for (let i2 = 0; i2 < data.metadata.rigidBodyCount; i2++) {
      const body = data.rigidBodies[i2];
      let value = boneTypeTable[body.boneIndex];
      value = value === void 0 ? body.type : Math.max(body.type, value);
      boneTypeTable[body.boneIndex] = value;
    }
    for (let i2 = 0; i2 < data.metadata.boneCount; i2++) {
      const boneData = data.bones[i2];
      const bone = {
        index: i2,
        transformationClass: boneData.transformationClass,
        parent: boneData.parentIndex,
        name: boneData.name,
        pos: boneData.position.slice(0, 3),
        rotq: [0, 0, 0, 1],
        scl: [1, 1, 1],
        rigidBodyType: boneTypeTable[i2] !== void 0 ? boneTypeTable[i2] : -1
      };
      if (bone.parent !== -1) {
        bone.pos[0] -= data.bones[bone.parent].position[0];
        bone.pos[1] -= data.bones[bone.parent].position[1];
        bone.pos[2] -= data.bones[bone.parent].position[2];
      }
      bones.push(bone);
    }
    if (data.metadata.format === "pmd") {
      for (let i2 = 0; i2 < data.metadata.ikCount; i2++) {
        const ik = data.iks[i2];
        const param = {
          target: ik.target,
          effector: ik.effector,
          iteration: ik.iteration,
          maxAngle: ik.maxAngle * 4,
          links: []
        };
        for (let j2 = 0, jl2 = ik.links.length; j2 < jl2; j2++) {
          const link = {};
          link.index = ik.links[j2].index;
          link.enabled = true;
          if (data.bones[link.index].name.indexOf("\u3072\u3056") >= 0) {
            link.limitation = new Vector3(1, 0, 0);
          }
          param.links.push(link);
        }
        iks.push(param);
      }
    } else {
      for (let i2 = 0; i2 < data.metadata.boneCount; i2++) {
        const ik = data.bones[i2].ik;
        if (ik === void 0)
          continue;
        const param = {
          target: i2,
          effector: ik.effector,
          iteration: ik.iteration,
          maxAngle: ik.maxAngle,
          links: []
        };
        for (let j2 = 0, jl2 = ik.links.length; j2 < jl2; j2++) {
          const link = {};
          link.index = ik.links[j2].index;
          link.enabled = true;
          if (ik.links[j2].angleLimitation === 1) {
            const rotationMin = ik.links[j2].lowerLimitationAngle;
            const rotationMax = ik.links[j2].upperLimitationAngle;
            const tmp1 = -rotationMax[0];
            const tmp2 = -rotationMax[1];
            rotationMax[0] = -rotationMin[0];
            rotationMax[1] = -rotationMin[1];
            rotationMin[0] = tmp1;
            rotationMin[1] = tmp2;
            link.rotationMin = new Vector3().fromArray(rotationMin);
            link.rotationMax = new Vector3().fromArray(rotationMax);
          }
          param.links.push(link);
        }
        iks.push(param);
        bones[i2].ik = param;
      }
    }
    if (data.metadata.format === "pmx") {
      let traverse = function(entry) {
        if (entry.param) {
          grants.push(entry.param);
          bones[entry.param.index].grant = entry.param;
        }
        entry.visited = true;
        for (let i2 = 0, il = entry.children.length; i2 < il; i2++) {
          const child = entry.children[i2];
          if (!child.visited)
            traverse(child);
        }
      };
      const grantEntryMap = {};
      for (let i2 = 0; i2 < data.metadata.boneCount; i2++) {
        const boneData = data.bones[i2];
        const grant = boneData.grant;
        if (grant === void 0)
          continue;
        const param = {
          index: i2,
          parentIndex: grant.parentIndex,
          ratio: grant.ratio,
          isLocal: grant.isLocal,
          affectRotation: grant.affectRotation,
          affectPosition: grant.affectPosition,
          transformationClass: boneData.transformationClass
        };
        grantEntryMap[i2] = {
          parent: null,
          children: [],
          param,
          visited: false
        };
      }
      const rootEntry = {
        parent: null,
        children: [],
        param: null,
        visited: false
      };
      for (const boneIndex in grantEntryMap) {
        const grantEntry = grantEntryMap[boneIndex];
        const parentGrantEntry = grantEntryMap[grantEntry.parentIndex] || rootEntry;
        grantEntry.parent = parentGrantEntry;
        parentGrantEntry.children.push(grantEntry);
      }
      traverse(rootEntry);
    }
    function updateAttributes(attribute2, morph, ratio) {
      for (let i2 = 0; i2 < morph.elementCount; i2++) {
        const element2 = morph.elements[i2];
        let index;
        if (data.metadata.format === "pmd") {
          index = data.morphs[0].elements[element2.index].index;
        } else {
          index = element2.index;
        }
        attribute2.array[index * 3 + 0] += element2.position[0] * ratio;
        attribute2.array[index * 3 + 1] += element2.position[1] * ratio;
        attribute2.array[index * 3 + 2] += element2.position[2] * ratio;
      }
    }
    for (let i2 = 0; i2 < data.metadata.morphCount; i2++) {
      const morph = data.morphs[i2];
      const params = {
        name: morph.name
      };
      const attribute2 = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3);
      attribute2.name = morph.name;
      for (let j2 = 0; j2 < data.metadata.vertexCount * 3; j2++) {
        attribute2.array[j2] = positions[j2];
      }
      if (data.metadata.format === "pmd") {
        if (i2 !== 0) {
          updateAttributes(attribute2, morph, 1);
        }
      } else {
        if (morph.type === 0) {
          for (let j2 = 0; j2 < morph.elementCount; j2++) {
            const morph2 = data.morphs[morph.elements[j2].index];
            const ratio = morph.elements[j2].ratio;
            if (morph2.type === 1) {
              updateAttributes(attribute2, morph2, ratio);
            }
          }
        } else if (morph.type === 1) {
          updateAttributes(attribute2, morph, 1);
        } else if (morph.type === 2)
          ;
        else if (morph.type === 3)
          ;
        else if (morph.type === 4)
          ;
        else if (morph.type === 5)
          ;
        else if (morph.type === 6)
          ;
        else if (morph.type === 7)
          ;
        else if (morph.type === 8)
          ;
      }
      morphTargets.push(params);
      morphPositions.push(attribute2);
    }
    for (let i2 = 0; i2 < data.metadata.rigidBodyCount; i2++) {
      const rigidBody = data.rigidBodies[i2];
      const params = {};
      for (const key in rigidBody) {
        params[key] = rigidBody[key];
      }
      if (data.metadata.format === "pmx") {
        if (params.boneIndex !== -1) {
          const bone = data.bones[params.boneIndex];
          params.position[0] -= bone.position[0];
          params.position[1] -= bone.position[1];
          params.position[2] -= bone.position[2];
        }
      }
      rigidBodies.push(params);
    }
    for (let i2 = 0; i2 < data.metadata.constraintCount; i2++) {
      const constraint = data.constraints[i2];
      const params = {};
      for (const key in constraint) {
        params[key] = constraint[key];
      }
      const bodyA = rigidBodies[params.rigidBodyIndex1];
      const bodyB = rigidBodies[params.rigidBodyIndex2];
      if (bodyA.type !== 0 && bodyB.type === 2) {
        if (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {
          bodyB.type = 1;
        }
      }
      constraints.push(params);
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    geometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    geometry.setAttribute("skinIndex", new Uint16BufferAttribute(skinIndices, 4));
    geometry.setAttribute("skinWeight", new Float32BufferAttribute(skinWeights, 4));
    geometry.setIndex(indices);
    for (let i2 = 0, il = groups.length; i2 < il; i2++) {
      geometry.addGroup(groups[i2].offset, groups[i2].count, i2);
    }
    geometry.bones = bones;
    geometry.morphTargets = morphTargets;
    geometry.morphAttributes.position = morphPositions;
    geometry.morphTargetsRelative = false;
    geometry.userData.MMD = {
      bones,
      iks,
      grants,
      rigidBodies,
      constraints,
      format: data.metadata.format
    };
    geometry.computeBoundingSphere();
    return geometry;
  }
};
var MaterialBuilder = class {
  constructor(manager) {
    this.manager = manager;
    this.textureLoader = new TextureLoader(this.manager);
    this.tgaLoader = null;
    this.crossOrigin = "anonymous";
    this.resourcePath = void 0;
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  build(data, geometry) {
    const materials = [];
    const textures = {};
    this.textureLoader.setCrossOrigin(this.crossOrigin);
    for (let i2 = 0; i2 < data.metadata.materialCount; i2++) {
      const material = data.materials[i2];
      const params = {
        userData: {}
      };
      if (material.name !== void 0)
        params.name = material.name;
      params.color = new Color().fromArray(material.diffuse);
      params.opacity = material.diffuse[3];
      params.emissive = new Color().fromArray(material.ambient);
      params.transparent = params.opacity !== 1;
      params.skinning = geometry.bones.length > 0 ? true : false;
      params.morphTargets = geometry.morphTargets.length > 0 ? true : false;
      params.fog = true;
      params.blending = CustomBlending;
      params.blendSrc = SrcAlphaFactor;
      params.blendDst = OneMinusSrcAlphaFactor;
      params.blendSrcAlpha = SrcAlphaFactor;
      params.blendDstAlpha = DstAlphaFactor;
      if (data.metadata.format === "pmx" && (material.flag & 1) === 1) {
        params.side = DoubleSide;
      } else {
        params.side = params.opacity === 1 ? FrontSide : DoubleSide;
      }
      if (data.metadata.format === "pmd") {
        if (material.fileName) {
          const fileName = material.fileName;
          const fileNames = fileName.split("*");
          params.map = this._loadTexture(fileNames[0], textures);
          if (fileNames.length > 1) {
            const extension = fileNames[1].slice(-4).toLowerCase();
            params.envMap = this._loadTexture(fileNames[1], textures);
            params.combine = extension === ".sph" ? MultiplyOperation : AddOperation;
          }
        }
        const toonFileName = material.toonIndex === -1 ? "toon00.bmp" : data.toonTextures[material.toonIndex].fileName;
        params.gradientMap = this._loadTexture(toonFileName, textures, {
          isToonTexture: true,
          isDefaultToonTexture: this._isDefaultToonTexture(toonFileName)
        });
        params.userData.outlineParameters = {
          thickness: material.edgeFlag === 1 ? 3e-3 : 0,
          color: [0, 0, 0],
          alpha: 1,
          visible: material.edgeFlag === 1
        };
      } else {
        if (material.textureIndex !== -1) {
          params.map = this._loadTexture(data.textures[material.textureIndex], textures);
        }
        if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {
          params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures);
          params.combine = material.envFlag === 1 ? MultiplyOperation : AddOperation;
        }
        let toonFileName, isDefaultToon;
        if (material.toonIndex === -1 || material.toonFlag !== 0) {
          toonFileName = "toon" + ("0" + (material.toonIndex + 1)).slice(-2) + ".bmp";
          isDefaultToon = true;
        } else {
          toonFileName = data.textures[material.toonIndex];
          isDefaultToon = false;
        }
        params.gradientMap = this._loadTexture(toonFileName, textures, {
          isToonTexture: true,
          isDefaultToonTexture: isDefaultToon
        });
        params.userData.outlineParameters = {
          thickness: material.edgeSize / 300,
          color: material.edgeColor.slice(0, 3),
          alpha: material.edgeColor[3],
          visible: (material.flag & 16) !== 0 && material.edgeSize > 0
        };
      }
      if (params.map !== void 0) {
        if (!params.transparent) {
          this._checkImageTransparency(params.map, geometry, i2);
        }
        params.emissive.multiplyScalar(0.2);
      }
      materials.push(new MeshToonMaterial(params));
    }
    if (data.metadata.format === "pmx") {
      let checkAlphaMorph = function(elements, materials2) {
        for (let i2 = 0, il = elements.length; i2 < il; i2++) {
          const element2 = elements[i2];
          if (element2.index === -1)
            continue;
          const material = materials2[element2.index];
          if (material.opacity !== element2.diffuse[3]) {
            material.transparent = true;
          }
        }
      };
      for (let i2 = 0, il = data.morphs.length; i2 < il; i2++) {
        const morph = data.morphs[i2];
        const elements = morph.elements;
        if (morph.type === 0) {
          for (let j2 = 0, jl2 = elements.length; j2 < jl2; j2++) {
            const morph2 = data.morphs[elements[j2].index];
            if (morph2.type !== 8)
              continue;
            checkAlphaMorph(morph2.elements, materials);
          }
        } else if (morph.type === 8) {
          checkAlphaMorph(elements, materials);
        }
      }
    }
    return materials;
  }
  _getTGALoader() {
    if (this.tgaLoader === null) {
      if (TGALoader === void 0) {
        throw new Error("THREE.MMDLoader: Import TGALoader");
      }
      this.tgaLoader = new TGALoader(this.manager);
    }
    return this.tgaLoader;
  }
  _isDefaultToonTexture(name) {
    if (name.length !== 10)
      return false;
    return /toon(10|0[0-9])\.bmp/.test(name);
  }
  _loadTexture(filePath, textures, params, onProgress, onError) {
    params = params || {};
    const scope2 = this;
    let fullPath;
    if (params.isDefaultToonTexture === true) {
      let index;
      try {
        index = parseInt(filePath.match(/toon([0-9]{2})\.bmp$/)[1]);
      } catch (e) {
        console.warn("THREE.MMDLoader: " + filePath + " seems like a not right default texture path. Using toon00.bmp instead.");
        index = 0;
      }
      fullPath = DEFAULT_TOON_TEXTURES[index];
    } else {
      fullPath = this.resourcePath + filePath;
    }
    if (textures[fullPath] !== void 0)
      return textures[fullPath];
    let loader = this.manager.getHandler(fullPath);
    if (loader === null) {
      loader = filePath.slice(-4).toLowerCase() === ".tga" ? this._getTGALoader() : this.textureLoader;
    }
    const texture2 = loader.load(fullPath, function(t2) {
      if (params.isToonTexture === true) {
        t2.image = scope2._getRotatedImage(t2.image);
        t2.magFilter = NearestFilter;
        t2.minFilter = NearestFilter;
      }
      t2.flipY = false;
      t2.wrapS = RepeatWrapping;
      t2.wrapT = RepeatWrapping;
      for (let i2 = 0; i2 < texture2.readyCallbacks.length; i2++) {
        texture2.readyCallbacks[i2](texture2);
      }
      delete texture2.readyCallbacks;
    }, onProgress, onError);
    texture2.readyCallbacks = [];
    textures[fullPath] = texture2;
    return texture2;
  }
  _getRotatedImage(image) {
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    const width = image.width;
    const height = image.height;
    canvas.width = width;
    canvas.height = height;
    context.clearRect(0, 0, width, height);
    context.translate(width / 2, height / 2);
    context.rotate(0.5 * Math.PI);
    context.translate(-width / 2, -height / 2);
    context.drawImage(image, 0, 0);
    return context.getImageData(0, 0, width, height);
  }
  _checkImageTransparency(map, geometry, groupIndex) {
    map.readyCallbacks.push(function(texture2) {
      function createImageData(image) {
        const canvas = document.createElement("canvas");
        canvas.width = image.width;
        canvas.height = image.height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0);
        return context.getImageData(0, 0, canvas.width, canvas.height);
      }
      function detectImageTransparency(image, uvs, indices) {
        const width = image.width;
        const height = image.height;
        const data = image.data;
        const threshold = 253;
        if (data.length / (width * height) !== 4)
          return false;
        for (let i2 = 0; i2 < indices.length; i2 += 3) {
          const centerUV = {
            x: 0,
            y: 0
          };
          for (let j2 = 0; j2 < 3; j2++) {
            const index = indices[i2 * 3 + j2];
            const uv2 = {
              x: uvs[index * 2 + 0],
              y: uvs[index * 2 + 1]
            };
            if (getAlphaByUv(image, uv2) < threshold)
              return true;
            centerUV.x += uv2.x;
            centerUV.y += uv2.y;
          }
          centerUV.x /= 3;
          centerUV.y /= 3;
          if (getAlphaByUv(image, centerUV) < threshold)
            return true;
        }
        return false;
      }
      function getAlphaByUv(image, uv2) {
        const width = image.width;
        const height = image.height;
        let x = Math.round(uv2.x * width) % width;
        let y = Math.round(uv2.y * height) % height;
        if (x < 0)
          x += width;
        if (y < 0)
          y += height;
        const index = y * width + x;
        return image.data[index * 4 + 3];
      }
      const imageData = texture2.image.data !== void 0 ? texture2.image : createImageData(texture2.image);
      const group = geometry.groups[groupIndex];
      if (detectImageTransparency(imageData, geometry.attributes.uv.array, geometry.index.array.slice(group.start, group.start + group.count))) {
        map.transparent = true;
      }
    });
  }
};
var AnimationBuilder = class {
  build(vmd, mesh) {
    const tracks = this.buildSkeletalAnimation(vmd, mesh).tracks;
    const tracks2 = this.buildMorphAnimation(vmd, mesh).tracks;
    for (let i2 = 0, il = tracks2.length; i2 < il; i2++) {
      tracks.push(tracks2[i2]);
    }
    return new AnimationClip("", -1, tracks);
  }
  buildSkeletalAnimation(vmd, mesh) {
    function pushInterpolation(array, interpolation, index) {
      array.push(interpolation[index + 0] / 127);
      array.push(interpolation[index + 8] / 127);
      array.push(interpolation[index + 4] / 127);
      array.push(interpolation[index + 12] / 127);
    }
    const tracks = [];
    const motions = {};
    const bones = mesh.skeleton.bones;
    const boneNameDictionary = {};
    for (let i2 = 0, il = bones.length; i2 < il; i2++) {
      boneNameDictionary[bones[i2].name] = true;
    }
    for (let i2 = 0; i2 < vmd.metadata.motionCount; i2++) {
      const motion = vmd.motions[i2];
      const boneName = motion.boneName;
      if (boneNameDictionary[boneName] === void 0)
        continue;
      motions[boneName] = motions[boneName] || [];
      motions[boneName].push(motion);
    }
    for (const key in motions) {
      const array = motions[key];
      array.sort(function(a2, b3) {
        return a2.frameNum - b3.frameNum;
      });
      const times = [];
      const positions = [];
      const rotations = [];
      const pInterpolations = [];
      const rInterpolations = [];
      const basePosition = mesh.skeleton.getBoneByName(key).position.toArray();
      for (let i2 = 0, il = array.length; i2 < il; i2++) {
        const time = array[i2].frameNum / 30;
        const position = array[i2].position;
        const rotation = array[i2].rotation;
        const interpolation = array[i2].interpolation;
        times.push(time);
        for (let j2 = 0; j2 < 3; j2++)
          positions.push(basePosition[j2] + position[j2]);
        for (let j2 = 0; j2 < 4; j2++)
          rotations.push(rotation[j2]);
        for (let j2 = 0; j2 < 3; j2++)
          pushInterpolation(pInterpolations, interpolation, j2);
        pushInterpolation(rInterpolations, interpolation, 3);
      }
      const targetName = ".bones[" + key + "]";
      tracks.push(this._createTrack(targetName + ".position", VectorKeyframeTrack, times, positions, pInterpolations));
      tracks.push(this._createTrack(targetName + ".quaternion", QuaternionKeyframeTrack, times, rotations, rInterpolations));
    }
    return new AnimationClip("", -1, tracks);
  }
  buildMorphAnimation(vmd, mesh) {
    const tracks = [];
    const morphs = {};
    const morphTargetDictionary = mesh.morphTargetDictionary;
    for (let i2 = 0; i2 < vmd.metadata.morphCount; i2++) {
      const morph = vmd.morphs[i2];
      const morphName = morph.morphName;
      if (morphTargetDictionary[morphName] === void 0)
        continue;
      morphs[morphName] = morphs[morphName] || [];
      morphs[morphName].push(morph);
    }
    for (const key in morphs) {
      const array = morphs[key];
      array.sort(function(a2, b3) {
        return a2.frameNum - b3.frameNum;
      });
      const times = [];
      const values = [];
      for (let i2 = 0, il = array.length; i2 < il; i2++) {
        times.push(array[i2].frameNum / 30);
        values.push(array[i2].weight);
      }
      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetDictionary[key] + "]", times, values));
    }
    return new AnimationClip("", -1, tracks);
  }
  buildCameraAnimation(vmd) {
    function pushVector3(array, vec) {
      array.push(vec.x);
      array.push(vec.y);
      array.push(vec.z);
    }
    function pushQuaternion(array, q) {
      array.push(q.x);
      array.push(q.y);
      array.push(q.z);
      array.push(q.w);
    }
    function pushInterpolation(array, interpolation, index) {
      array.push(interpolation[index * 4 + 0] / 127);
      array.push(interpolation[index * 4 + 1] / 127);
      array.push(interpolation[index * 4 + 2] / 127);
      array.push(interpolation[index * 4 + 3] / 127);
    }
    const cameras = vmd.cameras === void 0 ? [] : vmd.cameras.slice();
    cameras.sort(function(a2, b3) {
      return a2.frameNum - b3.frameNum;
    });
    const times = [];
    const centers = [];
    const quaternions = [];
    const positions = [];
    const fovs = [];
    const cInterpolations = [];
    const qInterpolations = [];
    const pInterpolations = [];
    const fInterpolations = [];
    const quaternion = new Quaternion();
    const euler = new Euler();
    const position = new Vector3();
    const center = new Vector3();
    for (let i2 = 0, il = cameras.length; i2 < il; i2++) {
      const motion = cameras[i2];
      const time = motion.frameNum / 30;
      const pos = motion.position;
      const rot = motion.rotation;
      const distance2 = motion.distance;
      const fov = motion.fov;
      const interpolation = motion.interpolation;
      times.push(time);
      position.set(0, 0, -distance2);
      center.set(pos[0], pos[1], pos[2]);
      euler.set(-rot[0], -rot[1], -rot[2]);
      quaternion.setFromEuler(euler);
      position.add(center);
      position.applyQuaternion(quaternion);
      pushVector3(centers, center);
      pushQuaternion(quaternions, quaternion);
      pushVector3(positions, position);
      fovs.push(fov);
      for (let j2 = 0; j2 < 3; j2++) {
        pushInterpolation(cInterpolations, interpolation, j2);
      }
      pushInterpolation(qInterpolations, interpolation, 3);
      for (let j2 = 0; j2 < 3; j2++) {
        pushInterpolation(pInterpolations, interpolation, 4);
      }
      pushInterpolation(fInterpolations, interpolation, 5);
    }
    const tracks = [];
    tracks.push(this._createTrack("target.position", VectorKeyframeTrack, times, centers, cInterpolations));
    tracks.push(this._createTrack(".quaternion", QuaternionKeyframeTrack, times, quaternions, qInterpolations));
    tracks.push(this._createTrack(".position", VectorKeyframeTrack, times, positions, pInterpolations));
    tracks.push(this._createTrack(".fov", NumberKeyframeTrack, times, fovs, fInterpolations));
    return new AnimationClip("", -1, tracks);
  }
  _createTrack(node, typedKeyframeTrack, times, values, interpolations) {
    if (times.length > 2) {
      times = times.slice();
      values = values.slice();
      interpolations = interpolations.slice();
      const stride = values.length / times.length;
      const interpolateStride = interpolations.length / times.length;
      let index = 1;
      for (let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {
        for (let i2 = 0; i2 < stride; i2++) {
          if (values[index * stride + i2] !== values[(index - 1) * stride + i2] || values[index * stride + i2] !== values[aheadIndex * stride + i2]) {
            index++;
            break;
          }
        }
        if (aheadIndex > index) {
          times[index] = times[aheadIndex];
          for (let i2 = 0; i2 < stride; i2++) {
            values[index * stride + i2] = values[aheadIndex * stride + i2];
          }
          for (let i2 = 0; i2 < interpolateStride; i2++) {
            interpolations[index * interpolateStride + i2] = interpolations[aheadIndex * interpolateStride + i2];
          }
        }
      }
      times.length = index + 1;
      values.length = (index + 1) * stride;
      interpolations.length = (index + 1) * interpolateStride;
    }
    const track = new typedKeyframeTrack(node, times, values);
    track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {
      return new CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));
    };
    return track;
  }
};
var CubicBezierInterpolation = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this.interpolationParams = params;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const params = this.interpolationParams;
    const offset1 = i1 * stride;
    const offset0 = offset1 - stride;
    const weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0 : (t2 - t0) / (t1 - t0);
    if (stride === 4) {
      const x1 = params[i1 * 4 + 0];
      const x2 = params[i1 * 4 + 1];
      const y1 = params[i1 * 4 + 2];
      const y2 = params[i1 * 4 + 3];
      const ratio = this._calculate(x1, x2, y1, y2, weight1);
      Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);
    } else if (stride === 3) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        const x1 = params[i1 * 12 + i2 * 4 + 0];
        const x2 = params[i1 * 12 + i2 * 4 + 1];
        const y1 = params[i1 * 12 + i2 * 4 + 2];
        const y2 = params[i1 * 12 + i2 * 4 + 3];
        const ratio = this._calculate(x1, x2, y1, y2, weight1);
        result[i2] = values[offset0 + i2] * (1 - ratio) + values[offset1 + i2] * ratio;
      }
    } else {
      const x1 = params[i1 * 4 + 0];
      const x2 = params[i1 * 4 + 1];
      const y1 = params[i1 * 4 + 2];
      const y2 = params[i1 * 4 + 3];
      const ratio = this._calculate(x1, x2, y1, y2, weight1);
      result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio;
    }
    return result;
  }
  _calculate(x1, x2, y1, y2, x) {
    let c = 0.5;
    let t2 = c;
    let s = 1 - t2;
    const loop = 15;
    const eps = 1e-5;
    const math = Math;
    let sst3, stt3, ttt;
    for (let i2 = 0; i2 < loop; i2++) {
      sst3 = 3 * s * s * t2;
      stt3 = 3 * s * t2 * t2;
      ttt = t2 * t2 * t2;
      const ft = sst3 * x1 + stt3 * x2 + ttt - x;
      if (math.abs(ft) < eps)
        break;
      c /= 2;
      t2 += ft < 0 ? c : -c;
      s = 1 - t2;
    }
    return sst3 * y1 + stt3 * y2 + ttt;
  }
};

// node_modules/three-stdlib/loaders/KTXLoader.js
var KTXLoader = class extends CompressedTextureLoader {
  constructor(manager) {
    super(manager);
  }
  parse(buffer2, loadMipmaps) {
    const ktx = new KhronosTextureContainer(buffer2, 1);
    return {
      mipmaps: ktx.mipmaps(loadMipmaps),
      width: ktx.pixelWidth,
      height: ktx.pixelHeight,
      format: ktx.glInternalFormat,
      isCubemap: ktx.numberOfFaces === 6,
      mipmapCount: ktx.numberOfMipmapLevels
    };
  }
};
var HEADER_LEN = 12 + 13 * 4;
var COMPRESSED_2D = 0;
var KhronosTextureContainer = class {
  constructor(arrayBuffer, facesExpected) {
    this.arrayBuffer = arrayBuffer;
    const identifier = new Uint8Array(this.arrayBuffer, 0, 12);
    if (identifier[0] !== 171 || identifier[1] !== 75 || identifier[2] !== 84 || identifier[3] !== 88 || identifier[4] !== 32 || identifier[5] !== 49 || identifier[6] !== 49 || identifier[7] !== 187 || identifier[8] !== 13 || identifier[9] !== 10 || identifier[10] !== 26 || identifier[11] !== 10) {
      console.error("texture missing KTX identifier");
      return;
    }
    const dataSize = Uint32Array.BYTES_PER_ELEMENT;
    const headerDataView = new DataView(this.arrayBuffer, 12, 13 * dataSize);
    const endianness = headerDataView.getUint32(0, true);
    const littleEndian = endianness === 67305985;
    this.glType = headerDataView.getUint32(1 * dataSize, littleEndian);
    this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian);
    this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian);
    this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian);
    this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian);
    this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian);
    this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian);
    this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian);
    this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian);
    this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian);
    this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian);
    this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian);
    if (this.glType !== 0) {
      console.warn("only compressed formats currently supported");
      return;
    } else {
      this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);
    }
    if (this.pixelHeight === 0 || this.pixelDepth !== 0) {
      console.warn("only 2D textures currently supported");
      return;
    }
    if (this.numberOfArrayElements !== 0) {
      console.warn("texture arrays not currently supported");
      return;
    }
    if (this.numberOfFaces !== facesExpected) {
      console.warn("number of faces expected" + facesExpected + ", but found " + this.numberOfFaces);
      return;
    }
    this.loadType = COMPRESSED_2D;
  }
  mipmaps(loadMipmaps) {
    const mipmaps = [];
    let dataOffset = HEADER_LEN + this.bytesOfKeyValueData;
    let width = this.pixelWidth;
    let height = this.pixelHeight;
    const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;
    for (let level = 0; level < mipmapCount; level++) {
      const imageSize = new Int32Array(this.arrayBuffer, dataOffset, 1)[0];
      dataOffset += 4;
      for (let face = 0; face < this.numberOfFaces; face++) {
        const byteArray = new Uint8Array(this.arrayBuffer, dataOffset, imageSize);
        mipmaps.push({
          data: byteArray,
          width,
          height
        });
        dataOffset += imageSize;
        dataOffset += 3 - (imageSize + 3) % 4;
      }
      width = Math.max(1, width * 0.5);
      height = Math.max(1, height * 0.5);
    }
    return mipmaps;
  }
};

// node_modules/three-stdlib/loaders/TiltLoader.js
var TiltLoader = class extends Loader {
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer2) {
      try {
        onLoad(scope2.parse(buffer2));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(buffer2) {
    const group = new Group();
    const zip = unzipSync(new Uint8Array(buffer2.slice(16)));
    const metadata = JSON.parse(strFromU8(zip["metadata.json"]));
    const data = new DataView(zip["data.sketch"].buffer);
    const num_strokes = data.getInt32(16, true);
    const brushes = {};
    let offset = 20;
    for (let i2 = 0; i2 < num_strokes; i2++) {
      const brush_index = data.getInt32(offset, true);
      const brush_color = [data.getFloat32(offset + 4, true), data.getFloat32(offset + 8, true), data.getFloat32(offset + 12, true), data.getFloat32(offset + 16, true)];
      const brush_size = data.getFloat32(offset + 20, true);
      const stroke_mask = data.getUint32(offset + 24, true);
      const controlpoint_mask = data.getUint32(offset + 28, true);
      let offset_stroke_mask = 0;
      let offset_controlpoint_mask = 0;
      for (let j2 = 0; j2 < 4; j2++) {
        const byte = 1 << j2;
        if ((stroke_mask & byte) > 0)
          offset_stroke_mask += 4;
        if ((controlpoint_mask & byte) > 0)
          offset_controlpoint_mask += 4;
      }
      offset = offset + 28 + offset_stroke_mask + 4;
      const num_control_points = data.getInt32(offset, true);
      const positions = new Float32Array(num_control_points * 3);
      const quaternions = new Float32Array(num_control_points * 4);
      offset = offset + 4;
      for (let j2 = 0, k = 0; j2 < positions.length; j2 += 3, k += 4) {
        positions[j2 + 0] = data.getFloat32(offset + 0, true);
        positions[j2 + 1] = data.getFloat32(offset + 4, true);
        positions[j2 + 2] = data.getFloat32(offset + 8, true);
        quaternions[k + 0] = data.getFloat32(offset + 12, true);
        quaternions[k + 1] = data.getFloat32(offset + 16, true);
        quaternions[k + 2] = data.getFloat32(offset + 20, true);
        quaternions[k + 3] = data.getFloat32(offset + 24, true);
        offset = offset + 28 + offset_controlpoint_mask;
      }
      if (brush_index in brushes === false) {
        brushes[brush_index] = [];
      }
      brushes[brush_index].push([positions, quaternions, brush_size, brush_color]);
    }
    for (const brush_index in brushes) {
      const geometry = new StrokeGeometry(brushes[brush_index]);
      const material = getMaterial(metadata.BrushIndex[brush_index]);
      group.add(new Mesh(geometry, material));
    }
    return group;
  }
};
var StrokeGeometry = class extends BufferGeometry {
  constructor(strokes) {
    super();
    const vertices = [];
    const colors = [];
    const uvs = [];
    const position = new Vector3();
    const prevPosition = new Vector3();
    const quaternion = new Quaternion();
    const prevQuaternion = new Quaternion();
    const vector1 = new Vector3();
    const vector2 = new Vector3();
    const vector3 = new Vector3();
    const vector4 = new Vector3();
    for (const k in strokes) {
      const stroke = strokes[k];
      const positions = stroke[0];
      const quaternions = stroke[1];
      const size2 = stroke[2];
      const color2 = stroke[3];
      prevPosition.fromArray(positions, 0);
      prevQuaternion.fromArray(quaternions, 0);
      for (let i2 = 3, j2 = 4, l = positions.length; i2 < l; i2 += 3, j2 += 4) {
        position.fromArray(positions, i2);
        quaternion.fromArray(quaternions, j2);
        vector1.set(-size2, 0, 0);
        vector1.applyQuaternion(quaternion);
        vector1.add(position);
        vector2.set(size2, 0, 0);
        vector2.applyQuaternion(quaternion);
        vector2.add(position);
        vector3.set(size2, 0, 0);
        vector3.applyQuaternion(prevQuaternion);
        vector3.add(prevPosition);
        vector4.set(-size2, 0, 0);
        vector4.applyQuaternion(prevQuaternion);
        vector4.add(prevPosition);
        vertices.push(vector1.x, vector1.y, -vector1.z);
        vertices.push(vector2.x, vector2.y, -vector2.z);
        vertices.push(vector4.x, vector4.y, -vector4.z);
        vertices.push(vector2.x, vector2.y, -vector2.z);
        vertices.push(vector3.x, vector3.y, -vector3.z);
        vertices.push(vector4.x, vector4.y, -vector4.z);
        prevPosition.copy(position);
        prevQuaternion.copy(quaternion);
        colors.push(...color2);
        colors.push(...color2);
        colors.push(...color2);
        colors.push(...color2);
        colors.push(...color2);
        colors.push(...color2);
        const p1 = i2 / l;
        const p2 = (i2 - 3) / l;
        uvs.push(p1, 0);
        uvs.push(p1, 1);
        uvs.push(p2, 0);
        uvs.push(p1, 1);
        uvs.push(p2, 1);
        uvs.push(p2, 0);
      }
    }
    this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
    this.setAttribute("color", new BufferAttribute(new Float32Array(colors), 4));
    this.setAttribute("uv", new BufferAttribute(new Float32Array(uvs), 2));
  }
};
var BRUSH_LIST_ARRAY = {
  "89d104cd-d012-426b-b5b3-bbaee63ac43c": "Bubbles",
  "700f3aa8-9a7c-2384-8b8a-ea028905dd8c": "CelVinyl",
  "0f0ff7b2-a677-45eb-a7d6-0cd7206f4816": "ChromaticWave",
  "1161af82-50cf-47db-9706-0c3576d43c43": "CoarseBristles",
  "79168f10-6961-464a-8be1-57ed364c5600": "CoarseBristlesSingleSided",
  "1caa6d7d-f015-3f54-3a4b-8b5354d39f81": "Comet",
  "c8313697-2563-47fc-832e-290f4c04b901": "DiamondHull",
  "4391aaaa-df73-4396-9e33-31e4e4930b27": "Disco",
  "d1d991f2-e7a0-4cf1-b328-f57e915e6260": "DotMarker",
  "6a1cf9f9-032c-45ec-9b1d-a6680bee30f7": "Dots",
  "0d3889f3-3ede-470c-8af4-f44813306126": "DoubleTaperedFlat",
  "0d3889f3-3ede-470c-8af4-de4813306126": "DoubleTaperedMarker",
  "d0262945-853c-4481-9cbd-88586bed93cb": "DuctTape",
  "3ca16e2f-bdcd-4da2-8631-dcef342f40f1": "DuctTapeSingleSided",
  "f6e85de3-6dcc-4e7f-87fd-cee8c3d25d51": "Electricity",
  "02ffb866-7fb2-4d15-b761-1012cefb1360": "Embers",
  "cb92b597-94ca-4255-b017-0e3f42f12f9e": "Fire",
  "2d35bcf0-e4d8-452c-97b1-3311be063130": "Flat",
  "55303bc4-c749-4a72-98d9-d23e68e76e18": "FlatDeprecated",
  "280c0a7a-aad8-416c-a7d2-df63d129ca70": "FlatSingleSided",
  "cf019139-d41c-4eb0-a1d0-5cf54b0a42f3": "Highlighter",
  "6a1cf9f9-032c-45ec-9b6e-a6680bee32e9": "HyperGrid",
  "dce872c2-7b49-4684-b59b-c45387949c5c": "Hypercolor",
  "e8ef32b1-baa8-460a-9c2c-9cf8506794f5": "HypercolorSingleSided",
  "2f212815-f4d3-c1a4-681a-feeaf9c6dc37": "Icing",
  "f5c336cf-5108-4b40-ade9-c687504385ab": "Ink",
  "c0012095-3ffd-4040-8ee1-fc180d346eaa": "InkSingleSided",
  "4a76a27a-44d8-4bfe-9a8c-713749a499b0": "Leaves",
  "ea19de07-d0c0-4484-9198-18489a3c1487": "LeavesSingleSided",
  "2241cd32-8ba2-48a5-9ee7-2caef7e9ed62": "Light",
  "4391aaaa-df81-4396-9e33-31e4e4930b27": "LightWire",
  "d381e0f5-3def-4a0d-8853-31e9200bcbda": "Lofted",
  "429ed64a-4e97-4466-84d3-145a861ef684": "Marker",
  "79348357-432d-4746-8e29-0e25c112e3aa": "MatteHull",
  "b2ffef01-eaaa-4ab5-aa64-95a2c4f5dbc6": "NeonPulse",
  "f72ec0e7-a844-4e38-82e3-140c44772699": "OilPaint",
  "c515dad7-4393-4681-81ad-162ef052241b": "OilPaintSingleSided",
  "f1114e2e-eb8d-4fde-915a-6e653b54e9f5": "Paper",
  "759f1ebd-20cd-4720-8d41-234e0da63716": "PaperSingleSided",
  "e0abbc80-0f80-e854-4970-8924a0863dcc": "Petal",
  "c33714d1-b2f9-412e-bd50-1884c9d46336": "Plasma",
  "ad1ad437-76e2-450d-a23a-e17f8310b960": "Rainbow",
  "faaa4d44-fcfb-4177-96be-753ac0421ba3": "ShinyHull",
  "70d79cca-b159-4f35-990c-f02193947fe8": "Smoke",
  "d902ed8b-d0d1-476c-a8de-878a79e3a34c": "Snow",
  "accb32f5-4509-454f-93f8-1df3fd31df1b": "SoftHighlighter",
  "cf7f0059-7aeb-53a4-2b67-c83d863a9ffa": "Spikes",
  "8dc4a70c-d558-4efd-a5ed-d4e860f40dc3": "Splatter",
  "7a1c8107-50c5-4b70-9a39-421576d6617e": "SplatterSingleSided",
  "0eb4db27-3f82-408d-b5a1-19ebd7d5b711": "Stars",
  "44bb800a-fbc3-4592-8426-94ecb05ddec3": "Streamers",
  "0077f88c-d93a-42f3-b59b-b31c50cdb414": "Taffy",
  "b468c1fb-f254-41ed-8ec9-57030bc5660c": "TaperedFlat",
  "c8ccb53d-ae13-45ef-8afb-b730d81394eb": "TaperedFlatSingleSided",
  "d90c6ad8-af0f-4b54-b422-e0f92abe1b3c": "TaperedMarker",
  "1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0": "TaperedMarker_Flat",
  "75b32cf0-fdd6-4d89-a64b-e2a00b247b0f": "ThickPaint",
  "fdf0326a-c0d1-4fed-b101-9db0ff6d071f": "ThickPaintSingleSided",
  "4391385a-df73-4396-9e33-31e4e4930b27": "Toon",
  "a8fea537-da7c-4d4b-817f-24f074725d6d": "UnlitHull",
  "d229d335-c334-495a-a801-660ac8a87360": "VelvetInk",
  "10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab": "Waveform",
  "b67c0e81-ce6d-40a8-aeb0-ef036b081aa3": "WetPaint",
  "dea67637-cd1a-27e4-c9b1-52f4bbcb84e5": "WetPaintSingleSided",
  "5347acf0-a8e2-47b6-8346-30c70719d763": "WigglyGraphite",
  "e814fef1-97fd-7194-4a2f-50c2bb918be2": "WigglyGraphiteSingleSided",
  "4391385a-cf83-4396-9e33-31e4e4930b27": "Wire"
};
var common = {
  colors: {
    BloomColor: `
			vec3 BloomColor(vec3 color, float gain) {
				// Guarantee that there's at least a little bit of all 3 channels.
				// This makes fully-saturated strokes (which only have 2 non-zero
				// color channels) eventually clip to white rather than to a secondary.
				float cmin = length(color.rgb) * .05;
				color.rgb = max(color.rgb, vec3(cmin, cmin, cmin));
				// If we try to remove this pow() from .a, it brightens up
				// pressure-sensitive strokes; looks better as-is.
				color = pow(color, vec3(2.2));
				color.rgb *= 2. * exp(gain * 10.);
				return color;
			}
		`,
    LinearToSrgb: `
			vec3 LinearToSrgb(vec3 color) {
				// Approximation http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
				vec3 linearColor = color.rgb;
				vec3 S1 = sqrt(linearColor);
				vec3 S2 = sqrt(S1);
				vec3 S3 = sqrt(S2);
				color.rgb = 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * linearColor;
				return color;
			}
		`,
    hsv: `
			// uniform sampler2D lookupTex;
			vec4 lookup(vec4 textureColor) {
				return textureColor;
			}

			vec3 lookup(vec3 textureColor) {
				return textureColor;
			}

			vec3 hsv2rgb( vec3 hsv ) {
				vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );
				return hsv.z * mix( vec3(1.0), rgb, hsv.y);
			}

			vec3 rgb2hsv( vec3 rgb ) {
				vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
				vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));
				vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));

				float d = q.x - min(q.w, q.y);
				float e = 1.0e-10;

				return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
			}
		`,
    SrgbToLinear: `
			vec3 SrgbToLinear(vec3 color) {
				// Approximation http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
				vec3 sRGB = color.rgb;
				color.rgb = sRGB * (sRGB * (sRGB * 0.305306011 + 0.682171111) + 0.012522878);
				return color;
			}
		`
  }
};
var shaders = () => ({
  Light: {
    uniforms: {
      mainTex: {
        value: new TextureLoader().setPath("./textures/tiltbrush/").loader.load("Light.webp")
      },
      alphaTest: {
        value: 0.067
      },
      emission_gain: {
        value: 0.45
      },
      alpha: {
        value: 1
      }
    },
    vertexShader: `
			precision highp float;
			precision highp int;

			attribute vec2 uv;
			attribute vec4 color;
			attribute vec3 position;

			uniform mat4 modelMatrix;
			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;
			uniform mat4 viewMatrix;
			uniform mat3 normalMatrix;
			uniform vec3 cameraPosition;

			varying vec2 vUv;
			varying vec3 vColor;

			${common.colors.LinearToSrgb}
			${common.colors.hsv}

			void main() {

				vUv = uv;

				vColor = lookup(color.rgb);

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_Position = projectionMatrix * mvPosition;

			}
		`,
    fragmentShader: `
			precision highp float;
			precision highp int;

			uniform float emission_gain;

			uniform sampler2D mainTex;
			uniform float alphaTest;

			varying vec2 vUv;
			varying vec3 vColor;

			${common.colors.BloomColor}
			${common.colors.SrgbToLinear}

			void main(){
				vec4 col = texture2D(mainTex, vUv);
				vec3 color = vColor;
				color = BloomColor(color, emission_gain);
				color = color * col.rgb;
				color = color * col.a;
				color = SrgbToLinear(color);
				gl_FragColor = vec4(color, 1.0);
			}
		`,
    side: 2,
    transparent: true,
    depthFunc: 2,
    depthWrite: true,
    depthTest: false,
    blending: 5,
    blendDst: 201,
    blendDstAlpha: 201,
    blendEquation: 100,
    blendEquationAlpha: 100,
    blendSrc: 201,
    blendSrcAlpha: 201
  }
});
function getMaterial(GUID) {
  const name = BRUSH_LIST_ARRAY[GUID];
  switch (name) {
    case "Light":
      return new RawShaderMaterial(shaders().Light);
    default:
      return new MeshBasicMaterial({
        vertexColors: true,
        side: DoubleSide
      });
  }
}

// node_modules/three-stdlib/loaders/DRACOLoader.js
var _taskCache4 = /* @__PURE__ */ new WeakMap();
var DRACOLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.decoderPath = "";
    this.decoderConfig = {};
    this.decoderBinary = null;
    this.decoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    };
    this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(path) {
    this.decoderPath = path;
    return this;
  }
  setDecoderConfig(config) {
    this.decoderConfig = config;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer2) => {
      const taskConfig = {
        attributeIDs: this.defaultAttributeIDs,
        attributeTypes: this.defaultAttributeTypes,
        useUniqueIDs: false
      };
      this.decodeGeometry(buffer2, taskConfig).then(onLoad).catch(onError);
    }, onProgress, onError);
  }
  decodeDracoFile(buffer2, callback, attributeIDs, attributeTypes) {
    const taskConfig = {
      attributeIDs: attributeIDs || this.defaultAttributeIDs,
      attributeTypes: attributeTypes || this.defaultAttributeTypes,
      useUniqueIDs: !!attributeIDs
    };
    this.decodeGeometry(buffer2, taskConfig).then(callback);
  }
  decodeGeometry(buffer2, taskConfig) {
    for (const attribute2 in taskConfig.attributeTypes) {
      const type2 = taskConfig.attributeTypes[attribute2];
      if (type2.BYTES_PER_ELEMENT !== void 0) {
        taskConfig.attributeTypes[attribute2] = type2.name;
      }
    }
    const taskKey = JSON.stringify(taskConfig);
    if (_taskCache4.has(buffer2)) {
      const cachedTask = _taskCache4.get(buffer2);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer2.byteLength === 0) {
        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
      }
    }
    let worker;
    const taskID = this.workerNextTaskID++;
    const taskCost = buffer2.byteLength;
    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
      worker = _worker;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = {
          resolve,
          reject
        };
        worker.postMessage({
          type: "decode",
          id: taskID,
          taskConfig,
          buffer: buffer2
        }, [buffer2]);
      });
    }).then((message) => this._createGeometry(message.geometry));
    geometryPending.catch(() => true).then(() => {
      if (worker && taskID) {
        this._releaseTask(worker, taskID);
      }
    });
    _taskCache4.set(buffer2, {
      key: taskKey,
      promise: geometryPending
    });
    return geometryPending;
  }
  _createGeometry(geometryData) {
    const geometry = new BufferGeometry();
    if (geometryData.index) {
      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
    }
    for (let i2 = 0; i2 < geometryData.attributes.length; i2++) {
      const attribute2 = geometryData.attributes[i2];
      const name = attribute2.name;
      const array = attribute2.array;
      const itemSize = attribute2.itemSize;
      geometry.setAttribute(name, new BufferAttribute(array, itemSize));
    }
    return geometry;
  }
  _loadLibrary(url, responseType) {
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.decoderPath);
    loader.setResponseType(responseType);
    loader.setWithCredentials(this.withCredentials);
    return new Promise((resolve, reject) => {
      loader.load(url, resolve, void 0, reject);
    });
  }
  preload() {
    this._initDecoder();
    return this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
    const librariesPending = [];
    if (useJS) {
      librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
    } else {
      librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
      librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
    }
    this.decoderPending = Promise.all(librariesPending).then((libraries) => {
      const jsContent = libraries[0];
      if (!useJS) {
        this.decoderConfig.wasmBinary = libraries[1];
      }
      const fn = DRACOWorker.toString();
      const body = ["/* draco decoder */", jsContent, "", "/* worker */", fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([body]));
    });
    return this.decoderPending;
  }
  _getWorker(taskID, taskCost) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskCosts = {};
        worker2._taskLoad = 0;
        worker2.postMessage({
          type: "init",
          decoderConfig: this.decoderConfig
        });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "decode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a2, b3) {
          return a2._taskLoad > b3._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskCosts[taskID] = taskCost;
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  _releaseTask(worker, taskID) {
    worker._taskLoad -= worker._taskCosts[taskID];
    delete worker._callbacks[taskID];
    delete worker._taskCosts[taskID];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((worker) => worker._taskLoad));
  }
  dispose() {
    for (let i2 = 0; i2 < this.workerPool.length; ++i2) {
      this.workerPool[i2].terminate();
    }
    this.workerPool.length = 0;
    return this;
  }
};
function DRACOWorker() {
  let decoderConfig;
  let decoderPending;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        decoderConfig = message.decoderConfig;
        decoderPending = new Promise(function(resolve) {
          decoderConfig.onModuleLoaded = function(draco) {
            resolve({
              draco
            });
          };
          DracoDecoderModule(decoderConfig);
        });
        break;
      case "decode":
        const buffer2 = message.buffer;
        const taskConfig = message.taskConfig;
        decoderPending.then((module2) => {
          const draco = module2.draco;
          const decoder = new draco.Decoder();
          const decoderBuffer = new draco.DecoderBuffer();
          decoderBuffer.Init(new Int8Array(buffer2), buffer2.byteLength);
          try {
            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);
            const buffers = geometry.attributes.map((attr) => attr.array.buffer);
            if (geometry.index)
              buffers.push(geometry.index.array.buffer);
            self.postMessage({
              type: "decode",
              id: message.id,
              geometry
            }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({
              type: "error",
              id: message.id,
              error: error.message
            });
          } finally {
            draco.destroy(decoderBuffer);
            draco.destroy(decoder);
          }
        });
        break;
    }
  };
  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {
    const attributeIDs = taskConfig.attributeIDs;
    const attributeTypes = taskConfig.attributeTypes;
    let dracoGeometry;
    let decodingStatus;
    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);
    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);
    } else {
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    }
    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
      throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
    }
    const geometry = {
      index: null,
      attributes: []
    };
    for (const attributeName in attributeIDs) {
      const attributeType = self[attributeTypes[attributeName]];
      let attribute2;
      let attributeID;
      if (taskConfig.useUniqueIDs) {
        attributeID = attributeIDs[attributeName];
        attribute2 = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
      } else {
        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
        if (attributeID === -1)
          continue;
        attribute2 = decoder.GetAttribute(dracoGeometry, attributeID);
      }
      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute2));
    }
    if (geometryType === draco.TRIANGULAR_MESH) {
      geometry.index = decodeIndex(draco, decoder, dracoGeometry);
    }
    draco.destroy(dracoGeometry);
    return geometry;
  }
  function decodeIndex(draco, decoder, dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * 4;
    const ptr = draco._malloc(byteLength);
    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
    draco._free(ptr);
    return {
      array: index,
      itemSize: 1
    };
  }
  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute2) {
    const numComponents = attribute2.num_components();
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(draco, attributeType);
    const ptr = draco._malloc(byteLength);
    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute2, dataType, byteLength, ptr);
    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
    draco._free(ptr);
    return {
      name: attributeName,
      array,
      itemSize: numComponents
    };
  }
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
    }
  }
}

// node_modules/three-stdlib/loaders/HDRCubeTextureLoader.js
var HDRCubeTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.hdrLoader = new RGBELoader();
    this.type = HalfFloatType;
  }
  load(urls, onLoad, onProgress, onError) {
    if (!Array.isArray(urls)) {
      console.warn("THREE.HDRCubeTextureLoader signature has changed. Use .setDataType() instead.");
      this.setDataType(urls);
      urls = onLoad;
      onLoad = onProgress;
      onProgress = onError;
      onError = arguments[4];
    }
    const texture2 = new CubeTexture();
    texture2.type = this.type;
    switch (texture2.type) {
      case FloatType:
        texture2.encoding = LinearEncoding;
        texture2.minFilter = LinearFilter;
        texture2.magFilter = LinearFilter;
        texture2.generateMipmaps = false;
        break;
      case HalfFloatType:
        texture2.encoding = LinearEncoding;
        texture2.minFilter = LinearFilter;
        texture2.magFilter = LinearFilter;
        texture2.generateMipmaps = false;
        break;
    }
    const scope2 = this;
    let loaded = 0;
    function loadHDRData(i2, onLoad2, onProgress2, onError2) {
      new FileLoader2(scope2.manager).setPath(scope2.path).setResponseType("arraybuffer").setWithCredentials(scope2.withCredentials).load(urls[i2], function(buffer2) {
        loaded++;
        const texData = scope2.hdrLoader.parse(buffer2);
        if (!texData)
          return;
        if (texData.data !== void 0) {
          const dataTexture = new DataTexture(texData.data, texData.width, texData.height);
          dataTexture.type = texture2.type;
          dataTexture.encoding = texture2.encoding;
          dataTexture.format = texture2.format;
          dataTexture.minFilter = texture2.minFilter;
          dataTexture.magFilter = texture2.magFilter;
          dataTexture.generateMipmaps = texture2.generateMipmaps;
          texture2.images[i2] = dataTexture;
        }
        if (loaded === 6) {
          texture2.needsUpdate = true;
          if (onLoad2)
            onLoad2(texture2);
        }
      }, onProgress2, onError2);
    }
    for (let i2 = 0; i2 < urls.length; i2++) {
      loadHDRData(i2, onLoad, onProgress, onError);
    }
    return texture2;
  }
  setDataType(value) {
    this.type = value;
    this.hdrLoader.setDataType(value);
    return this;
  }
};

// node_modules/three-stdlib/loaders/PDBLoader.js
var PDBLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope2.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(text) {
    function trim(text2) {
      return text2.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function capitalize(text2) {
      return text2.charAt(0).toUpperCase() + text2.substr(1).toLowerCase();
    }
    function hash(s, e) {
      return "s" + Math.min(s, e) + "e" + Math.max(s, e);
    }
    function parseBond(start, length2, satom, i2) {
      const eatom = parseInt(lines[i2].substr(start, length2));
      if (eatom) {
        const h = hash(satom, eatom);
        if (_bhash[h] === void 0) {
          _bonds.push([satom - 1, eatom - 1, 1]);
          _bhash[h] = _bonds.length - 1;
        }
      }
    }
    function buildGeometry() {
      const build = {
        geometryAtoms: new BufferGeometry(),
        geometryBonds: new BufferGeometry(),
        json: {
          atoms
        }
      };
      const geometryAtoms = build.geometryAtoms;
      const geometryBonds = build.geometryBonds;
      const verticesAtoms = [];
      const colorsAtoms = [];
      const verticesBonds = [];
      for (let i2 = 0, l = atoms.length; i2 < l; i2++) {
        const atom = atoms[i2];
        const x = atom[0];
        const y = atom[1];
        const z = atom[2];
        verticesAtoms.push(x, y, z);
        const r = atom[3][0] / 255;
        const g2 = atom[3][1] / 255;
        const b3 = atom[3][2] / 255;
        colorsAtoms.push(r, g2, b3);
      }
      for (let i2 = 0, l = _bonds.length; i2 < l; i2++) {
        const bond = _bonds[i2];
        const start = bond[0];
        const end = bond[1];
        const startAtom = _atomMap[start];
        const endAtom = _atomMap[end];
        let x = startAtom[0];
        let y = startAtom[1];
        let z = startAtom[2];
        verticesBonds.push(x, y, z);
        x = endAtom[0];
        y = endAtom[1];
        z = endAtom[2];
        verticesBonds.push(x, y, z);
      }
      geometryAtoms.setAttribute("position", new Float32BufferAttribute(verticesAtoms, 3));
      geometryAtoms.setAttribute("color", new Float32BufferAttribute(colorsAtoms, 3));
      geometryBonds.setAttribute("position", new Float32BufferAttribute(verticesBonds, 3));
      return build;
    }
    const CPK = {
      h: [255, 255, 255],
      he: [217, 255, 255],
      li: [204, 128, 255],
      be: [194, 255, 0],
      b: [255, 181, 181],
      c: [144, 144, 144],
      n: [48, 80, 248],
      o: [255, 13, 13],
      f: [144, 224, 80],
      ne: [179, 227, 245],
      na: [171, 92, 242],
      mg: [138, 255, 0],
      al: [191, 166, 166],
      si: [240, 200, 160],
      p: [255, 128, 0],
      s: [255, 255, 48],
      cl: [31, 240, 31],
      ar: [128, 209, 227],
      k: [143, 64, 212],
      ca: [61, 255, 0],
      sc: [230, 230, 230],
      ti: [191, 194, 199],
      v: [166, 166, 171],
      cr: [138, 153, 199],
      mn: [156, 122, 199],
      fe: [224, 102, 51],
      co: [240, 144, 160],
      ni: [80, 208, 80],
      cu: [200, 128, 51],
      zn: [125, 128, 176],
      ga: [194, 143, 143],
      ge: [102, 143, 143],
      as: [189, 128, 227],
      se: [255, 161, 0],
      br: [166, 41, 41],
      kr: [92, 184, 209],
      rb: [112, 46, 176],
      sr: [0, 255, 0],
      y: [148, 255, 255],
      zr: [148, 224, 224],
      nb: [115, 194, 201],
      mo: [84, 181, 181],
      tc: [59, 158, 158],
      ru: [36, 143, 143],
      rh: [10, 125, 140],
      pd: [0, 105, 133],
      ag: [192, 192, 192],
      cd: [255, 217, 143],
      in: [166, 117, 115],
      sn: [102, 128, 128],
      sb: [158, 99, 181],
      te: [212, 122, 0],
      i: [148, 0, 148],
      xe: [66, 158, 176],
      cs: [87, 23, 143],
      ba: [0, 201, 0],
      la: [112, 212, 255],
      ce: [255, 255, 199],
      pr: [217, 255, 199],
      nd: [199, 255, 199],
      pm: [163, 255, 199],
      sm: [143, 255, 199],
      eu: [97, 255, 199],
      gd: [69, 255, 199],
      tb: [48, 255, 199],
      dy: [31, 255, 199],
      ho: [0, 255, 156],
      er: [0, 230, 117],
      tm: [0, 212, 82],
      yb: [0, 191, 56],
      lu: [0, 171, 36],
      hf: [77, 194, 255],
      ta: [77, 166, 255],
      w: [33, 148, 214],
      re: [38, 125, 171],
      os: [38, 102, 150],
      ir: [23, 84, 135],
      pt: [208, 208, 224],
      au: [255, 209, 35],
      hg: [184, 184, 208],
      tl: [166, 84, 77],
      pb: [87, 89, 97],
      bi: [158, 79, 181],
      po: [171, 92, 0],
      at: [117, 79, 69],
      rn: [66, 130, 150],
      fr: [66, 0, 102],
      ra: [0, 125, 0],
      ac: [112, 171, 250],
      th: [0, 186, 255],
      pa: [0, 161, 255],
      u: [0, 143, 255],
      np: [0, 128, 255],
      pu: [0, 107, 255],
      am: [84, 92, 242],
      cm: [120, 92, 227],
      bk: [138, 79, 227],
      cf: [161, 54, 212],
      es: [179, 31, 212],
      fm: [179, 31, 186],
      md: [179, 13, 166],
      no: [189, 13, 135],
      lr: [199, 0, 102],
      rf: [204, 0, 89],
      db: [209, 0, 79],
      sg: [217, 0, 69],
      bh: [224, 0, 56],
      hs: [230, 0, 46],
      mt: [235, 0, 38],
      ds: [235, 0, 38],
      rg: [235, 0, 38],
      cn: [235, 0, 38],
      uut: [235, 0, 38],
      uuq: [235, 0, 38],
      uup: [235, 0, 38],
      uuh: [235, 0, 38],
      uus: [235, 0, 38],
      uuo: [235, 0, 38]
    };
    const atoms = [];
    const _bonds = [];
    const _bhash = {};
    const _atomMap = {};
    const lines = text.split("\n");
    for (let i2 = 0, l = lines.length; i2 < l; i2++) {
      if (lines[i2].substr(0, 4) === "ATOM" || lines[i2].substr(0, 6) === "HETATM") {
        const x = parseFloat(lines[i2].substr(30, 7));
        const y = parseFloat(lines[i2].substr(38, 7));
        const z = parseFloat(lines[i2].substr(46, 7));
        const index = parseInt(lines[i2].substr(6, 5)) - 1;
        let e = trim(lines[i2].substr(76, 2)).toLowerCase();
        if (e === "") {
          e = trim(lines[i2].substr(12, 2)).toLowerCase();
        }
        const atomData = [x, y, z, CPK[e], capitalize(e)];
        atoms.push(atomData);
        _atomMap[index] = atomData;
      } else if (lines[i2].substr(0, 6) === "CONECT") {
        const satom = parseInt(lines[i2].substr(6, 5));
        parseBond(11, 5, satom, i2);
        parseBond(16, 5, satom, i2);
        parseBond(21, 5, satom, i2);
        parseBond(26, 5, satom, i2);
      }
    }
    return buildGeometry();
  }
};

// node_modules/three-stdlib/loaders/PRWMLoader.js
var bigEndianPlatform = null;
function isBigEndianPlatform() {
  if (bigEndianPlatform === null) {
    const buffer2 = new ArrayBuffer(2), uint8Array = new Uint8Array(buffer2), uint16Array = new Uint16Array(buffer2);
    uint8Array[0] = 170;
    uint8Array[1] = 187;
    bigEndianPlatform = uint16Array[0] === 43707;
  }
  return bigEndianPlatform;
}
var InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array];
var getMethods = {
  Uint16Array: "getUint16",
  Uint32Array: "getUint32",
  Int16Array: "getInt16",
  Int32Array: "getInt32",
  Float32Array: "getFloat32",
  Float64Array: "getFloat64"
};
function copyFromBuffer(sourceArrayBuffer, viewType, position, length2, fromBigEndian) {
  const bytesPerElement = viewType.BYTES_PER_ELEMENT;
  let result;
  if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {
    result = new viewType(sourceArrayBuffer, position, length2);
  } else {
    const readView = new DataView(sourceArrayBuffer, position, length2 * bytesPerElement), getMethod = getMethods[viewType.name], littleEndian = !fromBigEndian;
    result = new viewType(length2);
    for (let i2 = 0; i2 < length2; i2++) {
      result[i2] = readView[getMethod](i2 * bytesPerElement, littleEndian);
    }
  }
  return result;
}
function decodePrwm(buffer2) {
  const array = new Uint8Array(buffer2), version = array[0];
  let flags = array[1];
  const indexedGeometry = !!(flags >> 7 & 1), indicesType = flags >> 6 & 1, bigEndian = (flags >> 5 & 1) === 1, attributesNumber = flags & 31;
  let valuesNumber = 0, indicesNumber = 0;
  if (bigEndian) {
    valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];
    indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];
  } else {
    valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);
    indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);
  }
  if (version === 0) {
    throw new Error("PRWM decoder: Invalid format version: 0");
  } else if (version !== 1) {
    throw new Error("PRWM decoder: Unsupported format version: " + version);
  }
  if (!indexedGeometry) {
    if (indicesType !== 0) {
      throw new Error("PRWM decoder: Indices type must be set to 0 for non-indexed geometries");
    } else if (indicesNumber !== 0) {
      throw new Error("PRWM decoder: Number of indices must be set to 0 for non-indexed geometries");
    }
  }
  let pos = 8;
  const attributes = {};
  for (let i2 = 0; i2 < attributesNumber; i2++) {
    let attributeName = "";
    while (pos < array.length) {
      const char = array[pos];
      pos++;
      if (char === 0) {
        break;
      } else {
        attributeName += String.fromCharCode(char);
      }
    }
    flags = array[pos];
    const attributeType = flags >> 7 & 1;
    const cardinality = (flags >> 4 & 3) + 1;
    const encodingType = flags & 15;
    const arrayType = InvertedEncodingTypes[encodingType];
    pos++;
    pos = Math.ceil(pos / 4) * 4;
    const values = copyFromBuffer(buffer2, arrayType, pos, cardinality * valuesNumber, bigEndian);
    pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;
    attributes[attributeName] = {
      type: attributeType,
      cardinality,
      values
    };
  }
  pos = Math.ceil(pos / 4) * 4;
  let indices = null;
  if (indexedGeometry) {
    indices = copyFromBuffer(buffer2, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);
  }
  return {
    version,
    attributes,
    indices
  };
}
var PRWMLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    url = url.replace(/\*/g, isBigEndianPlatform() ? "be" : "le");
    loader.load(url, function(arrayBuffer) {
      try {
        onLoad(scope2.parse(arrayBuffer));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(arrayBuffer) {
    const data = decodePrwm(arrayBuffer), attributesKey = Object.keys(data.attributes), bufferGeometry = new BufferGeometry();
    for (let i2 = 0; i2 < attributesKey.length; i2++) {
      const attribute2 = data.attributes[attributesKey[i2]];
      bufferGeometry.setAttribute(attributesKey[i2], new BufferAttribute(attribute2.values, attribute2.cardinality, attribute2.normalized));
    }
    if (data.indices !== null) {
      bufferGeometry.setIndex(new BufferAttribute(data.indices, 1));
    }
    return bufferGeometry;
  }
  static isBigEndianPlatform() {
    return isBigEndianPlatform();
  }
};

// node_modules/three-stdlib/loaders/RGBMLoader.js
var RGBMLoader = class extends DataTextureLoader {
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
    this.maxRange = 7;
  }
  setDataType(value) {
    this.type = value;
    return this;
  }
  setMaxRange(value) {
    this.maxRange = value;
    return this;
  }
  loadCubemap(urls, onLoad, onProgress, onError) {
    const texture2 = new CubeTexture();
    let loaded = 0;
    const scope2 = this;
    function loadTexture(i2) {
      scope2.load(urls[i2], function(image) {
        texture2.images[i2] = image;
        loaded++;
        if (loaded === 6) {
          texture2.needsUpdate = true;
          if (onLoad)
            onLoad(texture2);
        }
      }, void 0, onError);
    }
    for (let i2 = 0; i2 < urls.length; ++i2) {
      loadTexture(i2);
    }
    texture2.type = this.type;
    texture2.format = RGBAFormat;
    texture2.minFilter = LinearFilter;
    texture2.generateMipmaps = false;
    return texture2;
  }
  parse(buffer2) {
    const img = UPNG.decode(buffer2);
    const rgba = UPNG.toRGBA8(img)[0];
    const data = new Uint8Array(rgba);
    const size2 = img.width * img.height * 4;
    const output = this.type === HalfFloatType ? new Uint16Array(size2) : new Float32Array(size2);
    for (let i2 = 0; i2 < data.length; i2 += 4) {
      const r = data[i2 + 0] / 255;
      const g2 = data[i2 + 1] / 255;
      const b3 = data[i2 + 2] / 255;
      const a2 = data[i2 + 3] / 255;
      if (this.type === HalfFloatType) {
        output[i2 + 0] = DataUtils.toHalfFloat(Math.min(r * a2 * this.maxRange, 65504));
        output[i2 + 1] = DataUtils.toHalfFloat(Math.min(g2 * a2 * this.maxRange, 65504));
        output[i2 + 2] = DataUtils.toHalfFloat(Math.min(b3 * a2 * this.maxRange, 65504));
        output[i2 + 3] = DataUtils.toHalfFloat(1);
      } else {
        output[i2 + 0] = r * a2 * this.maxRange;
        output[i2 + 1] = g2 * a2 * this.maxRange;
        output[i2 + 2] = b3 * a2 * this.maxRange;
        output[i2 + 3] = 1;
      }
    }
    return {
      width: img.width,
      height: img.height,
      data: output,
      format: RGBAFormat,
      type: this.type,
      flipY: true
    };
  }
};
var UPNG = {};
UPNG.toRGBA8 = function(out) {
  var w = out.width, h = out.height;
  if (out.tabs.acTL == null)
    return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];
  var frms = [];
  if (out.frames[0].data == null)
    out.frames[0].data = out.data;
  var len = w * h * 4, img = new Uint8Array(len), empty = new Uint8Array(len), prev = new Uint8Array(len);
  for (var i2 = 0; i2 < out.frames.length; i2++) {
    var frm = out.frames[i2];
    var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;
    var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);
    if (i2 != 0)
      for (var j2 = 0; j2 < len; j2++)
        prev[j2] = img[j2];
    if (frm.blend == 0)
      UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);
    else if (frm.blend == 1)
      UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);
    frms.push(img.buffer.slice(0));
    if (frm.dispose == 1)
      UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);
    else if (frm.dispose == 2)
      for (var j2 = 0; j2 < len; j2++)
        img[j2] = prev[j2];
  }
  return frms;
};
UPNG.toRGBA8.decodeImage = function(data, w, h, out) {
  var area = w * h, bpp = UPNG.decode._getBPP(out);
  var bpl = Math.ceil(w * bpp / 8);
  var bf = new Uint8Array(area * 4), bf32 = new Uint32Array(bf.buffer);
  var ctype = out.ctype, depth = out.depth;
  var rs = UPNG._bin.readUshort;
  if (ctype == 6) {
    var qarea = area << 2;
    if (depth == 8) {
      for (var i2 = 0; i2 < qarea; i2 += 4) {
        bf[i2] = data[i2];
        bf[i2 + 1] = data[i2 + 1];
        bf[i2 + 2] = data[i2 + 2];
        bf[i2 + 3] = data[i2 + 3];
      }
    }
    if (depth == 16) {
      for (var i2 = 0; i2 < qarea; i2++) {
        bf[i2] = data[i2 << 1];
      }
    }
  } else if (ctype == 2) {
    var ts = out.tabs["tRNS"];
    if (ts == null) {
      if (depth == 8) {
        for (var i2 = 0; i2 < area; i2++) {
          var ti = i2 * 3;
          bf32[i2] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
        }
      }
      if (depth == 16) {
        for (var i2 = 0; i2 < area; i2++) {
          var ti = i2 * 6;
          bf32[i2] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
        }
      }
    } else {
      var tr = ts[0], tg = ts[1], tb = ts[2];
      if (depth == 8) {
        for (var i2 = 0; i2 < area; i2++) {
          var qi = i2 << 2, ti = i2 * 3;
          bf32[i2] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
          if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb)
            bf[qi + 3] = 0;
        }
      }
      if (depth == 16) {
        for (var i2 = 0; i2 < area; i2++) {
          var qi = i2 << 2, ti = i2 * 6;
          bf32[i2] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
          if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb)
            bf[qi + 3] = 0;
        }
      }
    }
  } else if (ctype == 3) {
    var p = out.tabs["PLTE"], ap = out.tabs["tRNS"], tl = ap ? ap.length : 0;
    if (depth == 1) {
      for (var y = 0; y < h; y++) {
        var s0 = y * bpl, t0 = y * w;
        for (var i2 = 0; i2 < w; i2++) {
          var qi = t0 + i2 << 2, j2 = data[s0 + (i2 >> 3)] >> 7 - ((i2 & 7) << 0) & 1, cj = 3 * j2;
          bf[qi] = p[cj];
          bf[qi + 1] = p[cj + 1];
          bf[qi + 2] = p[cj + 2];
          bf[qi + 3] = j2 < tl ? ap[j2] : 255;
        }
      }
    }
    if (depth == 2) {
      for (var y = 0; y < h; y++) {
        var s0 = y * bpl, t0 = y * w;
        for (var i2 = 0; i2 < w; i2++) {
          var qi = t0 + i2 << 2, j2 = data[s0 + (i2 >> 2)] >> 6 - ((i2 & 3) << 1) & 3, cj = 3 * j2;
          bf[qi] = p[cj];
          bf[qi + 1] = p[cj + 1];
          bf[qi + 2] = p[cj + 2];
          bf[qi + 3] = j2 < tl ? ap[j2] : 255;
        }
      }
    }
    if (depth == 4) {
      for (var y = 0; y < h; y++) {
        var s0 = y * bpl, t0 = y * w;
        for (var i2 = 0; i2 < w; i2++) {
          var qi = t0 + i2 << 2, j2 = data[s0 + (i2 >> 1)] >> 4 - ((i2 & 1) << 2) & 15, cj = 3 * j2;
          bf[qi] = p[cj];
          bf[qi + 1] = p[cj + 1];
          bf[qi + 2] = p[cj + 2];
          bf[qi + 3] = j2 < tl ? ap[j2] : 255;
        }
      }
    }
    if (depth == 8) {
      for (var i2 = 0; i2 < area; i2++) {
        var qi = i2 << 2, j2 = data[i2], cj = 3 * j2;
        bf[qi] = p[cj];
        bf[qi + 1] = p[cj + 1];
        bf[qi + 2] = p[cj + 2];
        bf[qi + 3] = j2 < tl ? ap[j2] : 255;
      }
    }
  } else if (ctype == 4) {
    if (depth == 8) {
      for (var i2 = 0; i2 < area; i2++) {
        var qi = i2 << 2, di = i2 << 1, gr = data[di];
        bf[qi] = gr;
        bf[qi + 1] = gr;
        bf[qi + 2] = gr;
        bf[qi + 3] = data[di + 1];
      }
    }
    if (depth == 16) {
      for (var i2 = 0; i2 < area; i2++) {
        var qi = i2 << 2, di = i2 << 2, gr = data[di];
        bf[qi] = gr;
        bf[qi + 1] = gr;
        bf[qi + 2] = gr;
        bf[qi + 3] = data[di + 2];
      }
    }
  } else if (ctype == 0) {
    var tr = out.tabs["tRNS"] ? out.tabs["tRNS"] : -1;
    for (var y = 0; y < h; y++) {
      var off = y * bpl, to = y * w;
      if (depth == 1) {
        for (var x = 0; x < w; x++) {
          var gr = 255 * (data[off + (x >>> 3)] >>> 7 - (x & 7) & 1), al = gr == tr * 255 ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      } else if (depth == 2) {
        for (var x = 0; x < w; x++) {
          var gr = 85 * (data[off + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      } else if (depth == 4) {
        for (var x = 0; x < w; x++) {
          var gr = 17 * (data[off + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      } else if (depth == 8) {
        for (var x = 0; x < w; x++) {
          var gr = data[off + x], al = gr == tr ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      } else if (depth == 16) {
        for (var x = 0; x < w; x++) {
          var gr = data[off + (x << 1)], al = rs(data, off + (x << 1)) == tr ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      }
    }
  }
  return bf;
};
UPNG.decode = function(buff) {
  var data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;
  var out = {
    tabs: {},
    frames: []
  };
  var dd = new Uint8Array(data.length), doff = 0;
  var fd2, foff = 0;
  var text, keyw, bfr;
  var mgck = [137, 80, 78, 71, 13, 10, 26, 10];
  for (var i2 = 0; i2 < 8; i2++)
    if (data[i2] != mgck[i2])
      throw new Error("The input is not a PNG file!");
  while (offset < data.length) {
    var len = bin.readUint(data, offset);
    offset += 4;
    var type2 = bin.readASCII(data, offset, 4);
    offset += 4;
    if (type2 == "IHDR") {
      UPNG.decode._IHDR(data, offset, out);
    } else if (type2 == "CgBI") {
      out.tabs[type2] = data.slice(offset, offset + 4);
    } else if (type2 == "IDAT") {
      for (var i2 = 0; i2 < len; i2++)
        dd[doff + i2] = data[offset + i2];
      doff += len;
    } else if (type2 == "acTL") {
      out.tabs[type2] = {
        num_frames: rUi(data, offset),
        num_plays: rUi(data, offset + 4)
      };
      fd2 = new Uint8Array(data.length);
    } else if (type2 == "fcTL") {
      if (foff != 0) {
        var fr = out.frames[out.frames.length - 1];
        fr.data = UPNG.decode._decompress(out, fd2.slice(0, foff), fr.rect.width, fr.rect.height);
        foff = 0;
      }
      var rct = {
        x: rUi(data, offset + 12),
        y: rUi(data, offset + 16),
        width: rUi(data, offset + 4),
        height: rUi(data, offset + 8)
      };
      var del = rUs(data, offset + 22);
      del = rUs(data, offset + 20) / (del == 0 ? 100 : del);
      var frm = {
        rect: rct,
        delay: Math.round(del * 1e3),
        dispose: data[offset + 24],
        blend: data[offset + 25]
      };
      out.frames.push(frm);
    } else if (type2 == "fdAT") {
      for (var i2 = 0; i2 < len - 4; i2++)
        fd2[foff + i2] = data[offset + i2 + 4];
      foff += len - 4;
    } else if (type2 == "pHYs") {
      out.tabs[type2] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];
    } else if (type2 == "cHRM") {
      out.tabs[type2] = [];
      for (var i2 = 0; i2 < 8; i2++)
        out.tabs[type2].push(bin.readUint(data, offset + i2 * 4));
    } else if (type2 == "tEXt" || type2 == "zTXt") {
      if (out.tabs[type2] == null)
        out.tabs[type2] = {};
      var nz = bin.nextZero(data, offset);
      keyw = bin.readASCII(data, offset, nz - offset);
      var tl = offset + len - nz - 1;
      if (type2 == "tEXt") {
        text = bin.readASCII(data, nz + 1, tl);
      } else {
        bfr = UPNG.decode._inflate(data.slice(nz + 2, nz + 2 + tl));
        text = bin.readUTF8(bfr, 0, bfr.length);
      }
      out.tabs[type2][keyw] = text;
    } else if (type2 == "iTXt") {
      if (out.tabs[type2] == null)
        out.tabs[type2] = {};
      var nz = 0, off = offset;
      nz = bin.nextZero(data, off);
      keyw = bin.readASCII(data, off, nz - off);
      off = nz + 1;
      var cflag = data[off];
      off += 2;
      nz = bin.nextZero(data, off);
      bin.readASCII(data, off, nz - off);
      off = nz + 1;
      nz = bin.nextZero(data, off);
      bin.readUTF8(data, off, nz - off);
      off = nz + 1;
      var tl = len - (off - offset);
      if (cflag == 0) {
        text = bin.readUTF8(data, off, tl);
      } else {
        bfr = UPNG.decode._inflate(data.slice(off, off + tl));
        text = bin.readUTF8(bfr, 0, bfr.length);
      }
      out.tabs[type2][keyw] = text;
    } else if (type2 == "PLTE") {
      out.tabs[type2] = bin.readBytes(data, offset, len);
    } else if (type2 == "hIST") {
      var pl = out.tabs["PLTE"].length / 3;
      out.tabs[type2] = [];
      for (var i2 = 0; i2 < pl; i2++)
        out.tabs[type2].push(rUs(data, offset + i2 * 2));
    } else if (type2 == "tRNS") {
      if (out.ctype == 3)
        out.tabs[type2] = bin.readBytes(data, offset, len);
      else if (out.ctype == 0)
        out.tabs[type2] = rUs(data, offset);
      else if (out.ctype == 2)
        out.tabs[type2] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
    } else if (type2 == "gAMA") {
      out.tabs[type2] = bin.readUint(data, offset) / 1e5;
    } else if (type2 == "sRGB") {
      out.tabs[type2] = data[offset];
    } else if (type2 == "bKGD") {
      if (out.ctype == 0 || out.ctype == 4) {
        out.tabs[type2] = [rUs(data, offset)];
      } else if (out.ctype == 2 || out.ctype == 6) {
        out.tabs[type2] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
      } else if (out.ctype == 3) {
        out.tabs[type2] = data[offset];
      }
    } else if (type2 == "IEND") {
      break;
    }
    offset += len;
    bin.readUint(data, offset);
    offset += 4;
  }
  if (foff != 0) {
    var fr = out.frames[out.frames.length - 1];
    fr.data = UPNG.decode._decompress(out, fd2.slice(0, foff), fr.rect.width, fr.rect.height);
  }
  out.data = UPNG.decode._decompress(out, dd, out.width, out.height);
  delete out.compress;
  delete out.interlace;
  delete out.filter;
  return out;
};
UPNG.decode._decompress = function(out, dd, w, h) {
  var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), buff = new Uint8Array((bpl + 1 + out.interlace) * h);
  if (out.tabs["CgBI"])
    dd = UPNG.inflateRaw(dd, buff);
  else
    dd = UPNG.decode._inflate(dd, buff);
  if (out.interlace == 0)
    dd = UPNG.decode._filterZero(dd, out, 0, w, h);
  else if (out.interlace == 1)
    dd = UPNG.decode._readInterlace(dd, out);
  return dd;
};
UPNG.decode._inflate = function(data, buff) {
  var out = UPNG["inflateRaw"](new Uint8Array(data.buffer, 2, data.length - 6), buff);
  return out;
};
UPNG.inflateRaw = function() {
  var H = {};
  H.H = {};
  H.H.N = function(N, W) {
    var R2 = Uint8Array, i2 = 0, m = 0, J = 0, h = 0, Q2 = 0, X = 0, u = 0, w = 0, d = 0, v, C2;
    if (N[0] == 3 && N[1] == 0)
      return W ? W : new R2(0);
    var V = H.H, n = V.b, A2 = V.e, l = V.R, M = V.n, I2 = V.A, e = V.Z, b3 = V.m, Z = W == null;
    if (Z)
      W = new R2(N.length >>> 2 << 5);
    while (i2 == 0) {
      i2 = n(N, d, 1);
      m = n(N, d + 1, 2);
      d += 3;
      if (m == 0) {
        if ((d & 7) != 0)
          d += 8 - (d & 7);
        var D = (d >>> 3) + 4, q = N[D - 4] | N[D - 3] << 8;
        if (Z)
          W = H.H.W(W, w + q);
        W.set(new R2(N.buffer, N.byteOffset + D, q), w);
        d = D + q << 3;
        w += q;
        continue;
      }
      if (Z)
        W = H.H.W(W, w + (1 << 17));
      if (m == 1) {
        v = b3.J;
        C2 = b3.h;
        X = (1 << 9) - 1;
        u = (1 << 5) - 1;
      }
      if (m == 2) {
        J = A2(N, d, 5) + 257;
        h = A2(N, d + 5, 5) + 1;
        Q2 = A2(N, d + 10, 4) + 4;
        d += 14;
        var j2 = 1;
        for (var c = 0; c < 38; c += 2) {
          b3.Q[c] = 0;
          b3.Q[c + 1] = 0;
        }
        for (var c = 0; c < Q2; c++) {
          var K = A2(N, d + c * 3, 3);
          b3.Q[(b3.X[c] << 1) + 1] = K;
          if (K > j2)
            j2 = K;
        }
        d += 3 * Q2;
        M(b3.Q, j2);
        I2(b3.Q, j2, b3.u);
        v = b3.w;
        C2 = b3.d;
        d = l(b3.u, (1 << j2) - 1, J + h, N, d, b3.v);
        var r = V.V(b3.v, 0, J, b3.C);
        X = (1 << r) - 1;
        var S = V.V(b3.v, J, h, b3.D);
        u = (1 << S) - 1;
        M(b3.C, r);
        I2(b3.C, r, v);
        M(b3.D, S);
        I2(b3.D, S, C2);
      }
      while (true) {
        var T = v[e(N, d) & X];
        d += T & 15;
        var p = T >>> 4;
        if (p >>> 8 == 0) {
          W[w++] = p;
        } else if (p == 256) {
          break;
        } else {
          var z = w + p - 254;
          if (p > 264) {
            var _ = b3.q[p - 257];
            z = w + (_ >>> 3) + A2(N, d, _ & 7);
            d += _ & 7;
          }
          var $ = C2[e(N, d) & u];
          d += $ & 15;
          var s = $ >>> 4, Y = b3.c[s], a2 = (Y >>> 4) + n(N, d, Y & 15);
          d += Y & 15;
          while (w < z) {
            W[w] = W[w++ - a2];
            W[w] = W[w++ - a2];
            W[w] = W[w++ - a2];
            W[w] = W[w++ - a2];
          }
          w = z;
        }
      }
    }
    return W.length == w ? W : W.slice(0, w);
  };
  H.H.W = function(N, W) {
    var R2 = N.length;
    if (W <= R2)
      return N;
    var V = new Uint8Array(R2 << 1);
    V.set(N, 0);
    return V;
  };
  H.H.R = function(N, W, R2, V, n, A2) {
    var l = H.H.e, M = H.H.Z, I2 = 0;
    while (I2 < R2) {
      var e = N[M(V, n) & W];
      n += e & 15;
      var b3 = e >>> 4;
      if (b3 <= 15) {
        A2[I2] = b3;
        I2++;
      } else {
        var Z = 0, m = 0;
        if (b3 == 16) {
          m = 3 + l(V, n, 2);
          n += 2;
          Z = A2[I2 - 1];
        } else if (b3 == 17) {
          m = 3 + l(V, n, 3);
          n += 3;
        } else if (b3 == 18) {
          m = 11 + l(V, n, 7);
          n += 7;
        }
        var J = I2 + m;
        while (I2 < J) {
          A2[I2] = Z;
          I2++;
        }
      }
    }
    return n;
  };
  H.H.V = function(N, W, R2, V) {
    var n = 0, A2 = 0, l = V.length >>> 1;
    while (A2 < R2) {
      var M = N[A2 + W];
      V[A2 << 1] = 0;
      V[(A2 << 1) + 1] = M;
      if (M > n)
        n = M;
      A2++;
    }
    while (A2 < l) {
      V[A2 << 1] = 0;
      V[(A2 << 1) + 1] = 0;
      A2++;
    }
    return n;
  };
  H.H.n = function(N, W) {
    var R2 = H.H.m, V = N.length, n, A2, l, M, I2, e = R2.j;
    for (var M = 0; M <= W; M++)
      e[M] = 0;
    for (M = 1; M < V; M += 2)
      e[N[M]]++;
    var b3 = R2.K;
    n = 0;
    e[0] = 0;
    for (A2 = 1; A2 <= W; A2++) {
      n = n + e[A2 - 1] << 1;
      b3[A2] = n;
    }
    for (l = 0; l < V; l += 2) {
      I2 = N[l + 1];
      if (I2 != 0) {
        N[l] = b3[I2];
        b3[I2]++;
      }
    }
  };
  H.H.A = function(N, W, R2) {
    var V = N.length, n = H.H.m, A2 = n.r;
    for (var l = 0; l < V; l += 2) {
      if (N[l + 1] != 0) {
        var M = l >> 1, I2 = N[l + 1], e = M << 4 | I2, b3 = W - I2, Z = N[l] << b3, m = Z + (1 << b3);
        while (Z != m) {
          var J = A2[Z] >>> 15 - W;
          R2[J] = e;
          Z++;
        }
      }
    }
  };
  H.H.l = function(N, W) {
    var R2 = H.H.m.r, V = 15 - W;
    for (var n = 0; n < N.length; n += 2) {
      var A2 = N[n] << W - N[n + 1];
      N[n] = R2[A2] >>> V;
    }
  };
  H.H.M = function(N, W, R2) {
    R2 = R2 << (W & 7);
    var V = W >>> 3;
    N[V] |= R2;
    N[V + 1] |= R2 >>> 8;
  };
  H.H.I = function(N, W, R2) {
    R2 = R2 << (W & 7);
    var V = W >>> 3;
    N[V] |= R2;
    N[V + 1] |= R2 >>> 8;
    N[V + 2] |= R2 >>> 16;
  };
  H.H.e = function(N, W, R2) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R2) - 1;
  };
  H.H.b = function(N, W, R2) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R2) - 1;
  };
  H.H.Z = function(N, W) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);
  };
  H.H.i = function(N, W) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);
  };
  H.H.m = function() {
    var N = Uint16Array, W = Uint32Array;
    return {
      K: new N(16),
      j: new N(16),
      X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
      S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],
      T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],
      q: new N(32),
      p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],
      z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],
      c: new W(32),
      J: new N(512),
      _: [],
      h: new N(32),
      $: [],
      w: new N(32768),
      C: [],
      v: [],
      d: new N(32768),
      D: [],
      u: new N(512),
      Q: [],
      r: new N(1 << 15),
      s: new W(286),
      Y: new W(30),
      a: new W(19),
      t: new W(15e3),
      k: new N(1 << 16),
      g: new N(1 << 15)
    };
  }();
  (function() {
    var N = H.H.m, W = 1 << 15;
    for (var R2 = 0; R2 < W; R2++) {
      var V = R2;
      V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;
      V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;
      V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;
      V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;
      N.r[R2] = (V >>> 16 | V << 16) >>> 17;
    }
    function n(A2, l, M) {
      while (l-- != 0)
        A2.push(0, M);
    }
    for (var R2 = 0; R2 < 32; R2++) {
      N.q[R2] = N.S[R2] << 3 | N.T[R2];
      N.c[R2] = N.p[R2] << 4 | N.z[R2];
    }
    n(N._, 144, 8);
    n(N._, 255 - 143, 9);
    n(N._, 279 - 255, 7);
    n(N._, 287 - 279, 8);
    H.H.n(N._, 9);
    H.H.A(N._, 9, N.J);
    H.H.l(N._, 9);
    n(N.$, 32, 5);
    H.H.n(N.$, 5);
    H.H.A(N.$, 5, N.h);
    H.H.l(N.$, 5);
    n(N.Q, 19, 0);
    n(N.C, 286, 0);
    n(N.D, 30, 0);
    n(N.v, 320, 0);
  })();
  return H.H.N;
}();
UPNG.decode._readInterlace = function(data, out) {
  var w = out.width, h = out.height;
  var bpp = UPNG.decode._getBPP(out), cbpp = bpp >> 3, bpl = Math.ceil(w * bpp / 8);
  var img = new Uint8Array(h * bpl);
  var di = 0;
  var starting_row = [0, 0, 4, 0, 2, 0, 1];
  var starting_col = [0, 4, 0, 2, 0, 1, 0];
  var row_increment = [8, 8, 8, 4, 4, 2, 2];
  var col_increment = [8, 8, 4, 4, 2, 2, 1];
  var pass = 0;
  while (pass < 7) {
    var ri = row_increment[pass], ci = col_increment[pass];
    var sw = 0, sh = 0;
    var cr = starting_row[pass];
    while (cr < h) {
      cr += ri;
      sh++;
    }
    var cc = starting_col[pass];
    while (cc < w) {
      cc += ci;
      sw++;
    }
    var bpll = Math.ceil(sw * bpp / 8);
    UPNG.decode._filterZero(data, out, di, sw, sh);
    var y = 0, row = starting_row[pass];
    var val;
    while (row < h) {
      var col = starting_col[pass];
      var cdi = di + y * bpll << 3;
      while (col < w) {
        if (bpp == 1) {
          val = data[cdi >> 3];
          val = val >> 7 - (cdi & 7) & 1;
          img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);
        }
        if (bpp == 2) {
          val = data[cdi >> 3];
          val = val >> 6 - (cdi & 7) & 3;
          img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);
        }
        if (bpp == 4) {
          val = data[cdi >> 3];
          val = val >> 4 - (cdi & 7) & 15;
          img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);
        }
        if (bpp >= 8) {
          var ii = row * bpl + col * cbpp;
          for (var j2 = 0; j2 < cbpp; j2++)
            img[ii + j2] = data[(cdi >> 3) + j2];
        }
        cdi += bpp;
        col += ci;
      }
      y++;
      row += ri;
    }
    if (sw * sh != 0)
      di += sh * (1 + bpll);
    pass = pass + 1;
  }
  return img;
};
UPNG.decode._getBPP = function(out) {
  var noc = [1, null, 3, 1, 2, null, 4][out.ctype];
  return noc * out.depth;
};
UPNG.decode._filterZero = function(data, out, off, w, h) {
  var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), paeth = UPNG.decode._paeth;
  bpp = Math.ceil(bpp / 8);
  var i2, di, type2 = data[off], x = 0;
  if (type2 > 1)
    data[off] = [0, 0, 1][type2 - 2];
  if (type2 == 3)
    for (x = bpp; x < bpl; x++)
      data[x + 1] = data[x + 1] + (data[x + 1 - bpp] >>> 1) & 255;
  for (var y = 0; y < h; y++) {
    i2 = off + y * bpl;
    di = i2 + y + 1;
    type2 = data[di - 1];
    x = 0;
    if (type2 == 0) {
      for (; x < bpl; x++)
        data[i2 + x] = data[di + x];
    } else if (type2 == 1) {
      for (; x < bpp; x++)
        data[i2 + x] = data[di + x];
      for (; x < bpl; x++)
        data[i2 + x] = data[di + x] + data[i2 + x - bpp];
    } else if (type2 == 2) {
      for (; x < bpl; x++)
        data[i2 + x] = data[di + x] + data[i2 + x - bpl];
    } else if (type2 == 3) {
      for (; x < bpp; x++)
        data[i2 + x] = data[di + x] + (data[i2 + x - bpl] >>> 1);
      for (; x < bpl; x++)
        data[i2 + x] = data[di + x] + (data[i2 + x - bpl] + data[i2 + x - bpp] >>> 1);
    } else {
      for (; x < bpp; x++)
        data[i2 + x] = data[di + x] + paeth(0, data[i2 + x - bpl], 0);
      for (; x < bpl; x++) {
        data[i2 + x] = data[di + x] + paeth(data[i2 + x - bpp], data[i2 + x - bpl], data[i2 + x - bpp - bpl]);
      }
    }
  }
  return data;
};
UPNG.decode._paeth = function(a2, b3, c) {
  var p = a2 + b3 - c, pa = p - a2, pb = p - b3, pc = p - c;
  if (pa * pa <= pb * pb && pa * pa <= pc * pc)
    return a2;
  else if (pb * pb <= pc * pc)
    return b3;
  return c;
};
UPNG.decode._IHDR = function(data, offset, out) {
  var bin = UPNG._bin;
  out.width = bin.readUint(data, offset);
  offset += 4;
  out.height = bin.readUint(data, offset);
  offset += 4;
  out.depth = data[offset];
  offset++;
  out.ctype = data[offset];
  offset++;
  out.compress = data[offset];
  offset++;
  out.filter = data[offset];
  offset++;
  out.interlace = data[offset];
  offset++;
};
UPNG._bin = {
  nextZero: function(data, p) {
    while (data[p] != 0)
      p++;
    return p;
  },
  readUshort: function(buff, p) {
    return buff[p] << 8 | buff[p + 1];
  },
  writeUshort: function(buff, p, n) {
    buff[p] = n >> 8 & 255;
    buff[p + 1] = n & 255;
  },
  readUint: function(buff, p) {
    return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);
  },
  writeUint: function(buff, p, n) {
    buff[p] = n >> 24 & 255;
    buff[p + 1] = n >> 16 & 255;
    buff[p + 2] = n >> 8 & 255;
    buff[p + 3] = n & 255;
  },
  readASCII: function(buff, p, l) {
    var s = "";
    for (var i2 = 0; i2 < l; i2++)
      s += String.fromCharCode(buff[p + i2]);
    return s;
  },
  writeASCII: function(data, p, s) {
    for (var i2 = 0; i2 < s.length; i2++)
      data[p + i2] = s.charCodeAt(i2);
  },
  readBytes: function(buff, p, l) {
    var arr = [];
    for (var i2 = 0; i2 < l; i2++)
      arr.push(buff[p + i2]);
    return arr;
  },
  pad: function(n) {
    return n.length < 2 ? "0" + n : n;
  },
  readUTF8: function(buff, p, l) {
    var s = "", ns;
    for (var i2 = 0; i2 < l; i2++)
      s += "%" + UPNG._bin.pad(buff[p + i2].toString(16));
    try {
      ns = decodeURIComponent(s);
    } catch (e) {
      return UPNG._bin.readASCII(buff, p, l);
    }
    return ns;
  }
};
UPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {
  var w = Math.min(sw, tw), h = Math.min(sh, th);
  var si = 0, ti = 0;
  for (var y = 0; y < h; y++) {
    for (var x = 0; x < w; x++) {
      if (xoff >= 0 && yoff >= 0) {
        si = y * sw + x << 2;
        ti = (yoff + y) * tw + xoff + x << 2;
      } else {
        si = (-yoff + y) * sw - xoff + x << 2;
        ti = y * tw + x << 2;
      }
      if (mode == 0) {
        tb[ti] = sb[si];
        tb[ti + 1] = sb[si + 1];
        tb[ti + 2] = sb[si + 2];
        tb[ti + 3] = sb[si + 3];
      } else if (mode == 1) {
        var fa = sb[si + 3] * (1 / 255), fr = sb[si] * fa, fg = sb[si + 1] * fa, fb = sb[si + 2] * fa;
        var ba = tb[ti + 3] * (1 / 255), br = tb[ti] * ba, bg = tb[ti + 1] * ba, bb = tb[ti + 2] * ba;
        var ifa = 1 - fa, oa = fa + ba * ifa, ioa = oa == 0 ? 0 : 1 / oa;
        tb[ti + 3] = 255 * oa;
        tb[ti + 0] = (fr + br * ifa) * ioa;
        tb[ti + 1] = (fg + bg * ifa) * ioa;
        tb[ti + 2] = (fb + bb * ifa) * ioa;
      } else if (mode == 2) {
        var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
        var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
        if (fa == ba && fr == br && fg == bg && fb == bb) {
          tb[ti] = 0;
          tb[ti + 1] = 0;
          tb[ti + 2] = 0;
          tb[ti + 3] = 0;
        } else {
          tb[ti] = fr;
          tb[ti + 1] = fg;
          tb[ti + 2] = fb;
          tb[ti + 3] = fa;
        }
      } else if (mode == 3) {
        var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
        var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
        if (fa == ba && fr == br && fg == bg && fb == bb)
          continue;
        if (fa < 220 && ba > 20)
          return false;
      }
    }
  }
  return true;
};

// node_modules/three-stdlib/loaders/VOXLoader.js
var VOXLoader = class extends Loader {
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope2.requestHeader);
    loader.load(url, function(buffer2) {
      try {
        onLoad(scope2.parse(buffer2));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(buffer2) {
    const data = new DataView(buffer2);
    const id = data.getUint32(0, true);
    const version = data.getUint32(4, true);
    if (id !== 542658390 || version !== 150) {
      console.error("Not a valid VOX file");
      return;
    }
    const DEFAULT_PALETTE = [0, 4294967295, 4291624959, 4288282623, 4284940287, 4281597951, 4278255615, 4294954239, 4291611903, 4288269567, 4284927231, 4281584895, 4278242559, 4294941183, 4291598847, 4288256511, 4284914175, 4281571839, 4278229503, 4294928127, 4291585791, 4288243455, 4284901119, 4281558783, 4278216447, 4294915071, 4291572735, 4288230399, 4284888063, 4281545727, 4278203391, 4294902015, 4291559679, 4288217343, 4284875007, 4281532671, 4278190335, 4294967244, 4291624908, 4288282572, 4284940236, 4281597900, 4278255564, 4294954188, 4291611852, 4288269516, 4284927180, 4281584844, 4278242508, 4294941132, 4291598796, 4288256460, 4284914124, 4281571788, 4278229452, 4294928076, 4291585740, 4288243404, 4284901068, 4281558732, 4278216396, 4294915020, 4291572684, 4288230348, 4284888012, 4281545676, 4278203340, 4294901964, 4291559628, 4288217292, 4284874956, 4281532620, 4278190284, 4294967193, 4291624857, 4288282521, 4284940185, 4281597849, 4278255513, 4294954137, 4291611801, 4288269465, 4284927129, 4281584793, 4278242457, 4294941081, 4291598745, 4288256409, 4284914073, 4281571737, 4278229401, 4294928025, 4291585689, 4288243353, 4284901017, 4281558681, 4278216345, 4294914969, 4291572633, 4288230297, 4284887961, 4281545625, 4278203289, 4294901913, 4291559577, 4288217241, 4284874905, 4281532569, 4278190233, 4294967142, 4291624806, 4288282470, 4284940134, 4281597798, 4278255462, 4294954086, 4291611750, 4288269414, 4284927078, 4281584742, 4278242406, 4294941030, 4291598694, 4288256358, 4284914022, 4281571686, 4278229350, 4294927974, 4291585638, 4288243302, 4284900966, 4281558630, 4278216294, 4294914918, 4291572582, 4288230246, 4284887910, 4281545574, 4278203238, 4294901862, 4291559526, 4288217190, 4284874854, 4281532518, 4278190182, 4294967091, 4291624755, 4288282419, 4284940083, 4281597747, 4278255411, 4294954035, 4291611699, 4288269363, 4284927027, 4281584691, 4278242355, 4294940979, 4291598643, 4288256307, 4284913971, 4281571635, 4278229299, 4294927923, 4291585587, 4288243251, 4284900915, 4281558579, 4278216243, 4294914867, 4291572531, 4288230195, 4284887859, 4281545523, 4278203187, 4294901811, 4291559475, 4288217139, 4284874803, 4281532467, 4278190131, 4294967040, 4291624704, 4288282368, 4284940032, 4281597696, 4278255360, 4294953984, 4291611648, 4288269312, 4284926976, 4281584640, 4278242304, 4294940928, 4291598592, 4288256256, 4284913920, 4281571584, 4278229248, 4294927872, 4291585536, 4288243200, 4284900864, 4281558528, 4278216192, 4294914816, 4291572480, 4288230144, 4284887808, 4281545472, 4278203136, 4294901760, 4291559424, 4288217088, 4284874752, 4281532416, 4278190318, 4278190301, 4278190267, 4278190250, 4278190216, 4278190199, 4278190165, 4278190148, 4278190114, 4278190097, 4278251008, 4278246656, 4278237952, 4278233600, 4278224896, 4278220544, 4278211840, 4278207488, 4278198784, 4278194432, 4293787648, 4292673536, 4290445312, 4289331200, 4287102976, 4285988864, 4283760640, 4282646528, 4280418304, 4279304192, 4293848814, 4292730333, 4290493371, 4289374890, 4287137928, 4286019447, 4283782485, 4282664004, 4280427042, 4279308561];
    let i2 = 8;
    let chunk;
    const chunks = [];
    while (i2 < data.byteLength) {
      let id2 = "";
      for (let j2 = 0; j2 < 4; j2++) {
        id2 += String.fromCharCode(data.getUint8(i2++, true));
      }
      const chunkSize = data.getUint32(i2, true);
      i2 += 4;
      data.getUint32(i2, true);
      i2 += 4;
      if (id2 === "SIZE") {
        const x = data.getUint32(i2, true);
        i2 += 4;
        const y = data.getUint32(i2, true);
        i2 += 4;
        const z = data.getUint32(i2, true);
        i2 += 4;
        chunk = {
          palette: DEFAULT_PALETTE,
          size: {
            x,
            y,
            z
          }
        };
        chunks.push(chunk);
        i2 += chunkSize - 3 * 4;
      } else if (id2 === "XYZI") {
        const numVoxels = data.getUint32(i2, true);
        i2 += 4;
        chunk.data = new Uint8Array(buffer2, i2, numVoxels * 4);
        i2 += numVoxels * 4;
      } else if (id2 === "RGBA") {
        const palette = [0];
        for (let j2 = 0; j2 < 256; j2++) {
          palette[j2 + 1] = data.getUint32(i2, true);
          i2 += 4;
        }
        chunk.palette = palette;
      } else {
        i2 += chunkSize;
      }
    }
    return chunks;
  }
};
var VOXMesh = class extends Mesh {
  constructor(chunk) {
    const data = chunk.data;
    const size2 = chunk.size;
    const palette = chunk.palette;
    const vertices = [];
    const colors = [];
    const nx = [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1];
    const px = [1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0];
    const py = [0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1];
    const ny = [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0];
    const nz = [0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0];
    const pz = [0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1];
    function add2(tile, x, y, z, r, g2, b3) {
      x -= size2.x / 2;
      y -= size2.z / 2;
      z += size2.y / 2;
      for (let i2 = 0; i2 < 18; i2 += 3) {
        vertices.push(tile[i2 + 0] + x, tile[i2 + 1] + y, tile[i2 + 2] + z);
        colors.push(r, g2, b3);
      }
    }
    const offsety = size2.x;
    const offsetz = size2.x * size2.y;
    const array = new Uint8Array(size2.x * size2.y * size2.z);
    for (let j2 = 0; j2 < data.length; j2 += 4) {
      const x = data[j2 + 0];
      const y = data[j2 + 1];
      const z = data[j2 + 2];
      const index = x + y * offsety + z * offsetz;
      array[index] = 255;
    }
    let hasColors = false;
    for (let j2 = 0; j2 < data.length; j2 += 4) {
      const x = data[j2 + 0];
      const y = data[j2 + 1];
      const z = data[j2 + 2];
      const c = data[j2 + 3];
      const hex = palette[c];
      const r = (hex >> 0 & 255) / 255;
      const g2 = (hex >> 8 & 255) / 255;
      const b3 = (hex >> 16 & 255) / 255;
      if (r > 0 || g2 > 0 || b3 > 0)
        hasColors = true;
      const index = x + y * offsety + z * offsetz;
      if (array[index + 1] === 0 || x === size2.x - 1)
        add2(px, x, z, -y, r, g2, b3);
      if (array[index - 1] === 0 || x === 0)
        add2(nx, x, z, -y, r, g2, b3);
      if (array[index + offsety] === 0 || y === size2.y - 1)
        add2(ny, x, z, -y, r, g2, b3);
      if (array[index - offsety] === 0 || y === 0)
        add2(py, x, z, -y, r, g2, b3);
      if (array[index + offsetz] === 0 || z === size2.z - 1)
        add2(pz, x, z, -y, r, g2, b3);
      if (array[index - offsetz] === 0 || z === 0)
        add2(nz, x, z, -y, r, g2, b3);
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.computeVertexNormals();
    const material = new MeshStandardMaterial();
    if (hasColors) {
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      material.vertexColors = true;
    }
    super(geometry, material);
  }
};
var VOXDataTexture3D = class extends DataTexture3D {
  constructor(chunk) {
    const data = chunk.data;
    const size2 = chunk.size;
    const offsety = size2.x;
    const offsetz = size2.x * size2.y;
    const array = new Uint8Array(size2.x * size2.y * size2.z);
    for (let j2 = 0; j2 < data.length; j2 += 4) {
      const x = data[j2 + 0];
      const y = data[j2 + 1];
      const z = data[j2 + 2];
      const index = x + y * offsety + z * offsetz;
      array[index] = 255;
    }
    super(array, size2.x, size2.y, size2.z);
    this.format = RedFormat;
    this.minFilter = NearestFilter;
    this.magFilter = LinearFilter;
    this.unpackAlignment = 1;
  }
};

// node_modules/three-stdlib/loaders/NodeMaterialLoader.js
var NodeMaterialLoaderUtils = class {
  static replaceUUIDObject(object, uuid, value, recursive) {
    recursive = recursive !== void 0 ? recursive : true;
    if (typeof uuid === "object")
      uuid = uuid.uuid;
    if (typeof object === "object") {
      const keys = Object.keys(object);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        if (recursive) {
          object[key] = this.replaceUUIDObject(object[key], uuid, value);
        }
        if (key === uuid) {
          object[uuid] = object[key];
          delete object[key];
        }
      }
    }
    return object === uuid ? value : object;
  }
  static replaceUUID(json, uuid, value) {
    this.replaceUUIDObject(json, uuid, value, false);
    this.replaceUUIDObject(json.nodes, uuid, value);
    this.replaceUUIDObject(json.materials, uuid, value);
    this.replaceUUIDObject(json.passes, uuid, value);
    this.replaceUUIDObject(json.library, uuid, value, false);
    return json;
  }
};

// node_modules/three-stdlib/loaders/PCDLoader.js
var PCDLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.littleEndian = true;
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(scope2.manager);
    loader.setPath(scope2.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope2.requestHeader);
    loader.setWithCredentials(scope2.withCredentials);
    loader.load(url, function(data) {
      try {
        onLoad(scope2.parse(data, url));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(data, url) {
    function decompressLZF(inData, outLength) {
      const inLength = inData.length;
      const outData = new Uint8Array(outLength);
      let inPtr = 0;
      let outPtr = 0;
      let ctrl;
      let len;
      let ref;
      do {
        ctrl = inData[inPtr++];
        if (ctrl < 1 << 5) {
          ctrl++;
          if (outPtr + ctrl > outLength)
            throw new Error("Output buffer is not large enough");
          if (inPtr + ctrl > inLength)
            throw new Error("Invalid compressed data");
          do {
            outData[outPtr++] = inData[inPtr++];
          } while (--ctrl);
        } else {
          len = ctrl >> 5;
          ref = outPtr - ((ctrl & 31) << 8) - 1;
          if (inPtr >= inLength)
            throw new Error("Invalid compressed data");
          if (len === 7) {
            len += inData[inPtr++];
            if (inPtr >= inLength)
              throw new Error("Invalid compressed data");
          }
          ref -= inData[inPtr++];
          if (outPtr + len + 2 > outLength)
            throw new Error("Output buffer is not large enough");
          if (ref < 0)
            throw new Error("Invalid compressed data");
          if (ref >= outPtr)
            throw new Error("Invalid compressed data");
          do {
            outData[outPtr++] = outData[ref++];
          } while (--len + 2);
        }
      } while (inPtr < inLength);
      return outData;
    }
    function parseHeader(data2) {
      const PCDheader2 = {};
      const result1 = data2.search(/[\r\n]DATA\s(\S*)\s/i);
      const result2 = /[\r\n]DATA\s(\S*)\s/i.exec(data2.substr(result1 - 1));
      PCDheader2.data = result2[1];
      PCDheader2.headerLen = result2[0].length + result1;
      PCDheader2.str = data2.substr(0, PCDheader2.headerLen);
      PCDheader2.str = PCDheader2.str.replace(/\#.*/gi, "");
      PCDheader2.version = /VERSION (.*)/i.exec(PCDheader2.str);
      PCDheader2.fields = /FIELDS (.*)/i.exec(PCDheader2.str);
      PCDheader2.size = /SIZE (.*)/i.exec(PCDheader2.str);
      PCDheader2.type = /TYPE (.*)/i.exec(PCDheader2.str);
      PCDheader2.count = /COUNT (.*)/i.exec(PCDheader2.str);
      PCDheader2.width = /WIDTH (.*)/i.exec(PCDheader2.str);
      PCDheader2.height = /HEIGHT (.*)/i.exec(PCDheader2.str);
      PCDheader2.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader2.str);
      PCDheader2.points = /POINTS (.*)/i.exec(PCDheader2.str);
      if (PCDheader2.version !== null)
        PCDheader2.version = parseFloat(PCDheader2.version[1]);
      if (PCDheader2.fields !== null)
        PCDheader2.fields = PCDheader2.fields[1].split(" ");
      if (PCDheader2.type !== null)
        PCDheader2.type = PCDheader2.type[1].split(" ");
      if (PCDheader2.width !== null)
        PCDheader2.width = parseInt(PCDheader2.width[1]);
      if (PCDheader2.height !== null)
        PCDheader2.height = parseInt(PCDheader2.height[1]);
      if (PCDheader2.viewpoint !== null)
        PCDheader2.viewpoint = PCDheader2.viewpoint[1];
      if (PCDheader2.points !== null)
        PCDheader2.points = parseInt(PCDheader2.points[1], 10);
      if (PCDheader2.points === null)
        PCDheader2.points = PCDheader2.width * PCDheader2.height;
      if (PCDheader2.size !== null) {
        PCDheader2.size = PCDheader2.size[1].split(" ").map(function(x) {
          return parseInt(x, 10);
        });
      }
      if (PCDheader2.count !== null) {
        PCDheader2.count = PCDheader2.count[1].split(" ").map(function(x) {
          return parseInt(x, 10);
        });
      } else {
        PCDheader2.count = [];
        for (let i2 = 0, l = PCDheader2.fields.length; i2 < l; i2++) {
          PCDheader2.count.push(1);
        }
      }
      PCDheader2.offset = {};
      let sizeSum = 0;
      for (let i2 = 0, l = PCDheader2.fields.length; i2 < l; i2++) {
        if (PCDheader2.data === "ascii") {
          PCDheader2.offset[PCDheader2.fields[i2]] = i2;
        } else {
          PCDheader2.offset[PCDheader2.fields[i2]] = sizeSum;
          sizeSum += PCDheader2.size[i2] * PCDheader2.count[i2];
        }
      }
      PCDheader2.rowSize = sizeSum;
      return PCDheader2;
    }
    const textData = LoaderUtils.decodeText(new Uint8Array(data));
    const PCDheader = parseHeader(textData);
    const position = [];
    const normal = [];
    const color2 = [];
    if (PCDheader.data === "ascii") {
      const offset = PCDheader.offset;
      const pcdData = textData.substr(PCDheader.headerLen);
      const lines = pcdData.split("\n");
      for (let i2 = 0, l = lines.length; i2 < l; i2++) {
        if (lines[i2] === "")
          continue;
        const line2 = lines[i2].split(" ");
        if (offset.x !== void 0) {
          position.push(parseFloat(line2[offset.x]));
          position.push(parseFloat(line2[offset.y]));
          position.push(parseFloat(line2[offset.z]));
        }
        if (offset.rgb !== void 0) {
          const rgb = parseFloat(line2[offset.rgb]);
          const r = rgb >> 16 & 255;
          const g2 = rgb >> 8 & 255;
          const b3 = rgb >> 0 & 255;
          color2.push(r / 255, g2 / 255, b3 / 255);
        }
        if (offset.normal_x !== void 0) {
          normal.push(parseFloat(line2[offset.normal_x]));
          normal.push(parseFloat(line2[offset.normal_y]));
          normal.push(parseFloat(line2[offset.normal_z]));
        }
      }
    }
    if (PCDheader.data === "binary_compressed") {
      const sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));
      const compressedSize = sizes[0];
      const decompressedSize = sizes[1];
      const decompressed = decompressLZF(new Uint8Array(data, PCDheader.headerLen + 8, compressedSize), decompressedSize);
      const dataview = new DataView(decompressed.buffer);
      const offset = PCDheader.offset;
      for (let i2 = 0; i2 < PCDheader.points; i2++) {
        if (offset.x !== void 0) {
          position.push(dataview.getFloat32(PCDheader.points * offset.x + PCDheader.size[0] * i2, this.littleEndian));
          position.push(dataview.getFloat32(PCDheader.points * offset.y + PCDheader.size[1] * i2, this.littleEndian));
          position.push(dataview.getFloat32(PCDheader.points * offset.z + PCDheader.size[2] * i2, this.littleEndian));
        }
        if (offset.rgb !== void 0) {
          color2.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i2 + 2) / 255);
          color2.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i2 + 1) / 255);
          color2.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i2 + 0) / 255);
        }
        if (offset.normal_x !== void 0) {
          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_x + PCDheader.size[4] * i2, this.littleEndian));
          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_y + PCDheader.size[5] * i2, this.littleEndian));
          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_z + PCDheader.size[6] * i2, this.littleEndian));
        }
      }
    }
    if (PCDheader.data === "binary") {
      const dataview = new DataView(data, PCDheader.headerLen);
      const offset = PCDheader.offset;
      for (let i2 = 0, row = 0; i2 < PCDheader.points; i2++, row += PCDheader.rowSize) {
        if (offset.x !== void 0) {
          position.push(dataview.getFloat32(row + offset.x, this.littleEndian));
          position.push(dataview.getFloat32(row + offset.y, this.littleEndian));
          position.push(dataview.getFloat32(row + offset.z, this.littleEndian));
        }
        if (offset.rgb !== void 0) {
          color2.push(dataview.getUint8(row + offset.rgb + 2) / 255);
          color2.push(dataview.getUint8(row + offset.rgb + 1) / 255);
          color2.push(dataview.getUint8(row + offset.rgb + 0) / 255);
        }
        if (offset.normal_x !== void 0) {
          normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian));
          normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian));
          normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian));
        }
      }
    }
    const geometry = new BufferGeometry();
    if (position.length > 0)
      geometry.setAttribute("position", new Float32BufferAttribute(position, 3));
    if (normal.length > 0)
      geometry.setAttribute("normal", new Float32BufferAttribute(normal, 3));
    if (color2.length > 0)
      geometry.setAttribute("color", new Float32BufferAttribute(color2, 3));
    geometry.computeBoundingSphere();
    const material = new PointsMaterial({
      size: 5e-3
    });
    if (color2.length > 0) {
      material.vertexColors = true;
    } else {
      material.color.setHex(Math.random() * 16777215);
    }
    const mesh = new Points(geometry, material);
    let name = url.split("").reverse().join("");
    name = /([^\/]*)/.exec(name);
    name = name[1].split("").reverse().join("");
    mesh.name = name;
    return mesh;
  }
};

// node_modules/three-stdlib/loaders/LWOLoader.js
var _lwoTree;
var LWOLoader = class extends Loader {
  constructor(manager, parameters = {}) {
    super(manager);
    this.resourcePath = parameters.resourcePath !== void 0 ? parameters.resourcePath : "";
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const path = scope2.path === "" ? extractParentUrl(url, "Objects") : scope2.path;
    const modelName = url.split(path).pop().split(".")[0];
    const loader = new FileLoader2(this.manager);
    loader.setPath(scope2.path);
    loader.setResponseType("arraybuffer");
    loader.load(url, function(buffer2) {
      try {
        onLoad(scope2.parse(buffer2, path, modelName));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(iffBuffer, path, modelName) {
    _lwoTree = new IFFParser().parse(iffBuffer);
    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    return new LWOTreeParser(textureLoader).parse(modelName);
  }
};
var LWOTreeParser = class {
  constructor(textureLoader) {
    this.textureLoader = textureLoader;
  }
  parse(modelName) {
    this.materials = new MaterialParser(this.textureLoader).parse();
    this.defaultLayerName = modelName;
    this.meshes = this.parseLayers();
    return {
      materials: this.materials,
      meshes: this.meshes
    };
  }
  parseLayers() {
    const meshes = [];
    const finalMeshes = [];
    const geometryParser = new GeometryParser2();
    const scope2 = this;
    _lwoTree.layers.forEach(function(layer) {
      const geometry = geometryParser.parse(layer.geometry, layer);
      const mesh = scope2.parseMesh(geometry, layer);
      meshes[layer.number] = mesh;
      if (layer.parent === -1)
        finalMeshes.push(mesh);
      else
        meshes[layer.parent].add(mesh);
    });
    this.applyPivots(finalMeshes);
    return finalMeshes;
  }
  parseMesh(geometry, layer) {
    let mesh;
    const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);
    this.duplicateUVs(geometry, materials);
    if (layer.geometry.type === "points")
      mesh = new Points(geometry, materials);
    else if (layer.geometry.type === "lines")
      mesh = new LineSegments(geometry, materials);
    else
      mesh = new Mesh(geometry, materials);
    if (layer.name)
      mesh.name = layer.name;
    else
      mesh.name = this.defaultLayerName + "_layer_" + layer.number;
    mesh.userData.pivot = layer.pivot;
    return mesh;
  }
  applyPivots(meshes) {
    meshes.forEach(function(mesh) {
      mesh.traverse(function(child) {
        const pivot = child.userData.pivot;
        child.position.x += pivot[0];
        child.position.y += pivot[1];
        child.position.z += pivot[2];
        if (child.parent) {
          const parentPivot = child.parent.userData.pivot;
          child.position.x -= parentPivot[0];
          child.position.y -= parentPivot[1];
          child.position.z -= parentPivot[2];
        }
      });
    });
  }
  getMaterials(namesArray, type2) {
    const materials = [];
    const scope2 = this;
    namesArray.forEach(function(name, i2) {
      materials[i2] = scope2.getMaterialByName(name);
    });
    if (type2 === "points" || type2 === "lines") {
      materials.forEach(function(mat, i2) {
        const spec = {
          color: mat.color
        };
        if (type2 === "points") {
          spec.size = 0.1;
          spec.map = mat.map;
          spec.morphTargets = mat.morphTargets;
          materials[i2] = new PointsMaterial(spec);
        } else if (type2 === "lines") {
          materials[i2] = new LineBasicMaterial(spec);
        }
      });
    }
    const filtered = materials.filter(Boolean);
    if (filtered.length === 1)
      return filtered[0];
    return materials;
  }
  getMaterialByName(name) {
    return this.materials.filter(function(m) {
      return m.name === name;
    })[0];
  }
  duplicateUVs(geometry, materials) {
    let duplicateUVs = false;
    if (!Array.isArray(materials)) {
      if (materials.aoMap)
        duplicateUVs = true;
    } else {
      materials.forEach(function(material) {
        if (material.aoMap)
          duplicateUVs = true;
      });
    }
    if (!duplicateUVs)
      return;
    geometry.setAttribute("uv2", new BufferAttribute(geometry.attributes.uv.array, 2));
  }
};
var MaterialParser = class {
  constructor(textureLoader) {
    this.textureLoader = textureLoader;
  }
  parse() {
    const materials = [];
    this.textures = {};
    for (const name in _lwoTree.materials) {
      if (_lwoTree.format === "LWO3") {
        materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));
      } else if (_lwoTree.format === "LWO2") {
        materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));
      }
    }
    return materials;
  }
  parseMaterial(materialData, name, textures) {
    let params = {
      name,
      side: this.getSide(materialData.attributes),
      flatShading: this.getSmooth(materialData.attributes)
    };
    const connections2 = this.parseConnections(materialData.connections, materialData.nodes);
    const maps = this.parseTextureNodes(connections2.maps);
    this.parseAttributeImageMaps(connections2.attributes, textures, maps, materialData.maps);
    const attributes = this.parseAttributes(connections2.attributes, maps);
    this.parseEnvMap(connections2, maps, attributes);
    params = Object.assign(maps, params);
    params = Object.assign(params, attributes);
    const materialType = this.getMaterialType(connections2.attributes);
    return new materialType(params);
  }
  parseMaterialLwo2(materialData, name) {
    let params = {
      name,
      side: this.getSide(materialData.attributes),
      flatShading: this.getSmooth(materialData.attributes)
    };
    const attributes = this.parseAttributes(materialData.attributes, {});
    params = Object.assign(params, attributes);
    return new MeshPhongMaterial(params);
  }
  getSide(attributes) {
    if (!attributes.side)
      return BackSide;
    switch (attributes.side) {
      case 0:
      case 1:
        return BackSide;
      case 2:
        return FrontSide;
      case 3:
        return DoubleSide;
    }
  }
  getSmooth(attributes) {
    if (!attributes.smooth)
      return true;
    return !attributes.smooth;
  }
  parseConnections(connections2, nodes) {
    const materialConnections = {
      maps: {}
    };
    const inputName = connections2.inputName;
    const inputNodeName = connections2.inputNodeName;
    const nodeName = connections2.nodeName;
    const scope2 = this;
    inputName.forEach(function(name, index) {
      if (name === "Material") {
        const matNode = scope2.getNodeByRefName(inputNodeName[index], nodes);
        materialConnections.attributes = matNode.attributes;
        materialConnections.envMap = matNode.fileName;
        materialConnections.name = inputNodeName[index];
      }
    });
    nodeName.forEach(function(name, index) {
      if (name === materialConnections.name) {
        materialConnections.maps[inputName[index]] = scope2.getNodeByRefName(inputNodeName[index], nodes);
      }
    });
    return materialConnections;
  }
  getNodeByRefName(refName, nodes) {
    for (const name in nodes) {
      if (nodes[name].refName === refName)
        return nodes[name];
    }
  }
  parseTextureNodes(textureNodes) {
    const maps = {};
    for (const name in textureNodes) {
      const node = textureNodes[name];
      const path = node.fileName;
      if (!path)
        return;
      const texture2 = this.loadTexture(path);
      if (node.widthWrappingMode !== void 0)
        texture2.wrapS = this.getWrappingType(node.widthWrappingMode);
      if (node.heightWrappingMode !== void 0)
        texture2.wrapT = this.getWrappingType(node.heightWrappingMode);
      switch (name) {
        case "Color":
          maps.map = texture2;
          break;
        case "Roughness":
          maps.roughnessMap = texture2;
          maps.roughness = 0.5;
          break;
        case "Specular":
          maps.specularMap = texture2;
          maps.specular = 16777215;
          break;
        case "Luminous":
          maps.emissiveMap = texture2;
          maps.emissive = 8421504;
          break;
        case "Luminous Color":
          maps.emissive = 8421504;
          break;
        case "Metallic":
          maps.metalnessMap = texture2;
          maps.metalness = 0.5;
          break;
        case "Transparency":
        case "Alpha":
          maps.alphaMap = texture2;
          maps.transparent = true;
          break;
        case "Normal":
          maps.normalMap = texture2;
          if (node.amplitude !== void 0)
            maps.normalScale = new Vector2(node.amplitude, node.amplitude);
          break;
        case "Bump":
          maps.bumpMap = texture2;
          break;
      }
    }
    if (maps.roughnessMap && maps.specularMap)
      delete maps.specularMap;
    return maps;
  }
  parseAttributeImageMaps(attributes, textures, maps) {
    for (const name in attributes) {
      const attribute2 = attributes[name];
      if (attribute2.maps) {
        const mapData = attribute2.maps[0];
        const path = this.getTexturePathByIndex(mapData.imageIndex, textures);
        if (!path)
          return;
        const texture2 = this.loadTexture(path);
        if (mapData.wrap !== void 0)
          texture2.wrapS = this.getWrappingType(mapData.wrap.w);
        if (mapData.wrap !== void 0)
          texture2.wrapT = this.getWrappingType(mapData.wrap.h);
        switch (name) {
          case "Color":
            maps.map = texture2;
            break;
          case "Diffuse":
            maps.aoMap = texture2;
            break;
          case "Roughness":
            maps.roughnessMap = texture2;
            maps.roughness = 1;
            break;
          case "Specular":
            maps.specularMap = texture2;
            maps.specular = 16777215;
            break;
          case "Luminosity":
            maps.emissiveMap = texture2;
            maps.emissive = 8421504;
            break;
          case "Metallic":
            maps.metalnessMap = texture2;
            maps.metalness = 1;
            break;
          case "Transparency":
          case "Alpha":
            maps.alphaMap = texture2;
            maps.transparent = true;
            break;
          case "Normal":
            maps.normalMap = texture2;
            break;
          case "Bump":
            maps.bumpMap = texture2;
            break;
        }
      }
    }
  }
  parseAttributes(attributes, maps) {
    const params = {};
    if (attributes.Color && !maps.map) {
      params.color = new Color().fromArray(attributes.Color.value);
    } else {
      params.color = new Color();
    }
    if (attributes.Transparency && attributes.Transparency.value !== 0) {
      params.opacity = 1 - attributes.Transparency.value;
      params.transparent = true;
    }
    if (attributes["Bump Height"])
      params.bumpScale = attributes["Bump Height"].value * 0.1;
    if (attributes["Refraction Index"])
      params.refractionRatio = 1 / attributes["Refraction Index"].value;
    this.parsePhysicalAttributes(params, attributes, maps);
    this.parseStandardAttributes(params, attributes, maps);
    this.parsePhongAttributes(params, attributes, maps);
    return params;
  }
  parsePhysicalAttributes(params, attributes) {
    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {
      params.clearcoat = attributes.Clearcoat.value;
      if (attributes["Clearcoat Gloss"]) {
        params.clearcoatRoughness = 0.5 * (1 - attributes["Clearcoat Gloss"].value);
      }
    }
  }
  parseStandardAttributes(params, attributes, maps) {
    if (attributes.Luminous) {
      params.emissiveIntensity = attributes.Luminous.value;
      if (attributes["Luminous Color"] && !maps.emissive) {
        params.emissive = new Color().fromArray(attributes["Luminous Color"].value);
      } else {
        params.emissive = new Color(8421504);
      }
    }
    if (attributes.Roughness && !maps.roughnessMap)
      params.roughness = attributes.Roughness.value;
    if (attributes.Metallic && !maps.metalnessMap)
      params.metalness = attributes.Metallic.value;
  }
  parsePhongAttributes(params, attributes, maps) {
    if (attributes.Diffuse)
      params.color.multiplyScalar(attributes.Diffuse.value);
    if (attributes.Reflection) {
      params.reflectivity = attributes.Reflection.value;
      params.combine = AddOperation;
    }
    if (attributes.Luminosity) {
      params.emissiveIntensity = attributes.Luminosity.value;
      if (!maps.emissiveMap && !maps.map) {
        params.emissive = params.color;
      } else {
        params.emissive = new Color(8421504);
      }
    }
    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {
      if (attributes["Color Highlight"]) {
        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes["Color Highlight"].value);
      } else {
        params.specular = new Color().setScalar(attributes.Specular.value);
      }
    }
    if (params.specular && attributes.Glossiness) {
      params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);
    }
  }
  parseEnvMap(connections2, maps, attributes) {
    if (connections2.envMap) {
      const envMap = this.loadTexture(connections2.envMap);
      if (attributes.transparent && attributes.opacity < 0.999) {
        envMap.mapping = EquirectangularRefractionMapping;
        if (attributes.reflectivity !== void 0) {
          delete attributes.reflectivity;
          delete attributes.combine;
        }
        if (attributes.metalness !== void 0) {
          delete attributes.metalness;
        }
      } else {
        envMap.mapping = EquirectangularReflectionMapping;
      }
      maps.envMap = envMap;
    }
  }
  getTexturePathByIndex(index) {
    let fileName = "";
    if (!_lwoTree.textures)
      return fileName;
    _lwoTree.textures.forEach(function(texture2) {
      if (texture2.index === index)
        fileName = texture2.fileName;
    });
    return fileName;
  }
  loadTexture(path) {
    if (!path)
      return null;
    const texture2 = this.textureLoader.load(path, void 0, void 0, function() {
      console.warn("LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.");
    });
    return texture2;
  }
  getWrappingType(num) {
    switch (num) {
      case 0:
        console.warn('LWOLoader: "Reset" texture wrapping type is not supported in three.js');
        return ClampToEdgeWrapping;
      case 1:
        return RepeatWrapping;
      case 2:
        return MirroredRepeatWrapping;
      case 3:
        return ClampToEdgeWrapping;
    }
  }
  getMaterialType(nodeData) {
    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0)
      return MeshPhysicalMaterial;
    if (nodeData.Roughness)
      return MeshStandardMaterial;
    return MeshPhongMaterial;
  }
};
var GeometryParser2 = class {
  parse(geoData, layer) {
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(geoData.points, 3));
    const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);
    geometry.setIndex(indices);
    this.parseGroups(geometry, geoData);
    geometry.computeVertexNormals();
    this.parseUVs(geometry, layer, indices);
    this.parseMorphTargets(geometry, layer, indices);
    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]);
    return geometry;
  }
  splitIndices(indices, polygonDimensions) {
    const remappedIndices = [];
    let i2 = 0;
    polygonDimensions.forEach(function(dim) {
      if (dim < 4) {
        for (let k = 0; k < dim; k++)
          remappedIndices.push(indices[i2 + k]);
      } else if (dim === 4) {
        remappedIndices.push(indices[i2], indices[i2 + 1], indices[i2 + 2], indices[i2], indices[i2 + 2], indices[i2 + 3]);
      } else if (dim > 4) {
        for (let k = 1; k < dim - 1; k++) {
          remappedIndices.push(indices[i2], indices[i2 + k], indices[i2 + k + 1]);
        }
        console.warn("LWOLoader: polygons with greater than 4 sides are not supported");
      }
      i2 += dim;
    });
    return remappedIndices;
  }
  parseGroups(geometry, geoData) {
    const tags = _lwoTree.tags;
    const matNames = [];
    let elemSize = 3;
    if (geoData.type === "lines")
      elemSize = 2;
    if (geoData.type === "points")
      elemSize = 1;
    const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);
    let indexNum = 0;
    const indexPairs = {};
    let prevMaterialIndex;
    let materialIndex;
    let prevStart = 0;
    let currentCount = 0;
    for (let i2 = 0; i2 < remappedIndices.length; i2 += 2) {
      materialIndex = remappedIndices[i2 + 1];
      if (i2 === 0)
        matNames[indexNum] = tags[materialIndex];
      if (prevMaterialIndex === void 0)
        prevMaterialIndex = materialIndex;
      if (materialIndex !== prevMaterialIndex) {
        let currentIndex;
        if (indexPairs[tags[prevMaterialIndex]]) {
          currentIndex = indexPairs[tags[prevMaterialIndex]];
        } else {
          currentIndex = indexNum;
          indexPairs[tags[prevMaterialIndex]] = indexNum;
          matNames[indexNum] = tags[prevMaterialIndex];
          indexNum++;
        }
        geometry.addGroup(prevStart, currentCount, currentIndex);
        prevStart += currentCount;
        prevMaterialIndex = materialIndex;
        currentCount = 0;
      }
      currentCount += elemSize;
    }
    if (geometry.groups.length > 0) {
      let currentIndex;
      if (indexPairs[tags[materialIndex]]) {
        currentIndex = indexPairs[tags[materialIndex]];
      } else {
        currentIndex = indexNum;
        indexPairs[tags[materialIndex]] = indexNum;
        matNames[indexNum] = tags[materialIndex];
      }
      geometry.addGroup(prevStart, currentCount, currentIndex);
    }
    geometry.userData.matNames = matNames;
  }
  splitMaterialIndices(polygonDimensions, indices) {
    const remappedIndices = [];
    polygonDimensions.forEach(function(dim, i2) {
      if (dim <= 3) {
        remappedIndices.push(indices[i2 * 2], indices[i2 * 2 + 1]);
      } else if (dim === 4) {
        remappedIndices.push(indices[i2 * 2], indices[i2 * 2 + 1], indices[i2 * 2], indices[i2 * 2 + 1]);
      } else {
        for (let k = 0; k < dim - 2; k++) {
          remappedIndices.push(indices[i2 * 2], indices[i2 * 2 + 1]);
        }
      }
    });
    return remappedIndices;
  }
  parseUVs(geometry, layer) {
    const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function() {
      return 0;
    });
    for (const name in layer.uvs) {
      const uvs = layer.uvs[name].uvs;
      const uvIndices = layer.uvs[name].uvIndices;
      uvIndices.forEach(function(i2, j2) {
        remappedUVs[i2 * 2] = uvs[j2 * 2];
        remappedUVs[i2 * 2 + 1] = uvs[j2 * 2 + 1];
      });
    }
    geometry.setAttribute("uv", new Float32BufferAttribute(remappedUVs, 2));
  }
  parseMorphTargets(geometry, layer) {
    let num = 0;
    for (const name in layer.morphTargets) {
      const remappedPoints = geometry.attributes.position.array.slice();
      if (!geometry.morphAttributes.position)
        geometry.morphAttributes.position = [];
      const morphPoints = layer.morphTargets[name].points;
      const morphIndices = layer.morphTargets[name].indices;
      const type2 = layer.morphTargets[name].type;
      morphIndices.forEach(function(i2, j2) {
        if (type2 === "relative") {
          remappedPoints[i2 * 3] += morphPoints[j2 * 3];
          remappedPoints[i2 * 3 + 1] += morphPoints[j2 * 3 + 1];
          remappedPoints[i2 * 3 + 2] += morphPoints[j2 * 3 + 2];
        } else {
          remappedPoints[i2 * 3] = morphPoints[j2 * 3];
          remappedPoints[i2 * 3 + 1] = morphPoints[j2 * 3 + 1];
          remappedPoints[i2 * 3 + 2] = morphPoints[j2 * 3 + 2];
        }
      });
      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);
      geometry.morphAttributes.position[num].name = name;
      num++;
    }
    geometry.morphTargetsRelative = false;
  }
};
function extractParentUrl(url, dir) {
  const index = url.indexOf(dir);
  if (index === -1)
    return "./";
  return url.substr(0, index);
}

// node_modules/three-stdlib/loaders/PLYLoader.js
var PLYLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.propertyNameMapping = {};
  }
  load(url, onLoad, onProgress, onError) {
    const scope2 = this;
    const loader = new FileLoader2(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope2.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope2.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  setPropertyNameMapping(mapping) {
    this.propertyNameMapping = mapping;
  }
  parse(data) {
    function parseHeader(data2) {
      const patternHeader = /ply([\s\S]*)end_header\r?\n/;
      let headerText = "";
      let headerLength = 0;
      const result = patternHeader.exec(data2);
      if (result !== null) {
        headerText = result[1];
        headerLength = new Blob([result[0]]).size;
      }
      const header = {
        comments: [],
        elements: [],
        headerLength,
        objInfo: ""
      };
      const lines = headerText.split("\n");
      let currentElement;
      function make_ply_element_property(propertValues, propertyNameMapping) {
        const property = {
          type: propertValues[0]
        };
        if (property.type === "list") {
          property.name = propertValues[3];
          property.countType = propertValues[1];
          property.itemType = propertValues[2];
        } else {
          property.name = propertValues[1];
        }
        if (property.name in propertyNameMapping) {
          property.name = propertyNameMapping[property.name];
        }
        return property;
      }
      for (let i2 = 0; i2 < lines.length; i2++) {
        let line2 = lines[i2];
        line2 = line2.trim();
        if (line2 === "")
          continue;
        const lineValues = line2.split(/\s+/);
        const lineType = lineValues.shift();
        line2 = lineValues.join(" ");
        switch (lineType) {
          case "format":
            header.format = lineValues[0];
            header.version = lineValues[1];
            break;
          case "comment":
            header.comments.push(line2);
            break;
          case "element":
            if (currentElement !== void 0) {
              header.elements.push(currentElement);
            }
            currentElement = {};
            currentElement.name = lineValues[0];
            currentElement.count = parseInt(lineValues[1]);
            currentElement.properties = [];
            break;
          case "property":
            currentElement.properties.push(make_ply_element_property(lineValues, scope2.propertyNameMapping));
            break;
          case "obj_info":
            header.objInfo = line2;
            break;
          default:
            console.log("unhandled", lineType, lineValues);
        }
      }
      if (currentElement !== void 0) {
        header.elements.push(currentElement);
      }
      return header;
    }
    function parseASCIINumber(n, type2) {
      switch (type2) {
        case "char":
        case "uchar":
        case "short":
        case "ushort":
        case "int":
        case "uint":
        case "int8":
        case "uint8":
        case "int16":
        case "uint16":
        case "int32":
        case "uint32":
          return parseInt(n);
        case "float":
        case "double":
        case "float32":
        case "float64":
          return parseFloat(n);
      }
    }
    function parseASCIIElement(properties, line2) {
      const values = line2.split(/\s+/);
      const element2 = {};
      for (let i2 = 0; i2 < properties.length; i2++) {
        if (properties[i2].type === "list") {
          const list = [];
          const n = parseASCIINumber(values.shift(), properties[i2].countType);
          for (let j2 = 0; j2 < n; j2++) {
            list.push(parseASCIINumber(values.shift(), properties[i2].itemType));
          }
          element2[properties[i2].name] = list;
        } else {
          element2[properties[i2].name] = parseASCIINumber(values.shift(), properties[i2].type);
        }
      }
      return element2;
    }
    function parseASCII(data2, header) {
      const buffer2 = {
        indices: [],
        vertices: [],
        normals: [],
        uvs: [],
        faceVertexUvs: [],
        colors: []
      };
      let result;
      const patternBody = /end_header\s([\s\S]*)$/;
      let body = "";
      if ((result = patternBody.exec(data2)) !== null) {
        body = result[1];
      }
      const lines = body.split("\n");
      let currentElement = 0;
      let currentElementCount = 0;
      for (let i2 = 0; i2 < lines.length; i2++) {
        let line2 = lines[i2];
        line2 = line2.trim();
        if (line2 === "") {
          continue;
        }
        if (currentElementCount >= header.elements[currentElement].count) {
          currentElement++;
          currentElementCount = 0;
        }
        const element2 = parseASCIIElement(header.elements[currentElement].properties, line2);
        handleElement(buffer2, header.elements[currentElement].name, element2);
        currentElementCount++;
      }
      return postProcess(buffer2);
    }
    function postProcess(buffer2) {
      let geometry2 = new BufferGeometry();
      if (buffer2.indices.length > 0) {
        geometry2.setIndex(buffer2.indices);
      }
      geometry2.setAttribute("position", new Float32BufferAttribute(buffer2.vertices, 3));
      if (buffer2.normals.length > 0) {
        geometry2.setAttribute("normal", new Float32BufferAttribute(buffer2.normals, 3));
      }
      if (buffer2.uvs.length > 0) {
        geometry2.setAttribute("uv", new Float32BufferAttribute(buffer2.uvs, 2));
      }
      if (buffer2.colors.length > 0) {
        geometry2.setAttribute("color", new Float32BufferAttribute(buffer2.colors, 3));
      }
      if (buffer2.faceVertexUvs.length > 0) {
        geometry2 = geometry2.toNonIndexed();
        geometry2.setAttribute("uv", new Float32BufferAttribute(buffer2.faceVertexUvs, 2));
      }
      geometry2.computeBoundingSphere();
      return geometry2;
    }
    function handleElement(buffer2, elementName, element2) {
      if (elementName === "vertex") {
        buffer2.vertices.push(element2.x, element2.y, element2.z);
        if ("nx" in element2 && "ny" in element2 && "nz" in element2) {
          buffer2.normals.push(element2.nx, element2.ny, element2.nz);
        }
        if ("s" in element2 && "t" in element2) {
          buffer2.uvs.push(element2.s, element2.t);
        }
        if ("red" in element2 && "green" in element2 && "blue" in element2) {
          buffer2.colors.push(element2.red / 255, element2.green / 255, element2.blue / 255);
        }
      } else if (elementName === "face") {
        const vertex_indices = element2.vertex_indices || element2.vertex_index;
        const texcoord = element2.texcoord;
        if (vertex_indices.length === 3) {
          buffer2.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);
          if (texcoord && texcoord.length === 6) {
            buffer2.faceVertexUvs.push(texcoord[0], texcoord[1]);
            buffer2.faceVertexUvs.push(texcoord[2], texcoord[3]);
            buffer2.faceVertexUvs.push(texcoord[4], texcoord[5]);
          }
        } else if (vertex_indices.length === 4) {
          buffer2.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);
          buffer2.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);
        }
      }
    }
    function binaryRead(dataview, at, type2, little_endian) {
      switch (type2) {
        case "int8":
        case "char":
          return [dataview.getInt8(at), 1];
        case "uint8":
        case "uchar":
          return [dataview.getUint8(at), 1];
        case "int16":
        case "short":
          return [dataview.getInt16(at, little_endian), 2];
        case "uint16":
        case "ushort":
          return [dataview.getUint16(at, little_endian), 2];
        case "int32":
        case "int":
          return [dataview.getInt32(at, little_endian), 4];
        case "uint32":
        case "uint":
          return [dataview.getUint32(at, little_endian), 4];
        case "float32":
        case "float":
          return [dataview.getFloat32(at, little_endian), 4];
        case "float64":
        case "double":
          return [dataview.getFloat64(at, little_endian), 8];
      }
    }
    function binaryReadElement(dataview, at, properties, little_endian) {
      const element2 = {};
      let result, read2 = 0;
      for (let i2 = 0; i2 < properties.length; i2++) {
        if (properties[i2].type === "list") {
          const list = [];
          result = binaryRead(dataview, at + read2, properties[i2].countType, little_endian);
          const n = result[0];
          read2 += result[1];
          for (let j2 = 0; j2 < n; j2++) {
            result = binaryRead(dataview, at + read2, properties[i2].itemType, little_endian);
            list.push(result[0]);
            read2 += result[1];
          }
          element2[properties[i2].name] = list;
        } else {
          result = binaryRead(dataview, at + read2, properties[i2].type, little_endian);
          element2[properties[i2].name] = result[0];
          read2 += result[1];
        }
      }
      return [element2, read2];
    }
    function parseBinary(data2, header) {
      const buffer2 = {
        indices: [],
        vertices: [],
        normals: [],
        uvs: [],
        faceVertexUvs: [],
        colors: []
      };
      const little_endian = header.format === "binary_little_endian";
      const body = new DataView(data2, header.headerLength);
      let result, loc = 0;
      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {
        for (let currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {
          result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);
          loc += result[1];
          const element2 = result[0];
          handleElement(buffer2, header.elements[currentElement].name, element2);
        }
      }
      return postProcess(buffer2);
    }
    let geometry;
    const scope2 = this;
    if (data instanceof ArrayBuffer) {
      const text = LoaderUtils.decodeText(new Uint8Array(data));
      const header = parseHeader(text);
      geometry = header.format === "ascii" ? parseASCII(text, header) : parseBinary(data, header);
    } else {
      geometry = parseASCII(data, parseHeader(data));
    }
    return geometry;
  }
};

// node_modules/three-stdlib/lines/LineSegmentsGeometry.js
var _box = new Box3();
var _vector2 = new Vector3();
var LineSegmentsGeometry = class extends InstancedBufferGeometry {
  constructor() {
    super();
    this.isLineSegmentsGeometry = true;
    this.type = "LineSegmentsGeometry";
    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(index);
    this.setAttribute("position", new Float32BufferAttribute(positions, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  applyMatrix4(matrix3) {
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0) {
      start.applyMatrix4(matrix3);
      end.applyMatrix4(matrix3);
      start.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  setPositions(array) {
    let lineSegments;
    if (array instanceof Float32Array) {
      lineSegments = array;
    } else if (Array.isArray(array)) {
      lineSegments = new Float32Array(array);
    }
    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1);
    this.setAttribute("instanceStart", new InterleavedBufferAttribute(instanceBuffer, 3, 0));
    this.setAttribute("instanceEnd", new InterleavedBufferAttribute(instanceBuffer, 3, 3));
    this.computeBoundingBox();
    this.computeBoundingSphere();
    return this;
  }
  setColors(array) {
    let colors;
    if (array instanceof Float32Array) {
      colors = array;
    } else if (Array.isArray(array)) {
      colors = new Float32Array(array);
    }
    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1);
    this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(instanceColorBuffer, 3, 0));
    this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(instanceColorBuffer, 3, 3));
    return this;
  }
  fromWireframeGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  fromEdgesGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  fromMesh(mesh) {
    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry));
    return this;
  }
  fromLineSegments(lineSegments) {
    const geometry = lineSegments.geometry;
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0 && end !== void 0) {
      this.boundingBox.setFromBufferAttribute(start);
      _box.setFromBufferAttribute(end);
      this.boundingBox.union(_box);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    if (this.boundingBox === null) {
      this.computeBoundingBox();
    }
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0 && end !== void 0) {
      const center = this.boundingSphere.center;
      this.boundingBox.getCenter(center);
      let maxRadiusSq = 0;
      for (let i2 = 0, il = start.count; i2 < il; i2++) {
        _vector2.fromBufferAttribute(start, i2);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector2));
        _vector2.fromBufferAttribute(end, i2);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector2));
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
      }
    }
  }
  toJSON() {
  }
  applyMatrix(matrix3) {
    console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().");
    return this.applyMatrix4(matrix3);
  }
};

// node_modules/three-stdlib/lines/LineGeometry.js
var LineGeometry = class extends LineSegmentsGeometry {
  constructor() {
    super();
    this.isLineGeometry = true;
    this.type = "LineGeometry";
  }
  setPositions(array) {
    const length2 = array.length - 3;
    const points = new Float32Array(2 * length2);
    for (let i2 = 0; i2 < length2; i2 += 3) {
      points[2 * i2] = array[i2];
      points[2 * i2 + 1] = array[i2 + 1];
      points[2 * i2 + 2] = array[i2 + 2];
      points[2 * i2 + 3] = array[i2 + 3];
      points[2 * i2 + 4] = array[i2 + 4];
      points[2 * i2 + 5] = array[i2 + 5];
    }
    super.setPositions(points);
    return this;
  }
  setColors(array) {
    const length2 = array.length - 3;
    const colors = new Float32Array(2 * length2);
    for (let i2 = 0; i2 < length2; i2 += 3) {
      colors[2 * i2] = array[i2];
      colors[2 * i2 + 1] = array[i2 + 1];
      colors[2 * i2 + 2] = array[i2 + 2];
      colors[2 * i2 + 3] = array[i2 + 3];
      colors[2 * i2 + 4] = array[i2 + 4];
      colors[2 * i2 + 5] = array[i2 + 5];
    }
    super.setColors(colors);
    return this;
  }
  fromLine(line2) {
    const geometry = line2.geometry;
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
};

// node_modules/three-stdlib/lines/LineMaterial.js
UniformsLib.line = {
  worldUnits: {
    value: 1
  },
  linewidth: {
    value: 1
  },
  resolution: {
    value: new Vector2(1, 1)
  },
  dashOffset: {
    value: 0
  },
  dashScale: {
    value: 1
  },
  dashSize: {
    value: 1
  },
  gapSize: {
    value: 1
  }
};
ShaderLib["line"] = {
  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, UniformsLib.line]),
  vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
  fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
};
var LineMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super({
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(ShaderLib["line"].uniforms),
      vertexShader: ShaderLib["line"].vertexShader,
      fragmentShader: ShaderLib["line"].fragmentShader,
      clipping: true
    });
    this.isLineMaterial = true;
    Object.defineProperties(this, {
      color: {
        enumerable: true,
        get: function() {
          return this.uniforms.diffuse.value;
        },
        set: function(value) {
          this.uniforms.diffuse.value = value;
        }
      },
      worldUnits: {
        enumerable: true,
        get: function() {
          return "WORLD_UNITS" in this.defines;
        },
        set: function(value) {
          if (value === true) {
            this.defines.WORLD_UNITS = "";
          } else {
            delete this.defines.WORLD_UNITS;
          }
        }
      },
      linewidth: {
        enumerable: true,
        get: function() {
          return this.uniforms.linewidth.value;
        },
        set: function(value) {
          this.uniforms.linewidth.value = value;
        }
      },
      dashed: {
        enumerable: true,
        get: function() {
          return Boolean("USE_DASH" in this.defines);
        },
        set(value) {
          if (Boolean(value) !== Boolean("USE_DASH" in this.defines)) {
            this.needsUpdate = true;
          }
          if (value === true) {
            this.defines.USE_DASH = "";
          } else {
            delete this.defines.USE_DASH;
          }
        }
      },
      dashScale: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashScale.value;
        },
        set: function(value) {
          this.uniforms.dashScale.value = value;
        }
      },
      dashSize: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashSize.value;
        },
        set: function(value) {
          this.uniforms.dashSize.value = value;
        }
      },
      dashOffset: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashOffset.value;
        },
        set: function(value) {
          this.uniforms.dashOffset.value = value;
        }
      },
      gapSize: {
        enumerable: true,
        get: function() {
          return this.uniforms.gapSize.value;
        },
        set: function(value) {
          this.uniforms.gapSize.value = value;
        }
      },
      opacity: {
        enumerable: true,
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(value) {
          this.uniforms.opacity.value = value;
        }
      },
      resolution: {
        enumerable: true,
        get: function() {
          return this.uniforms.resolution.value;
        },
        set: function(value) {
          this.uniforms.resolution.value.copy(value);
        }
      },
      alphaToCoverage: {
        enumerable: true,
        get: function() {
          return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
        },
        set: function(value) {
          if (Boolean(value) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines)) {
            this.needsUpdate = true;
          }
          if (value === true) {
            this.defines.USE_ALPHA_TO_COVERAGE = "";
            this.extensions.derivatives = true;
          } else {
            delete this.defines.USE_ALPHA_TO_COVERAGE;
            this.extensions.derivatives = false;
          }
        }
      }
    });
    this.setValues(parameters);
  }
};

// node_modules/three-stdlib/lines/Wireframe.js
var _start = new Vector3();
var _end = new Vector3();
var Wireframe = class extends Mesh {
  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({
    color: Math.random() * 16777215
  })) {
    super(geometry, material);
    this.isWireframe = true;
    this.type = "Wireframe";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    const instanceStart = geometry.attributes.instanceStart;
    const instanceEnd = geometry.attributes.instanceEnd;
    const lineDistances = new Float32Array(2 * instanceStart.count);
    for (let i2 = 0, j2 = 0, l = instanceStart.count; i2 < l; i2++, j2 += 2) {
      _start.fromBufferAttribute(instanceStart, i2);
      _end.fromBufferAttribute(instanceEnd, i2);
      lineDistances[j2] = j2 === 0 ? 0 : lineDistances[j2 - 1];
      lineDistances[j2 + 1] = lineDistances[j2] + _start.distanceTo(_end);
    }
    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);
    geometry.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));
    geometry.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));
    return this;
  }
};

// node_modules/three-stdlib/lines/WireframeGeometry2.js
var WireframeGeometry2 = class extends LineSegmentsGeometry {
  constructor(geometry) {
    super();
    this.isWireframeGeometry2 = true;
    this.type = "WireframeGeometry2";
    this.fromWireframeGeometry(new WireframeGeometry(geometry));
  }
};

// node_modules/three-stdlib/lines/LineSegments2.js
var _start2 = new Vector3();
var _end2 = new Vector3();
var _start4 = new Vector4();
var _end4 = new Vector4();
var _ssOrigin = new Vector4();
var _ssOrigin3 = new Vector3();
var _mvMatrix = new Matrix4();
var _line = new Line3();
var _closestPoint2 = new Vector3();
var _box2 = new Box3();
var _sphere = new Sphere();
var _clipToWorldVector = new Vector4();
var _ray2;
var _instanceStart;
var _instanceEnd;
var _lineWidth;
function getWorldSpaceHalfWidth(camera, distance2, resolution) {
  _clipToWorldVector.set(0, 0, -distance2, 1).applyMatrix4(camera.projectionMatrix);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  _clipToWorldVector.x = _lineWidth / resolution.width;
  _clipToWorldVector.y = _lineWidth / resolution.height;
  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));
}
function raycastWorldUnits(lineSegments, intersects) {
  for (let i2 = 0, l = _instanceStart.count; i2 < l; i2++) {
    _line.start.fromBufferAttribute(_instanceStart, i2);
    _line.end.fromBufferAttribute(_instanceEnd, i2);
    const pointOnLine = new Vector3();
    const point = new Vector3();
    _ray2.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;
    if (isInside) {
      intersects.push({
        point,
        pointOnLine,
        distance: _ray2.origin.distanceTo(point),
        object: lineSegments,
        face: null,
        faceIndex: i2,
        uv: null,
        uv2: null
      });
    }
  }
}
function raycastScreenSpace(lineSegments, camera, intersects) {
  const projectionMatrix = camera.projectionMatrix;
  const material = lineSegments.material;
  const resolution = material.resolution;
  const matrixWorld = lineSegments.matrixWorld;
  const geometry = lineSegments.geometry;
  const instanceStart = geometry.attributes.instanceStart;
  const instanceEnd = geometry.attributes.instanceEnd;
  const near = -camera.near;
  _ray2.at(1, _ssOrigin);
  _ssOrigin.w = 1;
  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);
  _ssOrigin.applyMatrix4(projectionMatrix);
  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);
  _ssOrigin.x *= resolution.x / 2;
  _ssOrigin.y *= resolution.y / 2;
  _ssOrigin.z = 0;
  _ssOrigin3.copy(_ssOrigin);
  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);
  for (let i2 = 0, l = instanceStart.count; i2 < l; i2++) {
    _start4.fromBufferAttribute(instanceStart, i2);
    _end4.fromBufferAttribute(instanceEnd, i2);
    _start4.w = 1;
    _end4.w = 1;
    _start4.applyMatrix4(_mvMatrix);
    _end4.applyMatrix4(_mvMatrix);
    const isBehindCameraNear = _start4.z > near && _end4.z > near;
    if (isBehindCameraNear) {
      continue;
    }
    if (_start4.z > near) {
      const deltaDist = _start4.z - _end4.z;
      const t2 = (_start4.z - near) / deltaDist;
      _start4.lerp(_end4, t2);
    } else if (_end4.z > near) {
      const deltaDist = _end4.z - _start4.z;
      const t2 = (_end4.z - near) / deltaDist;
      _end4.lerp(_start4, t2);
    }
    _start4.applyMatrix4(projectionMatrix);
    _end4.applyMatrix4(projectionMatrix);
    _start4.multiplyScalar(1 / _start4.w);
    _end4.multiplyScalar(1 / _end4.w);
    _start4.x *= resolution.x / 2;
    _start4.y *= resolution.y / 2;
    _end4.x *= resolution.x / 2;
    _end4.y *= resolution.y / 2;
    _line.start.copy(_start4);
    _line.start.z = 0;
    _line.end.copy(_end4);
    _line.end.z = 0;
    const param = _line.closestPointToPointParameter(_ssOrigin3, true);
    _line.at(param, _closestPoint2);
    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);
    const isInClipSpace = zPos >= -1 && zPos <= 1;
    const isInside = _ssOrigin3.distanceTo(_closestPoint2) < _lineWidth * 0.5;
    if (isInClipSpace && isInside) {
      _line.start.fromBufferAttribute(instanceStart, i2);
      _line.end.fromBufferAttribute(instanceEnd, i2);
      _line.start.applyMatrix4(matrixWorld);
      _line.end.applyMatrix4(matrixWorld);
      const pointOnLine = new Vector3();
      const point = new Vector3();
      _ray2.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
      intersects.push({
        point,
        pointOnLine,
        distance: _ray2.origin.distanceTo(point),
        object: lineSegments,
        face: null,
        faceIndex: i2,
        uv: null,
        uv2: null
      });
    }
  }
}
var LineSegments2 = class extends Mesh {
  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({
    color: Math.random() * 16777215
  })) {
    super(geometry, material);
    this.isLineSegments2 = true;
    this.type = "LineSegments2";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    const instanceStart = geometry.attributes.instanceStart;
    const instanceEnd = geometry.attributes.instanceEnd;
    const lineDistances = new Float32Array(2 * instanceStart.count);
    for (let i2 = 0, j2 = 0, l = instanceStart.count; i2 < l; i2++, j2 += 2) {
      _start2.fromBufferAttribute(instanceStart, i2);
      _end2.fromBufferAttribute(instanceEnd, i2);
      lineDistances[j2] = j2 === 0 ? 0 : lineDistances[j2 - 1];
      lineDistances[j2 + 1] = lineDistances[j2] + _start2.distanceTo(_end2);
    }
    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);
    geometry.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));
    geometry.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));
    return this;
  }
  raycast(raycaster, intersects) {
    const worldUnits = this.material.worldUnits;
    const camera = raycaster.camera;
    if (camera === null && !worldUnits) {
      console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    }
    const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;
    _ray2 = raycaster.ray;
    const matrixWorld = this.matrixWorld;
    const geometry = this.geometry;
    const material = this.material;
    _lineWidth = material.linewidth + threshold;
    _instanceStart = geometry.attributes.instanceStart;
    _instanceEnd = geometry.attributes.instanceEnd;
    if (geometry.boundingSphere === null) {
      geometry.computeBoundingSphere();
    }
    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);
    let sphereMargin;
    if (worldUnits) {
      sphereMargin = _lineWidth * 0.5;
    } else {
      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray2.origin));
      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);
    }
    _sphere.radius += sphereMargin;
    if (_ray2.intersectsSphere(_sphere) === false) {
      return;
    }
    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }
    _box2.copy(geometry.boundingBox).applyMatrix4(matrixWorld);
    let boxMargin;
    if (worldUnits) {
      boxMargin = _lineWidth * 0.5;
    } else {
      const distanceToBox = Math.max(camera.near, _box2.distanceToPoint(_ray2.origin));
      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);
    }
    _box2.expandByScalar(boxMargin);
    if (_ray2.intersectsBox(_box2) === false) {
      return;
    }
    if (worldUnits) {
      raycastWorldUnits(this, intersects);
    } else {
      raycastScreenSpace(this, camera, intersects);
    }
  }
};

// node_modules/three-stdlib/lines/Line2.js
var Line2 = class extends LineSegments2 {
  constructor(geometry = new LineGeometry(), material = new LineMaterial({
    color: Math.random() * 16777215
  })) {
    super(geometry, material);
    this.isLine2 = true;
    this.type = "Line2";
  }
};

// node_modules/three-stdlib/helpers/LightProbeHelper.js
var LightProbeHelper = class extends Mesh {
  constructor(lightProbe, size2) {
    this.lightProbe = lightProbe;
    this.size = size2;
    const material = new ShaderMaterial({
      type: "LightProbeHelperMaterial",
      uniforms: {
        sh: {
          value: this.lightProbe.sh.coefficients
        },
        intensity: {
          value: this.lightProbe.intensity
        }
      },
      vertexShader: ["varying vec3 vNormal;", "void main() {", "	vNormal = normalize( normalMatrix * normal );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
      fragmentShader: ["#define RECIPROCAL_PI 0.318309886", "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {", "	// matrix is assumed to be orthogonal", "	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );", "}", "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf", "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {", "	// normal is assumed to have unit length", "	float x = normal.x, y = normal.y, z = normal.z;", "	// band 0", "	vec3 result = shCoefficients[ 0 ] * 0.886227;", "	// band 1", "	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;", "	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;", "	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;", "	// band 2", "	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;", "	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;", "	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );", "	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;", "	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );", "	return result;", "}", "uniform vec3 sh[ 9 ]; // sh coefficients", "uniform float intensity; // light probe intensity", "varying vec3 vNormal;", "void main() {", "	vec3 normal = normalize( vNormal );", "	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );", "	vec3 irradiance = shGetIrradianceAt( worldNormal, sh );", "	vec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;", "	gl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );", "}"].join("\n")
    });
    const geometry = new SphereGeometry(1, 32, 16);
    super(geometry, material);
    this.type = "LightProbeHelper";
    this.onBeforeRender();
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
  onBeforeRender() {
    this.position.copy(this.lightProbe.position);
    this.scale.set(1, 1, 1).multiplyScalar(this.size);
    this.material.uniforms.intensity.value = this.lightProbe.intensity;
  }
};

// node_modules/three-stdlib/helpers/VertexTangentsHelper.js
var _v12 = new Vector3();
var _v2 = new Vector3();
var VertexTangentsHelper = class extends LineSegments {
  constructor(object, size2, hex) {
    const color2 = hex !== void 0 ? hex : 65535;
    const objGeometry = object.geometry;
    if (!(objGeometry && objGeometry.isBufferGeometry)) {
      console.error("THREE.VertexTangentsHelper: geometry not an instance of THREE.BufferGeometry.", objGeometry);
      return;
    }
    const nTangents = objGeometry.attributes.tangent.count;
    const geometry = new BufferGeometry();
    const positions = new Float32BufferAttribute(nTangents * 2 * 3, 3);
    geometry.setAttribute("position", positions);
    super(geometry, new LineBasicMaterial({
      color: color2,
      toneMapped: false
    }));
    this.type = "VertexTangentsHelper";
    this.object = object;
    this.size = size2 !== void 0 ? size2 : 1;
    this.matrixAutoUpdate = false;
    this.update();
  }
  update() {
    this.object.updateMatrixWorld(true);
    const matrixWorld = this.object.matrixWorld;
    const position = this.geometry.attributes.position;
    const objGeometry = this.object.geometry;
    const objPos = objGeometry.attributes.position;
    const objTan = objGeometry.attributes.tangent;
    let idx = 0;
    for (let j2 = 0, jl2 = objPos.count; j2 < jl2; j2++) {
      _v12.set(objPos.getX(j2), objPos.getY(j2), objPos.getZ(j2)).applyMatrix4(matrixWorld);
      _v2.set(objTan.getX(j2), objTan.getY(j2), objTan.getZ(j2));
      _v2.transformDirection(matrixWorld).multiplyScalar(this.size).add(_v12);
      position.setXYZ(idx, _v12.x, _v12.y, _v12.z);
      idx = idx + 1;
      position.setXYZ(idx, _v2.x, _v2.y, _v2.z);
      idx = idx + 1;
    }
    position.needsUpdate = true;
  }
};

// node_modules/three-stdlib/helpers/PositionalAudioHelper.js
var PositionalAudioHelper = class extends Line {
  constructor(audio, range, divisionsInnerAngle, divisionsOuterAngle) {
    this.audio = audio;
    this.range = range || 1;
    this.divisionsInnerAngle = divisionsInnerAngle || 16;
    this.divisionsOuterAngle = divisionsOuterAngle || 2;
    const geometry = new BufferGeometry();
    const divisions = this.divisionsInnerAngle + this.divisionsOuterAngle * 2;
    const positions = new Float32Array((divisions * 3 + 3) * 3);
    geometry.setAttribute("position", new BufferAttribute(positions, 3));
    const materialInnerAngle = new LineBasicMaterial({
      color: 65280
    });
    const materialOuterAngle = new LineBasicMaterial({
      color: 16776960
    });
    super(geometry, [materialOuterAngle, materialInnerAngle]);
    this.type = "PositionalAudioHelper";
    this.update();
  }
  update() {
    const audio = this.audio;
    const range = this.range;
    const divisionsInnerAngle = this.divisionsInnerAngle;
    const divisionsOuterAngle = this.divisionsOuterAngle;
    const coneInnerAngle = MathUtils.degToRad(audio.panner.coneInnerAngle);
    const coneOuterAngle = MathUtils.degToRad(audio.panner.coneOuterAngle);
    const halfConeInnerAngle = coneInnerAngle / 2;
    const halfConeOuterAngle = coneOuterAngle / 2;
    let start = 0;
    let count = 0;
    let i2, stride;
    const geometry = this.geometry;
    const positionAttribute = geometry.attributes.position;
    geometry.clearGroups();
    function generateSegment(from, to, divisions, materialIndex) {
      const step2 = (to - from) / divisions;
      positionAttribute.setXYZ(start, 0, 0, 0);
      count++;
      for (i2 = from; i2 < to; i2 += step2) {
        stride = start + count;
        positionAttribute.setXYZ(stride, Math.sin(i2) * range, 0, Math.cos(i2) * range);
        positionAttribute.setXYZ(stride + 1, Math.sin(Math.min(i2 + step2, to)) * range, 0, Math.cos(Math.min(i2 + step2, to)) * range);
        positionAttribute.setXYZ(stride + 2, 0, 0, 0);
        count += 3;
      }
      geometry.addGroup(start, count, materialIndex);
      start += count;
      count = 0;
    }
    generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);
    generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);
    generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0);
    positionAttribute.needsUpdate = true;
    if (coneInnerAngle === coneOuterAngle)
      this.material[0].visible = false;
  }
  dispose() {
    this.geometry.dispose();
    this.material[0].dispose();
    this.material[1].dispose();
  }
};

// node_modules/three-stdlib/helpers/VertexNormalsHelper.js
var _v13 = new Vector3();
var _v22 = new Vector3();
var _normalMatrix = new Matrix3();
var VertexNormalsHelper = class extends LineSegments {
  constructor(object, size2, hex) {
    const geometry = new BufferGeometry();
    const color2 = hex !== void 0 ? hex : 16711680;
    super(geometry, new LineBasicMaterial({
      color: color2,
      toneMapped: false
    }));
    this.object = object;
    this.size = size2 !== void 0 ? size2 : 0.1;
    let nNormals = 0;
    const objGeometry = this.object.geometry;
    if (objGeometry && objGeometry.isGeometry) {
      console.error("THREE.VertexNormalsHelper no longer supports Geometry. Use BufferGeometry instead.");
      return;
    } else if (objGeometry && objGeometry.isBufferGeometry) {
      nNormals = objGeometry.attributes.normal.count;
    }
    const positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
    geometry.setAttribute("position", positions);
    this.type = "VertexNormalsHelper";
    this.matrixAutoUpdate = false;
    this.update();
  }
  update() {
    this.object.updateMatrixWorld(true);
    _normalMatrix.getNormalMatrix(this.object.matrixWorld);
    const matrixWorld = this.object.matrixWorld;
    const position = this.geometry.attributes.position;
    const objGeometry = this.object.geometry;
    if (objGeometry && objGeometry.isGeometry) {
      console.error("THREE.VertexNormalsHelper no longer supports Geometry. Use BufferGeometry instead.");
      return;
    } else if (objGeometry && objGeometry.isBufferGeometry) {
      const objPos = objGeometry.attributes.position;
      const objNorm = objGeometry.attributes.normal;
      let idx = 0;
      for (let j2 = 0, jl2 = objPos.count; j2 < jl2; j2++) {
        _v13.set(objPos.getX(j2), objPos.getY(j2), objPos.getZ(j2)).applyMatrix4(matrixWorld);
        _v22.set(objNorm.getX(j2), objNorm.getY(j2), objNorm.getZ(j2));
        _v22.applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v13);
        position.setXYZ(idx, _v13.x, _v13.y, _v13.z);
        idx = idx + 1;
        position.setXYZ(idx, _v22.x, _v22.y, _v22.z);
        idx = idx + 1;
      }
    }
    position.needsUpdate = true;
  }
};

// node_modules/three-stdlib/helpers/RectAreaLightHelper.js
var RectAreaLightHelper = class extends Line {
  constructor(light, color2) {
    this.light = light;
    this.color = color2;
    const positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    const material = new LineBasicMaterial({
      fog: false
    });
    super(geometry, material);
    this.type = "RectAreaLightHelper";
    const positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    this.add(new Mesh(geometry2, new MeshBasicMaterial({
      side: BackSide,
      fog: false
    })));
  }
  updateMatrixWorld() {
    this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);
    if (this.color !== void 0) {
      this.material.color.set(this.color);
      this.children[0].material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const c = this.material.color;
      const max3 = Math.max(c.r, c.g, c.b);
      if (max3 > 1)
        c.multiplyScalar(1 / max3);
      this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.copy(this.light.matrixWorld).scale(this.scale);
    this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
};

// node_modules/three-stdlib/lights/RectAreaLightUniformsLib.js
var RectAreaLightUniformsLib = { init: function() {
  var LTC_MAT_1 = [1, 0, 0, 2e-5, 1, 0, 0, 503905e-9, 1, 0, 0, 201562e-8, 1, 0, 0, 453516e-8, 1, 0, 0, 806253e-8, 1, 0, 0, 0.0125978, 1, 0, 0, 0.018141, 1, 0, 0, 0.0246924, 1, 0, 0, 0.0322525, 1, 0, 0, 0.0408213, 1, 0, 0, 0.0503999, 1, 0, 0, 0.0609894, 1, 0, 0, 0.0725906, 1, 0, 0, 0.0852058, 1, 0, 0, 0.0988363, 1, 0, 0, 0.113484, 1, 0, 0, 0.129153, 1, 0, 0, 0.145839, 1, 0, 0, 0.163548, 1, 0, 0, 0.182266, 1, 0, 0, 0.201942, 1, 0, 0, 0.222314, 1, 0, 0, 0.241906, 1, 0, 0, 0.262314, 1, 0, 0, 0.285754, 1, 0, 0, 0.310159, 1, 0, 0, 0.335426, 1, 0, 0, 0.361341, 1, 0, 0, 0.387445, 1, 0, 0, 0.412784, 1, 0, 0, 0.438197, 1, 0, 0, 0.466966, 1, 0, 0, 0.49559, 1, 0, 0, 0.523448, 1, 0, 0, 0.549938, 1, 0, 0, 0.57979, 1, 0, 0, 0.608746, 1, 0, 0, 0.636185, 1, 0, 0, 0.664748, 1, 0, 0, 0.69313, 1, 0, 0, 0.71966, 1, 0, 0, 0.747662, 1, 0, 0, 0.774023, 1, 0, 0, 0.799775, 1, 0, 0, 0.825274, 1, 0, 0, 0.849156, 1, 0, 0, 0.873248, 1, 0, 0, 0.89532, 1, 0, 0, 0.917565, 1, 0, 0, 0.937863, 1, 0, 0, 0.958139, 1, 0, 0, 0.976563, 1, 0, 0, 0.994658, 1, 0, 0, 1.0112, 1, 0, 0, 1.02712, 1, 0, 0, 1.04189, 1, 0, 0, 1.05568, 1, 0, 0, 1.06877, 1, 0, 0, 1.08058, 1, 0, 0, 1.09194, 1, 0, 0, 1.10191, 1, 0, 0, 1.11161, 1, 0, 0, 1.1199, 1, 0, 0, 1.12813, 0.999547, -448815e-12, 0.0224417, 199902e-10, 0.999495, -113079e-10, 0.0224406, 503651e-9, 0.999496, -452317e-10, 0.0224406, 201461e-8, 0.999496, -101772e-9, 0.0224406, 453287e-8, 0.999495, -180928e-9, 0.0224406, 805845e-8, 0.999497, -282702e-9, 0.0224406, 0.0125914, 0.999496, -407096e-9, 0.0224406, 0.0181319, 0.999498, -554114e-9, 0.0224406, 0.02468, 0.999499, -723768e-9, 0.0224406, 0.0322363, 0.999495, -916058e-9, 0.0224405, 0.0408009, 0.999499, -113101e-8, 0.0224408, 0.050375, 0.999494, -136863e-8, 0.0224405, 0.0609586, 0.999489, -162896e-8, 0.0224401, 0.0725537, 0.999489, -191201e-8, 0.0224414, 0.0851619, 0.999498, -221787e-8, 0.0224413, 0.0987867, 0.999492, -254642e-8, 0.0224409, 0.113426, 0.999507, -289779e-8, 0.0224417, 0.129088, 0.999494, -32716e-7, 0.0224386, 0.145767, 0.999546, -36673e-7, 0.0224424, 0.163472, 0.999543, -408166e-8, 0.0224387, 0.182182, 0.999499, -450056e-8, 0.0224338, 0.201843, 0.999503, -483661e-8, 0.0224203, 0.222198, 0.999546, -452928e-8, 0.022315, 0.241714, 0.999508, -587403e-8, 0.0224329, 0.262184, 0.999509, -638806e-8, 0.0224271, 0.285609, 0.999501, -691028e-8, 0.0224166, 0.309998, 0.999539, -741979e-8, 0.0223989, 0.335262, 0.999454, -786282e-8, 0.0223675, 0.361154, 0.999529, -811928e-8, 0.0222828, 0.387224, 0.999503, -799941e-8, 0.0221063, 0.41252, 0.999561, -952753e-8, 0.0223057, 0.438006, 0.999557, -99134e-7, 0.0222065, 0.466735, 0.999541, -0.0100935, 0.0220402, 0.495332, 0.999562, -996821e-8, 0.0218067, 0.523197, 0.999556, -0.0105031, 0.0217096, 0.550223, 0.999561, -0.0114191, 0.0217215, 0.579498, 0.999588, -0.0111818, 0.0213357, 0.608416, 0.999633, -0.0107725, 0.0208689, 0.635965, 0.999527, -0.0121671, 0.0210149, 0.664476, 0.999508, -0.0116005, 0.020431, 0.692786, 0.999568, -0.0115604, 0.0199791, 0.719709, 0.999671, -0.0121117, 0.0197415, 0.74737, 0.999688, -0.0110769, 0.0188846, 0.773692, 0.99962, -0.0122368, 0.0188452, 0.799534, 0.999823, -0.0110325, 0.0178001, 0.825046, 0.999599, -0.0114923, 0.0174221, 0.849075, 0.999619, -0.0105923, 0.0164345, 0.872999, 0.999613, -0.0105988, 0.0158227, 0.895371, 0.99964, -979861e-8, 0.0148131, 0.917364, 0.99977, -967238e-8, 0.0140721, 0.938002, 0.999726, -869175e-8, 0.0129543, 0.957917, 0.99973, -866872e-8, 0.0122329, 0.976557, 0.999773, -731956e-8, 0.0108958, 0.994459, 0.999811, -756027e-8, 0.0102715, 1.01118, 0.999862, -583732e-8, 878781e-8, 1.02701, 0.999835, -631438e-8, 827529e-8, 1.04186, 0.999871, -450785e-8, 674583e-8, 1.05569, 0.999867, -486079e-8, 621041e-8, 1.06861, 0.999939, -322072e-8, 478301e-8, 1.08064, 0.999918, -318199e-8, 406395e-8, 1.09181, 1.00003, -193348e-8, 280682e-8, 1.10207, 0.999928, -153729e-8, 198741e-8, 1.11152, 0.999933, -623666e-9, 917714e-9, 1.12009, 1, -102387e-11, 907581e-12, 1.12813, 0.997866, -896716e-12, 0.0448334, 199584e-10, 0.997987, -225945e-10, 0.0448389, 502891e-9, 0.997987, -903781e-10, 0.0448388, 201156e-8, 0.997985, -203351e-9, 0.0448388, 452602e-8, 0.997986, -361514e-9, 0.0448388, 804629e-8, 0.997987, -56487e-8, 0.0448389, 0.0125724, 0.997988, -813423e-9, 0.0448389, 0.0181045, 0.997984, -110718e-8, 0.0448387, 0.0246427, 0.997985, -144616e-8, 0.0448388, 0.0321875, 0.997987, -183038e-8, 0.044839, 0.0407392, 0.997983, -225987e-8, 0.0448387, 0.0502986, 0.997991, -273467e-8, 0.0448389, 0.0608667, 0.997984, -325481e-8, 0.0448384, 0.0724444, 0.998002, -382043e-8, 0.044839, 0.0850348, 0.997997, -443145e-8, 0.0448396, 0.0986372, 0.998007, -508796e-8, 0.0448397, 0.113255, 0.998008, -578985e-8, 0.04484, 0.128891, 0.998003, -653683e-8, 0.0448384, 0.145548, 0.997983, -732713e-8, 0.0448358, 0.163221, 0.997985, -815454e-8, 0.0448358, 0.181899, 0.998005, -898985e-8, 0.0448286, 0.201533, 0.998026, -964404e-8, 0.0447934, 0.221821, 0.998055, -922677e-8, 0.044611, 0.241282, 0.99804, -0.0117361, 0.0448245, 0.261791, 0.998048, -0.0127628, 0.0448159, 0.285181, 0.998088, -0.0138055, 0.0447996, 0.30954, 0.998058, -0.0148206, 0.0447669, 0.334751, 0.998099, -0.0156998, 0.044697, 0.36061, 0.998116, -0.0161976, 0.0445122, 0.386603, 0.998195, -0.015945, 0.0441711, 0.411844, 0.998168, -0.0183947, 0.0444255, 0.43773, 0.998184, -0.0197913, 0.0443809, 0.466009, 0.998251, -0.0201426, 0.0440689, 0.494574, 0.998305, -0.0198847, 0.0435632, 0.522405, 0.998273, -0.0210577, 0.043414, 0.549967, 0.998254, -0.0227901, 0.0433943, 0.578655, 0.998349, -0.0223108, 0.0426529, 0.60758, 0.99843, -0.0223088, 0.042, 0.635524, 0.998373, -0.0241141, 0.0418987, 0.663621, 0.998425, -0.0231446, 0.0408118, 0.691906, 0.998504, -0.0233684, 0.0400565, 0.719339, 0.998443, -0.0241652, 0.0394634, 0.74643, 0.99848, -0.0228715, 0.0380002, 0.773086, 0.998569, -0.023519, 0.0372322, 0.798988, 0.998619, -0.0223108, 0.0356468, 0.824249, 0.998594, -0.0223105, 0.034523, 0.848808, 0.998622, -0.0213426, 0.0328887, 0.87227, 0.998669, -0.0207912, 0.0314374, 0.895157, 0.998705, -0.0198416, 0.0296925, 0.916769, 0.998786, -0.0189168, 0.0279634, 0.937773, 0.998888, -0.0178811, 0.0261597, 0.957431, 0.99906, -0.0166845, 0.0242159, 0.976495, 0.999038, -0.0155464, 0.0222638, 0.994169, 0.999237, -0.0141349, 0.0201967, 1.01112, 0.999378, -0.0129324, 0.0181744, 1.02692, 0.999433, -0.0113192, 0.0159898, 1.04174, 0.999439, -0.0101244, 0.0140385, 1.05559, 0.999614, -837456e-8, 0.0117826, 1.06852, 0.999722, -721769e-8, 983745e-8, 1.08069, 0.999817, -554067e-8, 769002e-8, 1.09176, 0.99983, -426961e-8, 5782e-6, 1.10211, 0.999964, -273904e-8, 374503e-8, 1.11152, 1.00001, -136739e-8, 187176e-8, 1.12031, 0.999946, 393227e-10, -28919e-9, 1.12804, 0.995847, -13435e-10, 0.0671785, 19916e-9, 0.995464, -338387e-10, 0.0671527, 501622e-9, 0.99547, -135355e-9, 0.0671531, 200649e-8, 0.995471, -30455e-8, 0.0671532, 451461e-8, 0.99547, -541423e-9, 0.0671531, 8026e-6, 0.995471, -84598e-8, 0.0671531, 0.0125407, 0.99547, -121823e-8, 0.0671531, 0.0180589, 0.99547, -165817e-8, 0.0671531, 0.0245806, 0.995463, -216583e-8, 0.0671526, 0.0321062, 0.995468, -274127e-8, 0.0671527, 0.0406366, 0.995474, -338447e-8, 0.0671534, 0.0501717, 0.995473, -409554e-8, 0.0671533, 0.0607131, 0.995478, -487451e-8, 0.0671531, 0.0722618, 0.995476, -572148e-8, 0.0671532, 0.0848191, 0.995477, -663658e-8, 0.0671539, 0.0983882, 0.995498, -761986e-8, 0.0671541, 0.112972, 0.995509, -867094e-8, 0.0671542, 0.128568, 0.995509, -978951e-8, 0.0671531, 0.145183, 0.995503, -0.0109725, 0.0671491, 0.162808, 0.995501, -0.012211, 0.0671465, 0.181441, 0.99553, -0.0134565, 0.0671371, 0.201015, 0.99555, -0.014391, 0.0670831, 0.221206, 0.99558, -0.014351, 0.0668883, 0.240813, 0.995577, -0.0173997, 0.0671055, 0.261257, 0.995602, -0.0191111, 0.0671178, 0.284467, 0.995623, -0.0206705, 0.0670946, 0.308765, 0.995658, -0.022184, 0.0670472, 0.333905, 0.995705, -0.0234832, 0.0669417, 0.359677, 0.995719, -0.0241933, 0.0666714, 0.385554, 0.995786, -0.0243539, 0.066266, 0.410951, 0.995887, -0.0271866, 0.0664367, 0.437163, 0.995944, -0.0296012, 0.0664931, 0.464842, 0.996004, -0.0301045, 0.0660105, 0.49332, 0.996128, -0.0298311, 0.0652694, 0.521131, 0.996253, -0.0316426, 0.0650739, 0.549167, 0.996244, -0.0339043, 0.0649433, 0.57737, 0.996309, -0.033329, 0.0638926, 0.606073, 0.996417, -0.0338935, 0.0630849, 0.634527, 0.996372, -0.0353104, 0.0625083, 0.66256, 0.996542, -0.0348942, 0.0611986, 0.690516, 0.996568, -0.0351614, 0.060069, 0.718317, 0.996711, -0.0354317, 0.0588522, 0.74528, 0.996671, -0.0349513, 0.0571902, 0.772061, 0.996865, -0.0345622, 0.0555321, 0.798089, 0.996802, -0.0342566, 0.0537816, 0.823178, 0.996992, -0.0330862, 0.0516095, 0.847949, 0.996944, -0.0324666, 0.0495537, 0.871431, 0.997146, -0.0309544, 0.0470302, 0.894357, 0.997189, -0.0299372, 0.0446043, 0.916142, 0.997471, -0.0281389, 0.0418812, 0.937193, 0.997515, -0.0268702, 0.0391823, 0.957, 0.997812, -0.0247166, 0.0361338, 0.975936, 0.998027, -0.0233525, 0.0333945, 0.99391, 0.998233, -0.0209839, 0.0301917, 1.01075, 0.998481, -0.0194309, 0.027271, 1.02669, 0.998859, -0.0169728, 0.0240162, 1.04173, 0.99894, -0.0152322, 0.0210517, 1.05551, 0.999132, -0.0127497, 0.0178632, 1.06856, 0.999369, -0.0108282, 0.014787, 1.08054, 0.999549, -845886e-8, 0.0116185, 1.09185, 0.999805, -63937e-7, 867209e-8, 1.10207, 0.99985, -414582e-8, 566823e-8, 1.1117, 0.999912, -207443e-8, 277562e-8, 1.12022, 1.00001, 870226e-10, -53766e-9, 1.12832, 0.991943, -178672e-11, 0.0893382, 198384e-10, 0.991952, -450183e-10, 0.089339, 499849e-9, 0.991956, -180074e-9, 0.0893394, 19994e-7, 0.991955, -405167e-9, 0.0893393, 449867e-8, 0.991953, -720298e-9, 0.0893391, 799764e-8, 0.991955, -112548e-8, 0.0893393, 0.0124964, 0.991957, -16207e-7, 0.0893395, 0.0179951, 0.991958, -220601e-8, 0.0893396, 0.0244939, 0.991947, -288137e-8, 0.0893385, 0.0319929, 0.991962, -364693e-8, 0.0893399, 0.0404933, 0.991965, -450264e-8, 0.0893399, 0.049995, 0.99198, -544862e-8, 0.0893411, 0.0604995, 0.99197, -648491e-8, 0.0893397, 0.0720074, 0.991976, -761164e-8, 0.089341, 0.0845207, 0.99198, -882891e-8, 0.0893405, 0.0980413, 0.991982, -0.0101367, 0.0893396, 0.112571, 0.992008, -0.011535, 0.0893415, 0.128115, 0.992026, -0.0130228, 0.0893414, 0.144672, 0.992064, -0.0145966, 0.0893418, 0.162241, 0.992041, -0.0162421, 0.0893359, 0.180801, 0.992086, -0.0178888, 0.0893214, 0.200302, 0.992157, -0.0190368, 0.0892401, 0.220332, 0.992181, -0.0195584, 0.0890525, 0.240144, 0.992175, -0.0227257, 0.0892153, 0.260728, 0.99221, -0.0254195, 0.089304, 0.283473, 0.99222, -0.0274883, 0.0892703, 0.307673, 0.992317, -0.0294905, 0.0892027, 0.332729, 0.992374, -0.0311861, 0.0890577, 0.358387, 0.992505, -0.0320656, 0.0886994, 0.384102, 0.992568, -0.0329715, 0.0883198, 0.409767, 0.992675, -0.036006, 0.0883602, 0.436145, 0.992746, -0.0392897, 0.0884591, 0.463217, 0.992873, -0.0399337, 0.0878287, 0.491557, 0.992934, -0.040231, 0.0870108, 0.519516, 0.993091, -0.0422013, 0.0865857, 0.547741, 0.993259, -0.0443503, 0.0861937, 0.575792, 0.993455, -0.0446368, 0.0851187, 0.604233, 0.993497, -0.0454299, 0.0840576, 0.632925, 0.993694, -0.0463296, 0.0829671, 0.660985, 0.993718, -0.0470619, 0.0817185, 0.688714, 0.993973, -0.0468838, 0.0800294, 0.716743, 0.994207, -0.046705, 0.0781286, 0.74377, 0.994168, -0.0469698, 0.0763337, 0.77042, 0.9945, -0.0456816, 0.0738184, 0.796659, 0.994356, -0.0455518, 0.0715545, 0.821868, 0.994747, -0.0439488, 0.0686085, 0.846572, 0.994937, -0.0430056, 0.065869, 0.870435, 0.995142, -0.0413414, 0.0626446, 0.893272, 0.995451, -0.0396521, 0.05929, 0.915376, 0.995445, -0.0378453, 0.0558503, 0.936196, 0.995967, -0.0355219, 0.0520949, 0.956376, 0.996094, -0.0335146, 0.048377, 0.975327, 0.996622, -0.030682, 0.0442575, 0.993471, 0.996938, -0.0285504, 0.0404693, 1.01052, 0.997383, -0.0253399, 0.0360903, 1.02637, 0.997714, -0.0231651, 0.0322176, 1.04139, 0.998249, -0.0198138, 0.0278433, 1.05542, 0.998596, -0.0174337, 0.0238759, 1.06846, 0.998946, -0.0141349, 0.0195944, 1.08056, 0.99928, -0.0115603, 0.0156279, 1.09181, 0.999507, -839065e-8, 0.0114607, 1.10213, 0.999697, -5666e-6, 763325e-8, 1.11169, 0.999869, -269902e-8, 364946e-8, 1.12042, 1.00001, 623836e-10, -319288e-10, 1.12832, 0.987221, -222675e-11, 0.111332, 197456e-10, 0.98739, -561116e-10, 0.111351, 497563e-9, 0.987448, -224453e-9, 0.111357, 199031e-8, 0.987441, -505019e-9, 0.111357, 44782e-7, 0.987442, -897816e-9, 0.111357, 796129e-8, 0.987442, -140284e-8, 0.111357, 0.0124396, 0.987444, -202012e-8, 0.111357, 0.0179132, 0.987442, -274964e-8, 0.111357, 0.0243824, 0.987446, -359147e-8, 0.111357, 0.0318474, 0.987435, -454562e-8, 0.111356, 0.0403086, 0.987461, -561225e-8, 0.111358, 0.0497678, 0.987458, -679125e-8, 0.111358, 0.0602239, 0.987443, -80828e-7, 0.111356, 0.0716792, 0.987476, -94872e-7, 0.111358, 0.0841364, 0.98749, -0.0110044, 0.111361, 0.097597, 0.987508, -0.0126344, 0.111362, 0.112062, 0.987494, -0.0143767, 0.111357, 0.127533, 0.987526, -0.0162307, 0.111359, 0.144015, 0.987558, -0.0181912, 0.111361, 0.161502, 0.987602, -0.0202393, 0.111355, 0.179979, 0.987692, -0.022273, 0.111346, 0.199386, 0.987702, -0.0235306, 0.111215, 0.219183, 0.987789, -0.0247628, 0.111061, 0.239202, 0.987776, -0.0280668, 0.111171, 0.259957, 0.987856, -0.0316751, 0.111327, 0.282198, 0.987912, -0.0342468, 0.111282, 0.306294, 0.988, -0.0367205, 0.111198, 0.331219, 0.988055, -0.0387766, 0.110994, 0.356708, 0.988241, -0.0397722, 0.110547, 0.382234, 0.988399, -0.0416076, 0.110198, 0.408227, 0.988539, -0.0448192, 0.110137, 0.434662, 0.988661, -0.0483793, 0.110143, 0.461442, 0.988967, -0.0495895, 0.109453, 0.489318, 0.989073, -0.0506797, 0.108628, 0.517516, 0.989274, -0.0526953, 0.108003, 0.545844, 0.989528, -0.054578, 0.107255, 0.573823, 0.989709, -0.0561503, 0.106294, 0.601944, 0.989991, -0.056866, 0.104896, 0.630855, 0.990392, -0.0572914, 0.103336, 0.658925, 0.990374, -0.0586224, 0.10189, 0.686661, 0.990747, -0.0584764, 0.099783, 0.714548, 0.991041, -0.0582662, 0.0974309, 0.74186, 0.991236, -0.0584118, 0.0951678, 0.768422, 0.991585, -0.0573055, 0.0921581, 0.794817, 0.991984, -0.0564241, 0.0891167, 0.820336, 0.9921, -0.0553608, 0.085805, 0.84493, 0.992749, -0.0533816, 0.0820354, 0.868961, 0.99288, -0.0518661, 0.0782181, 0.891931, 0.993511, -0.0492492, 0.0738935, 0.914186, 0.993617, -0.0471956, 0.0696402, 0.93532, 0.99411, -0.044216, 0.0649659, 0.95543, 0.994595, -0.0416654, 0.0603177, 0.974685, 0.994976, -0.0384314, 0.0553493, 0.992807, 0.995579, -0.0353491, 0.0503942, 1.00996, 0.996069, -0.0319787, 0.0452123, 1.02606, 0.996718, -0.028472, 0.0400112, 1.04114, 0.997173, -0.0250789, 0.0349456, 1.05517, 0.997818, -0.0213326, 0.029653, 1.0683, 0.998318, -0.0178509, 0.024549, 1.0805, 0.998853, -0.0141118, 0.0194197, 1.09177, 0.999218, -0.0105914, 0.0143869, 1.1022, 0.999594, -693474e-8, 943517e-8, 1.11175, 0.99975, -340478e-8, 464051e-8, 1.12056, 1.00001, 109172e-9, -112821e-9, 1.12853, 0.983383, -266524e-11, 0.133358, 196534e-10, 0.981942, -671009e-10, 0.133162, 494804e-9, 0.981946, -268405e-9, 0.133163, 197923e-8, 0.981944, -603912e-9, 0.133163, 445326e-8, 0.981941, -107362e-8, 0.133162, 791693e-8, 0.981946, -167755e-8, 0.133163, 0.0123703, 0.981944, -241569e-8, 0.133162, 0.0178135, 0.981945, -328807e-8, 0.133163, 0.0242466, 0.981945, -429472e-8, 0.133162, 0.03167, 0.981955, -543573e-8, 0.133164, 0.0400846, 0.981951, -671105e-8, 0.133163, 0.0494901, 0.981968, -812092e-8, 0.133165, 0.0598886, 0.981979, -966541e-8, 0.133166, 0.0712811, 0.981996, -0.0113446, 0.133168, 0.083669, 0.982014, -0.0131585, 0.133169, 0.0970533, 0.982011, -0.0151073, 0.133167, 0.111438, 0.982062, -0.0171906, 0.133172, 0.126826, 0.9821, -0.0194067, 0.133175, 0.143215, 0.982149, -0.0217502, 0.133176, 0.160609, 0.982163, -0.0241945, 0.133173, 0.178981, 0.982247, -0.0265907, 0.133148, 0.198249, 0.982291, -0.027916, 0.132974, 0.217795, 0.982396, -0.0299663, 0.132868, 0.238042, 0.982456, -0.0334544, 0.132934, 0.258901, 0.982499, -0.0378636, 0.133137, 0.280639, 0.982617, -0.0409274, 0.133085, 0.304604, 0.98274, -0.0438523, 0.132985, 0.329376, 0.982944, -0.0462288, 0.132728, 0.354697, 0.98308, -0.0475995, 0.132228, 0.380102, 0.983391, -0.0501901, 0.131924, 0.406256, 0.983514, -0.0535899, 0.131737, 0.432735, 0.98373, -0.0571858, 0.131567, 0.459359, 0.984056, -0.0592353, 0.130932, 0.486637, 0.984234, -0.0610488, 0.130092, 0.51509, 0.984748, -0.0630758, 0.12923, 0.543461, 0.985073, -0.0647398, 0.128174, 0.571376, 0.985195, -0.0671941, 0.127133, 0.599414, 0.985734, -0.0681345, 0.125576, 0.628134, 0.986241, -0.0686089, 0.123639, 0.656399, 0.986356, -0.0698511, 0.121834, 0.684258, 0.986894, -0.0700931, 0.119454, 0.711818, 0.987382, -0.0698321, 0.116718, 0.739511, 0.988109, -0.0693975, 0.113699, 0.766267, 0.988363, -0.0689584, 0.110454, 0.792456, 0.989112, -0.0672353, 0.106602, 0.81813, 0.989241, -0.0662034, 0.10267, 0.842889, 0.990333, -0.0638938, 0.0981381, 0.867204, 0.990591, -0.0618534, 0.0935388, 0.89038, 0.991106, -0.0593117, 0.088553, 0.912576, 0.991919, -0.0562676, 0.0832187, 0.934118, 0.992111, -0.0534085, 0.0778302, 0.954254, 0.992997, -0.0495459, 0.0720453, 0.973722, 0.993317, -0.0463707, 0.0663458, 0.991949, 0.994133, -0.0421245, 0.0601883, 1.00936, 0.994705, -0.0384977, 0.0542501, 1.02559, 0.995495, -0.0340956, 0.0479862, 1.04083, 0.996206, -0.030105, 0.041887, 1.05497, 0.996971, -0.0256095, 0.0355355, 1.06824, 0.997796, -0.0213932, 0.0293655, 1.08056, 0.998272, -0.0169612, 0.0232926, 1.09182, 0.998857, -0.0126756, 0.0172786, 1.10219, 0.99939, -832486e-8, 0.0113156, 1.11192, 0.999752, -410826e-8, 557892e-8, 1.12075, 1, 150957e-9, -119101e-9, 1.12885, 0.975169, -309397e-11, 0.154669, 195073e-10, 0.975439, -779608e-10, 0.154712, 491534e-9, 0.975464, -311847e-9, 0.154716, 196617e-8, 0.975464, -701656e-9, 0.154716, 442387e-8, 0.975462, -12474e-7, 0.154715, 78647e-7, 0.975461, -194906e-8, 0.154715, 0.0122886, 0.975464, -280667e-8, 0.154715, 0.0176959, 0.975468, -382025e-8, 0.154716, 0.0240867, 0.975471, -498985e-8, 0.154716, 0.0314612, 0.975472, -631541e-8, 0.154717, 0.0398199, 0.975486, -779719e-8, 0.154718, 0.0491639, 0.975489, -943505e-8, 0.154718, 0.0594932, 0.975509, -0.0112295, 0.154721, 0.0708113, 0.97554, -0.0131802, 0.154724, 0.0831176, 0.975557, -0.0152876, 0.154726, 0.096415, 0.975585, -0.0175512, 0.154728, 0.110705, 0.975605, -0.0199713, 0.154729, 0.125992, 0.975645, -0.0225447, 0.154729, 0.142272, 0.975711, -0.0252649, 0.154735, 0.159549, 0.975788, -0.0280986, 0.154736, 0.177805, 0.975872, -0.0308232, 0.154704, 0.196911, 0.975968, -0.0324841, 0.154525, 0.216324, 0.976063, -0.0351281, 0.154432, 0.236628, 0.976157, -0.0388618, 0.15446, 0.257539, 0.976204, -0.0437704, 0.154665, 0.278975, 0.976358, -0.047514, 0.154652, 0.302606, 0.976571, -0.0508638, 0.154535, 0.327204, 0.976725, -0.0534995, 0.154221, 0.352276, 0.977013, -0.0555547, 0.153737, 0.377696, 0.977294, -0.0586728, 0.153403, 0.403855, 0.977602, -0.0622715, 0.15312, 0.430333, 0.977932, -0.0658166, 0.152755, 0.456855, 0.978241, -0.0689877, 0.152233, 0.483668, 0.978602, -0.0712805, 0.15132, 0.512097, 0.979234, -0.0732775, 0.150235, 0.540455, 0.97977, -0.075163, 0.148978, 0.568486, 0.979995, -0.0778026, 0.147755, 0.596524, 0.98078, -0.0791854, 0.146019, 0.624825, 0.981628, -0.0799666, 0.143906, 0.653403, 0.982067, -0.0808532, 0.141561, 0.681445, 0.98271, -0.0816024, 0.139025, 0.708918, 0.983734, -0.0812511, 0.135764, 0.736594, 0.98431, -0.0806201, 0.132152, 0.763576, 0.985071, -0.0801605, 0.12846, 0.789797, 0.98618, -0.0784208, 0.124084, 0.815804, 0.986886, -0.0766643, 0.1193, 0.840869, 0.987485, -0.0747744, 0.114236, 0.864952, 0.988431, -0.0716701, 0.108654, 0.888431, 0.988886, -0.0691609, 0.102994, 0.910963, 0.990024, -0.0654048, 0.0967278, 0.932629, 0.990401, -0.0619765, 0.090384, 0.95313, 0.991093, -0.0579296, 0.0837885, 0.972587, 0.992018, -0.0536576, 0.0770171, 0.991184, 0.992536, -0.0493719, 0.0701486, 1.00863, 0.993421, -0.0444813, 0.062953, 1.02494, 0.993928, -0.040008, 0.0560455, 1.04017, 0.994994, -0.0347982, 0.04856, 1.05463, 0.995866, -0.0301017, 0.0416152, 1.06807, 0.996916, -0.0248225, 0.0342597, 1.08039, 0.997766, -0.0199229, 0.0271668, 1.09177, 0.998479, -0.0147422, 0.0201387, 1.10235, 0.99921, -980173e-8, 0.0131944, 1.11206, 0.999652, -47426e-7, 640712e-8, 1.12104, 0.999998, 891673e-10, -10379e-8, 1.12906, 0.967868, -351885e-11, 0.175947, 193569e-10, 0.968001, -886733e-10, 0.175972, 487782e-9, 0.96801, -354697e-9, 0.175973, 195115e-8, 0.968012, -798063e-9, 0.175974, 439006e-8, 0.968011, -141879e-8, 0.175973, 780461e-8, 0.968011, -221686e-8, 0.175973, 0.0121948, 0.968016, -319231e-8, 0.175974, 0.0175607, 0.968019, -434515e-8, 0.175974, 0.0239027, 0.968018, -567538e-8, 0.175974, 0.0312208, 0.968033, -718308e-8, 0.175977, 0.0395158, 0.968049, -886836e-8, 0.175979, 0.0487885, 0.968047, -0.0107312, 0.175978, 0.0590394, 0.968072, -0.0127719, 0.175981, 0.0702705, 0.968108, -0.0149905, 0.175986, 0.0824836, 0.968112, -0.0173866, 0.175985, 0.0956783, 0.968173, -0.0199611, 0.175993, 0.109862, 0.96827, -0.0227128, 0.176008, 0.125033, 0.968292, -0.025639, 0.17601, 0.141193, 0.968339, -0.0287299, 0.176007, 0.158336, 0.968389, -0.0319399, 0.176001, 0.176441, 0.968501, -0.034941, 0.175962, 0.195359, 0.968646, -0.0370812, 0.175793, 0.214686, 0.968789, -0.0402329, 0.175708, 0.234973, 0.96886, -0.0442601, 0.1757, 0.255871, 0.969013, -0.049398, 0.175876, 0.277238, 0.969242, -0.0539932, 0.17594, 0.300326, 0.969419, -0.0577299, 0.175781, 0.324702, 0.969763, -0.0605643, 0.175432, 0.349527, 0.970093, -0.0634488, 0.174992, 0.374976, 0.970361, -0.0670589, 0.174611, 0.401097, 0.970825, -0.0708246, 0.174226, 0.427496, 0.971214, -0.0742871, 0.173684, 0.453858, 0.971622, -0.0782608, 0.173186, 0.480637, 0.972175, -0.0813151, 0.172288, 0.508655, 0.972944, -0.0832678, 0.170979, 0.536973, 0.973595, -0.0855964, 0.169573, 0.565138, 0.974345, -0.0882163, 0.168152, 0.593222, 0.975233, -0.0901671, 0.166314, 0.621201, 0.976239, -0.0912111, 0.163931, 0.649919, 0.977289, -0.0916959, 0.161106, 0.678011, 0.978076, -0.0927061, 0.158272, 0.705717, 0.979533, -0.0925562, 0.15475, 0.733228, 0.980335, -0.0918159, 0.150638, 0.760454, 0.981808, -0.0908508, 0.146201, 0.786918, 0.983061, -0.0896172, 0.141386, 0.812953, 0.984148, -0.0871588, 0.135837, 0.838281, 0.985047, -0.0850624, 0.130135, 0.862594, 0.986219, -0.0818541, 0.123882, 0.88633, 0.987043, -0.0784523, 0.117126, 0.908952, 0.988107, -0.0749601, 0.110341, 0.930744, 0.988955, -0.0703548, 0.102885, 0.951728, 0.989426, -0.0662798, 0.0954167, 0.971166, 0.990421, -0.0610834, 0.0876331, 0.989984, 0.991032, -0.0562936, 0.0797785, 1.00765, 0.992041, -0.0508154, 0.0718166, 1.02434, 0.992794, -0.0454045, 0.0637125, 1.03976, 0.993691, -0.0398194, 0.0555338, 1.05418, 0.994778, -0.0341482, 0.0473388, 1.06772, 0.995915, -0.028428, 0.0391016, 1.08028, 0.997109, -0.022642, 0.0309953, 1.09185, 0.998095, -0.0168738, 0.0230288, 1.10247, 0.998985, -0.0111274, 0.0150722, 1.11229, 0.999581, -543881e-8, 740605e-8, 1.12131, 1.00003, 162239e-9, -105549e-9, 1.12946, 0.959505, -393734e-11, 0.196876, 191893e-10, 0.959599, -992157e-10, 0.196895, 483544e-9, 0.959641, -396868e-9, 0.196903, 19342e-7, 0.959599, -892948e-9, 0.196895, 435193e-8, 0.959603, -158747e-8, 0.196896, 77368e-7, 0.959604, -248042e-8, 0.196896, 0.0120888, 0.959605, -357184e-8, 0.196896, 0.0174082, 0.959605, -486169e-8, 0.196896, 0.0236949, 0.959613, -635008e-8, 0.196897, 0.0309497, 0.959619, -803696e-8, 0.196898, 0.0391725, 0.959636, -992255e-8, 0.196901, 0.0483649, 0.959634, -0.0120067, 0.1969, 0.0585266, 0.959675, -0.0142898, 0.196906, 0.0696609, 0.959712, -0.0167717, 0.196911, 0.0817678, 0.959752, -0.0194524, 0.196918, 0.0948494, 0.959807, -0.0223321, 0.196925, 0.10891, 0.959828, -0.0254091, 0.196924, 0.123947, 0.959906, -0.0286815, 0.196934, 0.139968, 0.960005, -0.0321371, 0.196944, 0.156968, 0.960071, -0.0357114, 0.196936, 0.17491, 0.960237, -0.0389064, 0.196882, 0.193597, 0.960367, -0.041623, 0.196731, 0.21285, 0.960562, -0.0452655, 0.196654, 0.233075, 0.960735, -0.0496207, 0.196643, 0.253941, 0.960913, -0.0549379, 0.196774, 0.275278, 0.961121, -0.0603414, 0.196893, 0.297733, 0.96139, -0.0644244, 0.196717, 0.321877, 0.961818, -0.067556, 0.196314, 0.346476, 0.962175, -0.0712709, 0.195917, 0.371907, 0.96255, -0.0752848, 0.1955, 0.397916, 0.963164, -0.0792073, 0.195026, 0.424229, 0.963782, -0.0828225, 0.194424, 0.450637, 0.964306, -0.0873119, 0.193831, 0.477288, 0.964923, -0.0911051, 0.192973, 0.504716, 0.966048, -0.093251, 0.19151, 0.533053, 0.967024, -0.0958983, 0.190013, 0.561366, 0.968038, -0.09835, 0.188253, 0.589464, 0.969152, -0.100754, 0.186257, 0.617433, 0.970557, -0.102239, 0.183775, 0.645801, 0.972104, -0.102767, 0.180645, 0.674278, 0.973203, -0.103492, 0.177242, 0.702004, 0.975123, -0.103793, 0.17345, 0.729529, 0.97641, -0.102839, 0.168886, 0.756712, 0.978313, -0.101687, 0.163892, 0.783801, 0.980036, -0.100314, 0.158439, 0.809671, 0.981339, -0.097836, 0.152211, 0.835402, 0.982794, -0.0950006, 0.145679, 0.860081, 0.984123, -0.0920994, 0.138949, 0.883757, 0.984918, -0.0878641, 0.131283, 0.90685, 0.985999, -0.083939, 0.123464, 0.928786, 0.987151, -0.0791234, 0.115324, 0.94983, 0.987827, -0.0739332, 0.106854, 0.96962, 0.988806, -0.0688088, 0.0982691, 0.98861, 0.989588, -0.0628962, 0.0893456, 1.00667, 0.990438, -0.0573146, 0.0805392, 1.02344, 0.991506, -0.0509433, 0.0713725, 1.03933, 0.992492, -0.0448724, 0.0623732, 1.05378, 0.993663, -0.0383497, 0.0530838, 1.06747, 0.994956, -0.0319593, 0.0439512, 1.08007, 0.99634, -0.025401, 0.0347803, 1.09182, 0.99761, -0.0189687, 0.0257954, 1.1025, 0.99863, -0.0124441, 0.0169893, 1.11247, 0.99947, -614003e-8, 829498e-8, 1.12151, 1.00008, 216624e-9, -146107e-9, 1.12993, 0.950129, -434955e-11, 0.217413, 190081e-10, 0.950264, -10957e-8, 0.217444, 47884e-8, 0.9503, -438299e-9, 0.217451, 191543e-8, 0.950246, -986124e-9, 0.21744, 430951e-8, 0.950246, -175311e-8, 0.21744, 766137e-8, 0.950245, -273923e-8, 0.21744, 0.011971, 0.950253, -394453e-8, 0.217441, 0.0172385, 0.950258, -536897e-8, 0.217442, 0.0234641, 0.950267, -701262e-8, 0.217444, 0.030648, 0.950277, -887551e-8, 0.217446, 0.038791, 0.950284, -0.0109576, 0.217446, 0.0478931, 0.950312, -0.0132591, 0.217451, 0.0579568, 0.950334, -0.01578, 0.217454, 0.0689821, 0.950378, -0.0185204, 0.217462, 0.0809714, 0.950417, -0.0214803, 0.217467, 0.0939265, 0.950488, -0.0246594, 0.217479, 0.10785, 0.950534, -0.0280565, 0.217483, 0.122743, 0.950633, -0.0316685, 0.217498, 0.138611, 0.950698, -0.0354787, 0.217499, 0.155442, 0.950844, -0.0394003, 0.217507, 0.173208, 0.950999, -0.0426812, 0.217419, 0.191605, 0.951221, -0.0461302, 0.217317, 0.21084, 0.951412, -0.0502131, 0.217238, 0.230945, 0.951623, -0.0549183, 0.21722, 0.251745, 0.951867, -0.0604493, 0.217306, 0.273001, 0.952069, -0.0665189, 0.217466, 0.294874, 0.952459, -0.0709179, 0.217266, 0.318732, 0.952996, -0.0746112, 0.216891, 0.34318, 0.953425, -0.0789252, 0.216503, 0.36849, 0.953885, -0.0833293, 0.216042, 0.394373, 0.954617, -0.087371, 0.215469, 0.420505, 0.955429, -0.0914054, 0.214802, 0.446907, 0.956068, -0.0961671, 0.214146, 0.473522, 0.957094, -0.10048, 0.213286, 0.50052, 0.958372, -0.103248, 0.211796, 0.528715, 0.959654, -0.106033, 0.21016, 0.557065, 0.961305, -0.108384, 0.208149, 0.585286, 0.962785, -0.111122, 0.206024, 0.613334, 0.964848, -0.112981, 0.203442, 0.641334, 0.966498, -0.113717, 0.19996, 0.669955, 0.968678, -0.114121, 0.196105, 0.698094, 0.970489, -0.114524, 0.191906, 0.725643, 0.972903, -0.113792, 0.186963, 0.752856, 0.974701, -0.112406, 0.181343, 0.780013, 0.976718, -0.110685, 0.175185, 0.806268, 0.978905, -0.108468, 0.168535, 0.832073, 0.980267, -0.105061, 0.161106, 0.857149, 0.981967, -0.101675, 0.153387, 0.881145, 0.983063, -0.0974492, 0.145199, 0.904255, 0.984432, -0.0925815, 0.136527, 0.926686, 0.985734, -0.0877983, 0.127584, 0.947901, 0.986228, -0.081884, 0.118125, 0.968111, 0.98719, -0.0761208, 0.108594, 0.98719, 0.988228, -0.0698196, 0.0989996, 1.00559, 0.989046, -0.0632739, 0.0890074, 1.02246, 0.990242, -0.056522, 0.0790832, 1.03841, 0.991252, -0.0495272, 0.0689182, 1.05347, 0.992542, -0.0425373, 0.0588592, 1.06724, 0.994096, -0.0353198, 0.0486833, 1.08009, 0.995593, -0.028235, 0.0385977, 1.09177, 0.99711, -0.0209511, 0.0286457, 1.10274, 0.998263, -0.0139289, 0.0188497, 1.11262, 0.999254, -67359e-7, 9208e-6, 1.12191, 0.999967, 141846e-9, -657764e-10, 1.13024, 0.935608, -474692e-11, 0.236466, 187817e-10, 0.93996, -11971e-8, 0.237568, 473646e-9, 0.939959, -478845e-9, 0.237567, 18946e-7, 0.939954, -10774e-7, 0.237566, 426284e-8, 0.939956, -191538e-8, 0.237566, 757842e-8, 0.939954, -299277e-8, 0.237566, 0.0118413, 0.93996, -430961e-8, 0.237567, 0.0170518, 0.939969, -586589e-8, 0.237569, 0.02321, 0.939982, -766166e-8, 0.237572, 0.0303164, 0.939987, -969686e-8, 0.237572, 0.0383711, 0.939997, -0.0119715, 0.237574, 0.0473751, 0.940031, -0.0144858, 0.237581, 0.0573298, 0.940073, -0.0172399, 0.237589, 0.0682366, 0.94012, -0.0202335, 0.237598, 0.080097, 0.940162, -0.0234663, 0.237604, 0.0929116, 0.940237, -0.0269387, 0.237615, 0.106686, 0.940328, -0.0306489, 0.237632, 0.121421, 0.940419, -0.0345917, 0.237645, 0.137115, 0.940522, -0.0387481, 0.237654, 0.153766, 0.940702, -0.0429906, 0.237661, 0.17133, 0.940871, -0.0465089, 0.237561, 0.189502, 0.941103, -0.050531, 0.23748, 0.208616, 0.941369, -0.0550657, 0.237423, 0.228595, 0.941641, -0.0601337, 0.237399, 0.249287, 0.941903, -0.0658804, 0.237443, 0.270467, 0.942224, -0.0722674, 0.237597, 0.292024, 0.942633, -0.0771788, 0.237419, 0.315272, 0.943172, -0.0815623, 0.237068, 0.339579, 0.943691, -0.0863973, 0.236682, 0.364717, 0.944382, -0.0911536, 0.236213, 0.390435, 0.945392, -0.0952967, 0.235562, 0.416425, 0.946185, -0.0998948, 0.234832, 0.442772, 0.947212, -0.104796, 0.234114, 0.469347, 0.948778, -0.10928, 0.233222, 0.496162, 0.950149, -0.113081, 0.231845, 0.523978, 0.951989, -0.115893, 0.230005, 0.552295, 0.953921, -0.11846, 0.227862, 0.580569, 0.955624, -0.12115, 0.225439, 0.608698, 0.958234, -0.123373, 0.222635, 0.636696, 0.960593, -0.124519, 0.219093, 0.665208, 0.963201, -0.124736, 0.214749, 0.693557, 0.965642, -0.125012, 0.210059, 0.721334, 0.968765, -0.124661, 0.204935, 0.748613, 0.971753, -0.122996, 0.198661, 0.776224, 0.973751, -0.120998, 0.191823, 0.802461, 0.976709, -0.118583, 0.184359, 0.828399, 0.977956, -0.115102, 0.176437, 0.853693, 0.979672, -0.111077, 0.167681, 0.877962, 0.981816, -0.10688, 0.158872, 0.901564, 0.98238, -0.101469, 0.149398, 0.924057, 0.983964, -0.0960013, 0.139436, 0.945751, 0.984933, -0.0899626, 0.12943, 0.966272, 0.985694, -0.0832973, 0.11894, 0.985741, 0.986822, -0.0767082, 0.108349, 1.00407, 0.987725, -0.0693614, 0.0976026, 1.02154, 0.98877, -0.06211, 0.086652, 1.03757, 0.990129, -0.0544143, 0.0756182, 1.05296, 0.991337, -0.046744, 0.0645753, 1.06683, 0.992978, -0.0387931, 0.0534683, 1.0798, 0.994676, -0.030973, 0.0424137, 1.09181, 0.99645, -0.0230311, 0.0314035, 1.10286, 0.997967, -0.0152065, 0.0206869, 1.11291, 0.99922, -744837e-8, 0.010155, 1.12237, 1.00002, 240209e-9, -752767e-10, 1.13089, 0.922948, -515351e-11, 0.255626, 186069e-10, 0.928785, -129623e-9, 0.257244, 468009e-9, 0.928761, -51849e-8, 0.257237, 187202e-8, 0.928751, -11666e-7, 0.257235, 421204e-8, 0.928751, -207395e-8, 0.257234, 74881e-7, 0.928754, -324055e-8, 0.257235, 0.0117002, 0.92876, -466639e-8, 0.257236, 0.0168486, 0.928763, -635149e-8, 0.257237, 0.0229334, 0.928774, -829584e-8, 0.257239, 0.029955, 0.928791, -0.0104995, 0.257243, 0.0379139, 0.928804, -0.0129623, 0.257245, 0.0468108, 0.928847, -0.0156846, 0.257255, 0.0566473, 0.92889, -0.0186661, 0.257263, 0.0674246, 0.928924, -0.0219067, 0.257268, 0.0791433, 0.928989, -0.0254066, 0.257282, 0.0918076, 0.92909, -0.0291651, 0.257301, 0.105419, 0.92918, -0.0331801, 0.257316, 0.119978, 0.92929, -0.0374469, 0.257332, 0.135491, 0.929453, -0.041939, 0.257357, 0.151948, 0.929586, -0.0464612, 0.257347, 0.169275, 0.929858, -0.0503426, 0.257269, 0.187257, 0.930125, -0.0548409, 0.257199, 0.206204, 0.930403, -0.0598063, 0.257149, 0.22601, 0.930726, -0.0652437, 0.257122, 0.246561, 0.931098, -0.0712376, 0.257153, 0.267618, 0.931396, -0.0777506, 0.257237, 0.288993, 0.931947, -0.0832374, 0.257124, 0.311527, 0.932579, -0.0883955, 0.25683, 0.335697, 0.933194, -0.0937037, 0.256444, 0.360634, 0.934013, -0.0987292, 0.255939, 0.386126, 0.935307, -0.103215, 0.255282, 0.412018, 0.936374, -0.108234, 0.254538, 0.438292, 0.93776, -0.113234, 0.253728, 0.464805, 0.939599, -0.118013, 0.25275, 0.491464, 0.941036, -0.122661, 0.251404, 0.518751, 0.94337, -0.125477, 0.249435, 0.547133, 0.945318, -0.128374, 0.247113, 0.575456, 0.947995, -0.130996, 0.244441, 0.60372, 0.950818, -0.133438, 0.241352, 0.63174, 0.954378, -0.135004, 0.237849, 0.659971, 0.957151, -0.135313, 0.233188, 0.688478, 0.960743, -0.13521, 0.228001, 0.716767, 0.964352, -0.135007, 0.222249, 0.744349, 0.967273, -0.133523, 0.21542, 0.771786, 0.969767, -0.131155, 0.208039, 0.798639, 0.973195, -0.128492, 0.200076, 0.824774, 0.975557, -0.125094, 0.191451, 0.850222, 0.977692, -0.120578, 0.18184, 0.874761, 0.98026, -0.115882, 0.172102, 0.898497, 0.981394, -0.110372, 0.161859, 0.921636, 0.982386, -0.10415, 0.15108, 0.943467, 0.983783, -0.0978128, 0.140407, 0.964045, 0.98422, -0.0906171, 0.129058, 0.98398, 0.985447, -0.0832921, 0.117614, 1.00276, 0.986682, -0.0754412, 0.10585, 1.02047, 0.987326, -0.0673885, 0.0940943, 1.03678, 0.988707, -0.0592565, 0.0822093, 1.05218, 0.990185, -0.050717, 0.070192, 1.06652, 0.991866, -0.0423486, 0.0582081, 1.07965, 0.993897, -0.0336118, 0.0460985, 1.09188, 0.995841, -0.0252178, 0.0342737, 1.10307, 0.997605, -0.0164893, 0.0224829, 1.11324, 0.999037, -817112e-8, 0.0110647, 1.12262, 1.00003, 291686e-9, -168673e-9, 1.13139, 0.915304, -552675e-11, 0.275999, 183285e-10, 0.91668, -139285e-9, 0.276414, 461914e-9, 0.916664, -55713e-8, 0.276409, 184763e-8, 0.916653, -125354e-8, 0.276406, 415715e-8, 0.916651, -222851e-8, 0.276405, 739053e-8, 0.916655, -348205e-8, 0.276406, 0.0115478, 0.916653, -501414e-8, 0.276405, 0.0166291, 0.916667, -682478e-8, 0.276409, 0.0226346, 0.91668, -891398e-8, 0.276412, 0.0295648, 0.91669, -0.0112817, 0.276413, 0.0374199, 0.916727, -0.013928, 0.276422, 0.0462016, 0.916759, -0.0168528, 0.276429, 0.0559101, 0.916793, -0.0200558, 0.276436, 0.0665466, 0.916849, -0.0235373, 0.276448, 0.0781139, 0.916964, -0.0272973, 0.276474, 0.0906156, 0.917047, -0.0313344, 0.276491, 0.104051, 0.917152, -0.0356465, 0.276511, 0.118424, 0.917286, -0.0402271, 0.276533, 0.133736, 0.917469, -0.0450408, 0.276564, 0.149978, 0.917686, -0.0497872, 0.276563, 0.167057, 0.917953, -0.0540937, 0.276493, 0.184846, 0.918228, -0.0590709, 0.276437, 0.203614, 0.918572, -0.0644277, 0.276398, 0.223212, 0.918918, -0.0702326, 0.276362, 0.243584, 0.919356, -0.076484, 0.276383, 0.264465, 0.919842, -0.0830808, 0.276434, 0.285701, 0.920451, -0.0892972, 0.276407, 0.307559, 0.921113, -0.095016, 0.276128, 0.331501, 0.921881, -0.100771, 0.275754, 0.356207, 0.923027, -0.106029, 0.275254, 0.381477, 0.924364, -0.111029, 0.274595, 0.40722, 0.925818, -0.116345, 0.273841, 0.433385, 0.92746, -0.121424, 0.272913, 0.459848, 0.929167, -0.12657, 0.271837, 0.486493, 0.931426, -0.131581, 0.270575, 0.513432, 0.934001, -0.135038, 0.268512, 0.541502, 0.936296, -0.138039, 0.266135, 0.569658, 0.939985, -0.140687, 0.263271, 0.598375, 0.943516, -0.143247, 0.260058, 0.626563, 0.94782, -0.145135, 0.256138, 0.654711, 0.951023, -0.145733, 0.251154, 0.683285, 0.955338, -0.145554, 0.245562, 0.711831, 0.959629, -0.145008, 0.239265, 0.739573, 0.963123, -0.144003, 0.232064, 0.767027, 0.966742, -0.141289, 0.224036, 0.794359, 0.969991, -0.138247, 0.215305, 0.820361, 0.973403, -0.134786, 0.206051, 0.846548, 0.975317, -0.129966, 0.195914, 0.871541, 0.977647, -0.12471, 0.185184, 0.895313, 0.980137, -0.119086, 0.174161, 0.918398, 0.981031, -0.112297, 0.162792, 0.940679, 0.982037, -0.105372, 0.150952, 0.961991, 0.983164, -0.097821, 0.138921, 0.981913, 0.983757, -0.0897245, 0.126611, 1.00109, 0.985036, -0.0815974, 0.114228, 1.01902, 0.986289, -0.0727725, 0.101389, 1.03604, 0.987329, -0.0639323, 0.0886476, 1.05149, 0.989193, -0.0548109, 0.0756837, 1.06619, 0.990716, -0.045687, 0.0627581, 1.07948, 0.992769, -0.0364315, 0.0498337, 1.09172, 0.99524, -0.0271761, 0.0370305, 1.1033, 0.997154, -0.0179609, 0.0243959, 1.11353, 0.998845, -878063e-8, 0.0119567, 1.12319, 1.00002, 259038e-9, -108146e-9, 1.13177, 0.903945, -591681e-11, 0.295126, 181226e-10, 0.903668, -148672e-9, 0.295037, 455367e-9, 0.903677, -594683e-9, 0.29504, 182145e-8, 0.903673, -133805e-8, 0.295039, 409831e-8, 0.903666, -237872e-8, 0.295036, 728584e-8, 0.903668, -371676e-8, 0.295037, 0.0113842, 0.903679, -535212e-8, 0.29504, 0.0163936, 0.903684, -728479e-8, 0.295041, 0.0223141, 0.903698, -951473e-8, 0.295044, 0.0291462, 0.903718, -0.0120419, 0.295049, 0.0368904, 0.903754, -0.0148664, 0.295058, 0.0455477, 0.903801, -0.017988, 0.29507, 0.0551194, 0.903851, -0.0214064, 0.295082, 0.0656058, 0.903921, -0.0251219, 0.295097, 0.0770109, 0.904002, -0.0291337, 0.295116, 0.0893354, 0.904111, -0.033441, 0.29514, 0.102583, 0.904246, -0.0380415, 0.295169, 0.116755, 0.904408, -0.0429258, 0.295202, 0.131853, 0.904637, -0.0480468, 0.295245, 0.147869, 0.904821, -0.0529208, 0.295214, 0.164658, 0.905163, -0.0577748, 0.295185, 0.182274, 0.905469, -0.0631763, 0.295143, 0.200828, 0.905851, -0.068917, 0.295112, 0.2202, 0.906322, -0.0750861, 0.295104, 0.240372, 0.906761, -0.0815855, 0.295086, 0.261082, 0.90735, -0.0882138, 0.295095, 0.282123, 0.908087, -0.095082, 0.295139, 0.303563, 0.908826, -0.101488, 0.29492, 0.327028, 0.909832, -0.107577, 0.294577, 0.351464, 0.911393, -0.113033, 0.294115, 0.376497, 0.912804, -0.118629, 0.293446, 0.402115, 0.914081, -0.124232, 0.292581, 0.428111, 0.91637, -0.129399, 0.29166, 0.454442, 0.91814, -0.134892, 0.290422, 0.481024, 0.921179, -0.140069, 0.289194, 0.507924, 0.924544, -0.144431, 0.287421, 0.535557, 0.927995, -0.147498, 0.284867, 0.563984, 0.931556, -0.150197, 0.281722, 0.5923, 0.935777, -0.152711, 0.278207, 0.620832, 0.940869, -0.154836, 0.274148, 0.649069, 0.945994, -0.155912, 0.269057, 0.677746, 0.949634, -0.155641, 0.262799, 0.706293, 0.955032, -0.154809, 0.256097, 0.734278, 0.95917, -0.153678, 0.248618, 0.761751, 0.962931, -0.151253, 0.239794, 0.789032, 0.966045, -0.147625, 0.230281, 0.815422, 0.96971, -0.143964, 0.220382, 0.841787, 0.972747, -0.139464, 0.209846, 0.867446, 0.975545, -0.133459, 0.198189, 0.892004, 0.978381, -0.127424, 0.186362, 0.915458, 0.979935, -0.120506, 0.173964, 0.937948, 0.980948, -0.11282, 0.161429, 0.959732, 0.982234, -0.104941, 0.148557, 0.980118, 0.982767, -0.0962905, 0.135508, 0.999463, 0.983544, -0.0873625, 0.122338, 1.01756, 0.984965, -0.0783447, 0.108669, 1.03492, 0.986233, -0.0684798, 0.0949911, 1.05087, 0.987796, -0.0590867, 0.0811386, 1.0656, 0.989885, -0.0489145, 0.0673099, 1.0794, 0.991821, -0.0391, 0.0535665, 1.09174, 0.99448, -0.029087, 0.0397529, 1.10341, 0.996769, -0.019114, 0.0261463, 1.11383, 0.998641, -947007e-8, 0.0128731, 1.1237, 0.999978, 446316e-9, -169093e-9, 1.13253, 0.888362, -627064e-11, 0.312578, 178215e-10, 0.889988, -157791e-9, 0.313148, 448451e-9, 0.889825, -631076e-9, 0.313092, 179356e-8, 0.88984, -141994e-8, 0.313097, 403554e-8, 0.889828, -25243e-7, 0.313092, 717429e-8, 0.889831, -394421e-8, 0.313093, 0.0112099, 0.889831, -567962e-8, 0.313093, 0.0161425, 0.889844, -773051e-8, 0.313096, 0.0219724, 0.889858, -0.0100968, 0.3131, 0.0286999, 0.889882, -0.0127786, 0.313106, 0.0363256, 0.889918, -0.0157757, 0.313116, 0.0448509, 0.889967, -0.0190878, 0.313129, 0.0542758, 0.89003, -0.022715, 0.313145, 0.0646032, 0.890108, -0.0266566, 0.313165, 0.0758339, 0.890218, -0.0309131, 0.313193, 0.0879729, 0.890351, -0.0354819, 0.313226, 0.101019, 0.89051, -0.0403613, 0.313263, 0.114979, 0.890672, -0.0455385, 0.313294, 0.129848, 0.890882, -0.0509444, 0.313333, 0.145616, 0.891189, -0.0559657, 0.313324, 0.162122, 0.891457, -0.0613123, 0.313281, 0.179524, 0.891856, -0.0671488, 0.313281, 0.197855, 0.892312, -0.0732732, 0.313268, 0.216991, 0.892819, -0.0797865, 0.313263, 0.236924, 0.893369, -0.0865269, 0.313247, 0.257433, 0.894045, -0.0931592, 0.313205, 0.278215, 0.894884, -0.100532, 0.313276, 0.299467, 0.895832, -0.107716, 0.313205, 0.322276, 0.897043, -0.114099, 0.312873, 0.34642, 0.898515, -0.119941, 0.312331, 0.371187, 0.900191, -0.126044, 0.311731, 0.396656, 0.90188, -0.131808, 0.310859, 0.422488, 0.904359, -0.137289, 0.309857, 0.448744, 0.906923, -0.142991, 0.308714, 0.475239, 0.910634, -0.148253, 0.307465, 0.501983, 0.914502, -0.153332, 0.305774, 0.529254, 0.919046, -0.156646, 0.303156, 0.557709, 0.923194, -0.159612, 0.299928, 0.586267, 0.928858, -0.162027, 0.296245, 0.614925, 0.934464, -0.164203, 0.291832, 0.643187, 0.939824, -0.165602, 0.286565, 0.671601, 0.944582, -0.165383, 0.280073, 0.700213, 0.949257, -0.164439, 0.272891, 0.728432, 0.954389, -0.162953, 0.264771, 0.756082, 0.958595, -0.161007, 0.255927, 0.78369, 0.962138, -0.157243, 0.245769, 0.810769, 0.966979, -0.152872, 0.235127, 0.836999, 0.969566, -0.148209, 0.22347, 0.862684, 0.972372, -0.142211, 0.211147, 0.887847, 0.975916, -0.135458, 0.198606, 0.911843, 0.978026, -0.128398, 0.185498, 0.934795, 0.979686, -0.120313, 0.17171, 0.956787, 0.980748, -0.11166, 0.158159, 0.978046, 0.981622, -0.103035, 0.144399, 0.997693, 0.982356, -0.0930328, 0.13001, 1.01642, 0.983308, -0.0834627, 0.115778, 1.03366, 0.985037, -0.0732249, 0.101327, 1.05014, 0.986493, -0.0628145, 0.086554, 1.06507, 0.988484, -0.0526556, 0.0720413, 1.07907, 0.991051, -0.0415744, 0.0571151, 1.09189, 0.993523, -0.0314275, 0.0426643, 1.10369, 0.99628, -0.0203603, 0.0279325, 1.11423, 0.998344, -0.0102446, 0.0138182, 1.12421, 0.999997, 42612e-8, -193628e-9, 1.1333, 0.871555, -660007e-11, 0.329176, 174749e-10, 0.875255, -166579e-9, 0.330571, 441051e-9, 0.875644, -666394e-9, 0.330718, 176441e-8, 0.875159, -149903e-8, 0.330536, 396899e-8, 0.87516, -266493e-8, 0.330536, 7056e-6, 0.875158, -416393e-8, 0.330535, 0.0110251, 0.87516, -599598e-8, 0.330535, 0.0158764, 0.875163, -816108e-8, 0.330536, 0.0216101, 0.875174, -0.0106591, 0.330538, 0.0282266, 0.875199, -0.0134899, 0.330545, 0.0357266, 0.875257, -0.0166538, 0.330563, 0.0441117, 0.875304, -0.0201501, 0.330575, 0.0533821, 0.875373, -0.0239785, 0.330595, 0.0635395, 0.875464, -0.0281389, 0.330619, 0.0745872, 0.875565, -0.0326301, 0.330645, 0.0865255, 0.875691, -0.0374516, 0.330676, 0.0993599, 0.875897, -0.0425993, 0.330733, 0.113093, 0.876091, -0.0480576, 0.330776, 0.127722, 0.876353, -0.0537216, 0.330826, 0.143227, 0.876649, -0.0589807, 0.330809, 0.159462, 0.877034, -0.0647865, 0.330819, 0.176642, 0.877443, -0.0709789, 0.330817, 0.194702, 0.877956, -0.0774782, 0.330832, 0.213577, 0.878499, -0.0843175, 0.330822, 0.233246, 0.879144, -0.0912714, 0.330804, 0.253512, 0.879982, -0.0980824, 0.330766, 0.274137, 0.88097, -0.105823, 0.330864, 0.295209, 0.882051, -0.113671, 0.330896, 0.317226, 0.883397, -0.120303, 0.330545, 0.341068, 0.884987, -0.12667, 0.330068, 0.365613, 0.886789, -0.133118, 0.329418, 0.390807, 0.889311, -0.139024, 0.328683, 0.416494, 0.891995, -0.144971, 0.327729, 0.442618, 0.895106, -0.150747, 0.326521, 0.469131, 0.899527, -0.156283, 0.325229, 0.495921, 0.90504, -0.161707, 0.32378, 0.523162, 0.909875, -0.165661, 0.32122, 0.55092, 0.91561, -0.168755, 0.317942, 0.579928, 0.921225, -0.171193, 0.313983, 0.608539, 0.927308, -0.17319, 0.309636, 0.636854, 0.933077, -0.174819, 0.304262, 0.66523, 0.938766, -0.175002, 0.297563, 0.693609, 0.943667, -0.173946, 0.289613, 0.722157, 0.949033, -0.172221, 0.281227, 0.750021, 0.953765, -0.169869, 0.271545, 0.777466, 0.95804, -0.166578, 0.261034, 0.804853, 0.962302, -0.161761, 0.249434, 0.831569, 0.966544, -0.156636, 0.237484, 0.857779, 0.969372, -0.150784, 0.224395, 0.883051, 0.972486, -0.143672, 0.210786, 0.907864, 0.975853, -0.135772, 0.196556, 0.931223, 0.977975, -0.127942, 0.182307, 0.954061, 0.979122, -0.118347, 0.167607, 0.97531, 0.980719, -0.109112, 0.152739, 0.995666, 0.981223, -0.0991789, 0.137932, 1.01475, 0.98216, -0.0883553, 0.122692, 1.03253, 0.983379, -0.0780825, 0.107493, 1.04917, 0.985434, -0.0665646, 0.0917791, 1.06464, 0.987332, -0.0557714, 0.0764949, 1.07896, 0.990004, -0.0442805, 0.060721, 1.09199, 0.992975, -0.0331676, 0.0452284, 1.10393, 0.995811, -0.0219547, 0.0297934, 1.11476, 0.9982, -0.0107613, 0.0146415, 1.12484, 1.00002, 248678e-9, -14555e-8, 1.13413, 0.859519, -693595e-11, 0.347264, 171673e-10, 0.859843, -17503e-8, 0.347394, 433219e-9, 0.859656, -700076e-9, 0.347319, 173277e-8, 0.859671, -157517e-8, 0.347325, 389875e-8, 0.859669, -280028e-8, 0.347324, 693112e-8, 0.85967, -43754e-7, 0.347324, 0.01083, 0.859665, -630049e-8, 0.347321, 0.0155954, 0.859685, -85755e-7, 0.347328, 0.0212278, 0.859694, -0.0112003, 0.347329, 0.0277273, 0.859718, -0.0141747, 0.347336, 0.0350946, 0.85976, -0.0174988, 0.347348, 0.0433314, 0.85982, -0.0211722, 0.347366, 0.0524384, 0.859892, -0.0251941, 0.347387, 0.0624168, 0.860006, -0.0295649, 0.347422, 0.0732708, 0.860122, -0.0342825, 0.347453, 0.0849999, 0.860282, -0.0393462, 0.347499, 0.0976102, 0.860482, -0.0447513, 0.347554, 0.111104, 0.860719, -0.0504775, 0.347614, 0.125479, 0.860998, -0.0563577, 0.347666, 0.140703, 0.861322, -0.0619473, 0.347662, 0.156681, 0.861724, -0.0681277, 0.347684, 0.173597, 0.862198, -0.0746567, 0.347709, 0.191371, 0.862733, -0.0815234, 0.347727, 0.209976, 0.863371, -0.0886643, 0.347744, 0.229351, 0.86414, -0.0957908, 0.347734, 0.24934, 0.865138, -0.102912, 0.34772, 0.269797, 0.866182, -0.110924, 0.3478, 0.290654, 0.867436, -0.119223, 0.347911, 0.312074, 0.869087, -0.126197, 0.347649, 0.335438, 0.870859, -0.133145, 0.347222, 0.359732, 0.872997, -0.139869, 0.346645, 0.38467, 0.875939, -0.146089, 0.345935, 0.41019, 0.879012, -0.152334, 0.345012, 0.436218, 0.883353, -0.15821, 0.343924, 0.462641, 0.888362, -0.164097, 0.342636, 0.489449, 0.895026, -0.169528, 0.341351, 0.516629, 0.900753, -0.174408, 0.339115, 0.544109, 0.906814, -0.17751, 0.335809, 0.572857, 0.912855, -0.180101, 0.331597, 0.601554, 0.919438, -0.182116, 0.32698, 0.630198, 0.925962, -0.183494, 0.321449, 0.658404, 0.931734, -0.184159, 0.314595, 0.686625, 0.93762, -0.18304, 0.306462, 0.71531, 0.943858, -0.181323, 0.297514, 0.744272, 0.948662, -0.178683, 0.287447, 0.771462, 0.953299, -0.175379, 0.276166, 0.798593, 0.957346, -0.170395, 0.263758, 0.8256, 0.962565, -0.165042, 0.251019, 0.852575, 0.966075, -0.158655, 0.237011, 0.878316, 0.969048, -0.151707, 0.222518, 0.90329, 0.972423, -0.143271, 0.207848, 0.927745, 0.975833, -0.134824, 0.192463, 0.950859, 0.977629, -0.125444, 0.1768, 0.972947, 0.978995, -0.114949, 0.161033, 0.993263, 0.980533, -0.104936, 0.145523, 1.01337, 0.980745, -0.0935577, 0.129799, 1.03128, 0.981814, -0.0822956, 0.113486, 1.04825, 0.983943, -0.0710082, 0.0972925, 1.06405, 0.986141, -0.0587931, 0.0808138, 1.0785, 0.988878, -0.0472755, 0.0644915, 1.09204, 0.992132, -0.0349128, 0.0478128, 1.10413, 0.9953, -0.0232407, 0.031621, 1.11527, 0.998117, -0.0112713, 0.0154935, 1.12551, 1.00003, 339743e-9, -195763e-9, 1.13504, 0.845441, -729126e-11, 0.364305, 169208e-10, 0.843588, -183164e-9, 0.363506, 425067e-9, 0.843412, -73253e-8, 0.36343, 169999e-8, 0.843401, -164818e-8, 0.363426, 382495e-8, 0.843399, -293008e-8, 0.363425, 679993e-8, 0.843401, -457822e-8, 0.363425, 0.010625, 0.843394, -659249e-8, 0.363421, 0.0153002, 0.843398, -897282e-8, 0.363421, 0.0208258, 0.843415, -0.0117191, 0.363426, 0.0272024, 0.843438, -0.0148312, 0.363432, 0.0344305, 0.843483, -0.018309, 0.363447, 0.0425116, 0.84356, -0.0221521, 0.363472, 0.0514471, 0.843646, -0.0263597, 0.363499, 0.061238, 0.843743, -0.0309315, 0.363527, 0.0718873, 0.84388, -0.0358658, 0.363569, 0.0833969, 0.844079, -0.0411624, 0.363631, 0.0957742, 0.844279, -0.0468128, 0.363688, 0.109015, 0.844549, -0.0527923, 0.363761, 0.123124, 0.844858, -0.0588204, 0.363817, 0.138044, 0.84522, -0.0647573, 0.36383, 0.153755, 0.845669, -0.0713181, 0.363879, 0.170394, 0.846155, -0.0781697, 0.363908, 0.187861, 0.846789, -0.0853913, 0.363969, 0.206176, 0.847502, -0.0928086, 0.363999, 0.225244, 0.8484, -0.10005, 0.363997, 0.244926, 0.849461, -0.107615, 0.364008, 0.265188, 0.850562, -0.115814, 0.364055, 0.28587, 0.851962, -0.124334, 0.364179, 0.306926, 0.854326, -0.131995, 0.364233, 0.329605, 0.856295, -0.139338, 0.363856, 0.35359, 0.858857, -0.146346, 0.363347, 0.37831, 0.862428, -0.152994, 0.362807, 0.403722, 0.866203, -0.159463, 0.361963, 0.429537, 0.871629, -0.165623, 0.36112, 0.456, 0.877365, -0.171649, 0.359917, 0.482773, 0.883744, -0.177151, 0.35848, 0.509705, 0.890693, -0.182381, 0.356523, 0.537215, 0.897278, -0.186076, 0.3533, 0.565493, 0.903958, -0.188602, 0.349095, 0.594293, 0.910908, -0.190755, 0.344215, 0.623165, 0.918117, -0.192063, 0.338606, 0.651573, 0.924644, -0.192758, 0.331544, 0.679869, 0.931054, -0.192238, 0.323163, 0.708668, 0.937303, -0.190035, 0.313529, 0.737201, 0.943387, -0.187162, 0.303152, 0.764977, 0.948494, -0.183876, 0.29146, 0.792683, 0.952546, -0.178901, 0.277917, 0.819228, 0.958077, -0.173173, 0.264753, 0.846559, 0.962462, -0.16645, 0.25002, 0.872962, 0.966569, -0.159452, 0.234873, 0.898729, 0.969108, -0.15074, 0.218752, 0.923126, 0.973072, -0.141523, 0.202673, 0.947278, 0.975452, -0.132075, 0.186326, 0.969938, 0.977784, -0.121257, 0.169396, 0.991325, 0.97899, -0.110182, 0.153044, 1.01123, 0.979777, -0.0989634, 0.136485, 1.0299, 0.980865, -0.0865894, 0.119343, 1.04727, 0.982432, -0.0746115, 0.102452, 1.06341, 0.984935, -0.0621822, 0.0852423, 1.07834, 0.987776, -0.0495694, 0.0678546, 1.092, 0.99103, -0.0372386, 0.0506917, 1.1043, 0.99474, -0.0244353, 0.0333316, 1.11576, 0.997768, -0.0121448, 0.0164348, 1.12617, 1.00003, 31774e-8, -169504e-9, 1.13598, 0.825551, -756799e-11, 0.378425, 165099e-10, 0.82664, -190922e-9, 0.378923, 416504e-9, 0.826323, -763495e-9, 0.378779, 16656e-7, 0.826359, -171789e-8, 0.378795, 374768e-8, 0.82636, -305402e-8, 0.378795, 666259e-8, 0.826368, -477185e-8, 0.378798, 0.0104104, 0.826364, -687131e-8, 0.378795, 0.0149912, 0.826368, -935232e-8, 0.378795, 0.0204054, 0.826376, -0.0122146, 0.378797, 0.0266532, 0.826399, -0.0154581, 0.378803, 0.0337355, 0.82646, -0.0190825, 0.378824, 0.0416537, 0.826525, -0.0230873, 0.378846, 0.0504091, 0.826614, -0.0274719, 0.378876, 0.0600032, 0.82674, -0.0322355, 0.378917, 0.0704393, 0.826888, -0.0373766, 0.378964, 0.0817195, 0.827078, -0.0428936, 0.379024, 0.0938492, 0.827318, -0.0487778, 0.379099, 0.106828, 0.82764, -0.0549935, 0.379199, 0.120659, 0.827926, -0.0611058, 0.379227, 0.13526, 0.828325, -0.0675054, 0.379275, 0.150713, 0.828801, -0.0743455, 0.379332, 0.167034, 0.8294, -0.0815523, 0.379415, 0.184209, 0.830094, -0.0890779, 0.379495, 0.202203, 0.8309, -0.096736, 0.379555, 0.220945, 0.831943, -0.104135, 0.379577, 0.240306, 0.833037, -0.112106, 0.379604, 0.260317, 0.834278, -0.120554, 0.379668, 0.2808, 0.836192, -0.129128, 0.3799, 0.301654, 0.838671, -0.137541, 0.380109, 0.323502, 0.840939, -0.14523, 0.379809, 0.347176, 0.844575, -0.15248, 0.379593, 0.371706, 0.848379, -0.159607, 0.37909, 0.39688, 0.853616, -0.166267, 0.378617, 0.422702, 0.858921, -0.172698, 0.377746, 0.448919, 0.865324, -0.178823, 0.376749, 0.475661, 0.872207, -0.184542, 0.375363, 0.502599, 0.880018, -0.189836, 0.373657, 0.529914, 0.88694, -0.194294, 0.370673, 0.557683, 0.894779, -0.197022, 0.36662, 0.586848, 0.902242, -0.199108, 0.36138, 0.615831, 0.909914, -0.200398, 0.355434, 0.644478, 0.917088, -0.20094, 0.348173, 0.672905, 0.923888, -0.200671, 0.339482, 0.701327, 0.930495, -0.198773, 0.32956, 0.730101, 0.937247, -0.195394, 0.318363, 0.758383, 0.943108, -0.191956, 0.306323, 0.786539, 0.948296, -0.187227, 0.292576, 0.813637, 0.953472, -0.181165, 0.278234, 0.840793, 0.958485, -0.174119, 0.263054, 0.867712, 0.962714, -0.166564, 0.246756, 0.893635, 0.966185, -0.158181, 0.229945, 0.919028, 0.970146, -0.148275, 0.212633, 0.943413, 0.973491, -0.138157, 0.195229, 0.966627, 0.975741, -0.127574, 0.178048, 0.988817, 0.977238, -0.11554, 0.160312, 1.00924, 0.978411, -0.10364, 0.142857, 1.02845, 0.979811, -0.0913122, 0.125317, 1.04648, 0.98116, -0.0782558, 0.107627, 1.06284, 0.983543, -0.0655957, 0.0895862, 1.07798, 0.986789, -0.0520411, 0.0713756, 1.092, 0.990292, -0.0389727, 0.053228, 1.10484, 0.994187, -0.025808, 0.0351945, 1.11642, 0.997499, -0.0126071, 0.0173198, 1.12703, 0.999999, 275604e-9, -148602e-9, 1.13674, 0.81075, -78735e-10, 0.394456, 161829e-10, 0.808692, -198293e-9, 0.393453, 407564e-9, 0.80846, -792877e-9, 0.39334, 162965e-8, 0.808595, -178416e-8, 0.393407, 366711e-8, 0.808597, -317182e-8, 0.393408, 651934e-8, 0.808598, -495589e-8, 0.393408, 0.0101866, 0.808591, -713627e-8, 0.393403, 0.0146689, 0.808592, -971285e-8, 0.393402, 0.0199667, 0.80861, -0.0126855, 0.393407, 0.0260803, 0.808633, -0.0160538, 0.393413, 0.0330107, 0.80868, -0.0198175, 0.393429, 0.0407589, 0.808748, -0.0239758, 0.393453, 0.0493264, 0.808854, -0.0285286, 0.39349, 0.0587161, 0.808992, -0.0334748, 0.39354, 0.0689304, 0.809141, -0.0388116, 0.393588, 0.0799707, 0.809352, -0.0445375, 0.39366, 0.0918432, 0.809608, -0.0506427, 0.393742, 0.104549, 0.809915, -0.0570708, 0.393834, 0.118085, 0.810253, -0.0633526, 0.393885, 0.132377, 0.810687, -0.0700966, 0.393953, 0.147537, 0.811233, -0.0772274, 0.394047, 0.163543, 0.811865, -0.0847629, 0.394148, 0.180394, 0.812648, -0.0925663, 0.394265, 0.198051, 0.813583, -0.100416, 0.394363, 0.216443, 0.814683, -0.108119, 0.394402, 0.235502, 0.815948, -0.11644, 0.394489, 0.255242, 0.817278, -0.125036, 0.394542, 0.275441, 0.819605, -0.133655, 0.39486, 0.296094, 0.822256, -0.142682, 0.395248, 0.317309, 0.825349, -0.150756, 0.395241, 0.340516, 0.829605, -0.158392, 0.395285, 0.364819, 0.83391, -0.165801, 0.394922, 0.389736, 0.839808, -0.172677, 0.394691, 0.415409, 0.845708, -0.179448, 0.394006, 0.441546, 0.853025, -0.185746, 0.393279, 0.46832, 0.859666, -0.191684, 0.391655, 0.495302, 0.86789, -0.197146, 0.390068, 0.52262, 0.875845, -0.201904, 0.38727, 0.550336, 0.882634, -0.205023, 0.382688, 0.578825, 0.891076, -0.207098, 0.377543, 0.608103, 0.900589, -0.208474, 0.371752, 0.63723, 0.90791, -0.209068, 0.364016, 0.665769, 0.915971, -0.208655, 0.355593, 0.694428, 0.923455, -0.20729, 0.345439, 0.723224, 0.931514, -0.203821, 0.334099, 0.751925, 0.937885, -0.19986, 0.321069, 0.780249, 0.943136, -0.194993, 0.306571, 0.8077, 0.948818, -0.189132, 0.291556, 0.83497, 0.954433, -0.181617, 0.275745, 0.86188, 0.959078, -0.173595, 0.258695, 0.888562, 0.962705, -0.164855, 0.240825, 0.914008, 0.966753, -0.155129, 0.22268, 0.939145, 0.970704, -0.144241, 0.204542, 0.963393, 0.973367, -0.133188, 0.185927, 0.985983, 0.975984, -0.121146, 0.167743, 1.00704, 0.976994, -0.108366, 0.149218, 1.02715, 0.978485, -0.0956746, 0.13131, 1.0455, 0.980074, -0.0820733, 0.112513, 1.06221, 0.98225, -0.0684061, 0.0938323, 1.07782, 0.98553, -0.0549503, 0.0749508, 1.09199, 0.989529, -0.0407857, 0.055848, 1.10508, 0.993536, -0.0271978, 0.0368581, 1.11684, 0.997247, -0.0132716, 0.0181845, 1.12789, 1, 431817e-9, -198809e-9, 1.13792, 0.785886, -812608e-11, 0.405036, 157669e-10, 0.790388, -205278e-9, 0.407355, 398297e-9, 0.790145, -820824e-9, 0.407231, 159263e-8, 0.790135, -184681e-8, 0.407226, 358336e-8, 0.790119, -328316e-8, 0.407218, 637039e-8, 0.790126, -512988e-8, 0.40722, 99539e-7, 0.79013, -738684e-8, 0.407221, 0.0143339, 0.790135, -0.0100538, 0.407221, 0.0195107, 0.790134, -0.0131306, 0.407217, 0.0254848, 0.79016, -0.0166169, 0.407224, 0.0322572, 0.790197, -0.020512, 0.407236, 0.0398284, 0.790273, -0.0248157, 0.407263, 0.0482014, 0.790381, -0.029527, 0.407304, 0.0573777, 0.790521, -0.0346446, 0.407355, 0.0673602, 0.790704, -0.0401665, 0.40742, 0.0781522, 0.790925, -0.0460896, 0.407499, 0.0897582, 0.791195, -0.0524017, 0.407589, 0.10218, 0.791522, -0.0590121, 0.407691, 0.11541, 0.791878, -0.0654876, 0.407748, 0.12939, 0.792361, -0.0725207, 0.407849, 0.144237, 0.792942, -0.0799844, 0.407963, 0.159924, 0.79362, -0.0877896, 0.408087, 0.176425, 0.794529, -0.0958451, 0.408259, 0.193733, 0.795521, -0.103827, 0.408362, 0.211756, 0.796778, -0.111937, 0.408482, 0.230524, 0.798027, -0.120521, 0.408547, 0.249967, 0.799813, -0.129242, 0.408721, 0.269926, 0.802387, -0.138048, 0.409148, 0.290338, 0.805279, -0.147301, 0.409641, 0.311193, 0.809251, -0.155895, 0.410154, 0.333611, 0.813733, -0.163942, 0.410297, 0.357615, 0.819081, -0.171666, 0.410373, 0.382339, 0.825427, -0.178905, 0.410348, 0.407828, 0.83172, -0.185812, 0.409486, 0.434034, 0.83877, -0.192318, 0.408776, 0.460493, 0.845817, -0.198249, 0.407176, 0.487346, 0.854664, -0.204034, 0.405719, 0.514832, 0.863495, -0.208908, 0.403282, 0.542401, 0.871883, -0.212765, 0.399293, 0.570683, 0.88065, -0.214911, 0.393803, 0.599947, 0.89004, -0.216214, 0.387536, 0.62932, 0.898476, -0.216745, 0.379846, 0.658319, 0.906738, -0.216387, 0.370625, 0.687138, 0.914844, -0.215053, 0.360139, 0.71601, 0.923877, -0.212007, 0.348849, 0.745124, 0.931925, -0.207481, 0.335639, 0.773366, 0.938054, -0.202418, 0.320798, 0.801636, 0.943895, -0.196507, 0.304772, 0.829055, 0.949468, -0.189009, 0.288033, 0.856097, 0.955152, -0.180539, 0.270532, 0.88301, 0.959403, -0.171437, 0.251639, 0.909296, 0.963309, -0.161661, 0.232563, 0.934868, 0.967399, -0.150425, 0.213231, 0.959662, 0.972009, -0.138659, 0.194247, 0.98302, 0.97433, -0.126595, 0.174718, 1.00517, 0.975823, -0.113205, 0.155518, 1.02566, 0.976371, -0.0996096, 0.136709, 1.04418, 0.978705, -0.0860754, 0.117571, 1.06146, 0.981477, -0.0714438, 0.0980046, 1.07777, 0.984263, -0.0572304, 0.0782181, 1.09214, 0.988423, -0.0428875, 0.0584052, 1.10553, 0.993, -0.0282442, 0.038522, 1.11758, 0.99704, -0.0140183, 0.0190148, 1.12864, 0.999913, 369494e-9, -145203e-9, 1.13901, 0.777662, -84153e-10, 0.423844, 154403e-10, 0.770458, -211714e-9, 0.419915, 38845e-8, 0.770716, -846888e-9, 0.420055, 155386e-8, 0.770982, -190567e-8, 0.420202, 349653e-8, 0.770981, -338782e-8, 0.420201, 621606e-8, 0.77098, -529338e-8, 0.4202, 971274e-8, 0.770983, -762223e-8, 0.4202, 0.0139867, 0.770985, -0.0103741, 0.420198, 0.0190381, 0.770996, -0.0135489, 0.4202, 0.0248677, 0.771029, -0.0171461, 0.420212, 0.0314764, 0.771052, -0.0211647, 0.420215, 0.0388648, 0.771131, -0.0256048, 0.420245, 0.047036, 0.771235, -0.0304647, 0.420284, 0.0559911, 0.771383, -0.0357436, 0.420341, 0.0657346, 0.771591, -0.0414392, 0.420423, 0.0762694, 0.771819, -0.0475462, 0.420506, 0.0875984, 0.772123, -0.0540506, 0.420617, 0.099727, 0.772464, -0.060797, 0.42072, 0.112637, 0.772855, -0.0675393, 0.420799, 0.126313, 0.773317, -0.0748323, 0.420893, 0.140824, 0.773981, -0.0825681, 0.421058, 0.15617, 0.774746, -0.0906307, 0.421226, 0.172322, 0.77566, -0.0988982, 0.421397, 0.189253, 0.776837, -0.106994, 0.421569, 0.206912, 0.778097, -0.115528, 0.421704, 0.225359, 0.779588, -0.124317, 0.421849, 0.24447, 0.781574, -0.133139, 0.422097, 0.264156, 0.784451, -0.142179, 0.422615, 0.284318, 0.787682, -0.15165, 0.423269, 0.304902, 0.792433, -0.160771, 0.424396, 0.3265, 0.797359, -0.169166, 0.424772, 0.35014, 0.803986, -0.177149, 0.425475, 0.374768, 0.809504, -0.184745, 0.424996, 0.399928, 0.815885, -0.19173, 0.424247, 0.425796, 0.823513, -0.198525, 0.423515, 0.452287, 0.832549, -0.204709, 0.422787, 0.479321, 0.841653, -0.210447, 0.421187, 0.506718, 0.850401, -0.215501, 0.418519, 0.53432, 0.859854, -0.219752, 0.414715, 0.56242, 0.869364, -0.222305, 0.409462, 0.591558, 0.878837, -0.223744, 0.402926, 0.621074, 0.888636, -0.224065, 0.395043, 0.650538, 0.898132, -0.223742, 0.38564, 0.679538, 0.907181, -0.222308, 0.375378, 0.708674, 0.915621, -0.219837, 0.363212, 0.737714, 0.9239, -0.215233, 0.349313, 0.767014, 0.931644, -0.209592, 0.334162, 0.795133, 0.938887, -0.203644, 0.317943, 0.823228, 0.945282, -0.196349, 0.300581, 0.850822, 0.950758, -0.18742, 0.282195, 0.877594, 0.956146, -0.177879, 0.262481, 0.904564, 0.960355, -0.167643, 0.242487, 0.930741, 0.965256, -0.156671, 0.222668, 0.955868, 0.968029, -0.144123, 0.201907, 0.979869, 0.97251, -0.131305, 0.18202, 1.00291, 0.974925, -0.118335, 0.161909, 1.02392, 0.975402, -0.103714, 0.142129, 1.0433, 0.976987, -0.089415, 0.122447, 1.06089, 0.979677, -0.0748858, 0.102248, 1.07713, 0.983184, -0.0596086, 0.0814851, 1.09218, 0.987466, -0.0447671, 0.0609484, 1.10585, 0.992348, -0.0295217, 0.0401835, 1.11829, 0.996674, -0.0143917, 0.0198163, 1.12966, 1.00003, 321364e-9, -149983e-9, 1.1402, 0.757901, -869074e-11, 0.436176, 151011e-10, 0.751195, -217848e-9, 0.432317, 378533e-9, 0.751178, -871373e-9, 0.432307, 15141e-7, 0.751195, -196061e-8, 0.432317, 34068e-7, 0.751198, -348552e-8, 0.432318, 605659e-8, 0.751195, -544599e-8, 0.432315, 946353e-8, 0.751207, -784203e-8, 0.43232, 0.013628, 0.751213, -0.0106732, 0.43232, 0.0185499, 0.751221, -0.0139393, 0.432319, 0.0242302, 0.751244, -0.0176398, 0.432325, 0.0306694, 0.7513, -0.0217743, 0.432348, 0.0378698, 0.751358, -0.0263412, 0.432367, 0.0458321, 0.751458, -0.0313396, 0.432404, 0.0545587, 0.751608, -0.0367682, 0.432464, 0.0640543, 0.7518, -0.0426246, 0.43254, 0.0743222, 0.752065, -0.0489031, 0.432645, 0.0853668, 0.752376, -0.0555828, 0.432762, 0.0971911, 0.752715, -0.0623861, 0.432859, 0.109768, 0.753137, -0.069415, 0.432958, 0.123126, 0.753676, -0.0770039, 0.433099, 0.137308, 0.754345, -0.084971, 0.433272, 0.15229, 0.755235, -0.0932681, 0.433504, 0.168075, 0.756186, -0.10171, 0.433693, 0.184625, 0.757363, -0.110019, 0.433857, 0.201897, 0.75884, -0.11887, 0.434102, 0.220014, 0.760467, -0.127881, 0.434306, 0.238778, 0.762969, -0.136766, 0.434751, 0.258172, 0.765823, -0.14612, 0.43529, 0.278062, 0.769676, -0.15566, 0.436236, 0.298437, 0.774909, -0.165177, 0.437754, 0.319532, 0.77994, -0.17402, 0.438343, 0.342505, 0.785757, -0.182201, 0.438609, 0.366693, 0.792487, -0.190104, 0.438762, 0.391668, 0.80038, -0.197438, 0.438795, 0.417494, 0.808494, -0.204365, 0.438226, 0.443933, 0.817695, -0.210714, 0.437283, 0.470929, 0.828111, -0.216651, 0.436087, 0.498569, 0.837901, -0.221804, 0.433717, 0.526165, 0.847813, -0.226318, 0.430133, 0.554155, 0.858314, -0.229297, 0.425213, 0.582822, 0.868891, -0.230999, 0.418576, 0.612847, 0.878941, -0.231155, 0.410405, 0.642445, 0.888809, -0.230935, 0.400544, 0.672024, 0.898089, -0.229343, 0.389613, 0.701366, 0.908081, -0.226886, 0.377197, 0.730763, 0.916819, -0.222676, 0.363397, 0.759642, 0.924968, -0.216835, 0.347437, 0.788775, 0.932906, -0.210245, 0.32995, 0.817135, 0.940025, -0.202992, 0.312262, 0.844912, 0.946101, -0.19436, 0.293313, 0.872164, 0.952835, -0.184125, 0.273638, 0.899443, 0.957347, -0.173657, 0.252385, 0.926389, 0.961434, -0.162204, 0.231038, 0.951947, 0.965522, -0.14979, 0.209834, 0.976751, 0.969412, -0.136307, 0.188821, 1.00022, 0.973902, -0.122527, 0.168013, 1.02229, 0.974045, -0.108213, 0.147634, 1.04199, 0.975775, -0.0927397, 0.12705, 1.06019, 0.978383, -0.0778212, 0.106309, 1.07711, 0.98211, -0.0621216, 0.0849279, 1.09245, 0.986517, -0.0463847, 0.0633519, 1.10651, 0.991696, -0.0309353, 0.0419698, 1.11903, 0.996349, -0.0150914, 0.0206272, 1.13073, 1.00003, 442449e-9, -231396e-9, 1.14146, 0.727498, -885074e-11, 0.441528, 145832e-10, 0.730897, -223525e-9, 0.443589, 368298e-9, 0.730796, -893996e-9, 0.443528, 147303e-8, 0.730805, -201149e-8, 0.443533, 331433e-8, 0.730814, -357596e-8, 0.443538, 589222e-8, 0.730815, -558734e-8, 0.443538, 920678e-8, 0.730822, -804544e-8, 0.44354, 0.0132582, 0.730836, -0.0109501, 0.443545, 0.0180468, 0.730848, -0.0143008, 0.443546, 0.0235732, 0.730871, -0.0180969, 0.443552, 0.0298382, 0.730915, -0.022338, 0.443567, 0.0368438, 0.730982, -0.0270225, 0.443591, 0.044591, 0.731076, -0.0321491, 0.443627, 0.0530831, 0.731245, -0.0377166, 0.443699, 0.0623243, 0.73144, -0.0437216, 0.443777, 0.0723181, 0.7317, -0.0501576, 0.443881, 0.0830691, 0.732034, -0.0569942, 0.444014, 0.0945809, 0.732388, -0.0638756, 0.444113, 0.106825, 0.732853, -0.071203, 0.444247, 0.119859, 0.733473, -0.0790076, 0.444442, 0.13369, 0.734195, -0.0871937, 0.444645, 0.148304, 0.735069, -0.095696, 0.444877, 0.163702, 0.736169, -0.10426, 0.445133, 0.179861, 0.73747, -0.112853, 0.44537, 0.196778, 0.738991, -0.12199, 0.445651, 0.214496, 0.740865, -0.131153, 0.445958, 0.232913, 0.743637, -0.140245, 0.446548, 0.251977, 0.746797, -0.149722, 0.447246, 0.271551, 0.751517, -0.159341, 0.448656, 0.291774, 0.756156, -0.169106, 0.449866, 0.312455, 0.761519, -0.178436, 0.450919, 0.334552, 0.768295, -0.186904, 0.451776, 0.358491, 0.776613, -0.195117, 0.452832, 0.383446, 0.783966, -0.202695, 0.45249, 0.408945, 0.793542, -0.20985, 0.452587, 0.435364, 0.803192, -0.216403, 0.451852, 0.462336, 0.813892, -0.22251, 0.450708, 0.48987, 0.824968, -0.227676, 0.4486, 0.517697, 0.835859, -0.232443, 0.445156, 0.545975, 0.846825, -0.235775, 0.440351, 0.574483, 0.858085, -0.237897, 0.433641, 0.604246, 0.868825, -0.238074, 0.425354, 0.634101, 0.879638, -0.237661, 0.415383, 0.664201, 0.889966, -0.236186, 0.404136, 0.693918, 0.899479, -0.233599, 0.390917, 0.723481, 0.908769, -0.229737, 0.376352, 0.75258, 0.917966, -0.223836, 0.360372, 0.781764, 0.926304, -0.217067, 0.342551, 0.811139, 0.934626, -0.209309, 0.324238, 0.839585, 0.941841, -0.20071, 0.304484, 0.867044, 0.94789, -0.190602, 0.283607, 0.894579, 0.954196, -0.179253, 0.262205, 0.921743, 0.958383, -0.167646, 0.239847, 0.948026, 0.963119, -0.155073, 0.218078, 0.973296, 0.966941, -0.141426, 0.195899, 0.998135, 0.970836, -0.126849, 0.174121, 1.02021, 0.973301, -0.112296, 0.153052, 1.04085, 0.97448, -0.0964965, 0.131733, 1.05946, 0.977045, -0.080489, 0.10997, 1.07693, 0.980751, -0.064844, 0.0881657, 1.09254, 0.985475, -0.0481938, 0.0657987, 1.10697, 0.991089, -0.0319185, 0.0435215, 1.12004, 0.996122, -0.0158088, 0.0214779, 1.13173, 1.00001, 372455e-9, -200295e-9, 1.14291, 0.708622, -907597e-11, 0.45304, 141962e-10, 0.711162, -228911e-9, 0.454662, 358052e-9, 0.709812, -914446e-9, 0.453797, 143034e-8, 0.709865, -205819e-8, 0.453834, 321935e-8, 0.709864, -365894e-8, 0.453833, 572331e-8, 0.709855, -571692e-8, 0.453826, 894278e-8, 0.709862, -823201e-8, 0.453828, 0.012878, 0.709875, -0.011204, 0.453832, 0.0175295, 0.709896, -0.0146323, 0.453839, 0.0228978, 0.709925, -0.0185163, 0.453847, 0.0289839, 0.709974, -0.0228551, 0.453866, 0.0357894, 0.710045, -0.0276473, 0.453892, 0.0433161, 0.710133, -0.032891, 0.453924, 0.0515665, 0.710292, -0.0385851, 0.453992, 0.0605458, 0.710485, -0.0447254, 0.45407, 0.0702574, 0.710769, -0.0513051, 0.454192, 0.0807077, 0.711106, -0.0582733, 0.454329, 0.091896, 0.711516, -0.0652866, 0.45446, 0.103814, 0.712071, -0.0728426, 0.454653, 0.116508, 0.712676, -0.0808307, 0.45484, 0.129968, 0.713476, -0.0892216, 0.455096, 0.144206, 0.714377, -0.0979047, 0.455346, 0.159212, 0.715579, -0.106531, 0.455647, 0.174973, 0.716977, -0.115492, 0.455961, 0.191504, 0.71862, -0.124821, 0.456315, 0.208835, 0.72084, -0.134079, 0.4568, 0.226869, 0.723786, -0.143427, 0.457521, 0.245582, 0.727464, -0.153061, 0.458475, 0.264957, 0.732771, -0.162768, 0.460239, 0.284948, 0.736515, -0.172627, 0.460899, 0.30522, 0.743519, -0.182487, 0.463225, 0.326717, 0.750041, -0.191295, 0.464027, 0.350113, 0.758589, -0.199746, 0.465227, 0.374782, 0.767703, -0.207584, 0.465877, 0.400226, 0.777484, -0.214973, 0.465996, 0.426442, 0.788792, -0.221796, 0.466019, 0.453688, 0.800194, -0.228038, 0.465083, 0.481246, 0.811234, -0.233346, 0.462506, 0.509086, 0.822859, -0.238073, 0.459257, 0.537338, 0.835082, -0.241764, 0.454863, 0.566108, 0.846332, -0.244241, 0.448163, 0.595126, 0.858355, -0.244736, 0.439709, 0.625574, 0.87034, -0.244278, 0.429837, 0.65617, 0.881027, -0.24255, 0.418002, 0.686029, 0.891007, -0.239912, 0.404325, 0.716039, 0.900874, -0.236133, 0.389222, 0.745518, 0.911072, -0.230672, 0.373269, 0.775026, 0.920359, -0.22356, 0.355083, 0.804521, 0.928604, -0.215591, 0.335533, 0.834045, 0.937175, -0.206503, 0.315278, 0.861612, 0.942825, -0.196684, 0.293653, 0.889131, 0.949805, -0.185116, 0.271503, 0.916853, 0.955535, -0.172703, 0.248821, 0.943541, 0.959843, -0.159978, 0.225591, 0.970132, 0.964393, -0.146375, 0.202719, 0.994709, 0.968008, -0.131269, 0.179928, 1.0186, 0.971013, -0.11569, 0.158007, 1.03928, 0.973334, -0.1003, 0.13624, 1.05887, 0.975775, -0.0833352, 0.1138, 1.07652, 0.979579, -0.0668981, 0.0913141, 1.09297, 0.984323, -0.0500902, 0.0683051, 1.10734, 0.990351, -0.0332377, 0.0451771, 1.12084, 0.995823, -0.0161491, 0.0221705, 1.13296, 1.0001, 234083e-9, -108712e-9, 1.14441, 0.683895, -924677e-11, 0.46015, 137429e-10, 0.68833, -233383e-9, 0.463134, 346865e-9, 0.688368, -933547e-9, 0.463159, 138748e-8, 0.688367, -210049e-8, 0.463159, 312187e-8, 0.688369, -373415e-8, 0.463159, 555004e-8, 0.688377, -583449e-8, 0.463163, 867216e-8, 0.688386, -840128e-8, 0.463166, 0.0124884, 0.688398, -0.0114343, 0.463169, 0.0169993, 0.688418, -0.0149329, 0.463175, 0.0222054, 0.688453, -0.0188964, 0.463188, 0.028108, 0.688515, -0.0233239, 0.463214, 0.0347085, 0.68857, -0.0282136, 0.463231, 0.0420091, 0.688679, -0.033564, 0.463276, 0.0500132, 0.688854, -0.0393733, 0.463356, 0.0587255, 0.689038, -0.0456354, 0.46343, 0.0681476, 0.689321, -0.0523433, 0.463553, 0.0782897, 0.689662, -0.059412, 0.463693, 0.0891501, 0.690188, -0.0665736, 0.4639, 0.100735, 0.690755, -0.0743106, 0.464107, 0.113074, 0.691405, -0.0824722, 0.464329, 0.126161, 0.692198, -0.0910484, 0.464585, 0.140007, 0.693196, -0.0998778, 0.464893, 0.154612, 0.69454, -0.108651, 0.465285, 0.169984, 0.695921, -0.117855, 0.465596, 0.186106, 0.697749, -0.12734, 0.466056, 0.203034, 0.700375, -0.136714, 0.466771, 0.220703, 0.703395, -0.146386, 0.467579, 0.239062, 0.707904, -0.156096, 0.469067, 0.258188, 0.711673, -0.165904, 0.469851, 0.277759, 0.717489, -0.175812, 0.471815, 0.297935, 0.724051, -0.185931, 0.47389, 0.318916, 0.731965, -0.195238, 0.47587, 0.341591, 0.741151, -0.204021, 0.477523, 0.366062, 0.751416, -0.212113, 0.478881, 0.391396, 0.761848, -0.21979, 0.479226, 0.417599, 0.771886, -0.2267, 0.478495, 0.444401, 0.783998, -0.232991, 0.477622, 0.472084, 0.796523, -0.238645, 0.475833, 0.500193, 0.808851, -0.243396, 0.472568, 0.52865, 0.821191, -0.247226, 0.467857, 0.557362, 0.834261, -0.250102, 0.461871, 0.586768, 0.846762, -0.251056, 0.453543, 0.617085, 0.859867, -0.250604, 0.443494, 0.647659, 0.871948, -0.248783, 0.431711, 0.678119, 0.882967, -0.245855, 0.417911, 0.708399, 0.892826, -0.242168, 0.401993, 0.738256, 0.90332, -0.237062, 0.385371, 0.767999, 0.913633, -0.22997, 0.366837, 0.798191, 0.922774, -0.221687, 0.346372, 0.827756, 0.931371, -0.212345, 0.325682, 0.856425, 0.938929, -0.20206, 0.303665, 0.884299, 0.944821, -0.190981, 0.280786, 0.912023, 0.951792, -0.178065, 0.2573, 0.939669, 0.957712, -0.164634, 0.233448, 0.96655, 0.961912, -0.150863, 0.209504, 0.992366, 0.966382, -0.13577, 0.18597, 1.01633, 0.969588, -0.119593, 0.162905, 1.03843, 0.971777, -0.103203, 0.14053, 1.05841, 0.97433, -0.0865888, 0.117909, 1.07632, 0.978686, -0.0690829, 0.0944101, 1.09326, 0.983281, -0.0516568, 0.0705671, 1.10796, 0.989562, -0.034558, 0.0468592, 1.12182, 0.995465, -0.0167808, 0.0229846, 1.1342, 0.999991, 373016e-9, -235606e-9, 1.1459, 0.662251, -939016e-11, 0.468575, 132714e-10, 0.666634, -237624e-9, 0.471675, 335842e-9, 0.666411, -950385e-9, 0.471516, 134321e-8, 0.666399, -213833e-8, 0.471509, 302221e-8, 0.666386, -38014e-7, 0.471499, 537283e-8, 0.666405, -593958e-8, 0.471511, 839533e-8, 0.666406, -855253e-8, 0.471508, 0.0120898, 0.666428, -0.0116401, 0.471519, 0.0164569, 0.666444, -0.0152015, 0.471522, 0.0214971, 0.66649, -0.0192362, 0.471543, 0.027212, 0.666537, -0.0237428, 0.471558, 0.033603, 0.666617, -0.0287198, 0.471591, 0.0406728, 0.666718, -0.0341647, 0.471631, 0.0484238, 0.666889, -0.0400759, 0.47171, 0.0568621, 0.667104, -0.0464479, 0.471805, 0.0659915, 0.667374, -0.0532677, 0.471923, 0.0758178, 0.667772, -0.0603805, 0.472098, 0.0863425, 0.668371, -0.0677392, 0.472363, 0.0975917, 0.668971, -0.0756028, 0.472596, 0.109567, 0.669696, -0.0839293, 0.472869, 0.122272, 0.670481, -0.0926683, 0.473126, 0.135718, 0.6715, -0.1016, 0.473442, 0.149914, 0.672911, -0.110566, 0.47389, 0.164882, 0.674512, -0.119984, 0.474354, 0.180602, 0.67651, -0.129574, 0.474922, 0.19711, 0.679292, -0.139106, 0.475764, 0.214371, 0.682798, -0.148993, 0.476886, 0.232405, 0.686955, -0.158737, 0.478179, 0.251153, 0.691406, -0.168754, 0.479432, 0.270436, 0.697438, -0.178703, 0.481481, 0.290374, 0.704761, -0.188955, 0.484143, 0.311044, 0.713599, -0.198814, 0.487007, 0.333003, 0.723194, -0.207869, 0.488962, 0.357144, 0.732601, -0.216189, 0.489815, 0.382169, 0.744193, -0.22398, 0.490888, 0.408227, 0.754907, -0.231156, 0.490355, 0.434928, 0.767403, -0.23747, 0.489548, 0.462599, 0.78107, -0.243503, 0.488274, 0.490908, 0.793893, -0.248114, 0.484843, 0.519421, 0.807296, -0.25222, 0.4803, 0.548561, 0.820529, -0.255265, 0.474097, 0.577772, 0.833716, -0.256741, 0.466041, 0.607782, 0.848403, -0.25637, 0.456547, 0.638807, 0.860755, -0.254804, 0.443946, 0.670058, 0.874012, -0.251834, 0.430852, 0.700749, 0.885619, -0.247867, 0.414903, 0.731446, 0.896069, -0.242634, 0.397276, 0.761191, 0.906266, -0.236093, 0.378535, 0.791053, 0.916759, -0.227543, 0.358038, 0.821298, 0.92523, -0.21783, 0.335705, 0.850747, 0.93436, -0.207534, 0.313797, 0.879258, 0.941631, -0.195983, 0.289671, 0.907734, 0.947564, -0.183567, 0.265319, 0.935206, 0.953681, -0.169345, 0.240815, 0.962739, 0.960008, -0.154909, 0.216119, 0.989227, 0.964145, -0.140161, 0.192096, 1.01465, 0.968171, -0.123411, 0.167855, 1.03737, 0.969859, -0.106525, 0.144817, 1.05767, 0.972666, -0.0891023, 0.12149, 1.0761, 0.977055, -0.0718094, 0.0975306, 1.09336, 0.982527, -0.0534213, 0.0730217, 1.10878, 0.989001, -0.0355579, 0.0483366, 1.12285, 0.99512, -0.0176383, 0.023938, 1.13548, 1.00007, 368831e-9, -211581e-9, 1.14744, 0.651047, -960845e-11, 0.484101, 12922e-9, 0.644145, -241347e-9, 0.478968, 324578e-9, 0.64396, -965142e-9, 0.478831, 129798e-8, 0.64396, -217154e-8, 0.47883, 292046e-8, 0.643968, -386049e-8, 0.478835, 519202e-8, 0.643974, -603186e-8, 0.478838, 81128e-7, 0.643977, -86854e-7, 0.478836, 0.011683, 0.643982, -0.0118207, 0.478834, 0.0159031, 0.644024, -0.0154374, 0.478856, 0.0207743, 0.644059, -0.0195343, 0.478868, 0.0262975, 0.644122, -0.0241103, 0.478896, 0.0324747, 0.644207, -0.0291638, 0.478933, 0.039309, 0.64432, -0.0346919, 0.478981, 0.0468029, 0.644481, -0.0406919, 0.479053, 0.0549614, 0.644722, -0.047159, 0.479169, 0.0637909, 0.645013, -0.0540748, 0.479302, 0.0732974, 0.645503, -0.0612001, 0.479541, 0.0834898, 0.646117, -0.0687303, 0.479829, 0.0943873, 0.646707, -0.0767846, 0.480061, 0.105991, 0.647431, -0.0852465, 0.480343, 0.11831, 0.64831, -0.0940719, 0.48066, 0.131348, 0.649486, -0.103056, 0.481083, 0.14514, 0.650864, -0.112261, 0.481528, 0.159676, 0.652604, -0.121852, 0.482102, 0.174979, 0.654825, -0.131505, 0.482813, 0.191079, 0.657876, -0.141189, 0.483876, 0.207927, 0.661339, -0.151239, 0.48499, 0.225586, 0.665463, -0.161091, 0.486279, 0.243947, 0.670542, -0.171235, 0.487968, 0.262957, 0.677361, -0.181347, 0.49053, 0.282781, 0.685672, -0.191679, 0.493862, 0.303311, 0.694551, -0.201781, 0.49699, 0.324607, 0.703753, -0.211164, 0.498884, 0.347916, 0.713703, -0.219675, 0.500086, 0.372628, 0.725911, -0.227836, 0.501554, 0.398694, 0.73862, -0.23533, 0.502193, 0.425529, 0.752118, -0.241786, 0.501811, 0.453209, 0.76579, -0.247865, 0.500185, 0.481381, 0.779568, -0.252696, 0.497159, 0.51011, 0.793991, -0.256802, 0.492765, 0.539322, 0.808182, -0.259942, 0.486827, 0.569078, 0.821698, -0.261703, 0.478386, 0.598818, 0.836009, -0.262006, 0.468772, 0.629762, 0.849824, -0.260333, 0.456352, 0.661366, 0.863888, -0.257398, 0.442533, 0.69295, 0.876585, -0.253264, 0.426573, 0.723608, 0.888665, -0.248026, 0.408964, 0.754378, 0.899537, -0.241487, 0.389677, 0.784761, 0.9094, -0.233463, 0.368516, 0.814688, 0.920166, -0.223397, 0.346624, 0.845009, 0.928899, -0.21255, 0.322717, 0.874431, 0.937156, -0.200869, 0.298698, 0.902922, 0.943861, -0.188387, 0.273491, 0.931356, 0.949557, -0.174341, 0.247866, 0.958854, 0.955862, -0.158994, 0.222496, 0.986098, 0.961721, -0.143664, 0.197522, 1.01229, 0.965976, -0.127412, 0.17302, 1.03571, 0.968652, -0.109798, 0.148954, 1.05699, 0.971084, -0.0916787, 0.125044, 1.07587, 0.975584, -0.0739634, 0.100577, 1.09372, 0.98122, -0.055322, 0.0753666, 1.10948, 0.988253, -0.0366825, 0.0498899, 1.12394, 0.99482, -0.0180389, 0.024611, 1.13694, 1.00001, 229839e-9, -188283e-9, 1.14919, 0.613867, -964198e-11, 0.479449, 123452e-10, 0.621485, -244534e-9, 0.485399, 313091e-9, 0.621429, -978202e-9, 0.485353, 125245e-8, 0.62112, -220004e-8, 0.485114, 281687e-8, 0.621119, -39111e-7, 0.485112, 500783e-8, 0.621122, -611091e-8, 0.485112, 782498e-8, 0.621133, -879922e-8, 0.485117, 0.0112687, 0.621152, -0.0119756, 0.485125, 0.0153394, 0.621183, -0.0156396, 0.485139, 0.0200382, 0.621227, -0.0197898, 0.485158, 0.0253663, 0.621298, -0.0244253, 0.485192, 0.0313261, 0.621388, -0.0295441, 0.485233, 0.0379204, 0.621507, -0.0351432, 0.485286, 0.0451523, 0.621693, -0.0412198, 0.485378, 0.0530277, 0.621933, -0.0477673, 0.485495, 0.0615522, 0.622232, -0.0547574, 0.485635, 0.0707316, 0.622809, -0.0619417, 0.485943, 0.0805883, 0.623407, -0.069625, 0.486232, 0.0911267, 0.62406, -0.077796, 0.486516, 0.102354, 0.624835, -0.0863731, 0.486838, 0.114279, 0.625758, -0.095251, 0.487188, 0.126902, 0.627043, -0.104299, 0.487695, 0.140285, 0.628438, -0.113724, 0.488163, 0.154397, 0.630325, -0.123417, 0.488858, 0.169267, 0.632801, -0.133137, 0.489754, 0.184941, 0.635784, -0.143052, 0.490815, 0.20136, 0.639406, -0.153132, 0.492048, 0.218643, 0.643872, -0.163143, 0.49363, 0.236615, 0.6499, -0.17333, 0.496009, 0.255449, 0.657201, -0.183622, 0.498994, 0.275006, 0.666221, -0.194019, 0.502888, 0.295354, 0.674419, -0.204192, 0.505459, 0.316244, 0.683729, -0.21406, 0.507771, 0.33849, 0.695584, -0.222854, 0.510245, 0.363166, 0.708583, -0.231315, 0.512293, 0.389071, 0.721233, -0.238911, 0.512747, 0.415737, 0.735134, -0.245657, 0.512482, 0.443331, 0.750179, -0.251879, 0.511526, 0.471891, 0.765073, -0.256911, 0.508935, 0.500892, 0.779794, -0.261144, 0.504341, 0.530294, 0.794801, -0.264316, 0.498515, 0.560144, 0.810339, -0.266276, 0.491015, 0.590213, 0.824818, -0.266981, 0.481126, 0.620865, 0.839375, -0.265778, 0.468685, 0.652687, 0.853043, -0.262748, 0.453925, 0.684759, 0.867335, -0.258474, 0.437912, 0.716209, 0.88037, -0.253187, 0.419648, 0.747508, 0.891711, -0.246476, 0.39982, 0.77797, 0.902896, -0.238735, 0.37879, 0.808586, 0.913601, -0.22885, 0.355891, 0.838843, 0.923019, -0.217656, 0.331773, 0.869014, 0.933432, -0.205539, 0.307356, 0.898512, 0.939691, -0.192595, 0.281321, 0.9269, 0.946938, -0.178945, 0.255441, 0.955297, 0.952372, -0.163587, 0.229013, 0.983231, 0.95909, -0.147214, 0.203179, 1.00971, 0.963675, -0.13064, 0.17792, 1.03438, 0.968247, -0.113121, 0.152898, 1.05625, 0.97001, -0.0945824, 0.128712, 1.07598, 0.974458, -0.0755648, 0.103349, 1.094, 0.980168, -0.0571998, 0.0776731, 1.1104, 0.987295, -0.0377994, 0.0514445, 1.12491, 0.994432, -0.0186417, 0.025429, 1.13851, 0.999975, 542714e-9, -282356e-9, 1.15108, 0.592656, -980249e-11, 0.486018, 119532e-10, 0.598467, -247275e-9, 0.490781, 301531e-9, 0.597934, -988317e-9, 0.490343, 120517e-8, 0.597903, -222366e-8, 0.490319, 27116e-7, 0.597913, -395315e-8, 0.490327, 482077e-8, 0.597919, -617653e-8, 0.490329, 753264e-8, 0.597936, -889375e-8, 0.490339, 0.0108478, 0.597956, -0.0121043, 0.490347, 0.0147668, 0.597992, -0.0158073, 0.490365, 0.0192905, 0.598032, -0.0200017, 0.490382, 0.0244204, 0.598109, -0.0246865, 0.49042, 0.0301593, 0.598215, -0.0298594, 0.490474, 0.03651, 0.59833, -0.0355167, 0.490524, 0.0434757, 0.598525, -0.0416559, 0.490624, 0.0510629, 0.598778, -0.0482692, 0.490753, 0.0592781, 0.599135, -0.0553114, 0.49094, 0.0681304, 0.599802, -0.062542, 0.491328, 0.0776467, 0.600361, -0.0703638, 0.491598, 0.0878184, 0.60101, -0.0786256, 0.491882, 0.0986573, 0.601811, -0.0872962, 0.492232, 0.11018, 0.602861, -0.0962284, 0.492684, 0.1224, 0.604167, -0.10538, 0.493213, 0.135354, 0.605693, -0.114896, 0.493799, 0.149034, 0.607682, -0.124654, 0.494576, 0.163469, 0.610672, -0.13456, 0.4959, 0.178747, 0.613313, -0.144581, 0.496713, 0.194723, 0.617603, -0.154703, 0.498499, 0.211617, 0.622174, -0.16489, 0.500188, 0.229183, 0.628855, -0.175164, 0.503072, 0.247786, 0.636963, -0.185565, 0.506798, 0.267116, 0.644866, -0.195911, 0.509719, 0.28702, 0.653741, -0.206104, 0.512776, 0.307763, 0.664942, -0.216447, 0.516812, 0.329631, 0.67633, -0.22552, 0.519181, 0.353515, 0.690012, -0.234316, 0.521681, 0.379226, 0.704243, -0.242032, 0.523129, 0.405901, 0.719396, -0.249172, 0.523768, 0.433585, 0.734471, -0.255543, 0.522541, 0.462085, 0.750539, -0.260697, 0.520217, 0.491233, 0.766365, -0.26501, 0.516293, 0.521094, 0.781677, -0.268409, 0.509708, 0.551014, 0.797132, -0.270399, 0.501944, 0.581463, 0.812655, -0.271247, 0.492025, 0.612402, 0.828592, -0.270708, 0.480424, 0.643798, 0.844044, -0.268085, 0.465955, 0.67682, 0.857305, -0.263459, 0.448425, 0.708496, 0.87114, -0.258151, 0.430243, 0.74046, 0.884936, -0.251171, 0.410578, 0.771583, 0.895772, -0.243305, 0.38862, 0.802234, 0.906961, -0.234037, 0.365214, 0.833179, 0.917775, -0.222714, 0.34116, 0.86353, 0.927883, -0.210175, 0.31572, 0.893557, 0.936617, -0.196925, 0.289159, 0.922976, 0.943384, -0.182788, 0.261996, 0.951606, 0.949713, -0.167965, 0.235324, 0.979958, 0.955818, -0.151109, 0.208408, 1.00765, 0.961344, -0.133834, 0.182591, 1.03329, 0.965469, -0.115987, 0.156958, 1.0557, 0.968693, -0.09746, 0.132239, 1.07583, 0.973165, -0.0778514, 0.106195, 1.09451, 0.979387, -0.0585067, 0.0797669, 1.11137, 0.98671, -0.0390409, 0.0530263, 1.12643, 0.994093, -0.019408, 0.0263163, 1.14016, 1.00002, 540029e-9, -194487e-9, 1.15299, 0.574483, -989066e-11, 0.494533, 114896e-10, 0.574478, -249127e-9, 0.494528, 289403e-9, 0.574607, -996811e-9, 0.494637, 115797e-8, 0.574396, -224241e-8, 0.494458, 260498e-8, 0.574377, -398632e-8, 0.49444, 463102e-8, 0.574386, -622836e-8, 0.494445, 723623e-8, 0.574401, -89683e-7, 0.494453, 0.010421, 0.574419, -0.0122056, 0.49446, 0.0141859, 0.574459, -0.0159396, 0.494481, 0.0185322, 0.574525, -0.0201692, 0.49452, 0.0234617, 0.574587, -0.0248924, 0.494547, 0.0289762, 0.574697, -0.0301074, 0.494604, 0.0350797, 0.574853, -0.0358114, 0.494688, 0.0417767, 0.575027, -0.041999, 0.494772, 0.0490718, 0.575294, -0.0486618, 0.494915, 0.0569728, 0.575733, -0.0557148, 0.495173, 0.0654955, 0.576356, -0.0630489, 0.495537, 0.0746612, 0.576944, -0.0709285, 0.495836, 0.0844615, 0.57765, -0.0792723, 0.496177, 0.0949142, 0.578491, -0.0880167, 0.496563, 0.10603, 0.579639, -0.0969462, 0.497096, 0.117841, 0.580989, -0.10622, 0.497684, 0.130367, 0.582587, -0.115861, 0.498337, 0.143609, 0.584951, -0.125605, 0.499414, 0.157625, 0.587602, -0.135608, 0.500518, 0.172413, 0.59076, -0.145742, 0.501767, 0.187999, 0.594992, -0.155934, 0.503542, 0.20445, 0.600656, -0.166303, 0.506135, 0.221764, 0.607816, -0.176681, 0.509542, 0.24002, 0.61522, -0.187071, 0.51263, 0.258992, 0.623702, -0.197465, 0.516021, 0.278773, 0.634192, -0.207816, 0.520422, 0.299377, 0.644936, -0.218183, 0.524073, 0.320802, 0.657888, -0.2278, 0.528049, 0.34384, 0.670666, -0.236747, 0.52986, 0.36916, 0.685626, -0.24484, 0.531892, 0.395867, 0.701304, -0.252071, 0.532727, 0.423488, 0.717727, -0.258714, 0.532146, 0.452201, 0.733914, -0.264211, 0.529883, 0.481579, 0.750529, -0.26859, 0.5259, 0.511558, 0.76747, -0.272046, 0.51999, 0.542042, 0.785189, -0.274225, 0.513083, 0.572799, 0.800954, -0.275189, 0.502936, 0.603816, 0.816962, -0.274946, 0.490921, 0.635461, 0.83336, -0.272695, 0.47684, 0.6676, 0.848143, -0.268223, 0.459405, 0.70051, 0.861818, -0.262768, 0.440319, 0.732902, 0.876828, -0.255872, 0.420123, 0.765084, 0.889312, -0.247703, 0.398379, 0.796391, 0.900412, -0.238381, 0.374496, 0.827333, 0.912251, -0.227783, 0.349874, 0.858385, 0.921792, -0.214832, 0.323181, 0.888652, 0.931273, -0.200949, 0.296624, 0.917763, 0.940295, -0.186537, 0.269211, 0.947878, 0.946812, -0.171538, 0.241447, 0.977016, 0.953588, -0.155254, 0.213829, 1.00501, 0.958841, -0.137156, 0.186807, 1.03179, 0.963746, -0.118699, 0.160706, 1.05502, 0.966468, -0.0998358, 0.135504, 1.07568, 0.971178, -0.0805186, 0.109131, 1.09479, 0.97831, -0.0599348, 0.0818293, 1.1123, 0.985886, -0.0399661, 0.0545872, 1.12771, 0.994021, -0.0198682, 0.0269405, 1.14186, 1.00009, 271022e-9, -12989e-8, 1.15514, 0.538716, -990918e-11, 0.486732, 109675e-10, 0.550656, -250642e-9, 0.497518, 277412e-9, 0.55057, -100265e-8, 0.497441, 110974e-8, 0.550903, -225672e-8, 0.497733, 249779e-8, 0.550568, -401046e-8, 0.497438, 443906e-8, 0.550574, -626613e-8, 0.49744, 693637e-8, 0.550591, -90226e-7, 0.497449, 998921e-8, 0.550623, -0.0122795, 0.497469, 0.0135984, 0.550667, -0.0160361, 0.497495, 0.0177654, 0.550724, -0.0202908, 0.497526, 0.0224915, 0.550792, -0.0250421, 0.497557, 0.0277795, 0.550918, -0.0302878, 0.49763, 0.0336334, 0.551058, -0.0360241, 0.497701, 0.0400573, 0.551276, -0.0422473, 0.497824, 0.0470585, 0.551551, -0.0489441, 0.497977, 0.0546433, 0.552074, -0.0559596, 0.498312, 0.0628367, 0.552681, -0.0633978, 0.498679, 0.071646, 0.553324, -0.0713176, 0.499031, 0.0810746, 0.554011, -0.0797268, 0.499365, 0.091129, 0.55488, -0.0885238, 0.499779, 0.101837, 0.556171, -0.0974417, 0.500444, 0.113239, 0.557498, -0.106841, 0.501025, 0.125316, 0.559299, -0.116533, 0.501864, 0.138128, 0.561647, -0.126298, 0.502967, 0.151695, 0.564347, -0.136388, 0.504129, 0.16604, 0.567863, -0.146576, 0.505713, 0.181207, 0.572569, -0.156832, 0.507953, 0.197259, 0.578919, -0.167323, 0.511186, 0.214258, 0.585387, -0.177712, 0.514042, 0.232038, 0.593134, -0.188184, 0.517484, 0.250733, 0.603295, -0.198717, 0.522345, 0.270454, 0.613854, -0.209177, 0.526751, 0.290807, 0.626092, -0.219644, 0.531595, 0.312202, 0.637868, -0.229494, 0.534721, 0.334435, 0.652458, -0.238718, 0.538304, 0.359184, 0.666985, -0.247061, 0.539875, 0.385637, 0.683301, -0.254652, 0.541042, 0.41328, 0.69998, -0.261376, 0.540735, 0.441903, 0.717824, -0.267085, 0.539139, 0.471609, 0.734617, -0.271465, 0.534958, 0.501446, 0.753663, -0.27528, 0.53032, 0.532571, 0.770512, -0.277617, 0.522134, 0.563641, 0.787356, -0.278525, 0.51206, 0.595067, 0.806252, -0.278512, 0.50119, 0.627226, 0.822061, -0.277023, 0.486791, 0.659402, 0.838959, -0.273175, 0.470467, 0.692874, 0.85379, -0.267238, 0.450688, 0.725702, 0.868268, -0.260327, 0.429741, 0.75832, 0.881994, -0.251946, 0.407223, 0.790189, 0.893885, -0.242432, 0.383214, 0.821625, 0.905118, -0.231904, 0.357297, 0.853011, 0.916045, -0.219545, 0.330733, 0.883773, 0.927614, -0.205378, 0.303916, 0.914435, 0.936005, -0.190388, 0.275941, 0.944502, 0.944533, -0.1749, 0.247493, 0.974439, 0.950758, -0.158588, 0.218996, 1.00286, 0.957078, -0.141027, 0.191559, 1.0304, 0.962448, -0.121507, 0.164457, 1.05466, 0.964993, -0.102068, 0.138636, 1.0761, 0.970017, -0.0822598, 0.111861, 1.09541, 0.97661, -0.062033, 0.0843438, 1.11317, 0.985073, -0.0409832, 0.0558496, 1.12911, 0.993515, -0.020146, 0.0275331, 1.1438, 1.00006, 27329e-8, -107883e-9, 1.15736, 0.525324, -999341e-11, 0.498153, 105385e-10, 0.526513, -251605e-9, 0.499277, 265329e-9, 0.526517, -100641e-8, 0.499282, 10613e-7, 0.526588, -226466e-8, 0.499337, 238823e-8, 0.526539, -40255e-7, 0.499302, 424535e-8, 0.526547, -628954e-8, 0.499306, 663364e-8, 0.526561, -905628e-8, 0.499313, 955337e-8, 0.526593, -0.0123253, 0.499334, 0.0130054, 0.526642, -0.0160957, 0.499365, 0.0169911, 0.5267, -0.0203661, 0.499396, 0.0215122, 0.526792, -0.0251347, 0.499451, 0.0265718, 0.526904, -0.0303985, 0.499511, 0.0321732, 0.527079, -0.0361554, 0.499617, 0.0383231, 0.527285, -0.0423982, 0.499731, 0.045026, 0.527602, -0.0491121, 0.499924, 0.0522936, 0.528166, -0.0561127, 0.500306, 0.0601528, 0.52879, -0.0635988, 0.5007, 0.0686059, 0.529421, -0.071581, 0.501048, 0.0776518, 0.530144, -0.0799854, 0.501421, 0.0873148, 0.531062, -0.0888032, 0.501884, 0.0976084, 0.532374, -0.0977643, 0.50259, 0.108588, 0.533828, -0.107197, 0.50329, 0.120234, 0.53581, -0.116887, 0.504312, 0.132602, 0.538063, -0.126755, 0.505365, 0.145721, 0.5409, -0.136819, 0.506668, 0.159617, 0.544882, -0.147117, 0.508731, 0.174369, 0.550238, -0.157446, 0.511601, 0.190028, 0.556038, -0.167988, 0.514431, 0.206587, 0.563031, -0.178364, 0.517808, 0.224046, 0.571543, -0.189007, 0.521937, 0.242503, 0.582255, -0.199546, 0.527415, 0.261977, 0.59272, -0.210084, 0.531682, 0.282162, 0.605648, -0.220448, 0.537123, 0.303426, 0.61785, -0.230593, 0.540664, 0.325323, 0.632223, -0.240238, 0.544467, 0.348993, 0.648819, -0.24887, 0.547594, 0.375462, 0.665825, -0.256657, 0.54912, 0.403024, 0.683389, -0.263711, 0.549294, 0.431773, 0.701495, -0.269666, 0.547649, 0.461494, 0.719197, -0.274169, 0.543786, 0.491623, 0.737906, -0.278124, 0.538644, 0.522994, 0.756652, -0.280632, 0.531057, 0.554775, 0.775279, -0.281741, 0.521972, 0.586441, 0.792688, -0.281652, 0.509613, 0.618596, 0.811894, -0.280345, 0.496497, 0.651462, 0.827938, -0.277128, 0.47968, 0.684023, 0.844837, -0.271646, 0.460688, 0.718024, 0.859239, -0.264397, 0.438872, 0.751207, 0.874088, -0.256144, 0.41577, 0.784232, 0.887693, -0.246311, 0.391369, 0.816191, 0.899402, -0.235497, 0.365872, 0.847828, 0.910973, -0.223631, 0.338618, 0.87934, 0.92204, -0.209874, 0.310803, 0.910325, 0.930987, -0.194265, 0.281802, 0.940695, 0.94, -0.178125, 0.252836, 0.970958, 0.948018, -0.161479, 0.224239, 1.00078, 0.955141, -0.144038, 0.195857, 1.0288, 0.960513, -0.124915, 0.168487, 1.05371, 0.963964, -0.104284, 0.141495, 1.07596, 0.968713, -0.0838732, 0.114437, 1.09628, 0.975524, -0.0635579, 0.0863105, 1.11448, 0.98431, -0.042291, 0.0574774, 1.13069, 0.992916, -0.0209131, 0.0284343, 1.14568, 0.999926, 743097e-9, -379265e-9, 1.15955, 0.501042, -998428e-11, 0.498726, 100306e-10, 0.502992, -252112e-9, 0.500665, 253283e-9, 0.502417, -100791e-8, 0.500092, 101259e-8, 0.502965, -226919e-8, 0.500621, 227978e-8, 0.502318, -403109e-8, 0.499994, 405011e-8, 0.502333, -629832e-8, 0.500005, 632868e-8, 0.502362, -906907e-8, 0.500027, 911446e-8, 0.502369, -0.0123423, 0.500023, 0.0124078, 0.50243, -0.0161178, 0.500066, 0.016211, 0.502493, -0.0203937, 0.500103, 0.0205256, 0.502592, -0.0251684, 0.500166, 0.0253548, 0.502707, -0.0304389, 0.50023, 0.0307029, 0.502881, -0.0362015, 0.500335, 0.0365753, 0.503124, -0.0424507, 0.500488, 0.0429798, 0.503443, -0.0491582, 0.500686, 0.0499268, 0.504083, -0.0561476, 0.501155, 0.0574541, 0.504668, -0.0636846, 0.501524, 0.0655408, 0.505319, -0.0716834, 0.501904, 0.0742072, 0.50609, -0.0800925, 0.502321, 0.0834699, 0.507122, -0.0888425, 0.502896, 0.0933603, 0.508414, -0.097855, 0.503603, 0.10391, 0.509955, -0.107304, 0.504416, 0.115113, 0.512061, -0.116921, 0.505565, 0.127054, 0.514419, -0.12689, 0.506732, 0.139709, 0.517529, -0.136934, 0.508338, 0.153173, 0.522085, -0.147327, 0.510987, 0.167528, 0.526986, -0.157612, 0.513527, 0.182708, 0.533122, -0.168213, 0.516717, 0.198881, 0.540807, -0.178688, 0.520832, 0.215986, 0.550687, -0.189511, 0.52632, 0.234335, 0.560567, -0.199998, 0.531009, 0.253375, 0.571698, -0.210652, 0.535839, 0.273499, 0.584364, -0.220917, 0.541091, 0.294355, 0.599066, -0.23137, 0.546875, 0.316525, 0.614148, -0.241206, 0.551306, 0.339671, 0.631157, -0.250379, 0.555187, 0.36531, 0.647919, -0.258397, 0.556595, 0.392767, 0.666112, -0.265528, 0.556949, 0.421397, 0.686158, -0.271827, 0.556617, 0.451433, 0.704838, -0.27674, 0.552975, 0.482131, 0.723957, -0.280733, 0.547814, 0.513458, 0.74262, -0.283359, 0.53997, 0.545446, 0.762009, -0.284541, 0.530422, 0.57775, 0.781314, -0.284507, 0.518546, 0.610434, 0.799116, -0.283309, 0.504178, 0.643178, 0.817604, -0.280378, 0.48843, 0.676248, 0.83459, -0.275619, 0.469457, 0.709698, 0.850974, -0.26856, 0.447698, 0.744245, 0.866747, -0.260094, 0.424791, 0.777695, 0.881412, -0.249929, 0.399913, 0.810392, 0.8936, -0.239137, 0.37308, 0.842872, 0.905943, -0.226818, 0.345705, 0.874677, 0.916408, -0.213699, 0.31706, 0.906257, 0.927215, -0.198428, 0.288444, 0.936881, 0.935625, -0.181643, 0.258329, 0.96795, 0.944076, -0.164386, 0.228488, 0.998216, 0.951229, -0.146339, 0.199763, 1.02689, 0.958793, -0.127709, 0.172153, 1.0535, 0.963219, -0.107244, 0.144989, 1.07646, 0.967562, -0.0857764, 0.11685, 1.09675, 0.974866, -0.0645377, 0.0880571, 1.11576, 0.983353, -0.0431732, 0.0587352, 1.13227, 0.992503, -0.0218356, 0.0294181, 1.1478, 1.00003, 605203e-9, -231013e-9, 1.16207, 0.482935, -101177e-10, 0.504695, 968142e-11, 0.477554, -251521e-9, 0.499071, 240676e-9, 0.477904, -100683e-8, 0.499436, 96342e-8, 0.478368, -226636e-8, 0.499899, 21687e-7, 0.477977, -402719e-8, 0.499513, 385384e-8, 0.477993, -629226e-8, 0.499525, 60221e-7, 0.478011, -906011e-8, 0.499536, 867289e-8, 0.478051, -0.0123305, 0.499566, 0.0118074, 0.478089, -0.016102, 0.499587, 0.0154269, 0.478171, -0.0203736, 0.499645, 0.0195341, 0.478254, -0.025143, 0.499692, 0.0241318, 0.47839, -0.0304071, 0.499779, 0.0292247, 0.478588, -0.0361631, 0.499911, 0.0348196, 0.478812, -0.0424023, 0.500046, 0.0409231, 0.479208, -0.0490724, 0.500326, 0.047552, 0.479841, -0.0560722, 0.500805, 0.0547377, 0.480392, -0.0636125, 0.501152, 0.0624607, 0.481068, -0.0716134, 0.501561, 0.0707473, 0.481898, -0.0800062, 0.502054, 0.0796118, 0.483022, -0.0886568, 0.502728, 0.0890974, 0.484332, -0.0977553, 0.503479, 0.0992099, 0.486126, -0.107173, 0.504546, 0.10999, 0.488066, -0.11677, 0.50557, 0.121476, 0.490521, -0.126725, 0.506849, 0.133672, 0.494232, -0.136793, 0.50911, 0.146731, 0.498302, -0.147116, 0.511345, 0.160577, 0.503565, -0.157446, 0.514344, 0.175335, 0.510902, -0.168121, 0.518824, 0.191207, 0.519263, -0.178799, 0.523666, 0.208058, 0.528204, -0.189407, 0.528296, 0.225875, 0.538854, -0.200145, 0.533724, 0.244782, 0.551278, -0.210701, 0.539833, 0.264753, 0.565222, -0.221303, 0.546131, 0.285745, 0.579403, -0.231688, 0.551496, 0.307592, 0.595469, -0.241718, 0.556809, 0.330582, 0.610929, -0.250992, 0.559641, 0.354995, 0.629433, -0.259602, 0.562379, 0.382471, 0.648504, -0.267038, 0.563676, 0.411126, 0.66756, -0.273388, 0.562092, 0.440924, 0.689143, -0.278788, 0.560807, 0.472118, 0.709056, -0.282783, 0.555701, 0.503774, 0.729855, -0.285836, 0.548698, 0.536364, 0.748954, -0.287078, 0.538544, 0.56895, 0.768373, -0.287133, 0.526711, 0.601991, 0.78827, -0.285839, 0.512511, 0.635403, 0.807465, -0.283238, 0.496323, 0.668797, 0.825194, -0.27906, 0.477638, 0.702584, 0.842203, -0.272286, 0.456253, 0.736393, 0.857749, -0.263854, 0.432412, 0.77096, 0.874799, -0.253943, 0.407806, 0.80489, 0.887497, -0.24237, 0.38033, 0.83771, 0.89966, -0.230278, 0.352446, 0.870376, 0.911753, -0.21646, 0.323268, 0.902256, 0.923011, -0.202071, 0.294314, 0.933306, 0.932375, -0.185519, 0.264104, 0.965177, 0.940537, -0.167604, 0.234035, 0.996303, 0.948904, -0.149068, 0.20412, 1.0261, 0.955263, -0.129539, 0.175431, 1.05304, 0.960303, -0.109932, 0.148116, 1.07617, 0.965512, -0.0880572, 0.119693, 1.09742, 0.973466, -0.0660548, 0.0901619, 1.11721, 0.98284, -0.0439228, 0.0599875, 1.13436, 0.992216, -0.0219588, 0.0298975, 1.15006, 0.999946, 119402e-9, -208547e-10, 1.16471, 0.447827, -100414e-10, 0.491543, 914833e-11, 0.454778, -251257e-9, 0.499172, 22891e-8, 0.453519, -100342e-8, 0.497787, 914184e-9, 0.45357, -225776e-8, 0.497847, 205701e-8, 0.453578, -401371e-8, 0.497855, 365705e-8, 0.45357, -627107e-8, 0.497841, 571453e-8, 0.453598, -902968e-8, 0.497864, 823019e-8, 0.453627, -0.0122888, 0.497882, 0.0112049, 0.453684, -0.0160475, 0.497923, 0.0146405, 0.453764, -0.0203044, 0.49798, 0.0185394, 0.453866, -0.0250576, 0.498049, 0.0229054, 0.453996, -0.0303028, 0.49813, 0.0277424, 0.454196, -0.0360379, 0.498267, 0.0330587, 0.454457, -0.0422521, 0.498445, 0.0388613, 0.454926, -0.0488393, 0.498812, 0.0451767, 0.455525, -0.0558653, 0.499272, 0.0520153, 0.456074, -0.0633772, 0.499625, 0.0593754, 0.456752, -0.0713606, 0.500049, 0.0672751, 0.457648, -0.07971, 0.500615, 0.0757447, 0.458849, -0.0883032, 0.501399, 0.0848231, 0.46029, -0.0974095, 0.502293, 0.0945135, 0.462, -0.106729, 0.503301, 0.104848, 0.464121, -0.116354, 0.504533, 0.115884, 0.466889, -0.126214, 0.506172, 0.127652, 0.470744, -0.136324, 0.508667, 0.14024, 0.47488, -0.146595, 0.510995, 0.153673, 0.480845, -0.157027, 0.514832, 0.168053, 0.488262, -0.167658, 0.519506, 0.183508, 0.496547, -0.178343, 0.524347, 0.199948, 0.506254, -0.188916, 0.52983, 0.217503, 0.517961, -0.199975, 0.536357, 0.236272, 0.531484, -0.210624, 0.543641, 0.256096, 0.545496, -0.221227, 0.550048, 0.277085, 0.559497, -0.231568, 0.555076, 0.298615, 0.575752, -0.241698, 0.560541, 0.321547, 0.591999, -0.251172, 0.564156, 0.345602, 0.610654, -0.260178, 0.567607, 0.371851, 0.630484, -0.268094, 0.56923, 0.40076, 0.651807, -0.274661, 0.569779, 0.430801, 0.67239, -0.280331, 0.566791, 0.461939, 0.693024, -0.284501, 0.562007, 0.493854, 0.715473, -0.287852, 0.555791, 0.526992, 0.736323, -0.28929, 0.546345, 0.560102, 0.755771, -0.289405, 0.534, 0.593543, 0.775424, -0.2881, 0.519114, 0.627256, 0.795447, -0.285562, 0.502543, 0.661464, 0.815319, -0.281416, 0.484773, 0.695206, 0.831769, -0.275523, 0.463445, 0.729044, 0.849464, -0.267516, 0.440269, 0.764069, 0.866775, -0.257584, 0.415049, 0.799089, 0.881252, -0.245817, 0.388049, 0.831948, 0.894209, -0.233127, 0.35889, 0.865526, 0.906922, -0.219579, 0.329915, 0.89818, 0.919686, -0.204491, 0.300441, 0.930013, 0.929044, -0.188962, 0.269445, 0.962061, 0.938393, -0.171079, 0.238402, 0.994214, 0.94661, -0.15199, 0.208204, 1.02533, 0.953095, -0.131953, 0.178653, 1.0529, 0.958644, -0.111233, 0.150684, 1.0771, 0.963925, -0.0903098, 0.122359, 1.09855, 0.971995, -0.0680505, 0.0923342, 1.11874, 0.981658, -0.0448512, 0.0614195, 1.13635, 0.991649, -0.0221931, 0.0303582, 1.15238, 0.999985, 393403e-9, -111086e-9, 1.16772, 0.396806, -971563e-11, 0.457671, 842355e-11, 0.429186, -249421e-9, 0.495017, 21625e-8, 0.429324, -998052e-9, 0.495173, 865322e-9, 0.429175, -224487e-8, 0.494999, 194637e-8, 0.429129, -399041e-8, 0.494952, 346004e-8, 0.429153, -623476e-8, 0.494974, 540684e-8, 0.429168, -89773e-7, 0.494983, 778714e-8, 0.429207, -0.0122175, 0.495012, 0.0106022, 0.429257, -0.0159542, 0.495047, 0.0138535, 0.429338, -0.0201864, 0.495106, 0.0175443, 0.429431, -0.0249104, 0.495165, 0.0216774, 0.429587, -0.0301252, 0.495279, 0.0262594, 0.429796, -0.0358249, 0.495432, 0.0312968, 0.430065, -0.0419972, 0.495621, 0.0367985, 0.430588, -0.0485144, 0.496061, 0.042798, 0.43113, -0.0555028, 0.496472, 0.0492914, 0.431743, -0.0629852, 0.496904, 0.0562907, 0.432448, -0.0709256, 0.497369, 0.0638056, 0.433414, -0.0791942, 0.498032, 0.071885, 0.434638, -0.0877346, 0.498854, 0.0805517, 0.43611, -0.0968056, 0.499812, 0.0898047, 0.437859, -0.106002, 0.500891, 0.0997142, 0.440017, -0.115648, 0.502198, 0.110289, 0.443236, -0.125427, 0.504389, 0.121644, 0.44697, -0.135492, 0.506809, 0.133769, 0.451689, -0.145746, 0.509858, 0.146787, 0.45811, -0.156219, 0.514247, 0.160793, 0.465305, -0.166834, 0.518816, 0.175791, 0.474085, -0.177546, 0.524331, 0.191906, 0.484808, -0.188262, 0.53104, 0.209199, 0.49732, -0.199346, 0.538511, 0.227825, 0.509693, -0.209951, 0.544554, 0.247269, 0.524367, -0.220533, 0.551616, 0.267978, 0.539228, -0.231082, 0.557368, 0.289672, 0.55644, -0.241342, 0.563782, 0.31268, 0.574204, -0.250964, 0.568851, 0.33651, 0.593388, -0.260306, 0.57312, 0.362219, 0.613358, -0.268667, 0.574916, 0.390322, 0.634512, -0.275591, 0.575053, 0.420478, 0.65563, -0.281328, 0.572404, 0.451614, 0.678265, -0.285948, 0.568893, 0.484112, 0.70011, -0.289408, 0.561878, 0.517348, 0.723005, -0.291328, 0.55359, 0.551355, 0.743744, -0.291418, 0.541099, 0.585109, 0.763949, -0.290252, 0.526489, 0.619487, 0.784186, -0.287648, 0.509496, 0.65404, 0.804304, -0.283782, 0.491484, 0.688649, 0.823629, -0.278067, 0.470517, 0.723133, 0.84094, -0.270588, 0.44705, 0.757163, 0.857852, -0.261188, 0.421252, 0.792816, 0.874934, -0.249313, 0.394191, 0.827248, 0.888709, -0.236492, 0.365359, 0.861074, 0.902589, -0.222185, 0.336016, 0.894417, 0.914201, -0.207314, 0.30527, 0.926825, 0.925978, -0.191146, 0.274532, 0.9595, 0.93512, -0.174135, 0.243393, 0.991583, 0.943656, -0.155231, 0.212414, 1.02356, 0.951719, -0.134403, 0.182005, 1.05239, 0.957164, -0.113023, 0.153043, 1.07754, 0.962656, -0.0914493, 0.124186, 1.09984, 0.970695, -0.0694179, 0.0941654, 1.12, 0.980749, -0.0466199, 0.0629671, 1.13849, 0.991205, -0.0227032, 0.0311146, 1.15494, 0.999884, 632388e-9, -254483e-9, 1.1706, 0.379821, -957289e-11, 0.460637, 789337e-11, 0.405188, -247483e-9, 0.491396, 204064e-9, 0.404796, -989434e-9, 0.490914, 815853e-9, 0.40483, -222607e-8, 0.490949, 183559e-8, 0.40473, -395723e-8, 0.49084, 326332e-8, 0.404731, -618287e-8, 0.490836, 509945e-8, 0.404768, -890258e-8, 0.490871, 734463e-8, 0.404791, -0.0121156, 0.490883, 999992e-8, 0.404857, -0.0158214, 0.490938, 0.0130676, 0.404943, -0.0200178, 0.491004, 0.0165503, 0.405059, -0.0247027, 0.491093, 0.0204521, 0.405213, -0.0298729, 0.491205, 0.0247788, 0.405399, -0.0355226, 0.491333, 0.0295373, 0.405731, -0.0416352, 0.491604, 0.034741, 0.406303, -0.0480807, 0.492116, 0.0404255, 0.406814, -0.0550458, 0.492506, 0.0465732, 0.407404, -0.0624652, 0.492926, 0.0532058, 0.408149, -0.0702958, 0.493442, 0.0603442, 0.409128, -0.0784623, 0.494136, 0.0680297, 0.410408, -0.087007, 0.495054, 0.0762786, 0.411813, -0.0959639, 0.495962, 0.0851046, 0.413735, -0.105075, 0.497257, 0.0945878, 0.416137, -0.114646, 0.498882, 0.104725, 0.41934, -0.124394, 0.501132, 0.11563, 0.423326, -0.134328, 0.503883, 0.127325, 0.428419, -0.14458, 0.50747, 0.139911, 0.43484, -0.154979, 0.511964, 0.153481, 0.442641, -0.165628, 0.517328, 0.168114, 0.452511, -0.176365, 0.524258, 0.183995, 0.463473, -0.187298, 0.531248, 0.200953, 0.475564, -0.198244, 0.538367, 0.219176, 0.488664, -0.208938, 0.545175, 0.238514, 0.504073, -0.219599, 0.553227, 0.259129, 0.520832, -0.230378, 0.560653, 0.280997, 0.538455, -0.240703, 0.567523, 0.303821, 0.55709, -0.250548, 0.573287, 0.327948, 0.576646, -0.259964, 0.577795, 0.353362, 0.596705, -0.268721, 0.580077, 0.380336, 0.618053, -0.276054, 0.58018, 0.4101, 0.640303, -0.282176, 0.578747, 0.44161, 0.662365, -0.286931, 0.574294, 0.474106, 0.684542, -0.290521, 0.567035, 0.507549, 0.707984, -0.292672, 0.558687, 0.541853, 0.730913, -0.293189, 0.547606, 0.576581, 0.752948, -0.292199, 0.533471, 0.61172, 0.773452, -0.289508, 0.516395, 0.646339, 0.794715, -0.285716, 0.497873, 0.682131, 0.814251, -0.280051, 0.476845, 0.716396, 0.833057, -0.272873, 0.453449, 0.751503, 0.84959, -0.263982, 0.427857, 0.786085, 0.867022, -0.252745, 0.400335, 0.821355, 0.882277, -0.239655, 0.371304, 0.85646, 0.895375, -0.225386, 0.340397, 0.890828, 0.909347, -0.209587, 0.310005, 0.923532, 0.921885, -0.193433, 0.2796, 0.956419, 0.932127, -0.176135, 0.247276, 0.989445, 0.941869, -0.157872, 0.216186, 1.02221, 0.949735, -0.137577, 0.185602, 1.05195, 0.956617, -0.115285, 0.155767, 1.07822, 0.961974, -0.0928418, 0.126103, 1.10149, 0.96972, -0.0700592, 0.0956758, 1.12207, 0.98012, -0.0474671, 0.0643269, 1.1408, 0.990825, -0.0238113, 0.0320863, 1.1577, 0.999876, 381574e-9, -812203e-10, 1.17403, 0.367636, -961342e-11, 0.469176, 753287e-11, 0.380377, -244772e-9, 0.485434, 191797e-9, 0.380416, -978857e-9, 0.485475, 767015e-9, 0.380376, -220165e-8, 0.485435, 172522e-8, 0.380419, -391408e-8, 0.485487, 306734e-8, 0.380438, -611549e-8, 0.485505, 479332e-8, 0.380462, -880558e-8, 0.485525, 690391e-8, 0.380496, -0.0119837, 0.485551, 940039e-8, 0.38056, -0.0156487, 0.485605, 0.0122848, 0.38064, -0.0197988, 0.485666, 0.0155601, 0.380767, -0.0244324, 0.48577, 0.0192313, 0.380909, -0.0295444, 0.485871, 0.0233032, 0.381142, -0.0351321, 0.48606, 0.0277861, 0.381472, -0.0411535, 0.486336, 0.0326939, 0.382015, -0.0475408, 0.486833, 0.0380565, 0.382523, -0.0544395, 0.487231, 0.0438615, 0.383129, -0.061784, 0.487683, 0.0501332, 0.383952, -0.0695085, 0.488313, 0.0568996, 0.38498, -0.0775819, 0.489077, 0.0641952, 0.386331, -0.0860443, 0.490113, 0.0720324, 0.387788, -0.0948406, 0.491099, 0.0804379, 0.389808, -0.103899, 0.492566, 0.0894899, 0.39252, -0.113313, 0.494601, 0.0992098, 0.395493, -0.123007, 0.496619, 0.109641, 0.399826, -0.132859, 0.499912, 0.120919, 0.405341, -0.143077, 0.504061, 0.133107, 0.411932, -0.153465, 0.508905, 0.146263, 0.420591, -0.164108, 0.515482, 0.160544, 0.43101, -0.174893, 0.523191, 0.176123, 0.441881, -0.185839, 0.53026, 0.192757, 0.453919, -0.196633, 0.537295, 0.210535, 0.468715, -0.207611, 0.546156, 0.229886, 0.485182, -0.218517, 0.555173, 0.250543, 0.501926, -0.229249, 0.562728, 0.27221, 0.51785, -0.239481, 0.567494, 0.294892, 0.536947, -0.249395, 0.573889, 0.318987, 0.557115, -0.259, 0.578831, 0.344348, 0.577966, -0.268075, 0.582055, 0.371223, 0.599489, -0.276115, 0.583307, 0.399834, 0.62479, -0.282523, 0.583902, 0.431415, 0.647504, -0.287663, 0.57953, 0.464301, 0.670601, -0.291538, 0.573103, 0.498123, 0.693539, -0.293842, 0.563731, 0.532662, 0.717385, -0.294681, 0.553169, 0.567925, 0.741533, -0.293717, 0.539908, 0.603502, 0.762142, -0.291156, 0.521902, 0.639074, 0.783014, -0.28719, 0.502815, 0.674439, 0.805158, -0.281773, 0.482598, 0.710497, 0.823646, -0.274682, 0.458949, 0.7456, 0.841879, -0.266184, 0.433129, 0.781085, 0.859515, -0.255682, 0.406064, 0.816, 0.875335, -0.242849, 0.376509, 0.851074, 0.890147, -0.228329, 0.345502, 0.886473, 0.903144, -0.212491, 0.31428, 0.920751, 0.916618, -0.195695, 0.282994, 0.954606, 0.927953, -0.178267, 0.251091, 0.988402, 0.937414, -0.159549, 0.219107, 1.02141, 0.946823, -0.140022, 0.18896, 1.05167, 0.954651, -0.118154, 0.158667, 1.07819, 0.959955, -0.0946636, 0.128808, 1.1025, 0.96858, -0.0711792, 0.0973787, 1.12391, 0.97938, -0.0475046, 0.0650965, 1.14322, 0.990498, -0.024059, 0.0326267, 1.16077, 0.999844, -512408e-10, 112444e-9, 1.17727, 0.316912, -934977e-11, 0.425996, 695559e-11, 0.356423, -241372e-9, 0.479108, 179562e-9, 0.356272, -965292e-9, 0.478897, 71811e-8, 0.356262, -217182e-8, 0.478894, 161574e-8, 0.356265, -386092e-8, 0.478895, 287261e-8, 0.356278, -60324e-7, 0.478905, 448907e-8, 0.356293, -868565e-8, 0.478914, 646572e-8, 0.356346, -0.0118207, 0.478965, 880438e-8, 0.356395, -0.0154355, 0.479001, 0.0115066, 0.356484, -0.019529, 0.479075, 0.0145762, 0.356609, -0.0240991, 0.47918, 0.018018, 0.356766, -0.0291413, 0.479305, 0.0218379, 0.357009, -0.0346498, 0.479512, 0.0260454, 0.357424, -0.0405462, 0.479909, 0.0306657, 0.357899, -0.0468825, 0.480337, 0.0357054, 0.358424, -0.0536887, 0.480771, 0.0411728, 0.359041, -0.0609416, 0.481242, 0.0470841, 0.359903, -0.0685239, 0.481943, 0.0534831, 0.360932, -0.0764883, 0.482741, 0.0603795, 0.362196, -0.0848364, 0.483688, 0.0678028, 0.363847, -0.0935002, 0.484947, 0.0758086, 0.365972, -0.102471, 0.486588, 0.0844173, 0.368741, -0.111751, 0.488787, 0.0937199, 0.372146, -0.121334, 0.491405, 0.103732, 0.377114, -0.131147, 0.495604, 0.114608, 0.38226, -0.141213, 0.499436, 0.126345, 0.389609, -0.151632, 0.505334, 0.139116, 0.397925, -0.162073, 0.51168, 0.152995, 0.407824, -0.172819, 0.518876, 0.168071, 0.420014, -0.183929, 0.527639, 0.184495, 0.434266, -0.195032, 0.537588, 0.20232, 0.447352, -0.205792, 0.544379, 0.221189, 0.463726, -0.216704, 0.553422, 0.241616, 0.481406, -0.227531, 0.562074, 0.263298, 0.498707, -0.238017, 0.568227, 0.286116, 0.518039, -0.247936, 0.574473, 0.3101, 0.538277, -0.257437, 0.579191, 0.335401, 0.561166, -0.266829, 0.584807, 0.362246, 0.583189, -0.275329, 0.586476, 0.390609, 0.606024, -0.28234, 0.585578, 0.420998, 0.632419, -0.287924, 0.584496, 0.454357, 0.656128, -0.291972, 0.577766, 0.488233, 0.679953, -0.29456, 0.56875, 0.523248, 0.704654, -0.295816, 0.558388, 0.559168, 0.729016, -0.295157, 0.544826, 0.595326, 0.752062, -0.292779, 0.528273, 0.631864, 0.773138, -0.288681, 0.508482, 0.667793, 0.794869, -0.283358, 0.487341, 0.704035, 0.815101, -0.27608, 0.46354, 0.739925, 0.834212, -0.26767, 0.438672, 0.775539, 0.852368, -0.257397, 0.411239, 0.810895, 0.870207, -0.245689, 0.3829, 0.846472, 0.884063, -0.231452, 0.351496, 0.881788, 0.898284, -0.215561, 0.31895, 0.917438, 0.912964, -0.198208, 0.287367, 0.952422, 0.924666, -0.180426, 0.254487, 0.987551, 0.934429, -0.161525, 0.222226, 1.02142, 0.943485, -0.141197, 0.191143, 1.05218, 0.9521, -0.120085, 0.161112, 1.07937, 0.957876, -0.0975881, 0.130982, 1.10403, 0.966943, -0.0726842, 0.0990553, 1.12616, 0.978313, -0.0483705, 0.0662818, 1.14619, 0.990048, -0.0239072, 0.0329243, 1.16413, 0.999984, 461885e-9, -772859e-10, 1.18099, 0.321287, -935049e-11, 0.455413, 659662e-11, 0.332595, -237513e-9, 0.471437, 167562e-9, 0.332729, -949964e-9, 0.471618, 670192e-9, 0.332305, -213618e-8, 0.471028, 150712e-8, 0.332326, -379765e-8, 0.471055, 267959e-8, 0.332344, -593353e-8, 0.471072, 418751e-8, 0.332356, -854349e-8, 0.471077, 603172e-8, 0.332403, -0.0116268, 0.471121, 821362e-8, 0.332461, -0.0151824, 0.47117, 0.0107357, 0.332552, -0.0192088, 0.471251, 0.0136014, 0.332657, -0.0237024, 0.47133, 0.0168152, 0.332835, -0.0286615, 0.471487, 0.0203853, 0.333083, -0.0340765, 0.471708, 0.0243212, 0.333547, -0.0398563, 0.47219, 0.0286518, 0.333989, -0.0460916, 0.472587, 0.0333763, 0.334532, -0.0527897, 0.473054, 0.0385084, 0.335167, -0.0599284, 0.473568, 0.0440638, 0.33608, -0.0673514, 0.474362, 0.0500962, 0.337146, -0.0752237, 0.475231, 0.0566022, 0.338462, -0.083418, 0.476282, 0.0636272, 0.34014, -0.0919382, 0.477615, 0.0712153, 0.342341, -0.100741, 0.479404, 0.079417, 0.345088, -0.109905, 0.481618, 0.0882631, 0.349049, -0.119369, 0.485081, 0.0978851, 0.353939, -0.129033, 0.489317, 0.108336, 0.359893, -0.139038, 0.494309, 0.119698, 0.366945, -0.149411, 0.499983, 0.132024, 0.375814, -0.159843, 0.507185, 0.145558, 0.387112, -0.170664, 0.516392, 0.160433, 0.40023, -0.181897, 0.526519, 0.176648, 0.412555, -0.192785, 0.53423, 0.193922, 0.427023, -0.203663, 0.542741, 0.212662, 0.443685, -0.214695, 0.552066, 0.232944, 0.461499, -0.225561, 0.560762, 0.254495, 0.480975, -0.236257, 0.569421, 0.277531, 0.501, -0.24639, 0.576101, 0.301724, 0.521691, -0.256101, 0.581493, 0.327112, 0.543478, -0.265289, 0.585221, 0.353917, 0.566094, -0.273938, 0.587614, 0.381941, 0.589578, -0.281679, 0.587991, 0.41172, 0.614583, -0.287655, 0.585928, 0.444148, 0.641813, -0.292228, 0.582092, 0.478617, 0.666189, -0.295172, 0.57398, 0.51397, 0.690475, -0.29648, 0.561676, 0.550118, 0.715543, -0.296203, 0.548758, 0.586933, 0.740405, -0.293999, 0.532792, 0.62384, 0.762183, -0.28998, 0.512735, 0.660723, 0.786069, -0.28478, 0.492402, 0.69807, 0.806812, -0.277568, 0.469058, 0.734422, 0.826987, -0.268951, 0.443017, 0.770946, 0.844588, -0.259049, 0.415501, 0.80699, 0.863725, -0.2471, 0.387328, 0.842107, 0.879137, -0.234157, 0.356108, 0.878078, 0.894634, -0.218719, 0.324315, 0.914058, 0.909162, -0.201293, 0.291813, 0.949922, 0.92072, -0.18267, 0.258474, 0.985337, 0.93158, -0.163212, 0.225593, 1.0205, 0.941238, -0.142771, 0.193986, 1.05273, 0.949293, -0.120956, 0.163392, 1.08075, 0.956226, -0.0985743, 0.132934, 1.10559, 0.96546, -0.075118, 0.101255, 1.12823, 0.977403, -0.0497921, 0.0675441, 1.149, 0.989648, -0.0241574, 0.0334681, 1.16765, 1.00001, 5762e-7, -184807e-9, 1.18519, 0.303474, -916603e-11, 0.4542, 61243e-10, 0.308894, -232869e-9, 0.462306, 155592e-9, 0.309426, -931661e-9, 0.463093, 622499e-9, 0.308643, -20949e-7, 0.461933, 139979e-8, 0.308651, -37242e-7, 0.461941, 248874e-8, 0.308662, -581873e-8, 0.46195, 388933e-8, 0.308687, -837818e-8, 0.461974, 560247e-8, 0.308728, -0.0114016, 0.462011, 762948e-8, 0.308789, -0.0148884, 0.462067, 997326e-8, 0.308882, -0.0188369, 0.462151, 0.0126375, 0.309007, -0.0232436, 0.462263, 0.0156271, 0.30918, -0.0281054, 0.462417, 0.0189498, 0.309442, -0.0334065, 0.462667, 0.0226167, 0.309901, -0.0390589, 0.463162, 0.0266614, 0.310331, -0.0452042, 0.463555, 0.0310715, 0.310858, -0.0517735, 0.464019, 0.0358698, 0.311576, -0.0587359, 0.464669, 0.0410848, 0.312436, -0.0660383, 0.465406, 0.0467453, 0.313526, -0.0737266, 0.466339, 0.0528718, 0.314903, -0.0817574, 0.467504, 0.0595039, 0.316814, -0.090167, 0.469226, 0.0666888, 0.318965, -0.0987555, 0.470981, 0.0744658, 0.322077, -0.107792, 0.473814, 0.082912, 0.325947, -0.117098, 0.477241, 0.0920846, 0.331008, -0.126602, 0.48184, 0.102137, 0.337893, -0.136619, 0.488334, 0.113135, 0.345106, -0.146838, 0.494415, 0.12511, 0.355111, -0.157357, 0.503275, 0.138356, 0.365095, -0.167955, 0.510966, 0.152686, 0.378344, -0.179157, 0.521508, 0.16856, 0.391599, -0.190143, 0.530455, 0.18561, 0.407786, -0.20123, 0.541275, 0.204308, 0.425294, -0.212456, 0.551784, 0.224623, 0.444021, -0.223568, 0.561493, 0.246172, 0.463418, -0.234154, 0.569886, 0.268979, 0.484077, -0.244546, 0.577116, 0.293411, 0.505513, -0.254301, 0.582914, 0.318936, 0.527672, -0.263564, 0.587208, 0.345856, 0.550565, -0.272332, 0.589277, 0.374054, 0.573656, -0.280011, 0.588426, 0.403276, 0.59827, -0.286924, 0.587504, 0.43474, 0.624731, -0.291994, 0.583401, 0.468767, 0.652396, -0.295159, 0.576997, 0.504411, 0.67732, -0.296954, 0.565863, 0.54114, 0.703147, -0.296877, 0.552316, 0.57816, 0.728715, -0.295147, 0.536773, 0.616124, 0.752448, -0.291275, 0.51771, 0.653885, 0.775169, -0.285905, 0.496087, 0.691537, 0.799307, -0.279064, 0.474232, 0.729251, 0.819482, -0.270294, 0.447676, 0.766267, 0.837659, -0.260032, 0.419656, 0.802616, 0.856903, -0.248497, 0.391328, 0.838583, 0.873325, -0.235252, 0.360285, 0.874711, 0.889788, -0.221126, 0.329215, 0.91077, 0.904486, -0.204304, 0.296392, 0.94653, 0.917711, -0.185562, 0.262159, 0.983828, 0.928969, -0.165635, 0.229142, 1.01955, 0.939707, -0.14442, 0.19673, 1.05317, 0.948167, -0.122147, 0.165095, 1.0823, 0.955222, -0.099098, 0.13451, 1.10791, 0.964401, -0.0755332, 0.102476, 1.1312, 0.976605, -0.0513817, 0.0689667, 1.15218, 0.989085, -0.0258499, 0.034506, 1.17129, 0.999908, 617773e-9, -271268e-9, 1.18961, 0.285803, -905752e-11, 0.452348, 572272e-11, 0.284689, -22732e-8, 0.450581, 143626e-9, 0.285263, -910214e-9, 0.451482, 575099e-9, 0.285302, -204784e-8, 0.451553, 129395e-8, 0.285318, -364057e-8, 0.451574, 23006e-7, 0.28533, -568813e-8, 0.451585, 359547e-8, 0.285361, -819001e-8, 0.451618, 517934e-8, 0.285397, -0.0111458, 0.45165, 7054e-6, 0.285447, -0.0145536, 0.451688, 922167e-8, 0.285527, -0.0184127, 0.451758, 0.0116869, 0.285688, -0.0227207, 0.451929, 0.0144555, 0.28584, -0.0274712, 0.452055, 0.0175341, 0.286136, -0.0326278, 0.452369, 0.0209406, 0.286574, -0.0381792, 0.452853, 0.0246965, 0.287012, -0.0441879, 0.453272, 0.0287996, 0.287542, -0.0506096, 0.453752, 0.033268, 0.288299, -0.0573634, 0.454488, 0.0381504, 0.289186, -0.0645458, 0.455294, 0.0434447, 0.290302, -0.0720405, 0.456301, 0.0491973, 0.291776, -0.0799046, 0.457648, 0.0554453, 0.29372, -0.088117, 0.459483, 0.0622311, 0.296052, -0.0965328, 0.461571, 0.0695992, 0.299563, -0.105409, 0.465085, 0.077658, 0.30335, -0.114553, 0.468506, 0.0864176, 0.309167, -0.123917, 0.474423, 0.0961078, 0.31529, -0.13381, 0.47995, 0.106643, 0.324163, -0.144021, 0.488592, 0.118322, 0.333272, -0.154382, 0.496461, 0.131133, 0.344224, -0.165015, 0.50562, 0.145208, 0.357733, -0.176168, 0.516719, 0.16073, 0.373046, -0.187468, 0.528513, 0.177807, 0.38788, -0.198488, 0.537713, 0.196072, 0.405133, -0.209545, 0.547999, 0.21605, 0.423845, -0.220724, 0.55759, 0.237484, 0.443777, -0.231518, 0.566246, 0.26039, 0.464824, -0.242035, 0.574326, 0.284835, 0.486635, -0.251898, 0.58037, 0.310518, 0.51012, -0.261304, 0.58568, 0.337678, 0.535301, -0.270384, 0.590197, 0.366242, 0.559193, -0.27841, 0.590569, 0.395873, 0.583544, -0.285325, 0.588161, 0.426857, 0.608834, -0.291113, 0.584249, 0.459477, 0.635753, -0.294882, 0.57763, 0.494734, 0.664367, -0.297088, 0.569479, 0.532023, 0.689688, -0.297364, 0.555064, 0.569629, 0.715732, -0.295949, 0.539522, 0.608124, 0.741307, -0.292259, 0.521613, 0.646231, 0.764949, -0.287063, 0.49969, 0.684938, 0.788599, -0.28012, 0.476747, 0.723548, 0.81048, -0.27153, 0.45116, 0.761135, 0.831372, -0.261289, 0.424101, 0.798916, 0.850092, -0.249559, 0.39443, 0.835952, 0.867777, -0.236348, 0.363849, 0.871606, 0.884632, -0.221569, 0.332477, 0.907843, 0.90047, -0.20618, 0.300667, 0.944187, 0.914524, -0.188771, 0.266552, 0.981371, 0.926892, -0.168362, 0.232349, 1.01841, 0.937951, -0.146761, 0.199359, 1.05308, 0.947236, -0.123813, 0.1675, 1.0839, 0.954367, -0.099984, 0.136166, 1.11047, 0.963907, -0.0759278, 0.103808, 1.13414, 0.976218, -0.0511367, 0.0697061, 1.15575, 0.988772, -0.0267415, 0.0352529, 1.17531, 0.999888, -520778e-9, 289926e-9, 1.19389, 0.263546, -883274e-11, 0.441896, 526783e-11, 0.262352, -221849e-9, 0.439889, 132311e-9, 0.262325, -886683e-9, 0.439848, 528824e-9, 0.26228, -199476e-8, 0.439765, 118975e-8, 0.262372, -354671e-8, 0.439922, 211568e-8, 0.26239, -554141e-8, 0.439941, 330652e-8, 0.262412, -797888e-8, 0.439961, 476346e-8, 0.262453, -0.0108584, 0.440002, 648818e-8, 0.262528, -0.0141788, 0.440085, 84835e-7, 0.262615, -0.017938, 0.440166, 0.0107533, 0.262744, -0.0221346, 0.440291, 0.0133044, 0.262939, -0.026762, 0.440493, 0.0161445, 0.263277, -0.0317573, 0.440889, 0.0192974, 0.26368, -0.0371832, 0.441338, 0.0227699, 0.264106, -0.0430371, 0.441753, 0.0265698, 0.264624, -0.0493035, 0.442227, 0.0307178, 0.265378, -0.0558669, 0.442985, 0.0352616, 0.266253, -0.0628718, 0.443795, 0.0401968, 0.267478, -0.0701569, 0.445008, 0.04559, 0.269062, -0.077845, 0.446599, 0.0514539, 0.270926, -0.0857941, 0.448349, 0.0578382, 0.273693, -0.0940773, 0.451221, 0.0648363, 0.276746, -0.102704, 0.454097, 0.0724389, 0.281693, -0.111735, 0.459517, 0.0808744, 0.287335, -0.121004, 0.46531, 0.0901551, 0.29448, -0.130734, 0.472605, 0.100371, 0.30257, -0.140777, 0.480251, 0.111644, 0.312465, -0.15111, 0.489444, 0.124111, 0.324856, -0.16189, 0.500919, 0.137979, 0.33774, -0.172946, 0.511317, 0.153163, 0.35255, -0.184152, 0.522684, 0.169817, 0.367786, -0.19522, 0.53248, 0.187886, 0.385474, -0.20632, 0.543326, 0.207634, 0.404976, -0.217744, 0.554109, 0.229165, 0.425203, -0.228691, 0.563395, 0.252068, 0.446704, -0.239299, 0.571565, 0.276471, 0.468951, -0.249348, 0.577935, 0.302323, 0.493487, -0.258933, 0.584309, 0.329882, 0.517861, -0.268009, 0.58773, 0.358525, 0.543309, -0.276238, 0.589612, 0.388585, 0.569704, -0.28356, 0.589294, 0.419787, 0.594871, -0.289497, 0.585137, 0.452114, 0.622555, -0.294452, 0.580356, 0.486466, 0.651167, -0.296918, 0.57185, 0.523079, 0.677332, -0.297647, 0.558428, 0.5611, 0.703718, -0.296321, 0.542232, 0.599592, 0.730262, -0.293339, 0.524541, 0.639138, 0.754304, -0.288036, 0.502691, 0.677978, 0.778051, -0.281018, 0.479212, 0.716537, 0.801557, -0.272414, 0.454071, 0.75586, 0.822559, -0.262419, 0.425952, 0.794477, 0.843051, -0.250702, 0.397313, 0.832664, 0.86232, -0.237264, 0.366534, 0.869876, 0.879044, -0.222716, 0.334816, 0.906973, 0.896362, -0.206827, 0.303143, 0.943558, 0.910342, -0.189659, 0.269699, 0.979759, 0.924119, -0.171108, 0.236411, 1.01718, 0.935374, -0.149579, 0.202224, 1.05289, 0.944295, -0.126295, 0.16989, 1.08496, 0.952227, -0.101511, 0.138089, 1.11256, 0.962041, -0.0766392, 0.105053, 1.1375, 0.97528, -0.0511967, 0.070329, 1.15983, 0.988476, -0.025463, 0.0351268, 1.17987, 0.999962, 286808e-10, 145564e-10, 1.19901, 0.227089, -841413e-11, 0.404216, 472707e-11, 0.239725, -215083e-9, 0.426708, 120833e-9, 0.239904, -860718e-9, 0.427028, 483555e-9, 0.239911, -193661e-8, 0.427039, 108806e-8, 0.239914, -344276e-8, 0.42704, 193457e-8, 0.239933, -537907e-8, 0.427064, 302363e-8, 0.239944, -774482e-8, 0.427065, 435604e-8, 0.239993, -0.01054, 0.427122, 593398e-8, 0.240052, -0.0137626, 0.427179, 775987e-8, 0.240148, -0.0174115, 0.427279, 983854e-8, 0.240278, -0.021484, 0.42741, 0.0121763, 0.240472, -0.0259729, 0.427618, 0.0147827, 0.240839, -0.0308131, 0.428086, 0.0176837, 0.241201, -0.0360893, 0.428482, 0.0208775, 0.241626, -0.0417723, 0.428907, 0.0243821, 0.242207, -0.0478337, 0.42952, 0.0282228, 0.24298, -0.0542199, 0.430332, 0.0324333, 0.243881, -0.0610015, 0.431222, 0.0370252, 0.245123, -0.0680874, 0.432512, 0.0420535, 0.24667, -0.0755482, 0.434088, 0.0475414, 0.248779, -0.0832873, 0.436323, 0.0535542, 0.251665, -0.0913546, 0.439509, 0.0601716, 0.255305, -0.0998489, 0.443478, 0.0674282, 0.260049, -0.108576, 0.448713, 0.0754673, 0.266192, -0.117754, 0.455524, 0.084339, 0.273158, -0.127294, 0.4627, 0.0941683, 0.282131, -0.137311, 0.472068, 0.10515, 0.293332, -0.147736, 0.483565, 0.117402, 0.304667, -0.158357, 0.493702, 0.130824, 0.317785, -0.169274, 0.504708, 0.145724, 0.333245, -0.180595, 0.517107, 0.16215, 0.349843, -0.191892, 0.528849, 0.180149, 0.367944, -0.203168, 0.540301, 0.199746, 0.387579, -0.214443, 0.551514, 0.221047, 0.408247, -0.225624, 0.560906, 0.243981, 0.43014, -0.236422, 0.56959, 0.268513, 0.452669, -0.24654, 0.576098, 0.294409, 0.476196, -0.256157, 0.580925, 0.322002, 0.501157, -0.265289, 0.584839, 0.351052, 0.527632, -0.273671, 0.587614, 0.3812, 0.555754, -0.281254, 0.589119, 0.412994, 0.581682, -0.287448, 0.585204, 0.445498, 0.608196, -0.292614, 0.579006, 0.479505, 0.635661, -0.296068, 0.571297, 0.514643, 0.664999, -0.297395, 0.560855, 0.552213, 0.691039, -0.296645, 0.544525, 0.591365, 0.7179, -0.293785, 0.526535, 0.630883, 0.744059, -0.289089, 0.50545, 0.670932, 0.76863, -0.282239, 0.482514, 0.710904, 0.793273, -0.273688, 0.457246, 0.750259, 0.814731, -0.26328, 0.428872, 0.78948, 0.835603, -0.251526, 0.399384, 0.828597, 0.85489, -0.238339, 0.368811, 0.866892, 0.872828, -0.223607, 0.336617, 0.90563, 0.889462, -0.207538, 0.303997, 0.943538, 0.904929, -0.190297, 0.270812, 0.980591, 0.919101, -0.172034, 0.237453, 1.01935, 0.930536, -0.152058, 0.204431, 1.05498, 0.941223, -0.129515, 0.172495, 1.08717, 0.94982, -0.104263, 0.140175, 1.11551, 0.960592, -0.0781944, 0.106465, 1.14098, 0.974629, -0.051688, 0.0711592, 1.16418, 0.98811, -0.0253929, 0.0354432, 1.18465, 1.00004, 804378e-9, -330876e-9, 1.20462, 0.214668, -821282e-11, 0.406619, 433582e-11, 0.218053, -208144e-9, 0.413025, 109887e-9, 0.217987, -832212e-9, 0.412901, 439362e-9, 0.217971, -187246e-8, 0.412876, 988623e-9, 0.217968, -332855e-8, 0.41286, 175772e-8, 0.217985, -520055e-8, 0.412882, 274729e-8, 0.218014, -748814e-8, 0.412916, 395842e-8, 0.218054, -0.0101901, 0.412957, 539274e-8, 0.218106, -0.0133057, 0.413005, 705348e-8, 0.218217, -0.0168342, 0.413139, 894581e-8, 0.218338, -0.0207707, 0.413258, 0.0110754, 0.21855, -0.0251001, 0.413509, 0.0134551, 0.218913, -0.0297861, 0.413992, 0.0161081, 0.219265, -0.0348956, 0.414383, 0.0190307, 0.219696, -0.0403909, 0.414839, 0.0222458, 0.220329, -0.0462003, 0.415567, 0.025792, 0.220989, -0.0524208, 0.41621, 0.0296637, 0.222027, -0.058948, 0.417385, 0.0339323, 0.223301, -0.0658208, 0.418779, 0.0386055, 0.224988, -0.0730347, 0.420665, 0.0437355, 0.227211, -0.0805274, 0.423198, 0.0493844, 0.230131, -0.088395, 0.426566, 0.0556135, 0.233908, -0.0966208, 0.43091, 0.0624829, 0.239092, -0.105223, 0.437148, 0.0701636, 0.245315, -0.11424, 0.444302, 0.0786949, 0.253166, -0.12368, 0.453262, 0.0882382, 0.262374, -0.133569, 0.463211, 0.0988682, 0.273145, -0.143836, 0.474271, 0.110727, 0.285512, -0.154577, 0.4863, 0.123945, 0.299512, -0.165501, 0.498817, 0.138581, 0.314287, -0.176698, 0.510341, 0.154676, 0.331083, -0.188066, 0.522583, 0.172459, 0.349615, -0.199597, 0.534879, 0.191979, 0.369318, -0.210843, 0.546083, 0.21309, 0.390377, -0.222068, 0.5562, 0.235998, 0.412411, -0.233059, 0.564704, 0.260518, 0.435715, -0.24357, 0.572314, 0.286795, 0.461196, -0.253356, 0.579395, 0.314559, 0.485587, -0.262362, 0.581985, 0.343581, 0.511908, -0.270895, 0.584347, 0.374367, 0.539798, -0.278452, 0.58505, 0.406015, 0.567974, -0.284877, 0.583344, 0.439168, 0.594303, -0.290124, 0.577348, 0.473005, 0.622951, -0.294183, 0.570751, 0.508534, 0.652404, -0.296389, 0.561541, 0.544764, 0.679291, -0.296605, 0.546426, 0.582927, 0.706437, -0.294095, 0.528599, 0.622681, 0.734485, -0.28978, 0.508676, 0.663567, 0.758841, -0.283363, 0.484768, 0.704092, 0.78537, -0.275015, 0.460434, 0.745101, 0.807315, -0.264689, 0.432166, 0.784712, 0.8271, -0.252597, 0.401807, 0.824241, 0.849191, -0.239154, 0.371458, 0.863803, 0.867046, -0.224451, 0.338873, 0.903063, 0.8852, -0.208342, 0.306175, 0.942763, 0.901771, -0.190684, 0.272759, 0.981559, 0.915958, -0.172105, 0.239306, 1.02048, 0.928046, -0.152214, 0.206071, 1.05765, 0.939961, -0.130247, 0.17367, 1.08999, 0.948711, -0.10672, 0.142201, 1.11829, 0.959305, -0.0808688, 0.108454, 1.14467, 0.973009, -0.0539145, 0.0728109, 1.16839, 0.987631, -0.0262947, 0.0360625, 1.19004, 0.999978, 132758e-8, -559424e-9, 1.21058, 0.193925, -793421e-11, 0.391974, 392537e-11, 0.196746, -200315e-9, 0.397675, 991033e-10, 0.19667, -801099e-9, 0.397521, 396342e-9, 0.196633, -180246e-8, 0.397445, 891829e-9, 0.196654, -320443e-8, 0.397482, 158582e-8, 0.196659, -500647e-8, 0.39748, 247867e-8, 0.196683, -72086e-7, 0.397506, 357167e-8, 0.196728, -981001e-8, 0.397562, 486675e-8, 0.196792, -0.0128096, 0.397633, 636707e-8, 0.19689, -0.0162055, 0.397746, 807752e-8, 0.197017, -0.0199943, 0.397884, 0.0100052, 0.19729, -0.024139, 0.39827, 0.0121691, 0.197583, -0.0286671, 0.398639, 0.0145755, 0.197927, -0.0335858, 0.399034, 0.0172355, 0.198383, -0.0388806, 0.399554, 0.0201718, 0.199002, -0.0444736, 0.400289, 0.0234194, 0.199739, -0.0504583, 0.401111, 0.026984, 0.200784, -0.056729, 0.402349, 0.0309217, 0.202075, -0.0633643, 0.403841, 0.0352496, 0.203898, -0.0703247, 0.406076, 0.0400313, 0.206199, -0.0775565, 0.408841, 0.0453282, 0.209252, -0.085184, 0.41259, 0.0511794, 0.213638, -0.0931994, 0.418288, 0.0577459, 0.21881, -0.101617, 0.424681, 0.0650508, 0.225642, -0.11052, 0.433429, 0.0732759, 0.233717, -0.119772, 0.442897, 0.0824683, 0.242823, -0.129505, 0.452888, 0.0927484, 0.254772, -0.139906, 0.466407, 0.104417, 0.266603, -0.150402, 0.477413, 0.117211, 0.28073, -0.161395, 0.490519, 0.131598, 0.295399, -0.172465, 0.50201, 0.147407, 0.312705, -0.183982, 0.515311, 0.165031, 0.331335, -0.195532, 0.52786, 0.184336, 0.351037, -0.206971, 0.5392, 0.205361, 0.372175, -0.218117, 0.54941, 0.228043, 0.394548, -0.229327, 0.558642, 0.25267, 0.419598, -0.240052, 0.567861, 0.279071, 0.443922, -0.249937, 0.573332, 0.306882, 0.471495, -0.259407, 0.58013, 0.33661, 0.496769, -0.267749, 0.580564, 0.367328, 0.524951, -0.275524, 0.581696, 0.399753, 0.55318, -0.282148, 0.579885, 0.433134, 0.581577, -0.287533, 0.575471, 0.467534, 0.609231, -0.291612, 0.567445, 0.502943, 0.637478, -0.293911, 0.557657, 0.53871, 0.667795, -0.295096, 0.546535, 0.576568, 0.694272, -0.294073, 0.529561, 0.614929, 0.722937, -0.290386, 0.510561, 0.655909, 0.749682, -0.284481, 0.487846, 0.697663, 0.774754, -0.276188, 0.462487, 0.738515, 0.799301, -0.266215, 0.43481, 0.779802, 0.820762, -0.254116, 0.404879, 0.820045, 0.843231, -0.240393, 0.374559, 0.860294, 0.861857, -0.225503, 0.341582, 0.900965, 0.880815, -0.209382, 0.308778, 0.941727, 0.89766, -0.19155, 0.275232, 0.980916, 0.912926, -0.172346, 0.240938, 1.02162, 0.926391, -0.151799, 0.207223, 1.0597, 0.938429, -0.129968, 0.17484, 1.09291, 0.947834, -0.10651, 0.142984, 1.12248, 0.958432, -0.0824098, 0.109902, 1.149, 0.972402, -0.0565242, 0.0744454, 1.1733, 0.987191, -0.028427, 0.0373794, 1.19538, 0.999975, 385685e-10, -4203e-8, 1.21676, 0.178114, -766075e-11, 0.385418, 354027e-11, 0.176074, -191966e-9, 0.381002, 887135e-10, 0.17601, -767549e-9, 0.380861, 354715e-9, 0.17598, -172696e-8, 0.380798, 798168e-9, 0.175994, -307012e-8, 0.380824, 141928e-8, 0.176017, -479684e-8, 0.380858, 221859e-8, 0.176019, -690648e-8, 0.380839, 319714e-8, 0.176072, -939888e-8, 0.380913, 43572e-7, 0.176131, -0.0122726, 0.380979, 5702e-6, 0.176239, -0.0155264, 0.38112, 723689e-8, 0.176371, -0.0191551, 0.381272, 896907e-8, 0.176638, -0.023117, 0.381669, 0.0109194, 0.176912, -0.0274633, 0.382015, 0.0130903, 0.177279, -0.032173, 0.382476, 0.0154949, 0.17774, -0.0372219, 0.383041, 0.0181669, 0.178344, -0.0426132, 0.38378, 0.0211209, 0.179153, -0.0483309, 0.384773, 0.0243899, 0.180197, -0.0543447, 0.386076, 0.0280062, 0.181581, -0.0607122, 0.387809, 0.032004, 0.18344, -0.0673855, 0.390205, 0.036453, 0.186139, -0.0743989, 0.393944, 0.0414162, 0.189432, -0.0817731, 0.39832, 0.0469394, 0.193795, -0.0895464, 0.404188, 0.0531442, 0.199641, -0.0978264, 0.4121, 0.0601374, 0.206679, -0.106499, 0.421425, 0.0680078, 0.214865, -0.115654, 0.431504, 0.076919, 0.224406, -0.125268, 0.442526, 0.0868835, 0.235876, -0.135475, 0.455465, 0.0981875, 0.248335, -0.146023, 0.4681, 0.110759, 0.262868, -0.157016, 0.482069, 0.124885, 0.278962, -0.168245, 0.496182, 0.140645, 0.295082, -0.17958, 0.507401, 0.157838, 0.313738, -0.191227, 0.520252, 0.17695, 0.333573, -0.202718, 0.531708, 0.197817, 0.356433, -0.214424, 0.544509, 0.220785, 0.378853, -0.225492, 0.55373, 0.245306, 0.402717, -0.236236, 0.561348, 0.271593, 0.428375, -0.246568, 0.568538, 0.299776, 0.454724, -0.255941, 0.573462, 0.329433, 0.482291, -0.264511, 0.576356, 0.360598, 0.509706, -0.272129, 0.576446, 0.393204, 0.538805, -0.278979, 0.575298, 0.427227, 0.568919, -0.284528, 0.572154, 0.462157, 0.596804, -0.288801, 0.564691, 0.497997, 0.625987, -0.291334, 0.555134, 0.534467, 0.656414, -0.292722, 0.545051, 0.571736, 0.683916, -0.292185, 0.528813, 0.610158, 0.711809, -0.290043, 0.51106, 0.649061, 0.739547, -0.285246, 0.490103, 0.690081, 0.766914, -0.277647, 0.465523, 0.732554, 0.791375, -0.267603, 0.437718, 0.773982, 0.814772, -0.256109, 0.40882, 0.81609, 0.836691, -0.242281, 0.377823, 0.856849, 0.856984, -0.227155, 0.34496, 0.898363, 0.876332, -0.210395, 0.311335, 0.939471, 0.894988, -0.192612, 0.277703, 0.980799, 0.911113, -0.173236, 0.243019, 1.02215, 0.924092, -0.152258, 0.209037, 1.06139, 0.936828, -0.129575, 0.175909, 1.09635, 0.946869, -0.10594, 0.143852, 1.12707, 0.958284, -0.081318, 0.110289, 1.15419, 0.972325, -0.0556133, 0.0747232, 1.17909, 0.986878, -0.0297899, 0.0383149, 1.20163, 0.999936, -197169e-8, 912402e-9, 1.22338, 0.151174, -720365e-11, 0.351531, 309789e-11, 0.155594, -18279e-8, 0.361806, 78608e-9, 0.156099, -731569e-9, 0.362982, 314615e-9, 0.156053, -164578e-8, 0.362869, 707845e-9, 0.156093, -29261e-7, 0.362961, 125884e-8, 0.156099, -457155e-8, 0.362959, 196783e-8, 0.15612, -658224e-8, 0.362982, 283622e-8, 0.156168, -895774e-8, 0.363048, 386625e-8, 0.156221, -0.0116962, 0.363101, 506109e-8, 0.156324, -0.0147973, 0.363241, 642675e-8, 0.156476, -0.0182503, 0.363448, 797175e-8, 0.156731, -0.0220266, 0.36384, 971484e-8, 0.156994, -0.026176, 0.364179, 0.0116575, 0.157341, -0.0306701, 0.36462, 0.0138207, 0.157867, -0.0354591, 0.365364, 0.0162356, 0.15846, -0.0406141, 0.366111, 0.0189092, 0.159308, -0.0460519, 0.367248, 0.021885, 0.160426, -0.0518096, 0.368767, 0.0252004, 0.161877, -0.0578906, 0.370745, 0.0288825, 0.163995, -0.0642812, 0.373831, 0.0330139, 0.16655, -0.0710067, 0.377366, 0.0376283, 0.170237, -0.0781522, 0.382799, 0.0428493, 0.175096, -0.0857172, 0.389915, 0.0487324, 0.181069, -0.0938025, 0.398487, 0.0554214, 0.188487, -0.102363, 0.408799, 0.0630189, 0.197029, -0.111343, 0.419991, 0.071634, 0.206684, -0.120812, 0.431455, 0.0812797, 0.218698, -0.131033, 0.445746, 0.0923651, 0.230726, -0.141373, 0.457471, 0.104545, 0.245516, -0.152387, 0.472388, 0.118449, 0.261551, -0.163628, 0.486671, 0.133923, 0.277437, -0.174814, 0.49762, 0.150849, 0.296662, -0.186713, 0.51162, 0.169924, 0.31795, -0.198513, 0.525435, 0.190848, 0.339422, -0.210119, 0.536267, 0.213504, 0.362143, -0.221354, 0.545982, 0.237947, 0.387198, -0.23224, 0.555364, 0.264427, 0.412349, -0.24257, 0.561489, 0.292519, 0.439274, -0.252284, 0.566903, 0.322561, 0.466779, -0.261023, 0.569614, 0.353952, 0.496011, -0.26899, 0.571589, 0.387278, 0.524964, -0.275498, 0.570325, 0.421356, 0.556518, -0.281449, 0.568792, 0.457314, 0.584363, -0.285526, 0.560268, 0.493199, 0.614214, -0.28844, 0.55205, 0.530276, 0.645684, -0.289777, 0.541906, 0.56855, 0.673446, -0.289722, 0.526464, 0.606927, 0.701924, -0.287792, 0.509872, 0.645945, 0.73037, -0.284315, 0.490649, 0.685564, 0.757405, -0.278804, 0.467964, 0.726511, 0.784025, -0.269543, 0.441468, 0.768601, 0.808255, -0.258117, 0.41216, 0.811321, 0.830739, -0.244728, 0.380606, 0.853496, 0.851914, -0.229428, 0.348111, 0.895374, 0.872586, -0.212508, 0.314732, 0.937674, 0.891581, -0.194025, 0.280338, 0.979869, 0.907641, -0.174711, 0.245203, 1.02253, 0.922233, -0.153509, 0.21077, 1.06371, 0.935878, -0.130418, 0.177399, 1.09972, 0.946338, -0.105558, 0.144507, 1.13124, 0.957265, -0.080059, 0.110508, 1.15973, 0.971668, -0.0539766, 0.0742311, 1.18515, 0.9866, -0.0277101, 0.0375224, 1.20858, 1.00021, -515531e-9, 135226e-9, 1.23135, 0.137468, -686011e-11, 0.345041, 273315e-11, 0.13703, -173378e-9, 0.343936, 690761e-10, 0.136986, -693048e-9, 0.34383, 276126e-9, 0.136964, -155931e-8, 0.343761, 621337e-9, 0.137003, -277211e-8, 0.343863, 110494e-8, 0.137012, -433103e-8, 0.343868, 172744e-8, 0.137043, -623606e-8, 0.343916, 249022e-8, 0.13709, -84868e-7, 0.343986, 339559e-8, 0.137145, -0.0110814, 0.344045, 444687e-8, 0.137242, -0.0140187, 0.344177, 565007e-8, 0.137431, -0.0172713, 0.344491, 701868e-8, 0.137644, -0.0208605, 0.344805, 856042e-8, 0.13791, -0.024792, 0.345172, 0.0102863, 0.138295, -0.0290461, 0.345734, 0.0122185, 0.138764, -0.0335957, 0.346371, 0.0143771, 0.139415, -0.038467, 0.347298, 0.0167894, 0.140272, -0.0436176, 0.348527, 0.0194895, 0.141457, -0.0491016, 0.350276, 0.0225043, 0.14303, -0.0548764, 0.352646, 0.0258962, 0.145289, -0.0610096, 0.356206, 0.0297168, 0.148502, -0.0674777, 0.361488, 0.0340562, 0.152188, -0.074345, 0.367103, 0.0389534, 0.157359, -0.0817442, 0.375247, 0.0445541, 0.16379, -0.0896334, 0.385064, 0.0509535, 0.171376, -0.098005, 0.396082, 0.0582611, 0.179901, -0.106817, 0.407418, 0.06654, 0.189892, -0.116239, 0.420031, 0.075994, 0.201838, -0.12627, 0.434321, 0.0867239, 0.214311, -0.136701, 0.447631, 0.0987517, 0.228902, -0.147616, 0.462046, 0.112353, 0.245107, -0.158871, 0.476942, 0.127605, 0.262292, -0.170261, 0.490285, 0.144469, 0.281215, -0.182017, 0.503783, 0.163282, 0.301058, -0.193729, 0.515505, 0.183873, 0.322752, -0.205512, 0.52682, 0.206466, 0.347547, -0.217214, 0.539473, 0.231194, 0.370969, -0.227966, 0.546625, 0.257288, 0.397533, -0.238555, 0.55472, 0.285789, 0.42398, -0.248278, 0.559468, 0.315746, 0.452928, -0.257422, 0.564095, 0.347724, 0.482121, -0.265306, 0.565426, 0.380922, 0.510438, -0.272043, 0.563205, 0.415639, 0.541188, -0.277614, 0.561087, 0.451702, 0.571667, -0.281927, 0.554922, 0.48845, 0.602432, -0.285015, 0.546838, 0.526442, 0.634126, -0.286512, 0.537415, 0.564896, 0.662816, -0.286388, 0.522906, 0.604037, 0.692411, -0.284734, 0.507003, 0.643795, 0.720946, -0.281297, 0.488398, 0.68298, 0.748293, -0.276262, 0.466353, 0.723466, 0.776931, -0.269978, 0.443573, 0.764565, 0.801065, -0.260305, 0.415279, 0.805838, 0.825843, -0.247426, 0.384773, 0.849985, 0.84807, -0.232437, 0.352555, 0.893174, 0.869122, -0.215806, 0.318642, 0.936564, 0.888963, -0.197307, 0.28381, 0.980253, 0.905547, -0.177203, 0.247888, 1.02463, 0.918554, -0.155542, 0.212904, 1.06714, 0.931395, -0.131948, 0.1787, 1.10451, 0.941749, -0.106723, 0.145902, 1.13694, 0.954551, -0.0804939, 0.111193, 1.1666, 0.970279, -0.0534239, 0.0744697, 1.19249, 0.986117, -0.0257452, 0.0368788, 1.21665, 0.999938, 190634e-8, -10291e-7, 1.23981, 0.118493, -647439e-11, 0.32272, 23772e-10, 0.118765, -163023e-9, 0.323456, 598573e-10, 0.118772, -65212e-8, 0.323477, 239447e-9, 0.118843, -146741e-8, 0.323657, 538881e-9, 0.118804, -260846e-8, 0.323553, 95826e-8, 0.118826, -407576e-8, 0.323595, 149845e-8, 0.118846, -586826e-8, 0.323617, 216047e-8, 0.118886, -798578e-8, 0.32367, 294679e-8, 0.118947, -0.0104273, 0.323753, 386124e-8, 0.119055, -0.0131909, 0.323922, 490999e-8, 0.119241, -0.0162444, 0.324251, 610804e-8, 0.11944, -0.0196339, 0.324544, 745805e-8, 0.119739, -0.0233378, 0.325026, 897805e-8, 0.12011, -0.0273179, 0.325586, 0.0106895, 0.120571, -0.0316143, 0.326231, 0.0126073, 0.12124, -0.0361939, 0.327264, 0.0147654, 0.122162, -0.0410511, 0.328733, 0.0172001, 0.123378, -0.0462233, 0.330659, 0.0199375, 0.125183, -0.0517109, 0.333754, 0.0230498, 0.127832, -0.0575652, 0.338507, 0.026597, 0.130909, -0.0637441, 0.343666, 0.0306345, 0.135221, -0.0704302, 0.351063, 0.035273, 0.14082, -0.0776364, 0.360604, 0.0406137, 0.146781, -0.0852293, 0.369638, 0.0466788, 0.155121, -0.0935351, 0.3827, 0.0537628, 0.16398, -0.102234, 0.39522, 0.0617985, 0.173926, -0.111465, 0.40793, 0.07097, 0.185137, -0.121296, 0.42105, 0.0813426, 0.19826, -0.13169, 0.435735, 0.0931596, 0.212938, -0.142614, 0.450932, 0.106547, 0.229046, -0.153884, 0.465726, 0.121575, 0.246246, -0.165382, 0.479461, 0.138286, 0.264637, -0.176806, 0.492106, 0.15666, 0.284959, -0.188793, 0.504774, 0.17728, 0.308157, -0.200763, 0.518805, 0.19988, 0.330951, -0.21239, 0.528231, 0.224293, 0.3549, -0.223521, 0.536376, 0.250541, 0.381502, -0.234169, 0.544846, 0.278902, 0.409529, -0.244077, 0.551717, 0.309227, 0.437523, -0.253363, 0.55517, 0.341426, 0.467624, -0.261659, 0.557772, 0.37518, 0.497268, -0.268498, 0.556442, 0.41007, 0.528294, -0.274018, 0.553915, 0.446445, 0.559053, -0.278169, 0.549153, 0.483779, 0.589329, -0.281229, 0.539878, 0.522249, 0.622503, -0.282902, 0.53162, 0.561754, 0.652382, -0.282815, 0.518119, 0.601544, 0.681847, -0.281247, 0.502187, 0.641574, 0.712285, -0.277986, 0.484824, 0.682633, 0.740094, -0.273017, 0.463483, 0.723426, 0.768478, -0.266692, 0.441299, 0.763747, 0.794556, -0.258358, 0.415238, 0.805565, 0.819408, -0.248807, 0.386912, 0.847254, 0.843411, -0.236214, 0.356165, 0.891091, 0.862397, -0.219794, 0.320562, 0.936174, 0.883113, -0.201768, 0.285322, 0.982562, 0.90023, -0.181672, 0.249713, 1.02862, 0.915192, -0.159279, 0.214546, 1.07163, 0.928458, -0.134725, 0.180285, 1.10995, 0.94069, -0.10913, 0.147119, 1.14354, 0.953409, -0.0821315, 0.112492, 1.17372, 0.969537, -0.0542677, 0.0752014, 1.20043, 0.985612, -0.0259096, 0.0370361, 1.22528, 0.999835, 298198e-8, -151801e-8, 1.24959, 0.10097, -602574e-11, 0.300277, 202619e-11, 0.101577, -152164e-9, 0.302077, 511662e-10, 0.101572, -608889e-9, 0.302066, 204751e-9, 0.101566, -136997e-8, 0.302047, 460753e-9, 0.101592, -243557e-8, 0.302114, 819497e-9, 0.101608, -38053e-7, 0.30214, 128154e-8, 0.101627, -547906e-8, 0.30216, 18483e-7, 0.101669, -745647e-8, 0.302224, 252223e-8, 0.101732, -973615e-8, 0.302318, 330716e-8, 0.101844, -0.0123097, 0.302513, 421061e-8, 0.102025, -0.0151681, 0.30285, 524481e-8, 0.102224, -0.0183334, 0.303166, 64154e-7, 0.102515, -0.0217819, 0.303654, 774063e-8, 0.102886, -0.0255067, 0.304243, 92398e-7, 0.103395, -0.029514, 0.305089, 0.0109339, 0.104109, -0.0337912, 0.306301, 0.0128561, 0.105074, -0.0383565, 0.30798, 0.0150338, 0.10654, -0.0432132, 0.310726, 0.0175228, 0.108478, -0.0484244, 0.314351, 0.0203648, 0.111015, -0.0539339, 0.319032, 0.0236325, 0.114682, -0.0598885, 0.32605, 0.0274188, 0.11911, -0.0663375, 0.334109, 0.0317905, 0.124736, -0.0733011, 0.344013, 0.0368502, 0.131479, -0.0807744, 0.355358, 0.0427104, 0.139283, -0.0888204, 0.367614, 0.0494788, 0.148054, -0.0973394, 0.380072, 0.0572367, 0.159037, -0.10665, 0.395678, 0.0662704, 0.169794, -0.116221, 0.40795, 0.0763192, 0.18314, -0.126632, 0.423546, 0.087956, 0.197515, -0.137383, 0.438213, 0.101042, 0.213514, -0.148641, 0.453248, 0.115827, 0.23065, -0.160117, 0.46688, 0.132283, 0.249148, -0.171807, 0.479962, 0.150644, 0.270219, -0.183695, 0.494618, 0.171073, 0.292338, -0.195574, 0.506937, 0.193378, 0.314999, -0.207205, 0.516463, 0.217585, 0.340991, -0.218955, 0.528123, 0.24428, 0.367982, -0.229917, 0.537025, 0.272784, 0.39432, -0.239737, 0.541627, 0.302742, 0.423364, -0.249048, 0.546466, 0.335112, 0.453751, -0.257329, 0.549466, 0.369032, 0.48416, -0.264623, 0.549503, 0.404577, 0.515262, -0.270411, 0.547008, 0.441337, 0.547036, -0.274581, 0.542249, 0.479162, 0.576614, -0.277266, 0.533015, 0.517904, 0.611143, -0.279144, 0.525512, 0.558508, 0.640989, -0.279001, 0.51154, 0.598995, 0.671182, -0.277324, 0.495641, 0.639935, 0.700848, -0.273908, 0.477526, 0.681017, 0.729862, -0.269063, 0.457955, 0.722764, 0.758273, -0.262282, 0.434846, 0.764349, 0.784121, -0.254281, 0.409203, 0.806206, 0.809798, -0.24505, 0.382694, 0.848617, 0.834953, -0.233861, 0.354034, 0.892445, 0.856817, -0.221308, 0.321764, 0.936263, 0.877609, -0.205996, 0.288118, 0.982401, 0.897489, -0.186702, 0.253277, 1.02975, 0.913792, -0.164618, 0.217963, 1.07488, 0.92785, -0.140023, 0.183221, 1.11487, 0.940378, -0.11328, 0.149385, 1.14947, 0.95273, -0.0853958, 0.114152, 1.1807, 0.969059, -0.0568698, 0.0769845, 1.20912, 0.985574, -0.0276502, 0.0381186, 1.23498, 0.999943, 239052e-8, -126861e-8, 1.25987, 0.0852715, -560067e-11, 0.279021, 171162e-11, 0.0854143, -140871e-9, 0.279483, 430516e-10, 0.0854191, -563385e-9, 0.2795, 172184e-9, 0.0854188, -126753e-8, 0.279493, 387464e-9, 0.0854229, -225337e-8, 0.279501, 68918e-8, 0.0854443, -352086e-8, 0.279549, 107803e-8, 0.0854697, -506962e-8, 0.279591, 155536e-8, 0.0855093, -689873e-8, 0.279652, 212354e-8, 0.0855724, -900821e-8, 0.279752, 278703e-8, 0.0856991, -0.0113799, 0.280011, 35551e-7, 0.085855, -0.0140314, 0.280297, 443449e-8, 0.0860682, -0.016963, 0.280682, 543636e-8, 0.086344, -0.0201438, 0.281159, 65788e-7, 0.0867426, -0.0235999, 0.281886, 787977e-8, 0.087239, -0.0273069, 0.282745, 93606e-7, 0.0879815, -0.031269, 0.284139, 0.011056, 0.0891258, -0.035531, 0.28647, 0.0130065, 0.0906909, -0.0400947, 0.289708, 0.0152495, 0.0927624, -0.0449638, 0.293904, 0.0178454, 0.0958376, -0.0502427, 0.300471, 0.0208915, 0.0995827, -0.0559514, 0.30806, 0.0244247, 0.104526, -0.0622152, 0.317874, 0.0285721, 0.110532, -0.0690046, 0.329332, 0.0334227, 0.117385, -0.0763068, 0.341217, 0.0390466, 0.12522, -0.084184, 0.353968, 0.0455786, 0.134037, -0.0925248, 0.366797, 0.0530773, 0.144014, -0.101487, 0.380209, 0.0617424, 0.156013, -0.111273, 0.395956, 0.071777, 0.168872, -0.121431, 0.41053, 0.0830905, 0.183089, -0.132105, 0.425073, 0.0959341, 0.198763, -0.143286, 0.439833, 0.110448, 0.216159, -0.154841, 0.454507, 0.126769, 0.234859, -0.166588, 0.468368, 0.14495, 0.255879, -0.178626, 0.482846, 0.165233, 0.27677, -0.190218, 0.493489, 0.187217, 0.301184, -0.202227, 0.506549, 0.211659, 0.325852, -0.213764, 0.5158, 0.237922, 0.352824, -0.22487, 0.525442, 0.26632, 0.380882, -0.235246, 0.532487, 0.296691, 0.410137, -0.244847, 0.537703, 0.329179, 0.439787, -0.253122, 0.540361, 0.363135, 0.472291, -0.260517, 0.542734, 0.399222, 0.501856, -0.266519, 0.538826, 0.436352, 0.534816, -0.270905, 0.535152, 0.474505, 0.565069, -0.273826, 0.525979, 0.513988, 0.597154, -0.275333, 0.516394, 0.554852, 0.630473, -0.275314, 0.506206, 0.596592, 0.660574, -0.273323, 0.489769, 0.638117, 0.692015, -0.270008, 0.472578, 0.680457, 0.720647, -0.265001, 0.452134, 0.723008, 0.750528, -0.258311, 0.430344, 0.765954, 0.777568, -0.250046, 0.405624, 0.809012, 0.80387, -0.240114, 0.378339, 0.852425, 0.828439, -0.228737, 0.349877, 0.895346, 0.851472, -0.216632, 0.318968, 0.940695, 0.873906, -0.202782, 0.287489, 0.987235, 0.89467, -0.187059, 0.254394, 1.03348, 0.912281, -0.168818, 0.221294, 1.07812, 0.927358, -0.146494, 0.18675, 1.11928, 0.940385, -0.120009, 0.152322, 1.15609, 0.952672, -0.0917183, 0.117514, 1.18875, 0.968496, -0.0620321, 0.0797405, 1.21821, 0.985236, -0.0314945, 0.0402383, 1.24523, 0.99998, -575153e-9, 110644e-9, 1.27133, 0.0702429, -512222e-11, 0.255273, 140947e-11, 0.0702981, -128826e-9, 0.255469, 354488e-10, 0.0703691, -515562e-9, 0.255727, 141874e-9, 0.0703805, -116e-5, 0.255754, 31929e-8, 0.0703961, -206224e-8, 0.255813, 567999e-9, 0.0704102, -322223e-8, 0.255839, 88871e-8, 0.0704298, -463928e-8, 0.255863, 128272e-8, 0.0704759, -631375e-8, 0.255953, 175283e-8, 0.0705434, -824317e-8, 0.256079, 230342e-8, 0.0706693, -0.010412, 0.25636, 29443e-7, 0.0708189, -0.0128439, 0.256647, 368031e-8, 0.0710364, -0.0155177, 0.257084, 452614e-8, 0.0713223, -0.0184374, 0.257637, 549706e-8, 0.0717182, -0.0216002, 0.258416, 661246e-8, 0.072321, -0.0249966, 0.259699, 790147e-8, 0.0731446, -0.0286566, 0.261475, 93884e-7, 0.0743352, -0.0325888, 0.264132, 0.0111186, 0.0760676, -0.036843, 0.26815, 0.013145, 0.078454, -0.0414292, 0.273636, 0.0155251, 0.0818618, -0.0464634, 0.281653, 0.0183525, 0.0857382, -0.0519478, 0.289992, 0.0216642, 0.0908131, -0.0579836, 0.30066, 0.0255956, 0.0967512, -0.0645124, 0.312204, 0.0301954, 0.103717, -0.0716505, 0.325001, 0.0356017, 0.111596, -0.0793232, 0.338129, 0.041896, 0.120933, -0.087645, 0.352853, 0.0492447, 0.130787, -0.096492, 0.366192, 0.0576749, 0.142311, -0.105973, 0.380864, 0.0673969, 0.155344, -0.116182, 0.396575, 0.0785899, 0.169535, -0.126815, 0.411443, 0.0912377, 0.185173, -0.138015, 0.426256, 0.105607, 0.201755, -0.149325, 0.439607, 0.121551, 0.221334, -0.161207, 0.455467, 0.139608, 0.241461, -0.173162, 0.469096, 0.159591, 0.26294, -0.18504, 0.481014, 0.18156, 0.286776, -0.196881, 0.493291, 0.205781, 0.311596, -0.208311, 0.503556, 0.231819, 0.338667, -0.219671, 0.513268, 0.260274, 0.366021, -0.230451, 0.519414, 0.290862, 0.395875, -0.240131, 0.526766, 0.323196, 0.425564, -0.248566, 0.52905, 0.357071, 0.457094, -0.256195, 0.530796, 0.393262, 0.488286, -0.262331, 0.528703, 0.430797, 0.522291, -0.267141, 0.52727, 0.470231, 0.554172, -0.270411, 0.519848, 0.510477, 0.586427, -0.271986, 0.510307, 0.551594, 0.619638, -0.27192, 0.499158, 0.593849, 0.650656, -0.269817, 0.483852, 0.636314, 0.68284, -0.266267, 0.467515, 0.679679, 0.714356, -0.26113, 0.44931, 0.723884, 0.742717, -0.254067, 0.425789, 0.767245, 0.770894, -0.245652, 0.401144, 0.811819, 0.797358, -0.235554, 0.374224, 0.856315, 0.823377, -0.223896, 0.346167, 0.901077, 0.847456, -0.210865, 0.316056, 0.946502, 0.870697, -0.196574, 0.284503, 0.993711, 0.891068, -0.180814, 0.251628, 1.04134, 0.909267, -0.163314, 0.219065, 1.08609, 0.925653, -0.143304, 0.186446, 1.12702, 0.940017, -0.121322, 0.153416, 1.16371, 0.952398, -0.0973872, 0.120334, 1.19712, 0.967568, -0.0698785, 0.08352, 1.22791, 0.984772, -0.0390031, 0.0439209, 1.25672, 1.00026, -70087e-7, 315668e-8, 1.28428, 0.0556653, -459654e-11, 0.227325, 112556e-11, 0.0565238, -116382e-9, 0.230826, 284985e-10, 0.0565717, -465666e-9, 0.231026, 114036e-9, 0.0565859, -104773e-8, 0.231079, 256656e-9, 0.0565761, -186255e-8, 0.231025, 45663e-8, 0.0565913, -291002e-8, 0.231058, 714664e-9, 0.0566108, -418998e-8, 0.231085, 103224e-8, 0.0566532, -570206e-8, 0.231169, 141202e-8, 0.0567473, -743666e-8, 0.231417, 186018e-8, 0.0568567, -940298e-8, 0.231661, 238264e-8, 0.0569859, -0.0115991, 0.231895, 298699e-8, 0.0572221, -0.0140096, 0.232456, 368957e-8, 0.057519, -0.0166508, 0.233096, 450303e-8, 0.0579534, -0.01951, 0.234094, 544945e-8, 0.0585922, -0.0225991, 0.235629, 655564e-8, 0.0595647, -0.0259416, 0.238106, 785724e-8, 0.0609109, -0.0295661, 0.241557, 939127e-8, 0.0628751, -0.0335126, 0.246652, 0.0112198, 0.0656908, -0.0378604, 0.254091, 0.0134168, 0.0691347, -0.0426543, 0.262666, 0.0160374, 0.0732165, -0.0478967, 0.272029, 0.0191514, 0.0782863, -0.0536716, 0.283007, 0.0228597, 0.0843973, -0.0600683, 0.295732, 0.0272829, 0.0913598, -0.0670095, 0.308779, 0.032484, 0.0994407, -0.0745516, 0.322886, 0.0385886, 0.108189, -0.082712, 0.336408, 0.0457133, 0.118574, -0.0914927, 0.351692, 0.0539832, 0.129989, -0.100854, 0.366502, 0.0635162, 0.142722, -0.110837, 0.381675, 0.0744386, 0.156654, -0.121353, 0.3963, 0.0868483, 0.172151, -0.132414, 0.411477, 0.100963, 0.188712, -0.143809, 0.42508, 0.116795, 0.208093, -0.155765, 0.441328, 0.134715, 0.227936, -0.167608, 0.454328, 0.154396, 0.249495, -0.179579, 0.467235, 0.176179, 0.27362, -0.191488, 0.480248, 0.200193, 0.296371, -0.202618, 0.487886, 0.225775, 0.324234, -0.214133, 0.499632, 0.25441, 0.353049, -0.225212, 0.509532, 0.285077, 0.381785, -0.234875, 0.514265, 0.317047, 0.414038, -0.244205, 0.521282, 0.351874, 0.445251, -0.252145, 0.522931, 0.388279, 0.476819, -0.258433, 0.520947, 0.425825, 0.509209, -0.263411, 0.517669, 0.465104, 0.542759, -0.266732, 0.512841, 0.505741, 0.574822, -0.268263, 0.503317, 0.547611, 0.609324, -0.268489, 0.493035, 0.590953, 0.641772, -0.266941, 0.478816, 0.63488, 0.674049, -0.263297, 0.462863, 0.679072, 0.705071, -0.257618, 0.442931, 0.723487, 0.734709, -0.250625, 0.421299, 0.768708, 0.763704, -0.24179, 0.397085, 0.814375, 0.791818, -0.231115, 0.370577, 0.859907, 0.817439, -0.21922, 0.34232, 0.906715, 0.843202, -0.205658, 0.312627, 0.953943, 0.866639, -0.190563, 0.280933, 1.00185, 0.888129, -0.173978, 0.248393, 1.05105, 0.907239, -0.155485, 0.216007, 1.09704, 0.923893, -0.134782, 0.183233, 1.13857, 0.938882, -0.11249, 0.150376, 1.17539, 0.952464, -0.0890706, 0.117177, 1.20924, 0.968529, -0.0646523, 0.0813095, 1.24055, 0.984763, -0.038606, 0.0439378, 1.27018, 1.00053, -0.01238, 598668e-8, 1.29873, 0.0437928, -409594e-11, 0.204012, 879224e-12, 0.0440166, -103395e-9, 0.205049, 221946e-10, 0.0440529, -413633e-9, 0.205225, 887981e-10, 0.0440493, -930594e-9, 0.2052, 199858e-9, 0.0439884, -165352e-8, 0.204901, 355495e-9, 0.0440716, -25849e-7, 0.205255, 556983e-9, 0.0440968, -372222e-8, 0.205311, 805326e-9, 0.0441359, -506478e-8, 0.205391, 110333e-8, 0.0442231, -660384e-8, 0.205638, 145768e-8, 0.0443254, -835246e-8, 0.205877, 187275e-8, 0.0444832, -0.0102992, 0.20627, 235938e-8, 0.0447001, -0.0124449, 0.206796, 29299e-7, 0.0450168, -0.0147935, 0.207593, 36005e-7, 0.0454816, -0.017336, 0.208819, 439246e-8, 0.0462446, -0.0201156, 0.211036, 533864e-8, 0.0473694, -0.0231568, 0.214388, 646984e-8, 0.0490191, -0.0264941, 0.219357, 783856e-8, 0.0512776, -0.030184, 0.226061, 950182e-8, 0.0541279, -0.0342661, 0.234094, 0.0115156, 0.0578989, -0.0388539, 0.244297, 0.0139687, 0.0620835, -0.0438735, 0.254457, 0.0169015, 0.0673497, -0.04951, 0.266706, 0.0204554, 0.0731759, -0.0556263, 0.278753, 0.0246606, 0.0803937, -0.0624585, 0.29309, 0.0297126, 0.0879287, -0.0697556, 0.305856, 0.0355868, 0.0970669, -0.0778795, 0.321059, 0.0425768, 0.106508, -0.0863541, 0.333873, 0.05056, 0.11776, -0.0955935, 0.349008, 0.0598972, 0.130081, -0.105438, 0.363776, 0.0706314, 0.144454, -0.115899, 0.380112, 0.0828822, 0.1596, -0.126827, 0.394843, 0.0967611, 0.176097, -0.138161, 0.409033, 0.112381, 0.194726, -0.149904, 0.424257, 0.129952, 0.213944, -0.161675, 0.436945, 0.149333, 0.235516, -0.173659, 0.450176, 0.170892, 0.260564, -0.185963, 0.466305, 0.194984, 0.285183, -0.197582, 0.477328, 0.220805, 0.311095, -0.208697, 0.486566, 0.248694, 0.338924, -0.219519, 0.494811, 0.279015, 0.369757, -0.229766, 0.504065, 0.311725, 0.3996, -0.238879, 0.507909, 0.345844, 0.430484, -0.246802, 0.509805, 0.381749, 0.46413, -0.253924, 0.511436, 0.420251, 0.497077, -0.259319, 0.508787, 0.459957, 0.530434, -0.263297, 0.50394, 0.501356, 0.565725, -0.265619, 0.49804, 0.544252, 0.599254, -0.265842, 0.487346, 0.587856, 0.631251, -0.263978, 0.472975, 0.631969, 0.663972, -0.26043, 0.457135, 0.677471, 0.697724, -0.255358, 0.439844, 0.723744, 0.727725, -0.248308, 0.417872, 0.770653, 0.756417, -0.239181, 0.39273, 0.817357, 0.785419, -0.22814, 0.367839, 0.864221, 0.81266, -0.215681, 0.339449, 0.912701, 0.839391, -0.201623, 0.309279, 0.962419, 0.86366, -0.185624, 0.278029, 1.0122, 0.885028, -0.16797, 0.245294, 1.06186, 0.904639, -0.148336, 0.212689, 1.10934, 0.922048, -0.12637, 0.179616, 1.15063, 0.936952, -0.102928, 0.146749, 1.18885, 0.951895, -0.0785268, 0.112733, 1.22352, 0.967198, -0.0530153, 0.0760056, 1.25681, 0.984405, -0.02649, 0.0383183, 1.28762, 1.00021, 70019e-8, -20039e-8, 1.31656, 0.0325964, -355447e-11, 0.176706, 655682e-12, 0.0329333, -899174e-10, 0.178527, 165869e-10, 0.0329181, -359637e-9, 0.178453, 663498e-10, 0.0329085, -808991e-9, 0.178383, 149332e-9, 0.0329181, -143826e-8, 0.178394, 265873e-9, 0.0329425, -224678e-8, 0.178517, 416597e-9, 0.0329511, -323575e-8, 0.17849, 603299e-9, 0.033011, -439875e-8, 0.178695, 829422e-9, 0.0330733, -574059e-8, 0.178843, 109908e-8, 0.0331857, -725896e-8, 0.179176, 141933e-8, 0.0333445, -895289e-8, 0.179618, 17999e-7, 0.0335674, -0.0108219, 0.180238, 225316e-8, 0.033939, -0.0128687, 0.181417, 279765e-8, 0.0345239, -0.015114, 0.183395, 34564e-7, 0.0354458, -0.017596, 0.186616, 425864e-8, 0.0368313, -0.0203524, 0.191547, 524936e-8, 0.0386115, -0.0234105, 0.197508, 647033e-8, 0.0410303, -0.0268509, 0.205395, 798121e-8, 0.0442245, -0.0307481, 0.215365, 98557e-7, 0.0478659, -0.0350863, 0.225595, 0.0121417, 0.0522416, -0.0399506, 0.236946, 0.0149385, 0.0574513, -0.045357, 0.249442, 0.0183189, 0.0631208, -0.0512863, 0.261222, 0.0223644, 0.0701124, -0.0579273, 0.275418, 0.0272418, 0.0777331, -0.0650652, 0.288989, 0.0329458, 0.0862709, -0.0728813, 0.302546, 0.0396819, 0.096103, -0.081363, 0.317164, 0.04757, 0.106976, -0.0904463, 0.331733, 0.0567012, 0.119175, -0.100105, 0.34661, 0.067202, 0.132919, -0.110375, 0.362249, 0.0792588, 0.147727, -0.121115, 0.376978, 0.0928672, 0.163618, -0.132299, 0.390681, 0.108228, 0.182234, -0.143887, 0.406571, 0.125502, 0.201809, -0.155827, 0.42042, 0.144836, 0.225041, -0.168357, 0.438411, 0.166706, 0.247621, -0.18004, 0.450368, 0.189909, 0.27097, -0.191536, 0.460083, 0.215251, 0.296658, -0.203024, 0.469765, 0.243164, 0.325892, -0.214056, 0.481837, 0.273388, 0.35406, -0.224104, 0.487474, 0.305344, 0.384372, -0.233489, 0.492773, 0.339741, 0.41749, -0.241874, 0.498451, 0.376287, 0.45013, -0.248834, 0.499632, 0.414195, 0.481285, -0.254658, 0.495233, 0.454077, 0.519183, -0.259367, 0.496401, 0.496352, 0.551544, -0.261818, 0.487686, 0.538798, 0.587349, -0.262964, 0.479453, 0.583626, 0.621679, -0.262128, 0.467709, 0.629451, 0.654991, -0.258998, 0.452123, 0.67566, 0.686873, -0.254119, 0.433495, 0.723248, 0.719801, -0.246946, 0.413657, 0.771156, 0.750355, -0.237709, 0.390366, 0.81989, 0.780033, -0.226549, 0.364947, 0.868601, 0.809254, -0.214186, 0.337256, 0.920034, 0.836576, -0.199639, 0.307395, 0.971706, 0.861774, -0.183169, 0.275431, 1.02479, 0.885707, -0.165111, 0.243431, 1.07837, 0.904742, -0.144363, 0.210921, 1.12783, 0.915604, -0.121305, 0.17647, 1.17254, 0.930959, -0.0962119, 0.143106, 1.21012, 0.948404, -0.069969, 0.108112, 1.24474, 0.967012, -0.0427586, 0.0708478, 1.27718, 0.984183, -0.0147043, 0.032335, 1.3083, 0.999577, 0.0142165, -726867e-8, 1.3382, 0.0229227, -299799e-11, 0.148623, 462391e-12, 0.0232194, -758796e-10, 0.15054, 117033e-10, 0.0232315, -303636e-9, 0.15063, 468397e-10, 0.0232354, -683189e-9, 0.150624, 105472e-9, 0.0232092, -12136e-7, 0.150445, 187744e-9, 0.0232523, -189765e-8, 0.150679, 294847e-9, 0.0232828, -273247e-8, 0.150789, 428013e-9, 0.0233371, -371287e-8, 0.150995, 591134e-9, 0.0234015, -484794e-8, 0.15118, 787642e-9, 0.023514, -612877e-8, 0.151562, 102547e-8, 0.023679, -756125e-8, 0.152116, 131351e-8, 0.0239559, -914651e-8, 0.153162, 166594e-8, 0.0244334, -0.010904, 0.155133, 210182e-8, 0.025139, -0.0128615, 0.158035, 264406e-8, 0.0262598, -0.0150628, 0.162751, 332923e-8, 0.0277875, -0.0175532, 0.168944, 419773e-8, 0.0298472, -0.0203981, 0.176835, 530034e-8, 0.0325444, -0.023655, 0.186686, 669777e-8, 0.0355581, -0.0272982, 0.196248, 842661e-8, 0.0392841, -0.0314457, 0.207352, 0.0105854, 0.0436815, -0.0361157, 0.219279, 0.0132458, 0.0485272, -0.0412932, 0.230728, 0.0164736, 0.0541574, -0.0470337, 0.242994, 0.0203715, 0.0609479, -0.0535002, 0.257042, 0.0250953, 0.0685228, -0.0605409, 0.27102, 0.0306856, 0.0768042, -0.0680553, 0.28406, 0.037193, 0.0864844, -0.0765011, 0.299186, 0.0449795, 0.0969415, -0.0852674, 0.3132, 0.0538316, 0.108478, -0.0947333, 0.327138, 0.0641149, 0.121705, -0.10481, 0.342345, 0.0759185, 0.136743, -0.115474, 0.358472, 0.0894116, 0.152986, -0.126536, 0.374067, 0.104562, 0.170397, -0.138061, 0.388267, 0.121632, 0.191392, -0.150203, 0.406467, 0.140996, 0.211566, -0.161751, 0.418641, 0.161696, 0.233567, -0.173407, 0.430418, 0.184557, 0.257769, -0.185397, 0.44277, 0.210092, 0.28531, -0.197048, 0.457191, 0.237827, 0.311726, -0.20784, 0.464712, 0.267253, 0.340537, -0.218345, 0.472539, 0.299332, 0.372921, -0.228306, 0.482331, 0.333988, 0.402924, -0.236665, 0.484378, 0.369722, 0.434475, -0.244097, 0.484717, 0.407836, 0.469736, -0.250547, 0.487093, 0.448465, 0.505045, -0.25511, 0.485575, 0.490263, 0.540262, -0.258444, 0.481225, 0.534495, 0.576347, -0.259903, 0.473481, 0.579451, 0.608656, -0.259572, 0.4603, 0.625604, 0.646679, -0.257908, 0.450341, 0.674511, 0.679902, -0.253663, 0.431561, 0.723269, 0.714159, -0.247419, 0.412684, 0.773263, 0.745345, -0.239122, 0.389388, 0.824182, 0.778248, -0.228837, 0.365361, 0.876634, 0.807208, -0.216197, 0.337667, 0.92945, 0.835019, -0.201772, 0.307197, 0.985261, 0.860261, -0.185291, 0.274205, 1.04299, 0.877601, -0.165809, 0.240178, 1.09816, 0.898211, -0.143897, 0.207571, 1.14694, 0.915789, -0.119513, 0.174904, 1.19008, 0.931831, -0.0932919, 0.141423, 1.2297, 0.949244, -0.0656528, 0.105603, 1.26553, 0.967527, -0.0370262, 0.0679551, 1.29986, 0.984139, -730117e-8, 0.0283133, 1.33252, 0.999713, 0.0234648, -0.0121785, 1.36397, 0.0152135, -245447e-11, 0.122795, 304092e-12, 0.0151652, -615778e-10, 0.122399, 76292e-10, 0.0151181, -245948e-9, 0.122023, 304802e-10, 0.0151203, -553394e-9, 0.12203, 686634e-10, 0.015125, -983841e-9, 0.122037, 122463e-9, 0.0151427, -153774e-8, 0.12214, 192706e-9, 0.0151708, -22103e-7, 0.122237, 281219e-9, 0.0152115, -300741e-8, 0.12238, 390804e-9, 0.0152877, -392494e-8, 0.1227, 526317e-9, 0.015412, -496597e-8, 0.123244, 69443e-8, 0.0156201, -613314e-8, 0.124228, 90547e-8, 0.0159658, -744113e-8, 0.125945, 11732e-7, 0.0165674, -892546e-8, 0.129098, 151888e-8, 0.017487, -0.010627, 0.133865, 197007e-8, 0.018839, -0.0126043, 0.140682, 25637e-7, 0.020554, -0.0148814, 0.148534, 333637e-8, 0.0226727, -0.0175123, 0.157381, 433738e-8, 0.0251879, -0.0205266, 0.166685, 561664e-8, 0.0283635, -0.0240319, 0.177796, 725563e-8, 0.0318694, -0.0279432, 0.188251, 928811e-8, 0.0361044, -0.0324313, 0.200038, 0.011835, 0.0406656, -0.0373527, 0.210685, 0.0149146, 0.0463846, -0.0430132, 0.224182, 0.0187254, 0.0525696, -0.0491013, 0.23634, 0.0232283, 0.0598083, -0.0559175, 0.250013, 0.0286521, 0.0679437, -0.0633657, 0.263981, 0.0350634, 0.0771181, -0.0714602, 0.278072, 0.0425882, 0.0881273, -0.0803502, 0.29511, 0.0514487, 0.0996628, -0.0896903, 0.309976, 0.0615766, 0.112702, -0.099644, 0.325611, 0.0732139, 0.126488, -0.109829, 0.339321, 0.0862324, 0.142625, -0.120859, 0.35574, 0.101275, 0.15953, -0.131956, 0.369845, 0.117892, 0.176991, -0.143145, 0.38146, 0.136205, 0.199715, -0.155292, 0.40052, 0.157252, 0.220787, -0.167066, 0.412055, 0.179966, 0.243697, -0.178396, 0.423133, 0.204418, 0.272106, -0.190433, 0.439524, 0.232141, 0.297637, -0.201265, 0.447041, 0.261109, 0.325273, -0.211834, 0.454488, 0.292627, 0.357219, -0.221889, 0.465004, 0.326669, 0.387362, -0.230729, 0.468527, 0.362426, 0.423131, -0.23924, 0.475836, 0.401533, 0.45543, -0.246067, 0.475017, 0.441902, 0.493393, -0.251557, 0.478017, 0.484239, 0.526253, -0.255571, 0.4709, 0.528586, 0.560554, -0.257752, 0.463167, 0.574346, 0.599306, -0.258076, 0.456452, 0.621655, 0.634541, -0.256471, 0.443725, 0.670492, 0.668907, -0.253283, 0.428719, 0.721943, 0.705619, -0.247562, 0.411348, 0.772477, 0.739034, -0.240626, 0.388939, 0.8264, 0.771408, -0.231493, 0.36425, 0.881702, 0.803312, -0.220125, 0.337321, 0.9385, 0.828457, -0.206645, 0.305364, 0.997437, 0.854819, -0.190664, 0.273715, 1.05693, 0.878666, -0.171429, 0.242218, 1.11251, 0.898404, -0.149235, 0.209556, 1.16398, 0.917416, -0.12435, 0.176863, 1.21014, 0.933133, -0.0972703, 0.142775, 1.25178, 0.95066, -0.0683607, 0.106735, 1.29028, 0.968589, -0.0378724, 0.0681609, 1.32703, 0.984776, -605712e-8, 0.0273966, 1.36158, 0.99994, 0.0263276, -0.0138124, 1.3943, 867437e-8, -186005e-11, 0.0928979, 173682e-12, 864003e-8, -466389e-10, 0.0925237, 435505e-11, 864593e-8, -186594e-9, 0.0925806, 174322e-10, 864095e-8, -419639e-9, 0.0924903, 392862e-10, 863851e-8, -746272e-9, 0.0924589, 702598e-10, 868531e-8, -116456e-8, 0.0929, 111188e-9, 869667e-8, -167711e-8, 0.0928529, 163867e-9, 874332e-8, -228051e-8, 0.0930914, 23104e-8, 882709e-8, -297864e-8, 0.0935679, 31741e-8, 898874e-8, -377557e-8, 0.0946165, 430186e-9, 929346e-8, -469247e-8, 0.0967406, 580383e-9, 978271e-8, -575491e-8, 0.100084, 783529e-9, 0.0105746, -701514e-8, 0.105447, 106304e-8, 0.0116949, -851797e-8, 0.112494, 144685e-8, 0.0130419, -0.0102757, 0.119876, 196439e-8, 0.0148375, -0.012381, 0.129034, 266433e-8, 0.0168725, -0.01482, 0.137812, 358364e-8, 0.0193689, -0.0176563, 0.147696, 478132e-8, 0.0222691, -0.0209211, 0.157795, 631721e-8, 0.0256891, -0.0246655, 0.168431, 826346e-8, 0.0294686, -0.0288597, 0.178587, 0.0106714, 0.0340412, -0.0336441, 0.190251, 0.0136629, 0.0393918, -0.039033, 0.202999, 0.0173272, 0.0453947, -0.0450087, 0.215655, 0.0217448, 0.0521936, -0.0515461, 0.228686, 0.0269941, 0.0600279, -0.058817, 0.242838, 0.033272, 0.0692398, -0.0667228, 0.258145, 0.0406457, 0.0793832, -0.0752401, 0.273565, 0.0492239, 0.0902297, -0.0841851, 0.287735, 0.0590105, 0.102014, -0.0936479, 0.301161, 0.0702021, 0.116054, -0.103967, 0.317438, 0.0832001, 0.13191, -0.114622, 0.334166, 0.0977951, 0.148239, -0.125452, 0.348192, 0.113985, 0.165809, -0.136453, 0.361094, 0.131928, 0.184616, -0.147648, 0.373534, 0.151811, 0.207491, -0.159607, 0.39101, 0.174476, 0.230106, -0.171119, 0.402504, 0.198798, 0.257036, -0.182906, 0.418032, 0.225796, 0.281172, -0.193605, 0.425468, 0.254027, 0.312034, -0.204771, 0.440379, 0.285713, 0.340402, -0.214988, 0.445406, 0.319196, 0.370231, -0.224711, 0.44968, 0.35537, 0.407105, -0.233516, 0.460747, 0.393838, 0.439037, -0.240801, 0.460624, 0.433747, 0.47781, -0.24762, 0.465957, 0.477234, 0.510655, -0.251823, 0.460054, 0.52044, 0.550584, -0.255552, 0.459172, 0.567853, 0.585872, -0.257036, 0.450311, 0.615943, 0.620466, -0.257535, 0.437763, 0.667693, 0.660496, -0.255248, 0.426639, 0.718988, 0.695578, -0.251141, 0.409185, 0.772503, 0.732176, -0.244718, 0.39015, 0.827023, 0.760782, -0.236782, 0.362594, 0.885651, 0.79422, -0.225923, 0.33711, 0.943756, 0.824521, -0.213855, 0.308272, 1.00874, 0.854964, -0.197723, 0.278529, 1.06764, 0.878065, -0.179209, 0.246208, 1.12836, 0.899834, -0.157569, 0.21329, 1.18318, 0.918815, -0.133206, 0.181038, 1.23161, 0.934934, -0.106545, 0.146993, 1.27644, 0.952115, -0.0780574, 0.111175, 1.31842, 0.96906, -0.0478279, 0.0728553, 1.35839, 0.985178, -0.0160014, 0.032579, 1.39697, 1.00039, 0.0173126, -95256e-7, 1.43312, 384146e-8, -124311e-11, 0.0613583, 778271e-13, 390023e-8, -314043e-10, 0.0622919, 196626e-11, 389971e-8, -125622e-9, 0.0622632, 787379e-11, 389491e-8, -282352e-9, 0.0620659, 1778e-8, 391618e-8, -502512e-9, 0.0624687, 320918e-10, 392662e-8, -784458e-9, 0.0625113, 515573e-10, 396053e-8, -112907e-8, 0.0628175, 778668e-10, 401911e-8, -153821e-8, 0.0633286, 113811e-9, 414994e-8, -20208e-7, 0.0646443, 16445e-8, 441223e-8, -260007e-8, 0.0673886, 237734e-9, 484427e-8, -33097e-7, 0.0716528, 345929e-9, 549109e-8, -418966e-8, 0.0774998, 505987e-9, 636293e-8, -527331e-8, 0.0844758, 739208e-9, 746566e-8, -660428e-8, 0.0921325, 107347e-8, 876625e-8, -818826e-8, 0.0997067, 153691e-8, 0.0103125, -0.0100811, 0.107433, 217153e-8, 0.0123309, -0.0123643, 0.117088, 303427e-8, 0.0146274, -0.0150007, 0.126438, 416018e-8, 0.0172295, -0.0180531, 0.135672, 561513e-8, 0.0204248, -0.0215962, 0.146244, 7478e-6, 0.0241597, -0.0256234, 0.157481, 981046e-8, 0.0284693, -0.0302209, 0.169125, 0.0127148, 0.033445, -0.0353333, 0.181659, 0.0162453, 0.0391251, -0.0410845, 0.1944, 0.0205417, 0.0454721, -0.0473451, 0.207082, 0.0256333, 0.0530983, -0.0542858, 0.221656, 0.0317036, 0.0615356, -0.0618384, 0.236036, 0.0388319, 0.0703363, -0.0697631, 0.248398, 0.046974, 0.0810391, -0.0784757, 0.263611, 0.0565246, 0.0920144, -0.0873488, 0.275857, 0.0671724, 0.105584, -0.0973652, 0.292555, 0.0798105, 0.119506, -0.107271, 0.306333, 0.0935945, 0.134434, -0.117608, 0.318888, 0.109106, 0.153399, -0.128938, 0.337552, 0.127074, 0.171258, -0.139944, 0.349955, 0.14643, 0.191059, -0.151288, 0.361545, 0.168, 0.215069, -0.163018, 0.378421, 0.192082, 0.237838, -0.174226, 0.38879, 0.217838, 0.266965, -0.186063, 0.405857, 0.246931, 0.292827, -0.196909, 0.414146, 0.277505, 0.324352, -0.207473, 0.426955, 0.310711, 0.354427, -0.217713, 0.433429, 0.346794, 0.389854, -0.227183, 0.443966, 0.385237, 0.420749, -0.235131, 0.44471, 0.424955, 0.459597, -0.242786, 0.451729, 0.468446, 0.495316, -0.248767, 0.45072, 0.513422, 0.534903, -0.253351, 0.450924, 0.560618, 0.572369, -0.256277, 0.445266, 0.609677, 0.612383, -0.2576, 0.438798, 0.660995, 0.644037, -0.256931, 0.421693, 0.713807, 0.686749, -0.254036, 0.4109, 0.767616, 0.719814, -0.249785, 0.390151, 0.82533, 0.754719, -0.244283, 0.367847, 0.888311, 0.792022, -0.235076, 0.345013, 0.948177, 0.822404, -0.225061, 0.316193, 1.01661, 0.853084, -0.211113, 0.287013, 1.08075, 0.879871, -0.19449, 0.255424, 1.14501, 0.901655, -0.174023, 0.222879, 1.20203, 0.919957, -0.1509, 0.18989, 1.25698, 0.938412, -0.124923, 0.15606, 1.30588, 0.953471, -0.0968139, 0.120512, 1.3529, 0.970451, -0.066734, 0.0828515, 1.3986, 0.985522, -0.034734, 0.0424458, 1.44148, 1.00099, -102222e-8, 678929e-9, 1.48398, 965494e-9, -627338e-12, 0.0306409, 197672e-13, 99168e-8, -158573e-10, 0.0314638, 499803e-12, 991068e-9, -634012e-10, 0.031363, 200682e-11, 974567e-9, -14144e-8, 0.03036, 457312e-11, 998079e-9, -252812e-9, 0.031496, 860131e-11, 102243e-8, -396506e-9, 0.0319955, 148288e-10, 107877e-8, -577593e-9, 0.0331376, 249141e-10, 121622e-8, -816816e-9, 0.0359396, 423011e-10, 14455e-7, -113761e-8, 0.0399652, 724613e-10, 178791e-8, -156959e-8, 0.0450556, 123929e-9, 225668e-8, -214064e-8, 0.0508025, 208531e-9, 285627e-8, -287655e-8, 0.0568443, 341969e-9, 35991e-7, -380271e-8, 0.0630892, 544158e-9, 455524e-8, -496264e-8, 0.0702204, 842423e-9, 569143e-8, -63793e-7, 0.0773426, 126704e-8, 716928e-8, -813531e-8, 0.0860839, 186642e-8, 885307e-8, -0.0101946, 0.0944079, 267014e-8, 0.0109316, -0.0126386, 0.103951, 374033e-8, 0.0133704, -0.0154876, 0.113786, 51304e-7, 0.0161525, -0.0187317, 0.123477, 688858e-8, 0.0194267, -0.0224652, 0.133986, 910557e-8, 0.0230967, -0.0265976, 0.143979, 0.0118074, 0.0273627, -0.0312848, 0.154645, 0.0151266, 0.0323898, -0.0365949, 0.166765, 0.0191791, 0.0379225, -0.0422914, 0.177932, 0.0239236, 0.0447501, -0.0487469, 0.19167, 0.0296568, 0.0519391, -0.0556398, 0.203224, 0.0362924, 0.0599464, -0.0631646, 0.215652, 0.0440585, 0.0702427, -0.0714308, 0.232089, 0.0531619, 0.0806902, -0.0800605, 0.245258, 0.0634564, 0.0923194, -0.0892815, 0.258609, 0.0752481, 0.106938, -0.09931, 0.276654, 0.0888914, 0.121238, -0.109575, 0.289847, 0.104055, 0.138817, -0.120461, 0.307566, 0.121266, 0.15595, -0.131209, 0.320117, 0.139944, 0.178418, -0.143049, 0.339677, 0.161591, 0.197875, -0.154074, 0.349886, 0.184303, 0.224368, -0.166307, 0.369352, 0.210669, 0.252213, -0.178051, 0.386242, 0.238895, 0.277321, -0.189335, 0.395294, 0.269182, 0.310332, -0.200683, 0.412148, 0.302508, 0.338809, -0.210856, 0.418266, 0.337264, 0.372678, -0.220655, 0.428723, 0.374881, 0.405632, -0.230053, 0.433887, 0.415656, 0.442293, -0.237993, 0.439911, 0.457982, 0.477256, -0.244897, 0.440175, 0.502831, 0.515592, -0.250657, 0.441079, 0.550277, 0.550969, -0.255459, 0.435219, 0.601102, 0.592883, -0.257696, 0.432882, 0.651785, 0.629092, -0.259894, 0.421054, 0.708961, 0.672033, -0.258592, 0.41177, 0.763806, 0.709147, -0.256525, 0.395267, 0.824249, 0.745367, -0.254677, 0.375013, 0.8951, 0.784715, -0.247892, 0.353906, 0.959317, 0.818107, -0.240162, 0.327801, 1.03153, 0.847895, -0.229741, 0.298821, 1.10601, 0.879603, -0.213084, 0.269115, 1.164, 0.902605, -0.195242, 0.236606, 1.22854, 0.922788, -0.174505, 0.203442, 1.29017, 0.944831, -0.150169, 0.169594, 1.34157, 0.959656, -0.124099, 0.135909, 1.3956, 0.972399, -0.0960626, 0.0990563, 1.45128, 0.986549, -0.0657097, 0.0602348, 1.50312, 1.00013, -0.0333558, 0.0186694, 1.55364, 619747e-11, -1e-7, 778326e-8, 796756e-16, 237499e-13, -999999e-13, 282592e-10, 114596e-15, 100292e-11, -166369e-11, 250354e-9, 677492e-14, 350752e-11, -637769e-11, 357289e-9, 631655e-13, 826445e-11, -174689e-10, 516179e-9, 31851e-11, 242481e-10, -450868e-10, 10223e-7, 130577e-11, 455631e-10, -89044e-9, 144302e-8, 374587e-11, 971222e-10, -178311e-9, 241912e-8, 102584e-10, 171403e-9, -313976e-9, 354938e-8, 236481e-10, 292747e-9, -520026e-9, 513765e-8, 496014e-10, 789827e-9, -118187e-8, 0.0238621, 139056e-9, 114093e-8, -171827e-8, 0.0286691, 244093e-9, 176119e-8, -249667e-8, 0.0368565, 420623e-9, 22233e-7, -333742e-8, 0.0400469, 65673e-8, 343382e-8, -481976e-8, 0.0535751, 109323e-8, 427602e-8, -600755e-8, 0.057099, 155268e-8, 461435e-8, -737637e-8, 0.0551084, 215031e-8, 695698e-8, -971401e-8, 0.0715767, 316529e-8, 867619e-8, -0.0120943, 0.0793314, 436995e-8, 0.0106694, -0.0148202, 0.0869391, 58959e-7, 0.0140351, -0.0183501, 0.101572, 798757e-8, 0.0168939, -0.022006, 0.11018, 0.0104233, 0.020197, -0.0261568, 0.119041, 0.0134167, 0.0254702, -0.0312778, 0.135404, 0.0173009, 0.0298384, -0.0362469, 0.1437, 0.0215428, 0.035159, -0.042237, 0.15512, 0.0268882, 0.0427685, -0.0488711, 0.17128, 0.033235, 0.0494848, -0.0557997, 0.181813, 0.0404443, 0.0592394, -0.0635578, 0.198745, 0.0490043, 0.0681463, -0.071838, 0.210497, 0.0588239, 0.0804753, -0.0809297, 0.228864, 0.0702835, 0.0942205, -0.0906488, 0.247008, 0.0834012, 0.106777, -0.100216, 0.258812, 0.0975952, 0.124471, -0.110827, 0.278617, 0.114162, 0.138389, -0.121193, 0.287049, 0.131983, 0.159543, -0.13253, 0.307151, 0.152541, 0.176432, -0.143611, 0.31564, 0.174673, 0.201723, -0.15548, 0.33538, 0.199842, 0.229721, -0.167166, 0.355256, 0.227097, 0.250206, -0.178238, 0.360047, 0.256014, 0.282118, -0.189905, 0.378761, 0.28855, 0.312821, -0.201033, 0.39181, 0.323348, 0.341482, -0.211584, 0.397716, 0.360564, 0.377368, -0.221314, 0.410141, 0.400004, 0.418229, -0.230474, 0.423485, 0.442371, 0.444881, -0.239443, 0.418874, 0.488796, 0.488899, -0.245987, 0.427545, 0.535012, 0.520317, -0.253948, 0.422147, 0.589678, 0.568566, -0.256616, 0.42719, 0.637683, 0.599607, -0.26376, 0.415114, 0.703363, 0.64222, -0.268687, 0.408715, 0.771363, 0.685698, -0.2694, 0.399722, 0.83574, 0.732327, -0.266642, 0.388651, 0.897764, 0.769873, -0.267712, 0.369198, 0.983312, 0.806733, -0.263479, 0.346802, 1.06222, 0.843466, -0.254575, 0.321368, 1.13477, 0.873008, -0.242749, 0.29211, 1.20712, 0.908438, -0.22725, 0.262143, 1.27465, 0.936321, -0.207621, 0.228876, 1.33203, 0.950353, -0.187932, 0.19484, 1.40439, 0.96442, -0.165154, 0.163178, 1.4732, 0.979856, -0.139302, 0.127531, 1.53574, 0.982561, -0.11134, 0.0903457, 1.59982, 0.996389, -0.0808124, 0.0489007, 1.6577];
  var LTC_MAT_2 = [1, 0, 0, 0, 1, 791421e-36, 0, 0, 1, 104392e-29, 0, 0, 1, 349405e-26, 0, 0, 1, 109923e-23, 0, 0, 1, 947414e-22, 0, 0, 1, 359627e-20, 0, 0, 1, 772053e-19, 0, 0, 1, 108799e-17, 0, 0, 1, 110655e-16, 0, 0, 1, 865818e-16, 0, 0, 0.999998, 545037e-15, 0, 0, 0.999994, 285095e-14, 0, 0, 0.999989, 126931e-13, 0, 0, 0.999973, 489938e-13, 0, 0, 0.999947, 166347e-12, 0, 0, 0.999894, 502694e-12, 0, 0, 0.999798, 136532e-11, 0, 0, 0.999617, 335898e-11, 0, 0, 0.999234, 752126e-11, 0, 0, 0.998258, 152586e-10, 0, 0, 0.99504, 266207e-10, 0, 0, 0.980816, 236802e-10, 0, 0, 0.967553, 207684e-11, 0, 0, 0.966877, 403733e-11, 0, 0, 0.965752, 741174e-11, 0, 0, 0.96382, 127746e-10, 0, 0, 0.960306, 202792e-10, 0, 0, 0.953619, 280232e-10, 0, 0, 0.941103, 278816e-10, 0, 0, 0.926619, 160221e-10, 0, 0, 0.920983, 235164e-10, 0, 0, 0.912293, 311924e-10, 0, 0.0158731, 0.899277, 348118e-10, 0, 0.0476191, 0.880884, 26041e-9, 0, 0.0793651, 0.870399, 338726e-10, 0, 0.111111, 0.856138, 392906e-10, 0, 0.142857, 0.837436, 372874e-10, 0, 0.174603, 0.820973, 392558e-10, 0, 0.206349, 0.803583, 434658e-10, 0, 0.238095, 0.782168, 40256e-9, 0, 0.269841, 0.764107, 448159e-10, 0, 0.301587, 0.743092, 457627e-10, 0, 0.333333, 0.721626, 455314e-10, 0, 0.365079, 0.700375, 477335e-10, 0, 0.396825, 0.677334, 461072e-10, 0, 0.428571, 0.655702, 484393e-10, 0, 0.460317, 0.632059, 464583e-10, 0, 0.492064, 0.610125, 483923e-10, 0, 0.52381, 0.58653, 464342e-10, 0, 0.555556, 0.564508, 477033e-10, 0, 0.587302, 0.541405, 459263e-10, 0, 0.619048, 0.519556, 46412e-9, 0, 0.650794, 0.497292, 448913e-10, 0, 0.68254, 0.475898, 445789e-10, 0, 0.714286, 0.454722, 433496e-10, 0, 0.746032, 0.434042, 423054e-10, 0, 0.777778, 0.414126, 413737e-10, 0, 0.809524, 0.394387, 397265e-10, 0, 0.84127, 0.375841, 390709e-10, 0, 0.873016, 0.357219, 369938e-10, 0, 0.904762, 0.340084, 365618e-10, 0, 0.936508, 0.322714, 342533e-10, 0, 0.968254, 0.306974, 339596e-10, 0, 1, 1, 101524e-23, 0, 0, 1, 10292e-22, 0, 0, 1, 130908e-23, 0, 0, 1, 473331e-23, 0, 0, 1, 625319e-22, 0, 0, 1, 107932e-20, 0, 0, 1, 163779e-19, 0, 0, 1, 203198e-18, 0, 0, 1, 204717e-17, 0, 0, 0.999999, 168995e-16, 0, 0, 0.999998, 115855e-15, 0, 0, 0.999996, 66947e-14, 0, 0, 0.999991, 330863e-14, 0, 0, 0.999983, 141737e-13, 0, 0, 0.999968, 532626e-13, 0, 0, 0.99994, 177431e-12, 0, 0, 0.999891, 528835e-12, 0, 0, 0.999797, 142169e-11, 0, 0, 0.999617, 347057e-11, 0, 0, 0.999227, 77231e-10, 0, 0, 0.998239, 155753e-10, 0, 0, 0.994937, 268495e-10, 0, 0, 0.980225, 213742e-10, 0, 0, 0.967549, 21631e-10, 0, 0, 0.966865, 417989e-11, 0, 0, 0.965739, 763341e-11, 0, 0, 0.963794, 130892e-10, 0, 0, 0.960244, 206456e-10, 0, 0, 0.953495, 282016e-10, 0, 148105e-9, 0.940876, 271581e-10, 0, 2454e-6, 0.926569, 164159e-10, 0, 867491e-8, 0.920905, 239521e-10, 0, 0.01956, 0.912169, 315127e-10, 0, 0.035433, 0.899095, 346626e-10, 0, 0.056294, 0.882209, 290223e-10, 0, 0.0818191, 0.870272, 342992e-10, 0, 0.111259, 0.855977, 394164e-10, 0, 0.142857, 0.837431, 372343e-10, 0, 0.174603, 0.820826, 396691e-10, 0, 0.206349, 0.803408, 435395e-10, 0, 0.238095, 0.782838, 419579e-10, 0, 0.269841, 0.763941, 450953e-10, 0, 0.301587, 0.742904, 455847e-10, 0, 0.333333, 0.721463, 458833e-10, 0, 0.365079, 0.700197, 477159e-10, 0, 0.396825, 0.677501, 470641e-10, 0, 0.428571, 0.655527, 484732e-10, 0, 0.460317, 0.6324, 476834e-10, 0, 0.492064, 0.609964, 484213e-10, 0, 0.52381, 0.586839, 475541e-10, 0, 0.555556, 0.564353, 476951e-10, 0, 0.587302, 0.541589, 467611e-10, 0, 0.619048, 0.519413, 463493e-10, 0, 0.650794, 0.497337, 453994e-10, 0, 0.68254, 0.475797, 445308e-10, 0, 0.714286, 0.454659, 435787e-10, 0, 0.746032, 0.434065, 424839e-10, 0, 0.777778, 0.414018, 41436e-9, 0, 0.809524, 0.39455, 401902e-10, 0, 0.84127, 0.375742, 390813e-10, 0, 0.873016, 0.357501, 377116e-10, 0, 0.904762, 0.339996, 36535e-9, 0, 0.936508, 0.323069, 351265e-10, 0, 0.968254, 0.306897, 339112e-10, 0, 1, 1, 10396e-19, 0, 0, 1, 104326e-20, 0, 0, 1, 110153e-20, 0, 0, 1, 144668e-20, 0, 0, 1, 34528e-19, 0, 0, 1, 175958e-19, 0, 0, 1, 12627e-17, 0, 0, 1, 936074e-18, 0, 0, 1, 645742e-17, 0, 0, 0.999998, 401228e-16, 0, 0, 0.999997, 222338e-15, 0, 0, 0.999995, 10967e-13, 0, 0, 0.999991, 482132e-14, 0, 0, 0.999981, 189434e-13, 0, 0, 0.999967, 667716e-13, 0, 0, 0.999938, 212066e-12, 0, 0, 0.999886, 60977e-11, 0, 0, 0.999792, 159504e-11, 0, 0, 0.999608, 381191e-11, 0, 0, 0.999209, 833727e-11, 0, 0, 0.998179, 165288e-10, 0, 0, 0.994605, 274387e-10, 0, 0, 0.979468, 167316e-10, 0, 0, 0.967529, 242877e-11, 0, 0, 0.966836, 461696e-11, 0, 0, 0.96569, 830977e-11, 0, 0, 0.963706, 140427e-10, 0, 244659e-11, 0.960063, 217353e-10, 0, 760774e-9, 0.953113, 286606e-10, 0, 367261e-8, 0.940192, 247691e-10, 0, 940263e-8, 0.927731, 195814e-10, 0, 0.018333, 0.920669, 252531e-10, 0, 0.0306825, 0.911799, 324277e-10, 0, 0.0465556, 0.89857, 340982e-10, 0, 0.0659521, 0.883283, 319622e-10, 0, 0.0887677, 0.86989, 35548e-9, 0, 0.114784, 0.855483, 397143e-10, 0, 0.143618, 0.837987, 391665e-10, 0, 0.174606, 0.820546, 411306e-10, 0, 0.206349, 0.802878, 436753e-10, 0, 0.238095, 0.783402, 444e-7, 0, 0.269841, 0.763439, 458726e-10, 0, 0.301587, 0.742925, 467097e-10, 0, 0.333333, 0.721633, 478887e-10, 0, 0.365079, 0.69985, 481251e-10, 0, 0.396825, 0.67783, 491811e-10, 0, 0.428571, 0.655126, 488199e-10, 0, 0.460318, 0.632697, 496025e-10, 0, 0.492064, 0.609613, 48829e-9, 0, 0.52381, 0.587098, 492754e-10, 0, 0.555556, 0.564119, 482625e-10, 0, 0.587302, 0.541813, 482807e-10, 0, 0.619048, 0.519342, 471552e-10, 0, 0.650794, 0.497514, 466765e-10, 0, 0.68254, 0.475879, 455582e-10, 0, 0.714286, 0.454789, 446007e-10, 0, 0.746032, 0.434217, 435382e-10, 0, 0.777778, 0.414086, 421753e-10, 0, 0.809524, 0.394744, 412093e-10, 0, 0.84127, 0.375782, 396634e-10, 0, 0.873016, 0.357707, 386419e-10, 0, 0.904762, 0.340038, 370345e-10, 0, 0.936508, 0.323284, 359725e-10, 0, 0.968254, 0.306954, 3436e-8, 0, 1, 1, 599567e-19, 0, 0, 1, 600497e-19, 0, 0, 1, 614839e-19, 0, 0, 1, 686641e-19, 0, 0, 1, 972658e-19, 0, 0, 1, 221271e-18, 0, 0, 1, 833195e-18, 0, 0, 1, 403601e-17, 0, 0, 0.999999, 206001e-16, 0, 0, 0.999998, 101739e-15, 0, 0, 0.999997, 470132e-15, 0, 0, 0.999993, 200436e-14, 0, 0, 0.999988, 783682e-14, 0, 0, 0.999979, 280338e-13, 0, 0, 0.999962, 917033e-13, 0, 0, 0.999933, 274514e-12, 0, 0, 0.999881, 753201e-12, 0, 0, 0.999783, 189826e-11, 0, 0, 0.999594, 440279e-11, 0, 0, 0.999178, 93898e-10, 0, 0, 0.998073, 181265e-10, 0, 0, 0.993993, 280487e-10, 0, 0, 0.979982, 149422e-10, 0, 0, 0.968145, 378481e-11, 0, 0, 0.966786, 53771e-10, 0, 0, 0.965611, 947508e-11, 0, 388934e-10, 0.963557, 156616e-10, 0, 9693e-7, 0.959752, 235144e-10, 0, 370329e-8, 0.952461, 291568e-10, 0, 868428e-8, 0.940193, 240102e-10, 0, 0.0161889, 0.929042, 231235e-10, 0, 0.0263948, 0.920266, 273968e-10, 0, 0.0394088, 0.911178, 337915e-10, 0, 0.0552818, 0.897873, 333629e-10, 0, 0.0740138, 0.884053, 351405e-10, 0, 0.0955539, 0.869455, 378034e-10, 0, 0.119795, 0.854655, 399378e-10, 0, 0.14656, 0.838347, 419108e-10, 0, 0.175573, 0.820693, 440831e-10, 0, 0.206388, 0.802277, 445599e-10, 0, 0.238095, 0.783634, 472691e-10, 0, 0.269841, 0.763159, 476984e-10, 0, 0.301587, 0.742914, 491487e-10, 0, 0.333333, 0.721662, 502312e-10, 0, 0.365079, 0.699668, 502817e-10, 0, 0.396825, 0.677839, 51406e-9, 0, 0.428571, 0.655091, 511095e-10, 0, 0.460317, 0.632665, 516067e-10, 0, 0.492064, 0.609734, 512255e-10, 0, 0.52381, 0.587043, 510263e-10, 0, 0.555556, 0.564298, 50565e-9, 0, 0.587302, 0.541769, 497951e-10, 0, 0.619048, 0.519529, 492698e-10, 0, 0.650794, 0.497574, 482066e-10, 0, 0.68254, 0.476028, 473689e-10, 0, 0.714286, 0.454961, 461941e-10, 0, 0.746032, 0.434341, 450618e-10, 0, 0.777778, 0.414364, 438355e-10, 0, 0.809524, 0.394832, 424196e-10, 0, 0.84127, 0.376109, 412563e-10, 0, 0.873016, 0.35779, 396226e-10, 0, 0.904762, 0.340379, 384886e-10, 0, 0.936508, 0.323385, 368214e-10, 0, 0.968254, 0.307295, 356636e-10, 0, 1, 1, 106465e-17, 0, 0, 1, 106555e-17, 0, 0, 1, 107966e-17, 0, 0, 1, 114601e-17, 0, 0, 1, 137123e-17, 0, 0, 1, 21243e-16, 0, 0, 0.999999, 489653e-17, 0, 0, 0.999999, 160283e-16, 0, 0, 0.999998, 62269e-15, 0, 0, 0.999997, 251859e-15, 0, 0, 0.999996, 996192e-15, 0, 0, 0.999992, 374531e-14, 0, 0, 0.999986, 132022e-13, 0, 0, 0.999975, 433315e-13, 0, 0, 0.999959, 131956e-12, 0, 0, 0.999927, 372249e-12, 0, 0, 0.999871, 972461e-12, 0, 0, 0.999771, 235343e-11, 0, 0, 0.999572, 52768e-10, 0, 0, 0.999133, 109237e-10, 0, 0, 0.997912, 203675e-10, 0, 0, 0.993008, 279396e-10, 0, 0, 0.980645, 139604e-10, 0, 0, 0.970057, 646596e-11, 0, 0, 0.966717, 65089e-10, 0, 474145e-10, 0.965497, 111863e-10, 0, 89544e-8, 0.96334, 179857e-10, 0, 32647e-7, 0.959294, 259045e-10, 0, 75144e-7, 0.951519, 292327e-10, 0, 0.0138734, 0.940517, 249769e-10, 0, 0.0224952, 0.93014, 26803e-9, 0, 0.0334828, 0.91972, 303656e-10, 0, 0.0468973, 0.910294, 353323e-10, 0, 0.0627703, 0.897701, 351002e-10, 0, 0.0811019, 0.884522, 388104e-10, 0, 0.10186, 0.869489, 412932e-10, 0, 0.124985, 0.853983, 415781e-10, 0, 0.150372, 0.838425, 454066e-10, 0, 0.177868, 0.820656, 471624e-10, 0, 0.207245, 0.801875, 475243e-10, 0, 0.238143, 0.783521, 505621e-10, 0, 0.269841, 0.763131, 50721e-9, 0, 0.301587, 0.74261, 523293e-10, 0, 0.333333, 0.72148, 528699e-10, 0, 0.365079, 0.699696, 538677e-10, 0, 0.396825, 0.677592, 539255e-10, 0, 0.428571, 0.65525, 546367e-10, 0, 0.460317, 0.632452, 541348e-10, 0, 0.492064, 0.609903, 544976e-10, 0, 0.52381, 0.586928, 536201e-10, 0, 0.555556, 0.564464, 535185e-10, 0, 0.587302, 0.541801, 524949e-10, 0, 0.619048, 0.519681, 51812e-9, 0, 0.650794, 0.497685, 507687e-10, 0, 0.68254, 0.47622, 496243e-10, 0, 0.714286, 0.455135, 485714e-10, 0, 0.746032, 0.4346, 471847e-10, 0, 0.777778, 0.414564, 459294e-10, 0, 0.809524, 0.395165, 444705e-10, 0, 0.84127, 0.376333, 430772e-10, 0, 0.873016, 0.358197, 416229e-10, 0, 0.904762, 0.34064, 401019e-10, 0, 0.936508, 0.323816, 386623e-10, 0, 0.968254, 0.307581, 370933e-10, 0, 1, 1, 991541e-17, 0, 0, 1, 992077e-17, 0, 0, 1, 100041e-16, 0, 0, 1, 10385e-15, 0, 0, 1, 115777e-16, 0, 0, 1, 150215e-16, 0, 0, 0.999999, 254738e-16, 0, 0, 0.999999, 598822e-16, 0, 0, 0.999998, 179597e-15, 0, 0, 0.999997, 602367e-15, 0, 0, 0.999994, 206835e-14, 0, 0, 0.99999, 694952e-14, 0, 0, 0.999984, 223363e-13, 0, 0, 0.999972, 678578e-13, 0, 0, 0.999952, 193571e-12, 0, 0, 0.999919, 516594e-12, 0, 0, 0.99986, 128739e-11, 0, 0, 0.999753, 299298e-11, 0, 0, 0.999546, 648258e-11, 0, 0, 0.999074, 129985e-10, 0, 0, 0.997671, 232176e-10, 0, 0, 0.991504, 256701e-10, 0, 0, 0.981148, 131141e-10, 0, 0, 0.971965, 869048e-11, 0, 280182e-10, 0.966624, 808301e-11, 0, 695475e-9, 0.965344, 135235e-10, 0, 265522e-8, 0.963048, 210592e-10, 0, 622975e-8, 0.958673, 287473e-10, 0, 0.0116234, 0.950262, 281379e-10, 0, 0.018976, 0.940836, 271089e-10, 0, 0.0283844, 0.930996, 30926e-9, 0, 0.0399151, 0.919848, 348359e-10, 0, 0.0536063, 0.909136, 366092e-10, 0, 0.0694793, 0.897554, 384162e-10, 0, 0.0875342, 0.884691, 430971e-10, 0, 0.107749, 0.869414, 447803e-10, 0, 0.130087, 0.853462, 452858e-10, 0, 0.154481, 0.838187, 495769e-10, 0, 0.180833, 0.820381, 502709e-10, 0, 0.209005, 0.801844, 522713e-10, 0, 0.238791, 0.783061, 541505e-10, 0, 0.269869, 0.763205, 553712e-10, 0, 0.301587, 0.742362, 564909e-10, 0, 0.333333, 0.721393, 572646e-10, 0, 0.365079, 0.699676, 581012e-10, 0, 0.396825, 0.677395, 58096e-9, 0, 0.428571, 0.655208, 585766e-10, 0, 0.460317, 0.632451, 583602e-10, 0, 0.492064, 0.609839, 580234e-10, 0, 0.52381, 0.587093, 577161e-10, 0, 0.555556, 0.564467, 568447e-10, 0, 0.587302, 0.542043, 563166e-10, 0, 0.619048, 0.519826, 55156e-9, 0, 0.650794, 0.497952, 541682e-10, 0, 0.68254, 0.476477, 528971e-10, 0, 0.714286, 0.455412, 514952e-10, 0, 0.746032, 0.434926, 502222e-10, 0, 0.777778, 0.4149, 485779e-10, 0, 0.809524, 0.395552, 472242e-10, 0, 0.84127, 0.376712, 454891e-10, 0, 0.873016, 0.358622, 440924e-10, 0, 0.904762, 0.341048, 422984e-10, 0, 0.936508, 0.324262, 408582e-10, 0, 0.968254, 0.308013, 390839e-10, 0, 1, 1, 613913e-16, 0, 0, 1, 614145e-16, 0, 0, 1, 617708e-16, 0, 0, 1, 633717e-16, 0, 0, 1, 681648e-16, 0, 0, 1, 808291e-16, 0, 0, 1, 114608e-15, 0, 0, 0.999998, 210507e-15, 0, 0, 0.999997, 499595e-15, 0, 0, 0.999995, 139897e-14, 0, 0, 0.999994, 419818e-14, 0, 0, 0.999988, 127042e-13, 0, 0, 0.999979, 375153e-13, 0, 0, 0.999965, 106206e-12, 0, 0, 0.999945, 285381e-12, 0, 0, 0.999908, 723611e-12, 0, 0, 0.999846, 17255e-10, 0, 0, 0.999733, 386104e-11, 0, 0, 0.999511, 808493e-11, 0, 0, 0.998993, 156884e-10, 0, 0, 0.997326, 265538e-10, 0, 0, 0.989706, 206466e-10, 0, 0, 0.981713, 130756e-10, 0, 70005e-10, 0.973636, 106473e-10, 0, 464797e-9, 0.966509, 10194e-9, 0, 201743e-8, 0.965149, 165881e-10, 0, 497549e-8, 0.962669, 249147e-10, 0, 953262e-8, 0.95786, 317449e-10, 0, 0.0158211, 0.949334, 281045e-10, 0, 0.0239343, 0.941041, 303263e-10, 0, 0.0339372, 0.931575, 356754e-10, 0, 0.0458738, 0.920102, 397075e-10, 0, 0.059772, 0.908002, 384886e-10, 0, 0.075645, 0.897269, 43027e-9, 0, 0.0934929, 0.884559, 479925e-10, 0, 0.113302, 0.869161, 48246e-9, 0, 0.135045, 0.853342, 509505e-10, 0, 0.158678, 0.837633, 542846e-10, 0, 0.184136, 0.820252, 554139e-10, 0, 0.211325, 0.801872, 581412e-10, 0, 0.240113, 0.782418, 585535e-10, 0, 0.270306, 0.7631, 610923e-10, 0, 0.301594, 0.742183, 613678e-10, 0, 0.333333, 0.721098, 627275e-10, 0, 0.365079, 0.699512, 629413e-10, 0, 0.396825, 0.677372, 636351e-10, 0, 0.428571, 0.655059, 633555e-10, 0, 0.460317, 0.632567, 636513e-10, 0, 0.492064, 0.609784, 628965e-10, 0, 0.52381, 0.587237, 625546e-10, 0, 0.555556, 0.564525, 615825e-10, 0, 0.587302, 0.542181, 605048e-10, 0, 0.619048, 0.520017, 596329e-10, 0, 0.650794, 0.498204, 581516e-10, 0, 0.68254, 0.476742, 569186e-10, 0, 0.714286, 0.455803, 553833e-10, 0, 0.746032, 0.435251, 537807e-10, 0, 0.777778, 0.415374, 522025e-10, 0, 0.809524, 0.395921, 503421e-10, 0, 0.84127, 0.377253, 488211e-10, 0, 0.873016, 0.359021, 468234e-10, 0, 0.904762, 0.341637, 453269e-10, 0, 0.936508, 0.3247, 433014e-10, 0, 0.968254, 0.308625, 418007e-10, 0, 1, 1, 286798e-15, 0, 0, 1, 286877e-15, 0, 0, 1, 288094e-15, 0, 0, 1, 293506e-15, 0, 0, 1, 309262e-15, 0, 0, 0.999999, 348593e-15, 0, 0, 0.999999, 444582e-15, 0, 0, 0.999998, 688591e-15, 0, 0, 0.999996, 134391e-14, 0, 0, 0.999993, 317438e-14, 0, 0, 0.999989, 835609e-14, 0, 0, 0.999983, 228677e-13, 0, 0, 0.999974, 623361e-13, 0, 0, 0.999959, 165225e-12, 0, 0, 0.999936, 419983e-12, 0, 0, 0.999896, 101546e-11, 0, 0, 0.99983, 232376e-11, 0, 0, 0.999709, 50156e-10, 0, 0, 0.999469, 10167e-9, 0, 0, 0.998886, 190775e-10, 0, 0, 0.996819, 300511e-10, 0, 0, 0.988837, 185092e-10, 0, 168222e-12, 0.982178, 134622e-10, 0, 259622e-9, 0.975017, 125961e-10, 0, 142595e-8, 0.967101, 13507e-9, 0, 382273e-8, 0.964905, 205003e-10, 0, 764164e-8, 0.96218, 29546e-9, 0, 0.0130121, 0.956821, 343738e-10, 0, 0.0200253, 0.948829, 305063e-10, 0, 0.0287452, 0.941092, 346487e-10, 0, 0.039218, 0.931883, 412061e-10, 0, 0.0514748, 0.920211, 444651e-10, 0, 0.0655351, 0.907307, 431252e-10, 0, 0.0814082, 0.89684, 490382e-10, 0, 0.0990939, 0.884119, 53334e-9, 0, 0.118583, 0.869148, 54114e-9, 0, 0.139856, 0.853377, 578536e-10, 0, 0.162882, 0.836753, 592285e-10, 0, 0.187615, 0.820063, 622787e-10, 0, 0.213991, 0.801694, 645492e-10, 0, 0.241918, 0.782116, 65353e-9, 0, 0.271267, 0.762673, 674344e-10, 0, 0.301847, 0.742133, 682788e-10, 0, 0.333333, 0.720779, 691959e-10, 0, 0.365079, 0.699386, 696817e-10, 0, 0.396826, 0.67732, 699583e-10, 0, 0.428572, 0.654888, 698447e-10, 0, 0.460318, 0.632499, 694063e-10, 0, 0.492064, 0.609825, 691612e-10, 0, 0.52381, 0.587287, 681576e-10, 0, 0.555556, 0.564743, 674138e-10, 0, 0.587302, 0.542409, 661617e-10, 0, 0.619048, 0.520282, 647785e-10, 0, 0.650794, 0.498506, 633836e-10, 0, 0.68254, 0.477102, 615905e-10, 0, 0.714286, 0.456167, 601013e-10, 0, 0.746032, 0.435728, 581457e-10, 0, 0.777778, 0.415809, 564215e-10, 0, 0.809524, 0.396517, 544997e-10, 0, 0.84127, 0.377737, 525061e-10, 0, 0.873016, 0.359698, 506831e-10, 0, 0.904762, 0.342164, 48568e-9, 0, 0.936508, 0.325417, 467826e-10, 0, 0.968254, 0.309186, 446736e-10, 0, 1, 1, 109018e-14, 0, 0, 1, 10904e-13, 0, 0, 1, 109393e-14, 0, 0, 1, 11095e-13, 0, 0, 1, 1154e-12, 0, 0, 1, 126089e-14, 0, 0, 0.999999, 15059e-13, 0, 0, 0.999997, 207899e-14, 0, 0, 0.999994, 348164e-14, 0, 0, 0.999993, 705728e-14, 0, 0, 0.999987, 163692e-13, 0, 0, 0.999981, 406033e-13, 0, 0, 0.999969, 10245e-11, 0, 0, 0.999953, 255023e-12, 0, 0, 0.999925, 61511e-11, 0, 0, 0.999881, 142218e-11, 0, 0, 0.99981, 313086e-11, 0, 0, 0.99968, 653119e-11, 0, 0, 0.999418, 12832e-9, 0, 0, 0.998748, 232497e-10, 0, 0, 0.996066, 329522e-10, 0, 0, 0.988379, 179613e-10, 0, 108799e-9, 0.982567, 143715e-10, 0, 921302e-9, 0.976097, 148096e-10, 0, 280738e-8, 0.968475, 178905e-10, 0, 596622e-8, 0.964606, 253921e-10, 0, 0.0105284, 0.961564, 348623e-10, 0, 0.0165848, 0.955517, 357612e-10, 0, 0.0242, 0.948381, 343493e-10, 0, 0.03342, 0.941095, 405849e-10, 0, 0.0442777, 0.931923, 475394e-10, 0, 0.0567958, 0.91996, 484328e-10, 0, 0.0709879, 0.907419, 502146e-10, 0, 0.086861, 0.89618, 561654e-10, 0, 0.104415, 0.88337, 587612e-10, 0, 0.123643, 0.869046, 618057e-10, 0, 0.144531, 0.853278, 657392e-10, 0, 0.167057, 0.836091, 66303e-9, 0, 0.191188, 0.819644, 704445e-10, 0, 0.216878, 0.801246, 714071e-10, 0, 0.244062, 0.782031, 740093e-10, 0, 0.272649, 0.762066, 74685e-9, 0, 0.302509, 0.741964, 766647e-10, 0, 0.333442, 0.720554, 766328e-10, 0, 0.365079, 0.699098, 777857e-10, 0, 0.396826, 0.677189, 774633e-10, 0, 0.428572, 0.65484, 776235e-10, 0, 0.460318, 0.632496, 770316e-10, 0, 0.492064, 0.609908, 762669e-10, 0, 0.52381, 0.587312, 753972e-10, 0, 0.555556, 0.564938, 739994e-10, 0, 0.587302, 0.542577, 728382e-10, 0, 0.619048, 0.52062, 71112e-9, 0, 0.650794, 0.498819, 694004e-10, 0, 0.68254, 0.477555, 675575e-10, 0, 0.714286, 0.456568, 653449e-10, 0, 0.746032, 0.436278, 636068e-10, 0, 0.777778, 0.41637, 613466e-10, 0, 0.809524, 0.397144, 594177e-10, 0, 0.84127, 0.378412, 570987e-10, 0, 0.873016, 0.360376, 550419e-10, 0, 0.904762, 0.342906, 527422e-10, 0, 0.936508, 0.326136, 506544e-10, 0, 0.968254, 0.30997, 484307e-10, 0, 1, 1, 354014e-14, 0, 0, 1, 354073e-14, 0, 0, 1, 354972e-14, 0, 0, 1, 358929e-14, 0, 0, 1, 370093e-14, 0, 0, 0.999999, 396194e-14, 0, 0, 0.999998, 453352e-14, 0, 0, 0.999997, 578828e-14, 0, 0, 0.999994, 863812e-14, 0, 0, 0.999991, 153622e-13, 0, 0, 0.999985, 316356e-13, 0, 0, 0.999977, 712781e-13, 0, 0, 0.999964, 166725e-12, 0, 0, 0.999945, 390501e-12, 0, 0, 0.999912, 895622e-12, 0, 0, 0.999866, 198428e-11, 0, 0, 0.999786, 421038e-11, 0, 0, 0.999647, 850239e-11, 0, 0, 0.999356, 162059e-10, 0, 0, 0.998563, 282652e-10, 0, 0, 0.994928, 336309e-10, 0, 244244e-10, 0.987999, 178458e-10, 0, 523891e-9, 0.982893, 159162e-10, 0, 194729e-8, 0.977044, 178056e-10, 0, 451099e-8, 0.969972, 230624e-10, 0, 835132e-8, 0.964237, 313922e-10, 0, 0.013561, 0.960791, 406145e-10, 0, 0.0202056, 0.954292, 372796e-10, 0, 0.0283321, 0.948052, 403199e-10, 0, 0.0379739, 0.940938, 479537e-10, 0, 0.0491551, 0.931689, 545292e-10, 0, 0.0618918, 0.91987, 54038e-9, 0, 0.0761941, 0.907665, 589909e-10, 0, 0.0920672, 0.895281, 642651e-10, 0, 0.109511, 0.882621, 659707e-10, 0, 0.12852, 0.86873, 709973e-10, 0, 0.149085, 0.853008, 742221e-10, 0, 0.171189, 0.835944, 761754e-10, 0, 0.194809, 0.818949, 797052e-10, 0, 0.21991, 0.800951, 812434e-10, 0, 0.246447, 0.781847, 838075e-10, 0, 0.274352, 0.761649, 84501e-9, 0, 0.303535, 0.74152, 860258e-10, 0, 0.333857, 0.720495, 866233e-10, 0, 0.365104, 0.698742, 868326e-10, 0, 0.396826, 0.677096, 87133e-9, 0, 0.428572, 0.654782, 863497e-10, 0, 0.460318, 0.632335, 860206e-10, 0, 0.492064, 0.610031, 849337e-10, 0, 0.52381, 0.587457, 838279e-10, 0, 0.555556, 0.56513, 82309e-9, 0, 0.587302, 0.542877, 803542e-10, 0, 0.619048, 0.5209, 786928e-10, 0, 0.650794, 0.499291, 765171e-10, 0, 0.68254, 0.477971, 744753e-10, 0, 0.714286, 0.457221, 72209e-9, 0, 0.746032, 0.436803, 697448e-10, 0, 0.777778, 0.417083, 675333e-10, 0, 0.809524, 0.397749, 648058e-10, 0, 0.84127, 0.379177, 625759e-10, 0, 0.873016, 0.361061, 598584e-10, 0, 0.904762, 0.343713, 575797e-10, 0, 0.936508, 0.326894, 549999e-10, 0, 0.968254, 0.310816, 527482e-10, 0, 1, 1, 10153e-12, 0, 0, 1, 101544e-13, 0, 0, 1, 101751e-13, 0, 0, 1, 102662e-13, 0, 0, 1, 10521e-12, 0, 0, 0.999999, 111049e-13, 0, 0, 0.999999, 123408e-13, 0, 0, 0.999996, 14924e-12, 0, 0, 0.999992, 204471e-13, 0, 0, 0.999989, 326539e-13, 0, 0, 0.99998, 603559e-13, 0, 0, 0.999971, 123936e-12, 0, 0, 0.999955, 269058e-12, 0, 0, 0.999933, 593604e-12, 0, 0, 0.999901, 129633e-11, 0, 0, 0.999847, 275621e-11, 0, 0, 0.999761, 564494e-11, 0, 0, 0.999607, 110485e-10, 0, 0, 0.999282, 204388e-10, 0, 0, 0.99831, 341084e-10, 0, 22038e-11, 0.993288, 294949e-10, 0, 242388e-9, 0.987855, 192736e-10, 0, 12503e-7, 0.983167, 182383e-10, 0, 32745e-7, 0.977908, 218633e-10, 0, 646321e-8, 0.971194, 290662e-10, 0, 0.0109133, 0.963867, 386401e-10, 0, 0.0166927, 0.95982, 462827e-10, 0, 0.0238494, 0.953497, 420705e-10, 0, 0.0324178, 0.947621, 477743e-10, 0, 0.0424225, 0.940611, 568258e-10, 0, 0.0538808, 0.931174, 618061e-10, 0, 0.0668047, 0.919919, 627098e-10, 0, 0.0812014, 0.907856, 694714e-10, 0, 0.0970745, 0.894509, 735008e-10, 0, 0.114424, 0.881954, 763369e-10, 0, 0.133246, 0.868309, 821896e-10, 0, 0.153534, 0.852511, 83769e-9, 0, 0.175275, 0.835821, 881615e-10, 0, 0.198453, 0.817981, 896368e-10, 0, 0.223042, 0.800504, 930906e-10, 0, 0.249009, 0.78141, 945056e-10, 0, 0.276304, 0.761427, 963605e-10, 0, 0.304862, 0.74094, 968088e-10, 0, 0.334584, 0.720233, 981481e-10, 0, 0.365322, 0.698592, 979122e-10, 0, 0.396826, 0.676763, 981057e-10, 0, 0.428571, 0.654808, 973956e-10, 0, 0.460318, 0.632326, 962619e-10, 0, 0.492064, 0.610049, 952996e-10, 0, 0.52381, 0.58763, 933334e-10, 0, 0.555556, 0.565261, 917573e-10, 0, 0.587302, 0.543244, 896636e-10, 0, 0.619048, 0.521273, 873304e-10, 0, 0.650794, 0.499818, 852648e-10, 0, 0.68254, 0.478536, 823961e-10, 0, 0.714286, 0.457826, 79939e-9, 0, 0.746032, 0.437549, 77126e-9, 0, 0.777778, 0.41776, 743043e-10, 0, 0.809524, 0.39863, 716426e-10, 0, 0.84127, 0.379954, 686456e-10, 0, 0.873016, 0.362025, 660514e-10, 0, 0.904762, 0.344581, 630755e-10, 0, 0.936508, 0.327909, 605439e-10, 0, 0.968254, 0.311736, 576345e-10, 0, 1, 1, 263344e-13, 0, 0, 1, 263373e-13, 0, 0, 1, 263815e-13, 0, 0, 1, 265753e-13, 0, 0, 1, 271132e-13, 0, 0, 0.999999, 283279e-13, 0, 0, 0.999997, 30833e-12, 0, 0, 0.999995, 358711e-13, 0, 0, 0.999992, 461266e-13, 0, 0, 0.999985, 67574e-12, 0, 0, 0.999977, 11358e-11, 0, 0, 0.999966, 213657e-12, 0, 0, 0.999948, 431151e-12, 0, 0, 0.999923, 896656e-12, 0, 0, 0.999884, 186603e-11, 0, 0, 0.999826, 381115e-11, 0, 0, 0.999732, 754184e-11, 0, 0, 0.999561, 143192e-10, 0, 0, 0.999191, 257061e-10, 0, 0, 0.997955, 405724e-10, 0, 744132e-10, 0.992228, 276537e-10, 0, 716477e-9, 0.987638, 208885e-10, 0, 22524e-7, 0.983395, 215226e-10, 0, 484816e-8, 0.978614, 270795e-10, 0, 860962e-8, 0.972389, 365282e-10, 0, 0.0136083, 0.964392, 474747e-10, 0, 0.0198941, 0.95861, 509141e-10, 0, 0.0275023, 0.952806, 48963e-9, 0, 0.0364584, 0.94712, 571119e-10, 0, 0.04678, 0.940104, 671704e-10, 0, 0.0584799, 0.930398, 687586e-10, 0, 0.0715665, 0.919866, 738161e-10, 0, 0.086045, 0.907853, 813235e-10, 0, 0.101918, 0.894078, 834582e-10, 0, 0.119186, 0.881177, 892093e-10, 0, 0.137845, 0.867575, 944548e-10, 0, 0.157891, 0.852107, 969607e-10, 0, 0.179316, 0.835502, 101456e-9, 0, 0.202106, 0.81756, 103256e-9, 0, 0.226243, 0.79984, 106954e-9, 0, 0.251704, 0.780998, 108066e-9, 0, 0.278451, 0.761132, 110111e-9, 0, 0.306436, 0.740429, 110459e-9, 0, 0.335586, 0.719836, 111219e-9, 0, 0.365796, 0.698467, 11145e-8, 0, 0.3969, 0.676446, 110393e-9, 0, 0.428571, 0.654635, 110035e-9, 0, 0.460318, 0.632411, 108548e-9, 0, 0.492064, 0.609986, 106963e-9, 0, 0.52381, 0.587872, 105238e-9, 0, 0.555556, 0.565528, 102665e-9, 0, 0.587302, 0.543563, 100543e-9, 0, 0.619048, 0.52176, 976182e-10, 0, 0.650794, 0.500188, 947099e-10, 0, 0.68254, 0.479204, 919929e-10, 0, 0.714286, 0.458413, 886139e-10, 0, 0.746032, 0.438314, 857839e-10, 0, 0.777778, 0.418573, 82411e-9, 0, 0.809524, 0.39947, 792211e-10, 0, 0.84127, 0.380892, 759546e-10, 0, 0.873016, 0.362953, 727571e-10, 0, 0.904762, 0.345601, 695738e-10, 0, 0.936508, 0.328895, 664907e-10, 0, 0.968254, 0.312808, 634277e-10, 0, 1, 1, 628647e-13, 0, 0, 1, 628705e-13, 0, 0, 1, 629587e-13, 0, 0, 1, 633441e-13, 0, 0, 0.999999, 644087e-13, 0, 0, 0.999998, 667856e-13, 0, 0, 0.999997, 715889e-13, 0, 0, 0.999995, 809577e-13, 0, 0, 0.999989, 992764e-13, 0, 0, 0.999983, 135834e-12, 0, 0, 0.999974, 210482e-12, 0, 0, 0.999959, 365215e-12, 0, 0, 0.999939, 686693e-12, 0, 0, 0.999911, 13472e-10, 0, 0, 0.999868, 26731e-10, 0, 0, 0.999804, 524756e-11, 0, 0, 0.9997, 100403e-10, 0, 0, 0.99951, 185019e-10, 0, 0, 0.999078, 322036e-10, 0, 620676e-11, 0.997428, 470002e-10, 0, 341552e-9, 0.99162, 287123e-10, 0, 143727e-8, 0.987479, 234706e-10, 0, 349201e-8, 0.983582, 260083e-10, 0, 66242e-7, 0.979186, 337927e-10, 0, 0.0109113, 0.97325, 454689e-10, 0, 0.0164064, 0.965221, 573759e-10, 0, 0.0231463, 0.957262, 544114e-10, 0, 0.0311571, 0.952211, 587006e-10, 0, 0.0404572, 0.946631, 692256e-10, 0, 0.0510592, 0.939391, 787819e-10, 0, 0.0629723, 0.929795, 792368e-10, 0, 0.0762025, 0.91965, 875075e-10, 0, 0.090753, 0.907737, 950903e-10, 0, 0.106626, 0.893899, 972963e-10, 0, 0.123822, 0.880239, 10459e-8, 0, 0.142337, 0.866562, 107689e-9, 0, 0.16217, 0.85164, 113081e-9, 0, 0.183314, 0.835021, 116636e-9, 0, 0.20576, 0.817311, 120074e-9, 0, 0.229496, 0.798845, 121921e-9, 0, 0.254502, 0.780479, 12475e-8, 0, 0.280753, 0.760694, 125255e-9, 0, 0.308212, 0.740142, 126719e-9, 0, 0.336825, 0.719248, 12636e-8, 0, 0.366517, 0.698209, 126712e-9, 0, 0.397167, 0.676398, 125769e-9, 0, 0.428578, 0.654378, 124432e-9, 0, 0.460318, 0.632484, 123272e-9, 0, 0.492064, 0.610113, 12085e-8, 0, 0.52381, 0.587931, 118411e-9, 0, 0.555556, 0.565872, 11569e-8, 0, 0.587302, 0.543814, 112521e-9, 0, 0.619048, 0.522265, 109737e-9, 0, 0.650794, 0.500835, 106228e-9, 0, 0.68254, 0.479818, 102591e-9, 0, 0.714286, 0.459258, 991288e-10, 0, 0.746032, 0.439061, 952325e-10, 0, 0.777778, 0.419552, 91895e-9, 0, 0.809524, 0.400399, 879051e-10, 0, 0.84127, 0.381976, 844775e-10, 0, 0.873016, 0.364009, 806316e-10, 0, 0.904762, 0.346761, 771848e-10, 0, 0.936508, 0.330049, 735429e-10, 0, 0.968254, 0.314018, 702103e-10, 0, 1, 1, 139968e-12, 0, 0, 1, 139979e-12, 0, 0, 1, 140145e-12, 0, 0, 1, 14087e-11, 0, 0, 0.999999, 142865e-12, 0, 0, 0.999998, 147279e-12, 0, 0, 0.999997, 156057e-12, 0, 0, 0.999992, 17276e-11, 0, 0, 0.999989, 204352e-12, 0, 0, 0.99998, 26494e-11, 0, 0, 0.999969, 383435e-12, 0, 0, 0.999953, 618641e-12, 0, 0, 0.999929, 108755e-11, 0, 0, 0.999898, 201497e-11, 0, 0, 0.999849, 381346e-11, 0, 0, 0.999778, 719815e-11, 0, 0, 0.999661, 133215e-10, 0, 0, 0.999451, 238313e-10, 0, 0, 0.998936, 401343e-10, 0, 113724e-9, 0.99662, 517346e-10, 0, 820171e-9, 0.991094, 304323e-10, 0, 238143e-8, 0.987487, 281757e-10, 0, 493527e-8, 0.983731, 320048e-10, 0, 856859e-8, 0.979647, 423905e-10, 0, 0.0133393, 0.973837, 562935e-10, 0, 0.0192863, 0.96584, 677442e-10, 0, 0.0264369, 0.956309, 623073e-10, 0, 0.03481, 0.951523, 704131e-10, 0, 0.0444184, 0.946003, 836594e-10, 0, 0.0552713, 0.938454, 911736e-10, 0, 0.0673749, 0.929279, 938264e-10, 0, 0.0807329, 0.919239, 103754e-9, 0, 0.0953479, 0.907293, 109928e-9, 0, 0.111221, 0.893936, 115257e-9, 0, 0.128352, 0.879674, 122265e-9, 0, 0.14674, 0.865668, 125733e-9, 0, 0.166382, 0.850998, 132305e-9, 0, 0.187276, 0.834498, 134844e-9, 0, 0.209413, 0.816903, 139276e-9, 0, 0.232786, 0.798235, 140984e-9, 0, 0.257382, 0.779724, 14378e-8, 0, 0.283181, 0.760251, 144623e-9, 0, 0.310156, 0.739808, 145228e-9, 0, 0.338269, 0.718762, 14539e-8, 0, 0.367461, 0.697815, 144432e-9, 0, 0.397646, 0.67631, 143893e-9, 0, 0.428685, 0.654278, 141846e-9, 0, 0.460318, 0.632347, 13935e-8, 0, 0.492064, 0.610296, 137138e-9, 0, 0.52381, 0.588039, 133806e-9, 0, 0.555556, 0.566218, 130755e-9, 0, 0.587302, 0.544346, 127128e-9, 0, 0.619048, 0.522701, 123002e-9, 0, 0.650794, 0.501542, 119443e-9, 0, 0.68254, 0.480508, 115055e-9, 0, 0.714286, 0.460092, 111032e-9, 0, 0.746032, 0.440021, 106635e-9, 0, 0.777778, 0.420446, 102162e-9, 0, 0.809524, 0.401512, 98184e-9, 0, 0.84127, 0.38299, 936497e-10, 0, 0.873016, 0.365232, 89813e-9, 0, 0.904762, 0.347865, 853073e-10, 0, 0.936508, 0.331342, 817068e-10, 0, 0.968254, 0.315202, 773818e-10, 0, 1, 1, 29368e-11, 0, 0, 1, 2937e-10, 0, 0, 1, 293998e-12, 0, 0, 1, 295298e-12, 0, 0, 0.999999, 298865e-12, 0, 0, 0.999998, 3067e-10, 0, 0, 0.999995, 322082e-12, 0, 0, 0.999992, 350767e-12, 0, 0, 0.999986, 403538e-12, 0, 0, 0.999976, 501372e-12, 0, 0, 0.999964, 68562e-11, 0, 0, 0.999945, 10374e-10, 0, 0, 0.999919, 171269e-11, 0, 0, 0.999882, 300175e-11, 0, 0, 0.999829, 542144e-11, 0, 0, 0.999749, 984182e-11, 0, 0, 0.99962, 176213e-10, 0, 0, 0.999382, 305995e-10, 0, 138418e-10, 0.998751, 496686e-10, 0, 389844e-9, 0.995344, 510733e-10, 0, 150343e-8, 0.990768, 345829e-10, 0, 352451e-8, 0.987464, 342841e-10, 0, 655379e-8, 0.983846, 399072e-10, 0, 0.0106554, 0.980007, 533219e-10, 0, 0.0158723, 0.974494, 696992e-10, 0, 0.0222333, 0.96622, 776754e-10, 0, 0.029758, 0.956273, 747718e-10, 0, 0.0384596, 0.950952, 864611e-10, 0, 0.0483473, 0.945215, 100464e-9, 0, 0.0594266, 0.937287, 103729e-9, 0, 0.0717019, 0.928649, 111665e-9, 0, 0.0851752, 0.918791, 12353e-8, 0, 0.0998479, 0.906685, 127115e-9, 0, 0.115721, 0.893706, 13628e-8, 0, 0.132794, 0.879248, 142427e-9, 0, 0.151067, 0.864685, 148091e-9, 0, 0.170538, 0.850032, 153517e-9, 0, 0.191204, 0.833853, 157322e-9, 0, 0.213063, 0.816353, 161086e-9, 0, 0.236107, 0.797834, 164111e-9, 0, 0.260329, 0.778831, 165446e-9, 0, 0.285714, 0.759756, 167492e-9, 0, 0.312243, 0.739419, 166928e-9, 0, 0.339887, 0.718491, 167e-6, 0, 0.368604, 0.697392, 165674e-9, 0, 0.398329, 0.676102, 163815e-9, 0, 0.428961, 0.654243, 162003e-9, 0, 0.460331, 0.632176, 158831e-9, 0, 0.492064, 0.610407, 155463e-9, 0, 0.52381, 0.588394, 152062e-9, 0, 0.555556, 0.56645, 147665e-9, 0, 0.587302, 0.5449, 14375e-8, 0, 0.619048, 0.523276, 138905e-9, 0, 0.650794, 0.502179, 134189e-9, 0, 0.68254, 0.481359, 129392e-9, 0, 0.714286, 0.46092, 124556e-9, 0, 0.746032, 0.441084, 11957e-8, 0, 0.777778, 0.421517, 114652e-9, 0, 0.809524, 0.402721, 109688e-9, 0, 0.84127, 0.384222, 104667e-9, 0, 0.873016, 0.366534, 999633e-10, 0, 0.904762, 0.349205, 950177e-10, 0, 0.936508, 0.332702, 907301e-10, 0, 0.968254, 0.316599, 859769e-10, 0, 1, 1, 585473e-12, 0, 0, 1, 585507e-12, 0, 0, 1, 58602e-11, 0, 0, 0.999999, 588259e-12, 0, 0, 0.999999, 594381e-12, 0, 0, 0.999998, 607754e-12, 0, 0, 0.999995, 633729e-12, 0, 0, 0.99999, 68137e-11, 0, 0, 0.999984, 767003e-12, 0, 0, 0.999973, 921212e-12, 0, 0, 0.999959, 120218e-11, 0, 0, 0.999936, 172024e-11, 0, 0, 0.999907, 268088e-11, 0, 0, 0.999866, 445512e-11, 0, 0, 0.999806, 768481e-11, 0, 0, 0.999716, 1342e-8, 0, 0, 0.999576, 232473e-10, 0, 0, 0.9993, 391694e-10, 0, 129917e-9, 0.998498, 608429e-10, 0, 845035e-9, 0.994132, 489743e-10, 0, 237616e-8, 0.99031, 384644e-10, 0, 484456e-8, 0.987409, 421768e-10, 0, 832472e-8, 0.983981, 504854e-10, 0, 0.0128643, 0.980268, 671028e-10, 0, 0.0184947, 0.974875, 852749e-10, 0, 0.025237, 0.966063, 85531e-9, 0, 0.0331046, 0.956779, 900588e-10, 0, 0.0421067, 0.950259, 10577e-8, 0, 0.0522487, 0.944239, 119458e-9, 0, 0.0635343, 0.936341, 122164e-9, 0, 0.0759654, 0.928047, 134929e-9, 0, 0.0895434, 0.918065, 145544e-9, 0, 0.104269, 0.906267, 150531e-9, 0, 0.120142, 0.893419, 161652e-9, 0, 0.137163, 0.878758, 16593e-8, 0, 0.15533, 0.863699, 174014e-9, 0, 0.174645, 0.848876, 177877e-9, 0, 0.195106, 0.833032, 184049e-9, 0, 0.21671, 0.815557, 186088e-9, 0, 0.239454, 0.797323, 19054e-8, 0, 0.263332, 0.778124, 191765e-9, 0, 0.288336, 0.758929, 192535e-9, 0, 0.314451, 0.738979, 192688e-9, 0, 0.341658, 0.718213, 191522e-9, 0, 0.369924, 0.696947, 190491e-9, 0, 0.399202, 0.675807, 187913e-9, 0, 0.429416, 0.654147, 184451e-9, 0, 0.460447, 0.63229, 181442e-9, 0, 0.492064, 0.610499, 177139e-9, 0, 0.523809, 0.588747, 172596e-9, 0, 0.555555, 0.566783, 167457e-9, 0, 0.587301, 0.545359, 162518e-9, 0, 0.619048, 0.523984, 156818e-9, 0, 0.650794, 0.502917, 151884e-9, 0, 0.68254, 0.482294, 145514e-9, 0, 0.714286, 0.461945, 140199e-9, 0, 0.746032, 0.442133, 134101e-9, 0, 0.777778, 0.422705, 128374e-9, 0, 0.809524, 0.403916, 122996e-9, 0, 0.84127, 0.38554, 116808e-9, 0, 0.873016, 0.367909, 111973e-9, 0, 0.904762, 0.350651, 105938e-9, 0, 0.936508, 0.334208, 101355e-9, 0, 0.968254, 0.318123, 957629e-10, 0, 1, 1, 111633e-11, 0, 0, 1, 111639e-11, 0, 0, 1, 111725e-11, 0, 0, 1, 112096e-11, 0, 0, 0.999999, 11311e-10, 0, 0, 0.999997, 115315e-11, 0, 0, 0.999995, 11956e-10, 0, 0, 0.999989, 127239e-11, 0, 0, 0.999981, 140772e-11, 0, 0, 0.999969, 164541e-11, 0, 0, 0.999952, 206607e-11, 0, 0, 0.999928, 281783e-11, 0, 0, 0.999895, 416835e-11, 0, 0, 0.999848, 658728e-11, 0, 0, 0.999781, 108648e-10, 0, 0, 0.999682, 182579e-10, 0, 0, 0.999523, 306003e-10, 0, 159122e-10, 0.999205, 499862e-10, 0, 391184e-9, 0.998131, 73306e-9, 0, 147534e-8, 0.993334, 513229e-10, 0, 34227e-7, 0.99016, 467783e-10, 0, 632232e-8, 0.987321, 523413e-10, 0, 0.0102295, 0.984099, 64267e-9, 0, 0.0151794, 0.980432, 843042e-10, 0, 0.0211947, 0.974976, 102819e-9, 0, 0.0282899, 0.966429, 996234e-10, 0, 0.0364739, 0.957633, 111074e-9, 0, 0.0457522, 0.949422, 128644e-9, 0, 0.0561278, 0.943045, 140076e-9, 0, 0.0676023, 0.935448, 146349e-9, 0, 0.0801762, 0.927225, 161854e-9, 0, 0.0938499, 0.917033, 169135e-9, 0, 0.108623, 0.905762, 179987e-9, 0, 0.124496, 0.892879, 189832e-9, 0, 0.141469, 0.878435, 195881e-9, 0, 0.159541, 0.863114, 20466e-8, 0, 0.178713, 0.84776, 209473e-9, 0, 0.198985, 0.832084, 214861e-9, 0, 0.220355, 0.814915, 217695e-9, 0, 0.242823, 0.796711, 220313e-9, 0, 0.266385, 0.777603, 22313e-8, 0, 0.291036, 0.757991, 222471e-9, 0, 0.316767, 0.738371, 222869e-9, 0, 0.343563, 0.717872, 221243e-9, 0, 0.371402, 0.696619, 218089e-9, 0, 0.400248, 0.675379, 21562e-8, 0, 0.430047, 0.65411, 21169e-8, 0, 0.460709, 0.63241, 206947e-9, 0, 0.492079, 0.61046, 201709e-9, 0, 0.52381, 0.58903, 196753e-9, 0, 0.555556, 0.567267, 189637e-9, 0, 0.587302, 0.545886, 184735e-9, 0, 0.619048, 0.524714, 177257e-9, 0, 0.650794, 0.503789, 171424e-9, 0, 0.68254, 0.483204, 164688e-9, 0, 0.714286, 0.462976, 157172e-9, 0, 0.746032, 0.443294, 151341e-9, 0, 0.777778, 0.423988, 143737e-9, 0, 0.809524, 0.405325, 138098e-9, 0, 0.84127, 0.386981, 130698e-9, 0, 0.873016, 0.369436, 125276e-9, 0, 0.904762, 0.35219, 118349e-9, 0, 0.936508, 0.335804, 11312e-8, 0, 0.968254, 0.319749, 106687e-9, 0, 1, 1, 204685e-11, 0, 0, 1, 204694e-11, 0, 0, 1, 204831e-11, 0, 0, 0.999999, 205428e-11, 0, 0, 0.999999, 207056e-11, 0, 0, 0.999997, 210581e-11, 0, 0, 0.999993, 21732e-10, 0, 0, 0.999987, 229365e-11, 0, 0, 0.999979, 250243e-11, 0, 0, 0.999965, 286127e-11, 0, 0, 0.999947, 348028e-11, 0, 0, 0.999918, 455588e-11, 0, 0, 0.999881, 643303e-11, 0, 0, 0.999828, 970064e-11, 0, 0, 0.999753, 153233e-10, 0, 0, 0.999642, 24793e-9, 0, 0, 0.999464, 402032e-10, 0, 122947e-9, 0.999089, 635852e-10, 0, 807414e-9, 0.997567, 857026e-10, 0, 227206e-8, 0.992903, 594912e-10, 0, 462812e-8, 0.990011, 578515e-10, 0, 794162e-8, 0.987192, 65399e-9, 0, 0.0122534, 0.98418, 819675e-10, 0, 0.0175888, 0.980491, 105514e-9, 0, 0.0239635, 0.974779, 121532e-9, 0, 0.031387, 0.96675, 119144e-9, 0, 0.0398644, 0.958248, 136125e-9, 0, 0.0493982, 0.948884, 155408e-9, 0, 0.0599896, 0.941673, 162281e-9, 0, 0.0716382, 0.934521, 176754e-9, 0, 0.0843437, 0.926205, 192873e-9, 0, 0.0981056, 0.916089, 200038e-9, 0, 0.112923, 0.904963, 213624e-9, 0, 0.128796, 0.892089, 221834e-9, 0, 0.145725, 0.878028, 232619e-9, 0, 0.163709, 0.86249, 238632e-9, 0, 0.182749, 0.846587, 247002e-9, 0, 0.202847, 0.830988, 250702e-9, 0, 0.224001, 0.814165, 255562e-9, 0, 0.246214, 0.796135, 257505e-9, 0, 0.269482, 0.777052, 258625e-9, 0, 0.293805, 0.757201, 258398e-9, 0, 0.319176, 0.737655, 256714e-9, 0, 0.345587, 0.717477, 255187e-9, 0, 0.373021, 0.696433, 251792e-9, 0, 0.401454, 0.675084, 247223e-9, 0, 0.430844, 0.653907, 242213e-9, 0, 0.461125, 0.632561, 237397e-9, 0, 0.492187, 0.610658, 229313e-9, 0, 0.52381, 0.589322, 224402e-9, 0, 0.555556, 0.567857, 216116e-9, 0, 0.587302, 0.54652, 209124e-9, 0, 0.619048, 0.525433, 201601e-9, 0, 0.650794, 0.504679, 192957e-9, 0, 0.68254, 0.484203, 186052e-9, 0, 0.714286, 0.464203, 177672e-9, 0, 0.746032, 0.444549, 170005e-9, 0, 0.777778, 0.425346, 162401e-9, 0, 0.809524, 0.406706, 1544e-7, 0, 0.84127, 0.388576, 147437e-9, 0, 0.873016, 0.37094, 139493e-9, 0, 0.904762, 0.353996, 133219e-9, 0, 0.936508, 0.337391, 125573e-9, 0, 0.968254, 0.321648, 119867e-9, 0, 1, 1, 362511e-11, 0, 0, 1, 362525e-11, 0, 0, 1, 362739e-11, 0, 0, 0.999999, 363673e-11, 0, 0, 0.999998, 366214e-11, 0, 0, 0.999996, 371698e-11, 0, 0, 0.999992, 382116e-11, 0, 0, 0.999986, 400554e-11, 0, 0, 0.999976, 432058e-11, 0, 0, 0.999961, 485194e-11, 0, 0, 0.999938, 574808e-11, 0, 0, 0.999908, 726643e-11, 0, 0, 0.999865, 984707e-11, 0, 0, 0.999807, 142217e-10, 0, 0, 0.999723, 215581e-10, 0, 0, 0.999602, 336114e-10, 0, 119113e-10, 0.999398, 527353e-10, 0, 355813e-9, 0.998946, 805809e-10, 0, 137768e-8, 0.996647, 942908e-10, 0, 322469e-8, 0.992298, 668733e-10, 0, 597897e-8, 0.989802, 716564e-10, 0, 968903e-8, 0.987019, 821355e-10, 0, 0.0143845, 0.984219, 104555e-9, 0, 0.0200831, 0.980425, 131245e-9, 0, 0.0267948, 0.974241, 139613e-9, 0, 0.034525, 0.967006, 145931e-9, 0, 0.0432757, 0.95893, 167153e-9, 0, 0.0530471, 0.949157, 188146e-9, 0, 0.0638386, 0.94062, 194625e-9, 0, 0.0756487, 0.933509, 213721e-9, 0, 0.0884762, 0.925088, 229616e-9, 0, 0.10232, 0.915178, 239638e-9, 0, 0.117178, 0.904093, 254814e-9, 0, 0.133051, 0.891337, 263685e-9, 0, 0.149939, 0.877326, 274789e-9, 0, 0.167841, 0.861794, 280534e-9, 0, 0.18676, 0.845758, 289534e-9, 0, 0.206696, 0.829792, 294446e-9, 0, 0.22765, 0.813037, 296877e-9, 0, 0.249625, 0.795285, 300217e-9, 0, 0.27262, 0.776323, 299826e-9, 0, 0.296636, 0.756673, 299787e-9, 0, 0.321671, 0.736856, 297867e-9, 0, 0.347718, 0.716883, 294052e-9, 0, 0.374768, 0.696089, 289462e-9, 0, 0.402804, 0.67505, 285212e-9, 0, 0.431796, 0.653509, 27653e-8, 0, 0.461695, 0.63258, 271759e-9, 0, 0.49242, 0.61104, 262811e-9, 0, 0.523822, 0.589567, 255151e-9, 0, 0.555556, 0.568322, 246434e-9, 0, 0.587302, 0.547235, 237061e-9, 0, 0.619048, 0.52616, 228343e-9, 0, 0.650794, 0.505716, 219236e-9, 0, 0.68254, 0.485274, 209595e-9, 0, 0.714286, 0.465411, 201011e-9, 0, 0.746032, 0.445854, 19109e-8, 0, 0.777778, 0.426911, 182897e-9, 0, 0.809524, 0.408222, 173569e-9, 0, 0.84127, 0.390307, 165496e-9, 0, 0.873016, 0.372624, 156799e-9, 0, 0.904762, 0.355804, 14917e-8, 0, 0.936508, 0.33924, 140907e-9, 0, 0.968254, 0.323534, 134062e-9, 0, 1, 1, 622487e-11, 0, 0, 1, 62251e-10, 0, 0, 1, 622837e-11, 0, 0, 0.999999, 624259e-11, 0, 0, 0.999998, 628127e-11, 0, 0, 0.999996, 636451e-11, 0, 0, 0.999991, 65218e-10, 0, 0, 0.999984, 679782e-11, 0, 0, 0.999973, 726361e-11, 0, 0, 0.999955, 803644e-11, 0, 0, 0.999931, 931397e-11, 0, 0, 0.999896, 114299e-10, 0, 0, 0.999847, 149402e-10, 0, 0, 0.999784, 207461e-10, 0, 0, 0.999692, 302493e-10, 0, 0, 0.999554, 454957e-10, 0, 997275e-10, 0.999326, 690762e-10, 0, 724813e-9, 0.998757, 101605e-9, 0, 20972e-7, 0.995367, 958745e-10, 0, 432324e-8, 0.99209, 832808e-10, 0, 746347e-8, 0.989517, 887601e-10, 0, 0.0115534, 0.987008, 10564e-8, 0, 0.0166134, 0.98421, 133179e-9, 0, 0.0226552, 0.98021, 161746e-9, 0, 0.0296838, 0.973676, 161821e-9, 0, 0.0377016, 0.967052, 178635e-9, 0, 0.0467079, 0.959385, 206765e-9, 0, 0.0567013, 0.949461, 22476e-8, 0, 0.0676796, 0.939578, 23574e-8, 0, 0.0796403, 0.932416, 25893e-8, 0, 0.0925812, 0.923759, 271228e-9, 0, 0.106501, 0.914223, 289165e-9, 0, 0.121397, 0.902942, 301156e-9, 0, 0.13727, 0.890419, 313852e-9, 0, 0.15412, 0.876639, 324408e-9, 0, 0.171946, 0.861316, 33249e-8, 0, 0.190751, 0.84496, 338497e-9, 0, 0.210537, 0.828427, 345861e-9, 0, 0.231305, 0.811871, 347863e-9, 0, 0.253057, 0.794397, 350225e-9, 0, 0.275797, 0.775726, 349915e-9, 0, 0.299525, 0.75617, 347297e-9, 0, 0.324242, 0.736091, 344232e-9, 0, 0.349947, 0.716213, 340835e-9, 0, 0.376633, 0.695736, 332369e-9, 0, 0.404289, 0.674961, 327943e-9, 0, 0.432895, 0.653518, 318533e-9, 0, 0.462415, 0.632574, 310391e-9, 0, 0.492788, 0.61134, 300755e-9, 0, 0.523909, 0.590017, 290506e-9, 0, 0.555556, 0.568752, 280446e-9, 0, 0.587302, 0.548061, 269902e-9, 0, 0.619048, 0.52711, 258815e-9, 0, 0.650794, 0.506682, 248481e-9, 0, 0.68254, 0.486524, 237141e-9, 0, 0.714286, 0.466812, 226872e-9, 0, 0.746032, 0.44732, 216037e-9, 0, 0.777778, 0.428473, 205629e-9, 0, 0.809524, 0.409921, 195691e-9, 0, 0.84127, 0.392028, 185457e-9, 0, 0.873016, 0.374606, 176436e-9, 0, 0.904762, 0.357601, 166508e-9, 0, 0.936508, 0.341348, 158385e-9, 0, 0.968254, 0.32542, 149203e-9, 0, 1, 1, 103967e-10, 0, 0, 1, 10397e-9, 0, 0, 1, 104019e-10, 0, 0, 0.999999, 104231e-10, 0, 0, 0.999998, 104806e-10, 0, 0, 0.999995, 106042e-10, 0, 0, 0.999991, 108366e-10, 0, 0, 0.999982, 112415e-10, 0, 0, 0.999968, 119174e-10, 0, 0, 0.99995, 130227e-10, 0, 0, 0.999922, 148176e-10, 0, 0, 0.999884, 177303e-10, 0, 0, 0.99983, 224564e-10, 0, 0, 0.999758, 300966e-10, 0, 0, 0.999654, 423193e-10, 0, 549083e-11, 0.999503, 614848e-10, 0, 296087e-9, 0.999237, 903576e-10, 0, 123144e-8, 0.998491, 1271e-7, 0, 295954e-8, 0.994594, 107754e-9, 0, 555829e-8, 0.99178, 103025e-9, 0, 907209e-8, 0.989265, 11154e-8, 0, 0.0135257, 0.986998, 136296e-9, 0, 0.0189327, 0.984137, 169154e-9, 0, 0.0252993, 0.979798, 196671e-9, 0, 0.0326272, 0.97337, 196678e-9, 0, 0.0409157, 0.967239, 223121e-9, 0, 0.0501623, 0.959543, 253809e-9, 0, 0.0603638, 0.949466, 265972e-9, 0, 0.0715171, 0.939074, 288372e-9, 0, 0.0836187, 0.931118, 310983e-9, 0, 0.0966657, 0.922525, 325561e-9, 0, 0.110656, 0.912983, 345725e-9, 0, 0.125588, 0.901617, 3556e-7, 0, 0.141461, 0.889487, 374012e-9, 0, 0.158275, 0.875787, 383445e-9, 0, 0.176031, 0.860654, 393972e-9, 0, 0.19473, 0.844417, 400311e-9, 0, 0.214374, 0.82741, 405004e-9, 0, 0.234967, 0.810545, 407378e-9, 0, 0.256512, 0.793312, 407351e-9, 0, 0.279011, 0.774847, 406563e-9, 0, 0.302468, 0.755621, 404903e-9, 0, 0.326887, 0.735511, 397486e-9, 0, 0.352266, 0.715435, 39357e-8, 0, 0.378605, 0.695403, 384739e-9, 0, 0.405897, 0.674681, 376108e-9, 0, 0.43413, 0.65359, 365997e-9, 0, 0.463277, 0.632471, 354957e-9, 0, 0.493295, 0.61151, 343593e-9, 0, 0.524106, 0.59064, 331841e-9, 0, 0.555561, 0.569386, 318891e-9, 0, 0.587302, 0.548785, 3072e-7, 0, 0.619048, 0.528146, 29361e-8, 0, 0.650794, 0.507872, 281709e-9, 0, 0.68254, 0.487805, 268627e-9, 0, 0.714286, 0.468196, 255887e-9, 0, 0.746032, 0.448922, 243997e-9, 0, 0.777778, 0.430093, 231662e-9, 0, 0.809524, 0.411845, 220339e-9, 0, 0.84127, 0.393808, 208694e-9, 0, 0.873016, 0.376615, 198045e-9, 0, 0.904762, 0.359655, 187375e-9, 0, 0.936508, 0.343452, 177371e-9, 0, 0.968254, 0.32765, 167525e-9, 0, 1, 1, 169351e-10, 0, 0, 1, 169356e-10, 0, 0, 1, 169427e-10, 0, 0, 0.999999, 169736e-10, 0, 0, 0.999998, 170575e-10, 0, 0, 0.999995, 172372e-10, 0, 0, 0.99999, 175739e-10, 0, 0, 0.999979, 181568e-10, 0, 0, 0.999966, 191206e-10, 0, 0, 0.999944, 20677e-9, 0, 0, 0.999912, 231644e-10, 0, 0, 0.999869, 271268e-10, 0, 0, 0.999811, 334272e-10, 0, 0, 0.99973, 433979e-10, 0, 0, 0.999617, 590083e-10, 0, 680315e-10, 0.999445, 829497e-10, 0, 612796e-9, 0.999138, 118019e-9, 0, 187408e-8, 0.998095, 156712e-9, 0, 395791e-8, 0.993919, 125054e-9, 0, 692144e-8, 0.991333, 126091e-9, 0, 0.0107962, 0.989226, 144912e-9, 0, 0.0155986, 0.986954, 175737e-9, 0, 0.0213364, 0.983982, 213883e-9, 0, 0.0280114, 0.979128, 234526e-9, 0, 0.0356226, 0.973327, 243725e-9, 0, 0.0441668, 0.967416, 2773e-7, 0, 0.0536399, 0.959729, 308799e-9, 0, 0.0640376, 0.949758, 322447e-9, 0, 0.0753554, 0.939173, 350021e-9, 0, 0.0875893, 0.9296, 370089e-9, 0, 0.100736, 0.921181, 391365e-9, 0, 0.114793, 0.91164, 413636e-9, 0, 0.129759, 0.900435, 427068e-9, 0, 0.145632, 0.888183, 441046e-9, 0, 0.162412, 0.874772, 454968e-9, 0, 0.180101, 0.859566, 461882e-9, 0, 0.1987, 0.843579, 471556e-9, 0, 0.218213, 0.826453, 474335e-9, 0, 0.238641, 0.809164, 477078e-9, 0, 0.259989, 0.792179, 47755e-8, 0, 0.282262, 0.773866, 472573e-9, 0, 0.305464, 0.754944, 469765e-9, 0, 0.329599, 0.735133, 462371e-9, 0, 0.35467, 0.714858, 453674e-9, 0, 0.380678, 0.694829, 443888e-9, 0, 0.407622, 0.674453, 432052e-9, 0, 0.435493, 0.653685, 420315e-9, 0, 0.464275, 0.632666, 406829e-9, 0, 0.493938, 0.611676, 392234e-9, 0, 0.524422, 0.591193, 379208e-9, 0, 0.555624, 0.570145, 36319e-8, 0, 0.587302, 0.549566, 349111e-9, 0, 0.619048, 0.529278, 334166e-9, 0, 0.650794, 0.509026, 318456e-9, 0, 0.68254, 0.489186, 30449e-8, 0, 0.714286, 0.469662, 289051e-9, 0, 0.746032, 0.450691, 275494e-9, 0, 0.777778, 0.431841, 261437e-9, 0, 0.809524, 0.413752, 247846e-9, 0, 0.84127, 0.395951, 235085e-9, 0, 0.873016, 0.378633, 222245e-9, 0, 0.904762, 0.36194, 210533e-9, 0, 0.936508, 0.345599, 198494e-9, 0, 0.968254, 0.329999, 188133e-9, 0, 1, 1, 269663e-10, 0, 0, 1, 26967e-9, 0, 0, 1, 269772e-10, 0, 0, 0.999999, 270214e-10, 0, 0, 0.999998, 271415e-10, 0, 0, 0.999994, 27398e-9, 0, 0, 0.999988, 278771e-10, 0, 0, 0.999977, 287019e-10, 0, 0, 0.999961, 300544e-10, 0, 0, 0.999937, 322138e-10, 0, 0, 0.999904, 356163e-10, 0, 0, 0.999854, 409465e-10, 0, 0, 0.99979, 492651e-10, 0, 0, 0.999699, 621722e-10, 0, 88288e-11, 0.999572, 819715e-10, 0, 223369e-9, 0.999381, 111689e-9, 0, 105414e-8, 0.999016, 153862e-9, 0, 26493e-7, 0.997437, 187667e-9, 0, 508608e-8, 0.993545, 155672e-9, 0, 840554e-8, 0.991135, 161455e-9, 0, 0.012629, 0.989157, 188241e-9, 0, 0.0177661, 0.986874, 226229e-9, 0, 0.0238198, 0.983714, 268668e-9, 0, 0.0307887, 0.978301, 277109e-9, 0, 0.0386688, 0.973227, 303446e-9, 0, 0.0474554, 0.967317, 341851e-9, 0, 0.0571428, 0.959477, 370885e-9, 0, 0.0677256, 0.950012, 392753e-9, 0, 0.0791988, 0.939484, 42781e-8, 0, 0.0915576, 0.928135, 443866e-9, 0, 0.104798, 0.919819, 472959e-9, 0, 0.118918, 0.910049, 491551e-9, 0, 0.133915, 0.899181, 512616e-9, 0, 0.149788, 0.886881, 523563e-9, 0, 0.166537, 0.87359, 540183e-9, 0, 0.184164, 0.858613, 547386e-9, 0, 0.202669, 0.842809, 554809e-9, 0, 0.222056, 0.825727, 558316e-9, 0, 0.242329, 0.808086, 557824e-9, 0, 0.263492, 0.790728, 556346e-9, 0, 0.285551, 0.772987, 552672e-9, 0, 0.30851, 0.7541, 543738e-9, 0, 0.332376, 0.734669, 536107e-9, 0, 0.357153, 0.714411, 523342e-9, 0, 0.382845, 0.694196, 512238e-9, 0, 0.409454, 0.674252, 497465e-9, 0, 0.436977, 0.65357, 481096e-9, 0, 0.465404, 0.632999, 467054e-9, 0, 0.494713, 0.611994, 448771e-9, 0, 0.524864, 0.591604, 431889e-9, 0, 0.555779, 0.571134, 415238e-9, 0, 0.587302, 0.550528, 396369e-9, 0, 0.619048, 0.530292, 379477e-9, 0, 0.650794, 0.510364, 361488e-9, 0, 0.68254, 0.490749, 343787e-9, 0, 0.714286, 0.471266, 327822e-9, 0, 0.746032, 0.452462, 310626e-9, 0, 0.777778, 0.433907, 295352e-9, 0, 0.809524, 0.415659, 279179e-9, 0, 0.84127, 0.398138, 264685e-9, 0, 0.873016, 0.380833, 249905e-9, 0, 0.904762, 0.364247, 236282e-9, 0, 0.936508, 0.348041, 222905e-9, 0, 0.968254, 0.332389, 210522e-9, 0, 1, 1, 420604e-10, 0, 0, 1, 420614e-10, 0, 0, 1, 420757e-10, 0, 0, 0.999999, 42138e-9, 0, 0, 0.999997, 423067e-10, 0, 0, 0.999993, 426668e-10, 0, 0, 0.999986, 433372e-10, 0, 0, 0.999974, 444857e-10, 0, 0, 0.999956, 463554e-10, 0, 0, 0.99993, 493105e-10, 0, 0, 0.999892, 539077e-10, 0, 0, 0.999838, 610005e-10, 0, 0, 0.999767, 718822e-10, 0, 0, 0.999666, 884581e-10, 0, 365471e-10, 0.999525, 113398e-9, 0, 485623e-9, 0.999311, 150043e-9, 0, 162096e-8, 0.998865, 200063e-9, 0, 355319e-8, 0.996278, 211014e-9, 0, 633818e-8, 0.992956, 189672e-9, 0, 0.0100043, 0.991017, 210262e-9, 0, 0.0145648, 0.989055, 244292e-9, 0, 0.0200237, 0.986741, 290481e-9, 0, 0.0263798, 0.983288, 334303e-9, 0, 0.033629, 0.977784, 340307e-9, 0, 0.0417652, 0.973037, 377864e-9, 0, 0.0507821, 0.967181, 4239e-7, 0, 0.060673, 0.958971, 443854e-9, 0, 0.0714314, 0.950093, 483039e-9, 0, 0.0830518, 0.939552, 517934e-9, 0, 0.0955288, 0.927678, 539449e-9, 0, 0.108859, 0.918278, 568604e-9, 0, 0.123038, 0.908449, 588505e-9, 0, 0.138065, 0.897713, 612473e-9, 0, 0.153938, 0.885533, 625575e-9, 0, 0.170657, 0.872131, 63854e-8, 0, 0.188224, 0.857517, 647034e-9, 0, 0.20664, 0.841796, 65209e-8, 0, 0.225909, 0.824726, 6544e-7, 0, 0.246035, 0.807297, 655744e-9, 0, 0.267022, 0.789058, 646716e-9, 0, 0.288878, 0.77189, 643898e-9, 0, 0.311607, 0.753082, 629973e-9, 0, 0.335216, 0.7341, 621564e-9, 0, 0.359713, 0.714094, 605171e-9, 0, 0.385103, 0.693839, 588752e-9, 0, 0.41139, 0.673891, 573294e-9, 0, 0.438576, 0.653565, 552682e-9, 0, 0.466656, 0.633326, 533446e-9, 0, 0.495617, 0.612582, 514635e-9, 0, 0.525431, 0.59205, 49303e-8, 0, 0.556041, 0.571918, 471842e-9, 0, 0.587338, 0.551572, 451713e-9, 0, 0.619048, 0.531553, 430049e-9, 0, 0.650794, 0.51175, 410445e-9, 0, 0.68254, 0.49238, 390098e-9, 0, 0.714286, 0.473143, 370033e-9, 0, 0.746032, 0.45423, 351205e-9, 0, 0.777778, 0.435963, 332049e-9, 0, 0.809524, 0.41787, 315021e-9, 0, 0.84127, 0.400387, 297315e-9, 0, 0.873016, 0.383332, 281385e-9, 0, 0.904762, 0.366665, 265397e-9, 0, 0.936508, 0.350633, 250601e-9, 0, 0.968254, 0.334964, 23589e-8, 0, 1, 1, 643736e-10, 0, 0, 1, 64375e-9, 0, 0, 1, 643947e-10, 0, 0, 0.999999, 64481e-9, 0, 0, 0.999997, 647143e-10, 0, 0, 0.999994, 652119e-10, 0, 0, 0.999985, 661359e-10, 0, 0, 0.999972, 677116e-10, 0, 0, 0.999952, 702599e-10, 0, 0, 0.999922, 742517e-10, 0, 0, 0.99988, 803906e-10, 0, 0, 0.99982, 897315e-10, 0, 0, 0.999741, 103838e-9, 0, 0, 0.999629, 12496e-8, 0, 149024e-9, 0.999474, 156161e-9, 0, 861027e-9, 0.999229, 201034e-9, 0, 231198e-8, 0.998662, 259069e-9, 0, 458147e-8, 0.995299, 245439e-9, 0, 770895e-8, 0.992732, 24498e-8, 0, 0.0117126, 0.990847, 273211e-9, 0, 0.0165989, 0.988911, 316492e-9, 0, 0.0223674, 0.98654, 37161e-8, 0, 0.0290135, 0.982636, 410352e-9, 0, 0.0365309, 0.977346, 421756e-9, 0, 0.0449117, 0.972909, 475578e-9, 0, 0.0541481, 0.966821, 522482e-9, 0, 0.0642326, 0.958686, 545008e-9, 0, 0.075158, 0.949754, 589286e-9, 0, 0.0869181, 0.939184, 619995e-9, 0, 0.0995074, 0.927505, 654266e-9, 0, 0.112922, 0.916606, 682362e-9, 0, 0.127157, 0.906707, 704286e-9, 0, 0.142212, 0.895937, 725909e-9, 0, 0.158085, 0.883913, 743939e-9, 0, 0.174776, 0.870642, 755157e-9, 0, 0.192287, 0.856241, 764387e-9, 0, 0.210619, 0.84069, 771032e-9, 0, 0.229775, 0.823728, 765906e-9, 0, 0.249761, 0.806481, 767604e-9, 0, 0.270582, 0.787924, 754385e-9, 0, 0.292243, 0.770588, 749668e-9, 0, 0.314753, 0.751991, 731613e-9, 0, 0.338118, 0.733407, 717655e-9, 0, 0.362347, 0.713688, 700604e-9, 0, 0.387447, 0.693595, 678765e-9, 0, 0.413424, 0.673426, 657042e-9, 0, 0.440284, 0.65359, 635892e-9, 0, 0.468027, 0.633576, 611569e-9, 0, 0.496645, 0.613144, 586011e-9, 0, 0.526122, 0.592711, 563111e-9, 0, 0.556417, 0.572722, 537699e-9, 0, 0.587451, 0.552762, 512556e-9, 0, 0.619048, 0.532985, 489757e-9, 0, 0.650794, 0.513219, 464139e-9, 0, 0.68254, 0.493992, 442193e-9, 0, 0.714286, 0.47509, 418629e-9, 0, 0.746032, 0.456287, 397045e-9, 0, 0.777778, 0.438152, 375504e-9, 0, 0.809524, 0.420294, 35492e-8, 0, 0.84127, 0.402749, 335327e-9, 0, 0.873016, 0.385879, 316422e-9, 0, 0.904762, 0.369352, 298333e-9, 0, 0.936508, 0.353301, 281417e-9, 0, 0.968254, 0.337781, 265203e-9, 0, 1, 1, 968267e-10, 0, 0, 1, 968284e-10, 0, 0, 1, 968556e-10, 0, 0, 0.999999, 969733e-10, 0, 0, 0.999997, 972913e-10, 0, 0, 0.999993, 979688e-10, 0, 0, 0.999984, 992239e-10, 0, 0, 0.999969, 101356e-9, 0, 0, 0.999946, 104784e-9, 0, 0, 0.999913, 110111e-9, 0, 0, 0.999868, 118217e-9, 0, 0, 0.999801, 130396e-9, 0, 0, 0.999712, 148523e-9, 0, 124907e-10, 0.999589, 175233e-9, 0, 355405e-9, 0.999416, 213999e-9, 0, 13528e-7, 0.999136, 268529e-9, 0, 312557e-8, 0.998367, 333088e-9, 0, 573045e-8, 0.994701, 304757e-9, 0, 919397e-8, 0.992497, 318031e-9, 0, 0.0135261, 0.990608, 353863e-9, 0, 0.0187278, 0.988715, 409044e-9, 0, 0.0247947, 0.986241, 472967e-9, 0, 0.0317196, 0.981696, 495104e-9, 0, 0.039494, 0.977097, 532873e-9, 0, 0.0481087, 0.972583, 594447e-9, 0, 0.0575549, 0.966142, 636867e-9, 0, 0.0678242, 0.95823, 669899e-9, 0, 0.0789089, 0.949677, 719499e-9, 0, 0.0908023, 0.939226, 750584e-9, 0, 0.103499, 0.927501, 793183e-9, 0, 0.116993, 0.915199, 81995e-8, 0, 0.131282, 0.90498, 847654e-9, 0, 0.146364, 0.894243, 868929e-9, 0, 0.162237, 0.882154, 884278e-9, 0, 0.178902, 0.869161, 898108e-9, 0, 0.196358, 0.854751, 901254e-9, 0, 0.21461, 0.839368, 90679e-8, 0, 0.23366, 0.822874, 901541e-9, 0, 0.253512, 0.805514, 897297e-9, 0, 0.274174, 0.78716, 881856e-9, 0, 0.29565, 0.769061, 870032e-9, 0, 0.31795, 0.751, 851719e-9, 0, 0.341081, 0.732614, 830671e-9, 0, 0.365053, 0.713171, 806569e-9, 0, 0.389874, 0.693472, 78338e-8, 0, 0.415553, 0.673528, 756404e-9, 0, 0.442098, 0.653397, 726872e-9, 0, 0.469512, 0.633781, 700494e-9, 0, 0.497794, 0.613877, 67105e-8, 0, 0.526935, 0.593506, 640361e-9, 0, 0.556908, 0.573667, 613502e-9, 0, 0.587657, 0.553932, 583177e-9, 0, 0.61906, 0.534345, 554375e-9, 0, 0.650794, 0.515042, 527811e-9, 0, 0.68254, 0.495674, 499367e-9, 0, 0.714286, 0.477132, 47429e-8, 0, 0.746032, 0.458609, 447726e-9, 0, 0.777778, 0.440354, 424205e-9, 0, 0.809524, 0.422765, 399549e-9, 0, 0.84127, 0.405472, 378315e-9, 0, 0.873016, 0.388482, 355327e-9, 0, 0.904762, 0.372191, 336122e-9, 0, 0.936508, 0.356099, 315247e-9, 0, 0.968254, 0.340737, 29794e-8, 0, 1, 1, 143327e-9, 0, 0, 1, 14333e-8, 0, 0, 1, 143366e-9, 0, 0, 0.999999, 143524e-9, 0, 0, 0.999996, 143952e-9, 0, 0, 0.999991, 144862e-9, 0, 0, 0.999981, 146544e-9, 0, 0, 0.999966, 149391e-9, 0, 0, 0.999941, 153946e-9, 0, 0, 0.999905, 160971e-9, 0, 0, 0.999852, 171562e-9, 0, 0, 0.99978, 18729e-8, 0, 0, 0.999681, 210386e-9, 0, 826239e-10, 0.999546, 243906e-9, 0, 664807e-9, 0.999352, 291739e-9, 0, 196192e-8, 0.999027, 357419e-9, 0, 405941e-8, 0.997886, 422349e-9, 0, 699664e-8, 0.99419, 385008e-9, 0, 0.0107896, 0.99214, 409775e-9, 0, 0.0154415, 0.990274, 456418e-9, 0, 0.0209488, 0.988455, 527008e-9, 0, 0.0273037, 0.985804, 597685e-9, 0, 0.0344969, 0.98103, 613124e-9, 0, 0.0425183, 0.976674, 668321e-9, 0, 0.0513575, 0.972021, 736985e-9, 0, 0.0610046, 0.965274, 773789e-9, 0, 0.0714508, 0.958046, 830852e-9, 0, 0.0826877, 0.949333, 875766e-9, 0, 0.0947085, 0.939135, 917088e-9, 0, 0.107507, 0.927119, 952244e-9, 0, 0.121078, 0.91469, 990626e-9, 0, 0.135419, 0.903006, 101304e-8, 0, 0.150526, 0.892368, 103834e-8, 0, 0.166399, 0.880231, 105002e-8, 0, 0.183038, 0.867432, 106331e-8, 0, 0.200443, 0.853208, 106783e-8, 0, 0.218618, 0.837956, 106458e-8, 0, 0.237566, 0.821772, 105945e-8, 0, 0.257291, 0.804328, 104685e-8, 0, 0.2778, 0.786465, 103178e-8, 0, 0.2991, 0.768004, 101077e-8, 0, 0.321199, 0.74972, 985504e-9, 0, 0.344106, 0.731682, 962893e-9, 0, 0.36783, 0.712813, 932146e-9, 0, 0.392383, 0.693139, 89871e-8, 0, 0.417774, 0.673566, 869678e-9, 0, 0.444013, 0.653483, 835525e-9, 0, 0.471107, 0.633891, 799853e-9, 0, 0.49906, 0.614433, 766838e-9, 0, 0.527869, 0.594586, 732227e-9, 0, 0.557517, 0.574769, 696442e-9, 0, 0.587966, 0.555149, 663935e-9, 0, 0.61913, 0.535898, 629826e-9, 0, 0.650794, 0.516753, 596486e-9, 0, 0.68254, 0.497816, 567078e-9, 0, 0.714286, 0.479034, 534399e-9, 0, 0.746032, 0.460975, 507013e-9, 0, 0.777778, 0.442935, 477421e-9, 0, 0.809524, 0.425263, 451101e-9, 0, 0.84127, 0.408248, 424964e-9, 0, 0.873016, 0.391339, 39993e-8, 0, 0.904762, 0.37513, 377619e-9, 0, 0.936508, 0.359172, 354418e-9, 0, 0.968254, 0.343876, 334823e-9, 0, 1, 1, 209042e-9, 0, 0, 1, 209045e-9, 0, 0, 1, 209093e-9, 0, 0, 0.999999, 209304e-9, 0, 0, 0.999996, 209871e-9, 0, 0, 0.999991, 211078e-9, 0, 0, 0.999979, 213304e-9, 0, 0, 0.999963, 217061e-9, 0, 0, 0.999933, 223042e-9, 0, 0, 0.999894, 232206e-9, 0, 0, 0.999837, 245901e-9, 0, 0, 0.999756, 266023e-9, 0, 102927e-11, 0.999648, 295204e-9, 0, 233468e-9, 0.999499, 336958e-9, 0, 108237e-8, 0.999283, 395563e-9, 0, 268832e-8, 0.998896, 473785e-9, 0, 511138e-8, 0.997006, 520008e-9, 0, 837705e-8, 0.993819, 497261e-9, 0, 0.0124928, 0.991632, 523722e-9, 0, 0.0174561, 0.989875, 587258e-9, 0, 0.0232596, 0.988109, 676329e-9, 0, 0.0298932, 0.985155, 747701e-9, 0, 0.0373453, 0.980479, 768803e-9, 0, 0.0456045, 0.976271, 841054e-9, 0, 0.0546593, 0.971347, 911469e-9, 0, 0.0644994, 0.964528, 953057e-9, 0, 0.0751152, 0.957632, 102221e-8, 0, 0.0864981, 0.948681, 106122e-8, 0, 0.0986407, 0.938716, 111857e-8, 0, 0.111537, 0.926629, 114762e-8, 0, 0.125182, 0.914025, 118995e-8, 0, 0.139571, 0.901026, 121228e-8, 0, 0.154703, 0.890358, 123946e-8, 0, 0.170576, 0.878283, 12527e-7, 0, 0.18719, 0.865459, 125536e-8, 0, 0.204547, 0.851407, 126134e-8, 0, 0.222648, 0.836276, 124759e-8, 0, 0.241498, 0.820436, 124443e-8, 0, 0.261101, 0.803253, 122071e-8, 0, 0.281465, 0.785562, 120107e-8, 0, 0.302595, 0.76718, 117762e-8, 0, 0.324501, 0.748551, 114289e-8, 0, 0.347192, 0.730564, 110872e-8, 0, 0.370679, 0.712253, 107636e-8, 0, 0.394973, 0.692867, 103646e-8, 0, 0.420085, 0.673695, 996793e-9, 0, 0.446027, 0.653912, 95675e-8, 0, 0.47281, 0.634129, 916739e-9, 0, 0.500441, 0.615004, 874401e-9, 0, 0.528921, 0.595587, 833411e-9, 0, 0.558244, 0.575965, 794556e-9, 0, 0.588384, 0.5566, 75196e-8, 0, 0.619281, 0.537428, 716381e-9, 0, 0.650795, 0.518623, 676558e-9, 0, 0.68254, 0.499964, 64074e-8, 0, 0.714286, 0.481356, 605984e-9, 0, 0.746032, 0.463279, 570256e-9, 0, 0.777778, 0.445673, 540138e-9, 0, 0.809524, 0.428032, 507299e-9, 0, 0.84127, 0.411112, 479553e-9, 0, 0.873016, 0.394444, 450737e-9, 0, 0.904762, 0.378247, 424269e-9, 0, 0.936508, 0.362415, 399111e-9, 0, 0.968254, 0.347103, 375274e-9, 0, 1, 1, 300729e-9, 0, 0, 1, 300733e-9, 0, 0, 1, 300797e-9, 0, 0, 0.999998, 301072e-9, 0, 0, 0.999996, 301817e-9, 0, 0, 0.999989, 303398e-9, 0, 0, 0.999977, 306309e-9, 0, 0, 0.999958, 311209e-9, 0, 0, 0.999927, 318975e-9, 0, 0, 0.999884, 330804e-9, 0, 0, 0.99982, 34834e-8, 0, 0, 0.999733, 373854e-9, 0, 326995e-10, 0.999613, 410424e-9, 0, 477174e-9, 0.999447, 462047e-9, 0, 161099e-8, 0.999204, 533322e-9, 0, 353153e-8, 0.998725, 624964e-9, 0, 627965e-8, 0.995871, 631786e-9, 0, 98693e-7, 0.993194, 632017e-9, 0, 0.0143011, 0.991541, 68923e-8, 0, 0.019568, 0.989773, 766892e-9, 0, 0.0256593, 0.987647, 863668e-9, 0, 0.0325625, 0.984193, 922089e-9, 0, 0.0402647, 0.980016, 970749e-9, 0, 0.0487532, 0.975859, 106027e-8, 0, 0.058016, 0.970514, 112239e-8, 0, 0.0680419, 0.963625, 117212e-8, 0, 0.0788208, 0.956959, 125211e-8, 0, 0.0903439, 0.947956, 129411e-8, 0, 0.102604, 0.93809, 135879e-8, 0, 0.115594, 0.92659, 139309e-8, 0, 0.129309, 0.913829, 143253e-8, 0, 0.143745, 0.90005, 145809e-8, 0, 0.158901, 0.888129, 14748e-7, 0, 0.174774, 0.87607, 148756e-8, 0, 0.191365, 0.863461, 148714e-8, 0, 0.208674, 0.849594, 148892e-8, 0, 0.226705, 0.834531, 146496e-8, 0, 0.245461, 0.81903, 14579e-7, 0, 0.264947, 0.802122, 143039e-8, 0, 0.28517, 0.78445, 139717e-8, 0, 0.306137, 0.766434, 136312e-8, 0, 0.327857, 0.747816, 132597e-8, 0, 0.350341, 0.729519, 128323e-8, 0, 0.373598, 0.711454, 123803e-8, 0, 0.397642, 0.692699, 119097e-8, 0, 0.422485, 0.673723, 114565e-8, 0, 0.448139, 0.654386, 109552e-8, 0, 0.474619, 0.634673, 104553e-8, 0, 0.501933, 0.615554, 99985e-8, 0, 0.530089, 0.596462, 948207e-9, 0, 0.559087, 0.577385, 902299e-9, 0, 0.588913, 0.558257, 856448e-9, 0, 0.619525, 0.5392, 810395e-9, 0, 0.650826, 0.520543, 768558e-9, 0, 0.68254, 0.502206, 7239e-7, 0, 0.714286, 0.48402, 685794e-9, 0, 0.746032, 0.465779, 64471e-8, 0, 0.777778, 0.448455, 609583e-9, 0, 0.809524, 0.431091, 57227e-8, 0, 0.84127, 0.414147, 54042e-8, 0, 0.873016, 0.39765, 506545e-9, 0, 0.904762, 0.381576, 477635e-9, 0, 0.936508, 0.365881, 448446e-9, 0, 0.968254, 0.350582, 421424e-9, 0, 1, 1, 427144e-9, 0, 0, 1, 427151e-9, 0, 0, 1, 427232e-9, 0, 0, 0.999998, 42759e-8, 0, 0, 0.999995, 428555e-9, 0, 0, 0.999988, 430603e-9, 0, 0, 0.999976, 434368e-9, 0, 0, 0.999952, 440688e-9, 0, 0, 0.999919, 450667e-9, 0, 0, 0.999871, 46578e-8, 0, 0, 0.999801, 488024e-9, 0, 0, 0.999704, 520092e-9, 0, 129791e-9, 0.999572, 565553e-9, 0, 821056e-9, 0.999389, 628906e-9, 0, 225241e-8, 0.999114, 714911e-9, 0, 449109e-8, 0.998488, 819218e-9, 0, 756249e-8, 0.995234, 80415e-8, 0, 0.0114716, 0.993021, 830181e-9, 0, 0.0162131, 0.991407, 902645e-9, 0, 0.021776, 0.989625, 996934e-9, 0, 0.0281471, 0.987064, 109707e-8, 0, 0.0353118, 0.983265, 114353e-8, 0, 0.0432562, 0.979535, 12272e-7, 0, 0.0519665, 0.975224, 132642e-8, 0, 0.0614298, 0.969574, 138092e-8, 0, 0.0716348, 0.963021, 145896e-8, 0, 0.0825709, 0.956046, 152834e-8, 0, 0.094229, 0.947136, 158217e-8, 0, 0.106602, 0.937313, 16347e-7, 0, 0.119682, 0.926073, 168383e-8, 0, 0.133465, 0.913121, 171627e-8, 0, 0.147947, 0.899165, 174229e-8, 0, 0.163125, 0.885891, 176137e-8, 0, 0.178998, 0.873783, 176406e-8, 0, 0.195566, 0.861331, 176156e-8, 0, 0.21283, 0.847569, 175346e-8, 0, 0.230793, 0.832785, 172753e-8, 0, 0.249459, 0.817442, 170204e-8, 0, 0.268832, 0.800613, 166576e-8, 0, 0.28892, 0.783597, 162909e-8, 0, 0.30973, 0.76571, 15826e-7, 0, 0.331271, 0.747021, 153106e-8, 0, 0.353554, 0.728593, 148036e-8, 0, 0.37659, 0.710661, 142808e-8, 0, 0.400391, 0.692426, 136906e-8, 0, 0.424973, 0.673623, 131066e-8, 0, 0.450347, 0.65494, 125569e-8, 0, 0.476531, 0.635448, 119517e-8, 0, 0.503535, 0.616221, 113828e-8, 0, 0.531372, 0.597531, 10816e-7, 0, 0.560047, 0.578795, 102673e-8, 0, 0.589554, 0.559892, 970985e-9, 0, 0.619869, 0.541307, 919773e-9, 0, 0.650923, 0.522608, 868479e-9, 0, 0.68254, 0.504484, 82137e-8, 0, 0.714286, 0.486603, 772916e-9, 0, 0.746032, 0.468802, 730353e-9, 0, 0.777778, 0.451172, 684955e-9, 0, 0.809524, 0.434348, 647565e-9, 0, 0.84127, 0.417445, 605863e-9, 0, 0.873016, 0.401077, 571885e-9, 0, 0.904762, 0.385039, 536034e-9, 0, 0.936508, 0.369483, 504227e-9, 0, 0.968254, 0.354272, 473165e-9, 0, 1, 1, 599525e-9, 0, 0, 1, 599533e-9, 0, 0, 1, 599639e-9, 0, 0, 0.999998, 600097e-9, 0, 0, 0.999994, 601336e-9, 0, 0, 0.999987, 603958e-9, 0, 0, 0.999972, 608775e-9, 0, 0, 0.999949, 616842e-9, 0, 0, 0.999912, 629534e-9, 0, 0, 0.999857, 648658e-9, 0, 0, 0.999781, 676615e-9, 0, 538873e-11, 0.999674, 716574e-9, 0, 308602e-9, 0.999528, 772641e-9, 0, 127003e-8, 0.999326, 849806e-9, 0, 300783e-8, 0.999009, 952682e-9, 0, 556637e-8, 0.998112, 106394e-8, 0, 895889e-8, 0.994496, 102228e-8, 0, 0.0131827, 0.992806, 108586e-8, 0, 0.0182277, 0.991211, 11759e-7, 0, 0.0240795, 0.989415, 128955e-8, 0, 0.030723, 0.986499, 139038e-8, 0, 0.0381418, 0.982679, 144539e-8, 0, 0.046321, 0.978839, 153954e-8, 0, 0.0552459, 0.974295, 164417e-8, 0, 0.0649034, 0.968784, 171517e-8, 0, 0.0752814, 0.962324, 180282e-8, 0, 0.0863693, 0.954956, 186387e-8, 0, 0.0981578, 0.94624, 193817e-8, 0, 0.110639, 0.936517, 198156e-8, 0, 0.123806, 0.925186, 203042e-8, 0, 0.137655, 0.91252, 20664e-7, 0, 0.15218, 0.898441, 207822e-8, 0, 0.16738, 0.884394, 20992e-7, 0, 0.183253, 0.871273, 208748e-8, 0, 0.199799, 0.859057, 208686e-8, 0, 0.21702, 0.845243, 205519e-8, 0, 0.234918, 0.830723, 202868e-8, 0, 0.253496, 0.815801, 199501e-8, 0, 0.272761, 0.79914, 194193e-8, 0, 0.292719, 0.782372, 188824e-8, 0, 0.313377, 0.76482, 183695e-8, 0, 0.334745, 0.746586, 177418e-8, 0, 0.356833, 0.7281, 170628e-8, 0, 0.379654, 0.709842, 164063e-8, 0, 0.403221, 0.692019, 157355e-8, 0, 0.427548, 0.67364, 150262e-8, 0, 0.452651, 0.655277, 143473e-8, 0, 0.478545, 0.636438, 136371e-8, 0, 0.505246, 0.617364, 129911e-8, 0, 0.532768, 0.598603, 123014e-8, 0, 0.561122, 0.580195, 116587e-8, 0, 0.590309, 0.561786, 110398e-8, 0, 0.620318, 0.543377, 104148e-8, 0, 0.651102, 0.525093, 983984e-9, 0, 0.682545, 0.506791, 92667e-8, 0, 0.714286, 0.489291, 874326e-9, 0, 0.746032, 0.471811, 821734e-9, 0, 0.777778, 0.454435, 774698e-9, 0, 0.809524, 0.437493, 727302e-9, 0, 0.84127, 0.420977, 684039e-9, 0, 0.873016, 0.404729, 64373e-8, 0, 0.904762, 0.388756, 60285e-8, 0, 0.936508, 0.373344, 56765e-8, 0, 0.968254, 0.358191, 531929e-9, 0, 1, 1, 832169e-9, 0, 0, 1, 832178e-9, 0, 0, 1, 83231e-8, 0, 0, 0.999998, 832893e-9, 0, 0, 0.999995, 834465e-9, 0, 0, 0.999985, 837791e-9, 0, 0, 0.999969, 843893e-9, 0, 0, 0.999944, 854086e-9, 0, 0, 0.999903, 870071e-9, 0, 0, 0.999843, 894042e-9, 0, 0, 0.999759, 928865e-9, 0, 531805e-10, 0.999643, 978242e-9, 0, 579365e-9, 0.99948, 104684e-8, 0, 182774e-8, 0.999255, 114012e-8, 0, 387804e-8, 0.998885, 126188e-8, 0, 675709e-8, 0.997405, 135888e-8, 0, 0.010468, 0.99424, 133626e-8, 0, 0.0150018, 0.992458, 140905e-8, 0, 0.0203443, 0.990929, 152305e-8, 0, 0.0264786, 0.989116, 165882e-8, 0, 0.0333875, 0.985624, 174128e-8, 0, 0.0410536, 0.982003, 182108e-8, 0, 0.0494609, 0.978336, 194498e-8, 0, 0.0585941, 0.973184, 202708e-8, 0, 0.0684396, 0.9678, 212166e-8, 0, 0.0789851, 0.961348, 221366e-8, 0, 0.0902199, 0.953841, 228219e-8, 0, 0.102134, 0.94534, 235662e-8, 0, 0.114721, 0.935552, 240572e-8, 0, 0.127972, 0.924064, 244405e-8, 0, 0.141884, 0.911827, 247557e-8, 0, 0.156451, 0.897731, 248374e-8, 0, 0.171672, 0.883409, 249863e-8, 0, 0.187545, 0.868625, 246688e-8, 0, 0.20407, 0.856529, 246523e-8, 0, 0.221249, 0.842999, 242368e-8, 0, 0.239083, 0.828505, 237354e-8, 0, 0.257578, 0.813825, 232588e-8, 0, 0.276738, 0.797813, 226731e-8, 0, 0.296569, 0.781097, 219704e-8, 0, 0.31708, 0.764038, 212394e-8, 0, 0.338281, 0.746067, 204786e-8, 0, 0.360181, 0.727687, 196728e-8, 0, 0.382794, 0.709571, 188779e-8, 0, 0.406133, 0.691503, 180532e-8, 0, 0.430213, 0.673673, 171849e-8, 0, 0.45505, 0.655732, 164147e-8, 0, 0.480662, 0.637399, 155858e-8, 0, 0.507065, 0.618616, 147641e-8, 0, 0.534278, 0.60005, 140125e-8, 0, 0.562313, 0.581713, 132441e-8, 0, 0.59118, 0.563546, 125014e-8, 0, 0.620875, 0.545605, 118249e-8, 0, 0.651373, 0.527559, 11116e-7, 0, 0.682593, 0.509764, 104979e-8, 0, 0.714286, 0.49193, 985977e-9, 0, 0.746032, 0.475011, 928592e-9, 0, 0.777778, 0.457878, 873466e-9, 0, 0.809524, 0.440979, 819585e-9, 0, 0.84127, 0.424613, 772365e-9, 0, 0.873016, 0.408549, 722195e-9, 0, 0.904762, 0.392771, 680014e-9, 0, 0.936508, 0.377317, 636797e-9, 0, 0.968254, 0.362352, 598318e-9, 0, 1, 1, 114313e-8, 0, 0, 1, 114314e-8, 0, 0, 0.999999, 114331e-8, 0, 0, 0.999998, 114404e-8, 0, 0, 0.999994, 114601e-8, 0, 0, 0.999984, 115019e-8, 0, 0, 0.999967, 115784e-8, 0, 0, 0.999937, 11706e-7, 0, 0, 0.999894, 119054e-8, 0, 0, 0.999828, 122031e-8, 0, 0, 0.999735, 126331e-8, 0, 169263e-9, 0.999606, 132382e-8, 0, 949167e-9, 0.999426, 14071e-7, 0, 249668e-8, 0.999173, 151895e-8, 0, 486392e-8, 0.99873, 166102e-8, 0, 806323e-8, 0.996243, 17023e-7, 0, 0.0120895, 0.993779, 172782e-8, 0, 0.0169288, 0.9919, 18108e-7, 0, 0.0225633, 0.990524, 196028e-8, 0, 0.028974, 0.98868, 212014e-8, 0, 0.036142, 0.984663, 217598e-8, 0, 0.044049, 0.981457, 230563e-8, 0, 0.0526781, 0.977608, 243966e-8, 0, 0.0620137, 0.972215, 251336e-8, 0, 0.0720418, 0.966798, 26285e-7, 0, 0.0827499, 0.960241, 271409e-8, 0, 0.0941271, 0.952489, 278381e-8, 0, 0.106164, 0.944127, 285399e-8, 0, 0.118852, 0.934282, 290994e-8, 0, 0.132185, 0.923271, 294558e-8, 0, 0.146157, 0.910803, 296269e-8, 0, 0.160766, 0.896705, 296803e-8, 0, 0.176007, 0.88238, 296637e-8, 0, 0.19188, 0.867116, 293163e-8, 0, 0.208385, 0.853636, 289418e-8, 0, 0.225523, 0.840469, 284663e-8, 0, 0.243296, 0.82639, 278594e-8, 0, 0.261709, 0.811759, 271618e-8, 0, 0.280767, 0.796113, 263187e-8, 0, 0.300476, 0.779518, 254589e-8, 0, 0.320845, 0.763142, 246003e-8, 0, 0.341883, 0.745464, 236529e-8, 0, 0.363601, 0.727491, 226536e-8, 0, 0.386011, 0.709414, 216375e-8, 0, 0.409128, 0.691396, 207127e-8, 0, 0.432967, 0.67368, 197106e-8, 0, 0.457545, 0.656049, 187022e-8, 0, 0.482881, 0.638188, 177605e-8, 0, 0.508992, 0.620177, 168482e-8, 0, 0.535899, 0.601506, 158909e-8, 0, 0.563619, 0.58362, 150583e-8, 0, 0.592165, 0.565496, 141791e-8, 0, 0.621544, 0.54789, 133693e-8, 0, 0.651743, 0.530323, 126038e-8, 0, 0.682709, 0.512795, 118556e-8, 0, 0.714286, 0.495199, 111527e-8, 0, 0.746032, 0.478101, 10489e-7, 0, 0.777778, 0.461511, 984264e-9, 0, 0.809524, 0.444879, 92591e-8, 0, 0.84127, 0.428424, 866582e-9, 0, 0.873016, 0.412495, 814463e-9, 0, 0.904762, 0.396975, 764498e-9, 0, 0.936508, 0.381614, 715967e-9, 0, 0.968254, 0.366732, 672483e-9, 0, 1, 1, 155501e-8, 0, 0, 1, 155503e-8, 0, 0, 1, 155524e-8, 0, 0, 0.999998, 155615e-8, 0, 0, 0.999994, 15586e-7, 0, 0, 0.999983, 156379e-8, 0, 0, 0.999963, 15733e-7, 0, 0, 0.999932, 158911e-8, 0, 0, 0.999882, 161376e-8, 0, 0, 0.99981, 165041e-8, 0, 100875e-10, 0.999708, 170304e-8, 0, 367658e-9, 0.999565, 177658e-8, 0, 14234e-7, 0.999368, 187688e-8, 0, 327939e-8, 0.999081, 200989e-8, 0, 596629e-8, 0.99852, 217177e-8, 0, 94852e-7, 0.99549, 21745e-7, 0, 0.013824, 0.993252, 222357e-8, 0, 0.0189642, 0.991727, 235022e-8, 0, 0.0248856, 0.989951, 250561e-8, 0, 0.0315669, 0.988029, 268829e-8, 0, 0.0389882, 0.984029, 27496e-7, 0, 0.0471302, 0.980683, 289793e-8, 0, 0.0559754, 0.976554, 303315e-8, 0, 0.0655081, 0.97139, 313257e-8, 0, 0.0757138, 0.965544, 323656e-8, 0, 0.08658, 0.95912, 333432e-8, 0, 0.0980954, 0.951183, 34039e-7, 0, 0.110251, 0.942974, 347515e-8, 0, 0.123038, 0.932642, 350381e-8, 0, 0.13645, 0.922158, 354519e-8, 0, 0.150482, 0.909404, 353851e-8, 0, 0.165129, 0.896071, 35435e-7, 0, 0.18039, 0.881206, 349936e-8, 0, 0.196263, 0.866077, 347256e-8, 0, 0.212748, 0.85093, 3415e-6, 0, 0.229847, 0.837703, 333367e-8, 0, 0.247561, 0.823878, 3249e-6, 0, 0.265895, 0.809449, 316347e-8, 0, 0.284854, 0.794379, 306351e-8, 0, 0.304445, 0.778138, 29499e-7, 0, 0.324675, 0.761997, 284099e-8, 0, 0.345555, 0.744938, 272104e-8, 0, 0.367095, 0.727212, 260715e-8, 0, 0.389309, 0.709549, 248855e-8, 0, 0.41221, 0.691704, 236783e-8, 0, 0.435814, 0.673689, 225178e-8, 0, 0.460138, 0.656453, 213765e-8, 0, 0.485203, 0.639128, 202178e-8, 0, 0.511028, 0.621512, 191443e-8, 0, 0.537634, 0.603598, 180977e-8, 0, 0.565041, 0.58559, 170456e-8, 0, 0.593268, 0.567852, 160927e-8, 0, 0.622327, 0.5503, 151395e-8, 0, 0.652217, 0.533033, 142499e-8, 0, 0.682907, 0.515942, 133955e-8, 0, 0.714296, 0.498814, 12602e-7, 0, 0.746032, 0.481595, 118188e-8, 0, 0.777778, 0.465117, 111171e-8, 0, 0.809524, 0.448865, 104091e-8, 0, 0.84127, 0.432711, 976618e-9, 0, 0.873016, 0.416822, 91859e-8, 0, 0.904762, 0.401272, 857704e-9, 0, 0.936508, 0.386226, 807172e-9, 0, 0.968254, 0.371321, 75464e-8, 0, 1, 1, 209596e-8, 0, 0, 1, 209598e-8, 0, 0, 1, 209624e-8, 0, 0, 0.999997, 209736e-8, 0, 0, 0.999991, 210039e-8, 0, 0, 0.999979, 210678e-8, 0, 0, 0.999959, 211847e-8, 0, 0, 0.999925, 21379e-7, 0, 0, 0.99987, 216809e-8, 0, 0, 0.999791, 221281e-8, 0, 681487e-10, 0.999677, 227669e-8, 0, 658161e-9, 0.999521, 236533e-8, 0, 200635e-8, 0.999301, 248514e-8, 0, 41779e-7, 0.998977, 264185e-8, 0, 718648e-8, 0.998191, 281695e-8, 0, 0.0110239, 0.994801, 278518e-8, 0, 0.015672, 0.993091, 288774e-8, 0, 0.0211091, 0.991571, 303931e-8, 0, 0.0273123, 0.9897, 321643e-8, 0, 0.034259, 0.987023, 337332e-8, 0, 0.0419282, 0.983289, 346146e-8, 0, 0.0502998, 0.979892, 363704e-8, 0, 0.0593562, 0.975111, 373601e-8, 0, 0.069081, 0.970351, 38842e-7, 0, 0.0794598, 0.964131, 397053e-8, 0, 0.0904798, 0.957747, 408078e-8, 0, 0.10213, 0.949536, 413533e-8, 0, 0.1144, 0.941372, 420305e-8, 0, 0.127284, 0.931049, 422815e-8, 0, 0.140772, 0.920647, 425048e-8, 0, 0.154862, 0.908033, 42281e-7, 0, 0.169548, 0.895028, 422026e-8, 0, 0.184828, 0.879968, 415042e-8, 0, 0.200701, 0.864875, 408821e-8, 0, 0.217167, 0.84918, 400909e-8, 0, 0.234227, 0.834934, 391178e-8, 0, 0.251884, 0.821397, 380066e-8, 0, 0.270141, 0.807135, 367974e-8, 0, 0.289004, 0.792363, 355172e-8, 0, 0.308479, 0.776661, 3411e-6, 0, 0.328575, 0.760705, 328123e-8, 0, 0.349301, 0.744408, 314003e-8, 0, 0.370668, 0.726994, 29906e-7, 0, 0.392689, 0.709598, 285034e-8, 0, 0.415379, 0.692112, 271179e-8, 0, 0.438754, 0.674435, 257185e-8, 0, 0.46283, 0.65676, 243425e-8, 0, 0.48763, 0.639982, 230351e-8, 0, 0.513173, 0.622983, 21777e-7, 0, 0.539482, 0.605471, 204991e-8, 0, 0.566579, 0.58796, 193759e-8, 0, 0.594488, 0.570463, 181976e-8, 0, 0.623226, 0.553058, 171497e-8, 0, 0.6528, 0.535894, 161109e-8, 0, 0.683198, 0.519089, 151394e-8, 0, 0.714354, 0.502454, 142122e-8, 0, 0.746032, 0.485681, 133488e-8, 0, 0.777778, 0.468935, 124975e-8, 0, 0.809524, 0.452951, 117309e-8, 0, 0.84127, 0.437139, 110155e-8, 0, 0.873016, 0.421446, 103124e-8, 0, 0.904762, 0.405951, 966387e-9, 0, 0.936508, 0.391003, 908119e-9, 0, 0.968254, 0.376198, 848057e-9, 0, 1, 1, 280076e-8, 0, 0, 1, 280078e-8, 0, 0, 0.999999, 280109e-8, 0, 0, 0.999997, 280246e-8, 0, 0, 0.999992, 280616e-8, 0, 0, 0.999979, 281396e-8, 0, 0, 0.999956, 282822e-8, 0, 0, 0.999916, 285186e-8, 0, 0, 0.999857, 28885e-7, 0, 0, 0.999768, 294259e-8, 0, 196026e-9, 0.999645, 301946e-8, 0, 104842e-8, 0.99947, 312541e-8, 0, 270199e-8, 0.999229, 326733e-8, 0, 519449e-8, 0.998852, 344992e-8, 0, 852602e-8, 0.997558, 361052e-8, 0, 0.0126804, 0.994417, 35898e-7, 0, 0.017635, 0.992824, 372393e-8, 0, 0.023365, 0.991344, 390695e-8, 0, 0.0298456, 0.989337, 410392e-8, 0, 0.0370529, 0.985811, 420987e-8, 0, 0.0449651, 0.982772, 437488e-8, 0, 0.0535615, 0.979001, 455069e-8, 0, 0.0628243, 0.974102, 464462e-8, 0, 0.0727368, 0.969197, 480577e-8, 0, 0.0832844, 0.962759, 487818e-8, 0, 0.0944545, 0.956207, 498176e-8, 0, 0.106236, 0.947909, 503392e-8, 0, 0.118619, 0.939596, 507474e-8, 0, 0.131595, 0.929642, 509798e-8, 0, 0.145159, 0.918807, 508476e-8, 0, 0.159305, 0.906921, 505634e-8, 0, 0.174028, 0.893312, 498845e-8, 0, 0.189327, 0.878933, 49133e-7, 0, 0.2052, 0.863986, 48259e-7, 0, 0.221647, 0.847936, 470848e-8, 0, 0.23867, 0.832253, 456889e-8, 0, 0.25627, 0.818619, 442726e-8, 0, 0.274453, 0.804788, 427677e-8, 0, 0.293222, 0.790241, 411906e-8, 0, 0.312585, 0.775162, 394833e-8, 0, 0.33255, 0.759463, 377366e-8, 0, 0.353126, 0.743598, 361026e-8, 0, 0.374324, 0.72697, 343627e-8, 0, 0.396158, 0.709646, 326422e-8, 0, 0.418641, 0.69277, 309717e-8, 0, 0.44179, 0.675371, 29356e-7, 0, 0.465624, 0.657863, 277712e-8, 0, 0.490163, 0.640772, 261738e-8, 0, 0.515429, 0.624441, 24737e-7, 0, 0.541445, 0.607497, 233125e-8, 0, 0.568236, 0.590438, 218994e-8, 0, 0.595828, 0.573224, 20664e-7, 0, 0.624242, 0.556168, 193526e-8, 0, 0.653496, 0.539232, 182463e-8, 0, 0.683588, 0.522352, 170735e-8, 0, 0.714482, 0.506172, 160555e-8, 0, 0.746032, 0.489842, 150451e-8, 0, 0.777778, 0.473463, 140938e-8, 0, 0.809524, 0.457266, 132568e-8, 0, 0.84127, 0.441609, 12376e-7, 0, 0.873016, 0.426348, 116265e-8, 0, 0.904762, 0.411002, 108935e-8, 0, 0.936508, 0.396045, 101946e-8, 0, 0.968254, 0.381448, 955665e-9, 0, 1, 1, 37121e-7, 0, 0, 1, 371213e-8, 0, 0, 1, 371251e-8, 0, 0, 0.999997, 371417e-8, 0, 0, 0.99999, 371863e-8, 0, 0, 0.999977, 372807e-8, 0, 0, 0.99995, 374529e-8, 0, 0, 0.999908, 37738e-7, 0, 0, 0.999843, 381789e-8, 0, 123596e-10, 0.999745, 388273e-8, 0, 407442e-9, 0.999608, 397443e-8, 0, 15447e-7, 0.999415, 409998e-8, 0, 351385e-8, 0.999143, 426662e-8, 0, 63316e-7, 0.9987, 447625e-8, 0, 998679e-8, 0.996363, 455323e-8, 0, 0.0144569, 0.994021, 461052e-8, 0, 0.0197151, 0.992372, 476359e-8, 0, 0.0257344, 0.991007, 499101e-8, 0, 0.0324882, 0.988767, 51972e-7, 0, 0.0399517, 0.984872, 528407e-8, 0, 0.0481022, 0.982004, 548926e-8, 0, 0.0569191, 0.977714, 564385e-8, 0, 0.0663839, 0.973076, 57693e-7, 0, 0.0764801, 0.967565, 58924e-7, 0, 0.0871928, 0.961384, 599629e-8, 0, 0.0985095, 0.954435, 605998e-8, 0, 0.110419, 0.946303, 61133e-7, 0, 0.122912, 0.937662, 612028e-8, 0, 0.13598, 0.927867, 612209e-8, 0, 0.149617, 0.916475, 604813e-8, 0, 0.163817, 0.90541, 603088e-8, 0, 0.178577, 0.891591, 592218e-8, 0, 0.193894, 0.877573, 578854e-8, 0, 0.209767, 0.862511, 566648e-8, 0, 0.226196, 0.846861, 551481e-8, 0, 0.243182, 0.83068, 533754e-8, 0, 0.260728, 0.815725, 515487e-8, 0, 0.278837, 0.802321, 49655e-7, 0, 0.297515, 0.787826, 475421e-8, 0, 0.316768, 0.773454, 456002e-8, 0, 0.336605, 0.758224, 434727e-8, 0, 0.357034, 0.74265, 414444e-8, 0, 0.378067, 0.726729, 393738e-8, 0, 0.399717, 0.710155, 373575e-8, 0, 0.421998, 0.693312, 353736e-8, 0, 0.444928, 0.67653, 334368e-8, 0, 0.468523, 0.659444, 315981e-8, 0, 0.492806, 0.642051, 297809e-8, 0, 0.517798, 0.625758, 280592e-8, 0, 0.543525, 0.609615, 264254e-8, 0, 0.570012, 0.592919, 248459e-8, 0, 0.597288, 0.576298, 233327e-8, 0, 0.625379, 0.559489, 219519e-8, 0, 0.654307, 0.542891, 205441e-8, 0, 0.684084, 0.526255, 193385e-8, 0, 0.714693, 0.509853, 180745e-8, 0, 0.746044, 0.494131, 169817e-8, 0, 0.777778, 0.478114, 15913e-7, 0, 0.809524, 0.462274, 148981e-8, 0, 0.84127, 0.446412, 139537e-8, 0, 0.873016, 0.431274, 130984e-8, 0, 0.904762, 0.41635, 122403e-8, 0, 0.936508, 0.401476, 114809e-8, 0, 0.968254, 0.386993, 107563e-8, 0, 1, 1, 488216e-8, 0, 0, 1, 48822e-7, 0, 0, 1, 488265e-8, 0, 0, 0.999997, 488463e-8, 0, 0, 0.999988, 488999e-8, 0, 0, 0.999974, 490129e-8, 0, 0, 0.999946, 492191e-8, 0, 0, 0.999897, 495598e-8, 0, 0, 0.999825, 500855e-8, 0, 744791e-10, 0.999718, 508559e-8, 0, 712744e-9, 0.999565, 5194e-6, 0, 215249e-8, 0.999352, 534147e-8, 0, 444576e-8, 0.999046, 553523e-8, 0, 759218e-8, 0.998492, 577016e-8, 0, 0.0115714, 0.995564, 578487e-8, 0, 0.0163557, 0.993339, 586414e-8, 0, 0.021915, 0.991834, 606002e-8, 0, 0.0282201, 0.990496, 633312e-8, 0, 0.0352433, 0.987826, 651941e-8, 0, 0.042959, 0.98383, 660842e-8, 0, 0.0513439, 0.98109, 685523e-8, 0, 0.0603772, 0.976131, 695778e-8, 0, 0.0700402, 0.971922, 714236e-8, 0, 0.0803163, 0.965901, 721437e-8, 0, 0.0911908, 0.959606, 732017e-8, 0, 0.102651, 0.952504, 735788e-8, 0, 0.114686, 0.944365, 738493e-8, 0, 0.127286, 0.935652, 737969e-8, 0, 0.140443, 0.925813, 733612e-8, 0, 0.154151, 0.914397, 723094e-8, 0, 0.168405, 0.903257, 714002e-8, 0, 0.183201, 0.890015, 700149e-8, 0, 0.198536, 0.876014, 682813e-8, 0, 0.214409, 0.861436, 665567e-8, 0, 0.23082, 0.845752, 644526e-8, 0, 0.24777, 0.829169, 621635e-8, 0, 0.265263, 0.813435, 597789e-8, 0, 0.283301, 0.799701, 575694e-8, 0, 0.301889, 0.785726, 549866e-8, 0, 0.321035, 0.77152, 52503e-7, 0, 0.340746, 0.75683, 499619e-8, 0, 0.361032, 0.741951, 47543e-7, 0, 0.381904, 0.726367, 45084e-7, 0, 0.403374, 0.710537, 426784e-8, 0, 0.425457, 0.693965, 403487e-8, 0, 0.448169, 0.677724, 38075e-7, 0, 0.47153, 0.66117, 359431e-8, 0, 0.495561, 0.644274, 338354e-8, 0, 0.520284, 0.627449, 318163e-8, 0, 0.545725, 0.611645, 299672e-8, 0, 0.571911, 0.595614, 281016e-8, 0, 0.598873, 0.579426, 264252e-8, 0, 0.62664, 0.563016, 247509e-8, 0, 0.655239, 0.546728, 232647e-8, 0, 0.684692, 0.530539, 217803e-8, 0, 0.714999, 0.514164, 204216e-8, 0, 0.746106, 0.498344, 191403e-8, 0, 0.777778, 0.482957, 179203e-8, 0, 0.809524, 0.467336, 167695e-8, 0, 0.84127, 0.451994, 157567e-8, 0, 0.873016, 0.436514, 147113e-8, 0, 0.904762, 0.42178, 138034e-8, 0, 0.936508, 0.407271, 129219e-8, 0, 0.968254, 0.392822, 12098e-7, 0, 1, 1, 637427e-8, 0, 0, 1, 637431e-8, 0, 0, 0.999999, 637485e-8, 0, 0, 0.999996, 637721e-8, 0, 0, 0.999987, 638357e-8, 0, 0, 0.999971, 6397e-6, 0, 0, 0.999939, 642142e-8, 0, 0, 0.999888, 646177e-8, 0, 0, 0.999807, 652387e-8, 0, 207916e-9, 0.999689, 661454e-8, 0, 112051e-8, 0.99952, 674155e-8, 0, 287719e-8, 0.999283, 691313e-8, 0, 550145e-8, 0.998936, 713598e-8, 0, 897928e-8, 0.998165, 738501e-8, 0, 0.0132829, 0.994847, 734388e-8, 0, 0.01838, 0.993182, 749991e-8, 0, 0.0242381, 0.991665, 77246e-7, 0, 0.030826, 0.989708, 797579e-8, 0, 0.0381152, 0.986663, 813011e-8, 0, 0.0460794, 0.983288, 830365e-8, 0, 0.0546951, 0.980104, 853496e-8, 0, 0.0639411, 0.974855, 861045e-8, 0, 0.0737988, 0.97045, 879133e-8, 0, 0.0842516, 0.964509, 886377e-8, 0, 0.0952848, 0.957594, 890346e-8, 0, 0.106886, 0.950546, 893289e-8, 0, 0.119044, 0.942225, 890074e-8, 0, 0.131749, 0.933365, 886826e-8, 0, 0.144994, 0.923202, 87316e-7, 0, 0.158772, 0.912605, 863082e-8, 0, 0.173078, 0.901099, 847403e-8, 0, 0.187908, 0.888177, 825838e-8, 0, 0.203261, 0.873955, 801834e-8, 0, 0.219134, 0.860091, 779026e-8, 0, 0.235527, 0.84434, 752478e-8, 0, 0.252443, 0.828517, 724074e-8, 0, 0.269883, 0.81239, 693769e-8, 0, 0.287851, 0.79721, 664817e-8, 0, 0.306352, 0.783489, 634763e-8, 0, 0.325393, 0.769514, 604221e-8, 0, 0.344981, 0.755419, 573568e-8, 0, 0.365126, 0.741083, 544359e-8, 0, 0.385839, 0.726059, 515515e-8, 0, 0.407132, 0.710809, 487139e-8, 0, 0.42902, 0.695052, 459846e-8, 0, 0.45152, 0.678886, 433412e-8, 0, 0.474651, 0.663042, 407981e-8, 0, 0.498433, 0.646634, 384264e-8, 0, 0.52289, 0.630117, 360897e-8, 0, 0.548048, 0.613804, 338863e-8, 0, 0.573936, 0.598338, 318486e-8, 0, 0.600584, 0.582687, 298377e-8, 0, 0.628027, 0.566809, 280082e-8, 0, 0.656295, 0.550817, 262255e-8, 0, 0.685417, 0.534937, 245835e-8, 0, 0.715406, 0.519151, 230574e-8, 0, 0.74624, 0.503118, 21549e-7, 0, 0.777778, 0.487723, 202008e-8, 0, 0.809524, 0.472725, 189355e-8, 0, 0.84127, 0.457599, 177108e-8, 0, 0.873016, 0.442558, 165843e-8, 0, 0.904762, 0.427624, 155494e-8, 0, 0.936508, 0.413171, 145273e-8, 0, 0.968254, 0.399122, 136454e-8, 0, 1, 1, 826496e-8, 0, 0, 1, 826499e-8, 0, 0, 1, 826564e-8, 0, 0, 0.999996, 826842e-8, 0, 0, 0.999987, 827589e-8, 0, 0, 0.999967, 829167e-8, 0, 0, 0.999933, 832037e-8, 0, 0, 0.999876, 836768e-8, 0, 109338e-10, 0.999786, 844031e-8, 0, 427145e-9, 0.999655, 854603e-8, 0, 16384e-7, 0.999468, 869337e-8, 0, 372392e-8, 0.999203, 8891e-6, 0, 668513e-8, 0.998803, 914387e-8, 0, 0.0104968, 0.99748, 935838e-8, 0, 0.015125, 0.994446, 933309e-8, 0, 0.0205338, 0.99292, 953084e-8, 0, 0.0266884, 0.991414, 97893e-7, 0, 0.0335565, 0.989049, 0.0100228, 0, 0.0411086, 0.98582, 0.0101664, 0, 0.0493181, 0.982441, 0.0103582, 0, 0.0581613, 0.978595, 0.0105292, 0, 0.0676169, 0.973495, 0.0106274, 0, 0.0776661, 0.968405, 0.0107261, 0, 0.0882926, 0.962717, 0.0108234, 0, 0.0994817, 0.955478, 0.0108102, 0, 0.111221, 0.948275, 0.0107914, 0, 0.123499, 0.940006, 0.0107161, 0, 0.136308, 0.930831, 0.0106309, 0, 0.149639, 0.920648, 0.0104083, 0, 0.163485, 0.910205, 0.0102312, 0, 0.177843, 0.898445, 0.0100051, 0, 0.192707, 0.885986, 971928e-8, 0, 0.208077, 0.872204, 940747e-8, 0, 0.22395, 0.858436, 91085e-7, 0, 0.240326, 0.843454, 876595e-8, 0, 0.257208, 0.827437, 839794e-8, 0, 0.274596, 0.811488, 803692e-8, 0, 0.292496, 0.796039, 767352e-8, 0, 0.310911, 0.781083, 73097e-7, 0, 0.329849, 0.767642, 694032e-8, 0, 0.349316, 0.753901, 657476e-8, 0, 0.369323, 0.740131, 622699e-8, 0, 0.38988, 0.725845, 58838e-7, 0, 0.410999, 0.710991, 555586e-8, 0, 0.432696, 0.696002, 523089e-8, 0, 0.454987, 0.680461, 492494e-8, 0, 0.47789, 0.664875, 463464e-8, 0, 0.501426, 0.649273, 435422e-8, 0, 0.52562, 0.63302, 40875e-7, 0, 0.550498, 0.61705, 384075e-8, 0, 0.576089, 0.601154, 359557e-8, 0, 0.602427, 0.586008, 337636e-8, 0, 0.629544, 0.570699, 316019e-8, 0, 0.657479, 0.555166, 296033e-8, 0, 0.686264, 0.539645, 277552e-8, 0, 0.715924, 0.524159, 259499e-8, 0, 0.746459, 0.508682, 243257e-8, 0, 0.777789, 0.493163, 227851e-8, 0, 0.809524, 0.478004, 213083e-8, 0, 0.84127, 0.46347, 199502e-8, 0, 0.873016, 0.448778, 186967e-8, 0, 0.904762, 0.434105, 174732e-8, 0, 0.936508, 0.419576, 163861e-8, 0, 0.968254, 0.405541, 153341e-8, 0, 1, 1, 0.0106462, 0, 0, 1, 0.0106462, 0, 0, 0.999999, 0.010647, 0, 0, 0.999995, 0.0106502, 0, 0, 0.999985, 0.0106589, 0, 0, 0.999964, 0.0106773, 0, 0, 0.999925, 0.0107106, 0, 0, 0.999861, 0.0107655, 0, 712986e-10, 0.999763, 0.0108497, 0, 743959e-9, 0.999616, 0.0109716, 0, 227361e-8, 0.999408, 0.0111408, 0, 46983e-7, 0.999112, 0.0113659, 0, 800158e-8, 0.998637, 0.0116475, 0, 0.0121493, 0.996223, 0.0117231, 0, 0.0171023, 0.994006, 0.0118064, 0, 0.0228218, 0.992444, 0.0120254, 0, 0.0292711, 0.991028, 0.0123314, 0, 0.036417, 0.98803, 0.0124954, 0, 0.0442295, 0.984816, 0.0126538, 0, 0.0526815, 0.981399, 0.0128537, 0, 0.0617492, 0.977085, 0.0129694, 0, 0.0714114, 0.972154, 0.013091, 0, 0.0816495, 0.966617, 0.0131166, 0, 0.0924472, 0.960628, 0.0131583, 0, 0.10379, 0.953295, 0.0131094, 0, 0.115665, 0.94575, 0.0129966, 0, 0.128062, 0.937654, 0.0128796, 0, 0.140972, 0.927716, 0.0126477, 0, 0.154387, 0.917932, 0.0123889, 0, 0.168301, 0.907719, 0.012131, 0, 0.182709, 0.89584, 0.0118013, 0, 0.197608, 0.883526, 0.0114145, 0, 0.212994, 0.870301, 0.0110075, 0, 0.228867, 0.856272, 0.0106019, 0, 0.245227, 0.842251, 0.0101938, 0, 0.262074, 0.826466, 973254e-8, 0, 0.279412, 0.810859, 92846e-7, 0, 0.297244, 0.795051, 883304e-8, 0, 0.315575, 0.780053, 840272e-8, 0, 0.334412, 0.76575, 796438e-8, 0, 0.35376, 0.752298, 752526e-8, 0, 0.373631, 0.739153, 711486e-8, 0, 0.394034, 0.725514, 670361e-8, 0, 0.414983, 0.711473, 632656e-8, 0, 0.436491, 0.696936, 595206e-8, 0, 0.458575, 0.682126, 559191e-8, 0, 0.481253, 0.667027, 525362e-8, 0, 0.504547, 0.651875, 493805e-8, 0, 0.528481, 0.636463, 462848e-8, 0, 0.553081, 0.620641, 433936e-8, 0, 0.578377, 0.604931, 407e-5, 0, 0.604404, 0.589549, 380864e-8, 0, 0.631197, 0.574712, 357049e-8, 0, 0.658795, 0.559775, 334466e-8, 0, 0.687238, 0.544514, 312505e-8, 0, 0.716559, 0.529555, 293199e-8, 0, 0.746776, 0.514402, 274204e-8, 0, 0.777849, 0.499302, 256647e-8, 0, 0.809524, 0.484114, 239901e-8, 0, 0.84127, 0.469308, 225148e-8, 0, 0.873016, 0.455133, 210178e-8, 0, 0.904762, 0.440939, 19727e-7, 0, 0.936508, 0.426627, 184382e-8, 0, 0.968254, 0.412509, 172548e-8, 0, 1, 1, 0.013628, 0, 0, 1, 0.0136281, 0, 0, 0.999999, 0.0136289, 0, 0, 0.999995, 0.0136327, 0, 0, 0.999983, 0.0136427, 0, 0, 0.99996, 0.0136638, 0, 0, 0.999917, 0.0137022, 0, 0, 0.999846, 0.0137652, 0, 204597e-9, 0.999736, 0.0138615, 0, 116837e-8, 0.999573, 0.0140007, 0, 303325e-8, 0.99934, 0.0141927, 0, 580613e-8, 0.999004, 0.0144457, 0, 945626e-8, 0.998407, 0.0147489, 0, 0.0139421, 0.995464, 0.014731, 0, 0.0192202, 0.993328, 0.0148283, 0, 0.0252495, 0.991799, 0.0150797, 0, 0.0319921, 0.990397, 0.0154316, 0, 0.0394138, 0.986835, 0.0155005, 0, 0.0474843, 0.983938, 0.0157308, 0, 0.0561763, 0.980154, 0.0158753, 0, 0.0654661, 0.975659, 0.0159581, 0, 0.0753326, 0.970171, 0.0159832, 0, 0.0857571, 0.964803, 0.0160084, 0, 0.0967236, 0.958366, 0.0159484, 0, 0.108218, 0.950613, 0.0158001, 0, 0.120227, 0.942874, 0.0155845, 0, 0.132741, 0.935005, 0.0154292, 0, 0.145751, 0.924991, 0.0150742, 0, 0.159249, 0.914814, 0.0146757, 0, 0.17323, 0.904743, 0.0143097, 0, 0.187687, 0.893216, 0.0138695, 0, 0.202619, 0.880769, 0.0133706, 0, 0.218021, 0.868136, 0.0128606, 0, 0.233894, 0.85469, 0.0123403, 0, 0.250238, 0.840593, 0.0118091, 0, 0.267052, 0.825808, 0.011253, 0, 0.284341, 0.81009, 0.0107099, 0, 0.302106, 0.79504, 0.0101636, 0, 0.320354, 0.779757, 964041e-8, 0, 0.33909, 0.764697, 911896e-8, 0, 0.358322, 0.750913, 859533e-8, 0, 0.378059, 0.738175, 811592e-8, 0, 0.398311, 0.725242, 764504e-8, 0, 0.41909, 0.711864, 718885e-8, 0, 0.440412, 0.698009, 675843e-8, 0, 0.462292, 0.683841, 634984e-8, 0, 0.484748, 0.669391, 595502e-8, 0, 0.507802, 0.654731, 558671e-8, 0, 0.531477, 0.639805, 523578e-8, 0, 0.555802, 0.624789, 490834e-8, 0, 0.580805, 0.609325, 459448e-8, 0, 0.606522, 0.593975, 430342e-8, 0, 0.63299, 0.578983, 403019e-8, 0, 0.66025, 0.564442, 37707e-7, 0, 0.688346, 0.549835, 35316e-7, 0, 0.717319, 0.535039, 330255e-8, 0, 0.7472, 0.520403, 308932e-8, 0, 0.777982, 0.505687, 289335e-8, 0, 0.809524, 0.490939, 270818e-8, 0, 0.84127, 0.476233, 25343e-7, 0, 0.873016, 0.461624, 237097e-8, 0, 0.904762, 0.447833, 222065e-8, 0, 0.936508, 0.433992, 207561e-8, 0, 0.968254, 0.420147, 194955e-8, 0, 1, 1, 0.0173415, 0, 0, 1, 0.0173416, 0, 0, 0.999999, 0.0173426, 0, 0, 0.999995, 0.0173468, 0, 0, 0.999983, 0.0173582, 0, 0, 0.999954, 0.0173822, 0, 0, 0.999908, 0.0174258, 0, 669501e-11, 0.999828, 0.0174973, 0, 427399e-9, 0.999705, 0.0176063, 0, 171019e-8, 0.999524, 0.0177631, 0, 39248e-7, 0.999263, 0.0179781, 0, 705382e-8, 0.998878, 0.018258, 0, 0.0110552, 0.998012, 0.0185551, 0, 0.0158812, 0.994614, 0.0184264, 0, 0.0214852, 0.993132, 0.0186385, 0, 0.0278239, 0.991563, 0.0189067, 0, 0.0348585, 0.989298, 0.0191577, 0, 0.0425544, 0.986036, 0.0192522, 0, 0.050881, 0.982558, 0.0194063, 0, 0.059811, 0.978531, 0.019486, 0, 0.0693209, 0.974198, 0.0195847, 0, 0.0793895, 0.968148, 0.0194749, 0, 0.0899984, 0.962565, 0.0194277, 0, 0.101132, 0.956041, 0.0192991, 0, 0.112775, 0.947749, 0.0189893, 0, 0.124917, 0.94018, 0.018704, 0, 0.137547, 0.93165, 0.0183458, 0, 0.150655, 0.921798, 0.0178775, 0, 0.164236, 0.911573, 0.0173618, 0, 0.178281, 0.901569, 0.0168482, 0, 0.192788, 0.890341, 0.016265, 0, 0.207752, 0.877835, 0.0156199, 0, 0.223171, 0.865472, 0.0149516, 0, 0.239044, 0.852905, 0.0143274, 0, 0.255371, 0.838906, 0.0136643, 0, 0.272153, 0.824888, 0.0129903, 0, 0.289393, 0.809977, 0.0123218, 0, 0.307093, 0.794697, 0.0116572, 0, 0.325259, 0.780028, 0.0110307, 0, 0.343896, 0.765124, 0.0104236, 0, 0.363012, 0.750411, 98219e-7, 0, 0.382617, 0.737264, 924397e-8, 0, 0.402719, 0.724799, 868719e-8, 0, 0.423332, 0.712253, 816476e-8, 0, 0.444469, 0.699267, 767262e-8, 0, 0.466146, 0.685618, 719746e-8, 0, 0.488383, 0.671736, 673916e-8, 0, 0.511199, 0.657777, 631937e-8, 0, 0.534618, 0.643497, 592411e-8, 0, 0.558668, 0.62889, 553928e-8, 0, 0.58338, 0.614299, 51934e-7, 0, 0.608787, 0.599197, 485985e-8, 0, 0.634929, 0.584175, 454357e-8, 0, 0.661849, 0.569541, 425787e-8, 0, 0.689594, 0.555193, 397905e-8, 0, 0.718211, 0.540947, 372364e-8, 0, 0.747742, 0.526593, 348599e-8, 0, 0.778205, 0.512335, 326103e-8, 0, 0.80953, 0.498017, 305137e-8, 0, 0.84127, 0.483609, 285485e-8, 0, 0.873016, 0.469368, 267472e-8, 0, 0.904762, 0.455037, 249945e-8, 0, 0.936508, 0.441493, 234792e-8, 0, 0.968254, 0.428147, 219936e-8, 0, 1, 1, 0.0219422, 0, 0, 1, 0.0219423, 0, 0, 0.999998, 0.0219434, 0, 0, 0.999993, 0.0219481, 0, 0, 0.999981, 0.021961, 0, 0, 0.999949, 0.0219879, 0, 0, 0.999896, 0.0220367, 0, 593194e-10, 0.999808, 0.0221167, 0, 75364e-8, 0.99967, 0.0222383, 0, 237884e-8, 0.999466, 0.0224125, 0, 495612e-8, 0.999174, 0.0226495, 0, 844887e-8, 0.998725, 0.0229525, 0, 0.0128058, 0.996979, 0.0231123, 0, 0.0179742, 0.994317, 0.0230742, 0, 0.0239047, 0.992781, 0.0232895, 0, 0.0305526, 0.991191, 0.0235734, 0, 0.0378786, 0.987787, 0.0236152, 0, 0.0458475, 0.985092, 0.0237994, 0, 0.0544287, 0.981121, 0.0238553, 0, 0.0635952, 0.976924, 0.0238706, 0, 0.0733233, 0.97218, 0.0238704, 0, 0.0835922, 0.965956, 0.0236598, 0, 0.0943839, 0.959998, 0.0234735, 0, 0.105682, 0.953245, 0.0232277, 0, 0.117474, 0.944445, 0.0226973, 0, 0.129747, 0.937087, 0.0223527, 0, 0.142491, 0.928341, 0.0218144, 0, 0.155697, 0.9184, 0.0211516, 0, 0.169358, 0.907959, 0.0204553, 0, 0.183469, 0.89808, 0.0197673, 0, 0.198024, 0.887047, 0.0189915, 0, 0.21302, 0.875221, 0.0182082, 0, 0.228455, 0.86269, 0.0173584, 0, 0.244329, 0.850735, 0.0165718, 0, 0.260639, 0.837545, 0.0157524, 0, 0.277389, 0.823639, 0.0149482, 0, 0.29458, 0.809699, 0.0141431, 0, 0.312216, 0.794797, 0.0133527, 0, 0.3303, 0.780578, 0.0126193, 0, 0.34884, 0.766019, 0.0118914, 0, 0.367842, 0.751447, 0.0111839, 0, 0.387315, 0.737275, 0.010514, 0, 0.40727, 0.724545, 987277e-8, 0, 0.427717, 0.712644, 926569e-8, 0, 0.448671, 0.700432, 869029e-8, 0, 0.470149, 0.687664, 814691e-8, 0, 0.492167, 0.674288, 763012e-8, 0, 0.514746, 0.660966, 714437e-8, 0, 0.537911, 0.647264, 668457e-8, 0, 0.561688, 0.633431, 626581e-8, 0, 0.586108, 0.619133, 585593e-8, 0, 0.611206, 0.604935, 548188e-8, 0, 0.637022, 0.590236, 513288e-8, 0, 0.663599, 0.575473, 47906e-7, 0, 0.690989, 0.561228, 448895e-8, 0, 0.719242, 0.547054, 420233e-8, 0, 0.748411, 0.533175, 392869e-8, 0, 0.778531, 0.519163, 367445e-8, 0, 0.809583, 0.505328, 344097e-8, 0, 0.84127, 0.491446, 322003e-8, 0, 0.873016, 0.477356, 301283e-8, 0, 0.904762, 0.46356, 282592e-8, 0, 0.936508, 0.449623, 264956e-8, 0, 0.968254, 0.436068, 246956e-8, 0, 1, 1, 0.0276135, 0, 0, 1, 0.0276136, 0, 0, 0.999998, 0.0276148, 0, 0, 0.999993, 0.0276201, 0, 0, 0.999976, 0.0276342, 0, 0, 0.999945, 0.027664, 0, 0, 0.999884, 0.0277179, 0, 18679e-8, 0.999784, 0.027806, 0, 119607e-8, 0.99963, 0.0279394, 0, 318407e-8, 0.999401, 0.0281295, 0, 613601e-8, 0.999066, 0.0283858, 0, 999963e-8, 0.998524, 0.0287027, 0, 0.0147164, 0.995702, 0.0286256, 0, 0.0202295, 0.993593, 0.0286733, 0, 0.0264876, 0.992067, 0.0288989, 0, 0.0334452, 0.990548, 0.0292135, 0, 0.0410621, 0.986775, 0.0291296, 0, 0.0493032, 0.984054, 0.0293099, 0, 0.0581381, 0.979481, 0.0291881, 0, 0.0675397, 0.975297, 0.0291598, 0, 0.0774848, 0.96981, 0.028954, 0, 0.0879528, 0.963524, 0.028628, 0, 0.0989258, 0.957398, 0.0283135, 0, 0.110388, 0.950088, 0.0278469, 0, 0.122327, 0.941538, 0.0271798, 0, 0.134729, 0.933332, 0.0265388, 0, 0.147587, 0.924392, 0.0257776, 0, 0.160889, 0.914581, 0.024916, 0, 0.174631, 0.904347, 0.0240242, 0, 0.188806, 0.894324, 0.0231229, 0, 0.203409, 0.883724, 0.022153, 0, 0.218437, 0.872207, 0.0211355, 0, 0.233888, 0.859927, 0.0201048, 0, 0.249761, 0.848373, 0.0191263, 0, 0.266056, 0.836023, 0.0181306, 0, 0.282774, 0.82289, 0.0171718, 0, 0.299917, 0.809324, 0.0162196, 0, 0.317488, 0.795361, 0.0152622, 0, 0.335493, 0.781253, 0.01439, 0, 0.353936, 0.767338, 0.013533, 0, 0.372825, 0.753156, 0.0127244, 0, 0.392168, 0.739122, 0.0119454, 0, 0.411976, 0.725358, 0.0112054, 0, 0.432259, 0.712949, 0.010487, 0, 0.453032, 0.701621, 984032e-8, 0, 0.47431, 0.689703, 921495e-8, 0, 0.496111, 0.677216, 862492e-8, 0, 0.518456, 0.664217, 806882e-8, 0, 0.541367, 0.65137, 755922e-8, 0, 0.564872, 0.638, 705705e-8, 0, 0.589001, 0.62453, 661266e-8, 0, 0.613789, 0.610601, 618432e-8, 0, 0.639277, 0.59676, 578033e-8, 0, 0.66551, 0.582433, 540927e-8, 0, 0.692539, 0.568026, 506104e-8, 0, 0.720422, 0.55414, 47353e-7, 0, 0.749216, 0.540178, 442889e-8, 0, 0.778974, 0.526513, 414363e-8, 0, 0.809711, 0.512954, 388237e-8, 0, 0.84127, 0.499403, 362875e-8, 0, 0.873016, 0.486026, 340827e-8, 0, 0.904762, 0.472345, 318598e-8, 0, 0.936508, 0.458828, 297635e-8, 0, 0.968254, 0.445379, 279447e-8, 0, 1, 1, 0.0345716, 0, 0, 1, 0.0345717, 0, 0, 0.999999, 0.034573, 0, 0, 0.999991, 0.0345787, 0, 0, 0.999974, 0.0345941, 0, 0, 0.999937, 0.0346263, 0, 188589e-11, 0.999869, 0.0346847, 0, 409238e-9, 0.999757, 0.0347798, 0, 17674e-7, 0.999582, 0.0349233, 0, 413658e-8, 0.999322, 0.0351265, 0, 747408e-8, 0.998939, 0.0353967, 0, 0.0117157, 0.998219, 0.0357018, 0, 0.0167966, 0.994974, 0.0354726, 0, 0.0226572, 0.993201, 0.0355621, 0, 0.0292445, 0.991573, 0.0357641, 0, 0.0365123, 0.989301, 0.0359252, 0, 0.0444203, 0.985712, 0.0358017, 0, 0.0529334, 0.982411, 0.0358353, 0, 0.0620214, 0.977827, 0.035617, 0, 0.0716574, 0.973278, 0.0354398, 0, 0.0818186, 0.967397, 0.0350483, 0, 0.0924846, 0.960696, 0.0344795, 0, 0.103638, 0.954349, 0.0339861, 0, 0.115263, 0.946066, 0.0331323, 0, 0.127348, 0.938012, 0.032359, 0, 0.13988, 0.929413, 0.0314413, 0, 0.152849, 0.920355, 0.0304103, 0, 0.166248, 0.910586, 0.0292785, 0, 0.18007, 0.900609, 0.0281391, 0, 0.194308, 0.890093, 0.0269103, 0, 0.208958, 0.880013, 0.0257269, 0, 0.224018, 0.869001, 0.0244671, 0, 0.239485, 0.85751, 0.0232252, 0, 0.255359, 0.84582, 0.0220117, 0, 0.271638, 0.834383, 0.0208274, 0, 0.288324, 0.822158, 0.0196628, 0, 0.305419, 0.809056, 0.0185306, 0, 0.322927, 0.795832, 0.0174174, 0, 0.340851, 0.782547, 0.0163758, 0, 0.359199, 0.7689, 0.015391, 0, 0.377975, 0.755526, 0.0144488, 0, 0.397189, 0.741681, 0.0135372, 0, 0.416851, 0.728178, 0.0126957, 0, 0.436971, 0.714642, 0.0118812, 0, 0.457564, 0.702756, 0.0111165, 0, 0.478644, 0.69175, 0.0104145, 0, 0.500229, 0.680159, 974439e-8, 0, 0.522339, 0.668073, 911926e-8, 0, 0.544997, 0.655405, 851393e-8, 0, 0.56823, 0.642921, 797637e-8, 0, 0.592068, 0.629993, 745119e-8, 0, 0.616546, 0.616828, 696972e-8, 0, 0.641705, 0.603305, 652425e-8, 0, 0.66759, 0.589833, 610188e-8, 0, 0.694255, 0.575945, 570834e-8, 0, 0.72176, 0.561745, 533384e-8, 0, 0.750168, 0.548277, 500001e-8, 0, 0.779545, 0.534467, 467582e-8, 0, 0.809933, 0.521032, 438092e-8, 0, 0.841272, 0.507877, 410348e-8, 0, 0.873016, 0.494654, 383618e-8, 0, 0.904762, 0.481592, 358699e-8, 0, 0.936508, 0.468509, 337281e-8, 0, 0.968254, 0.455293, 316196e-8, 0, 1, 1, 0.0430698, 0, 0, 1, 0.0430699, 0, 0, 0.999998, 0.0430713, 0, 0, 0.999991, 0.0430773, 0, 0, 0.99997, 0.0430936, 0, 0, 0.999928, 0.0431277, 0, 406396e-10, 0.999852, 0.0431893, 0, 744376e-9, 0.999724, 0.0432895, 0, 24806e-7, 0.999527, 0.0434397, 0, 524779e-8, 0.99923, 0.0436507, 0, 898164e-8, 0.998783, 0.0439255, 0, 0.0136083, 0.997507, 0.0441104, 0, 0.0190582, 0.994418, 0.0438225, 0, 0.0252694, 0.992864, 0.0439396, 0, 0.0321879, 0.991127, 0.0440962, 0, 0.039767, 0.987331, 0.0438408, 0, 0.0479667, 0.984819, 0.0438991, 0, 0.056752, 0.980384, 0.0435906, 0, 0.0660929, 0.975846, 0.0432543, 0, 0.075963, 0.970748, 0.0428293, 0, 0.0863398, 0.964303, 0.042153, 0, 0.0972035, 0.95772, 0.0414111, 0, 0.108537, 0.950747, 0.0405893, 0, 0.120325, 0.942533, 0.0394887, 0, 0.132554, 0.934045, 0.0383544, 0, 0.145215, 0.924942, 0.037057, 0, 0.158296, 0.915811, 0.0356993, 0, 0.17179, 0.90612, 0.0342401, 0, 0.185691, 0.896434, 0.0328078, 0, 0.199993, 0.886021, 0.031288, 0, 0.214691, 0.876081, 0.0297776, 0, 0.229782, 0.865608, 0.0282334, 0, 0.245265, 0.854924, 0.026749, 0, 0.261138, 0.843607, 0.02526, 0, 0.277401, 0.832456, 0.0238214, 0, 0.294056, 0.821342, 0.0224682, 0, 0.311104, 0.809303, 0.0211297, 0, 0.328548, 0.796468, 0.0198387, 0, 0.346394, 0.784046, 0.0186227, 0, 0.364645, 0.771262, 0.0174561, 0, 0.38331, 0.758118, 0.0163806, 0, 0.402396, 0.745075, 0.0153287, 0, 0.421912, 0.731926, 0.0143647, 0, 0.44187, 0.71863, 0.0134363, 0, 0.462283, 0.705414, 0.0125603, 0, 0.483165, 0.693792, 0.0117508, 0, 0.504535, 0.683108, 0.0110016, 0, 0.52641, 0.67183, 0.0102757, 0, 0.548816, 0.66015, 962044e-8, 0, 0.571776, 0.647907, 898031e-8, 0, 0.595323, 0.635734, 840811e-8, 0, 0.619489, 0.623208, 786211e-8, 0, 0.644317, 0.610438, 734953e-8, 0, 0.669852, 0.597345, 687688e-8, 0, 0.696148, 0.584138, 643469e-8, 0, 0.723267, 0.5707, 602236e-8, 0, 0.75128, 0.556966, 56324e-7, 0, 0.780258, 0.543607, 528277e-8, 0, 0.810268, 0.530213, 493999e-8, 0, 0.841311, 0.516912, 462265e-8, 0, 0.873016, 0.503916, 43307e-7, 0, 0.904762, 0.491146, 406858e-8, 0, 0.936508, 0.478439, 381436e-8, 0, 0.968254, 0.465834, 358003e-8, 0, 1, 1, 0.0534039, 0, 0, 1, 0.053404, 0, 0, 0.999998, 0.0534055, 0, 0, 0.999989, 0.0534116, 0, 0, 0.999968, 0.0534283, 0, 0, 0.999918, 0.0534633, 0, 155895e-9, 0.99983, 0.0535262, 0, 120914e-8, 0.999685, 0.0536281, 0, 334944e-8, 0.999461, 0.0537799, 0, 653077e-8, 0.999119, 0.0539902, 0, 0.0106718, 0.998582, 0.0542524, 0, 0.0156907, 0.995919, 0.0540318, 0, 0.0215147, 0.993735, 0.0538914, 0, 0.0280801, 0.992126, 0.0539557, 0, 0.0353323, 0.990266, 0.0540401, 0, 0.0432247, 0.986317, 0.0536064, 0, 0.0517172, 0.983213, 0.0534425, 0, 0.0607754, 0.978303, 0.0528622, 0, 0.0703698, 0.973665, 0.0523363, 0, 0.0804742, 0.968091, 0.0516165, 0, 0.0910667, 0.961026, 0.0505434, 0, 0.102128, 0.954333, 0.049523, 0, 0.113641, 0.946372, 0.0481698, 0, 0.125591, 0.938254, 0.0467674, 0, 0.137965, 0.929516, 0.0452341, 0, 0.150754, 0.920106, 0.0435083, 0, 0.163947, 0.910899, 0.0417399, 0, 0.177537, 0.901532, 0.0399389, 0, 0.191516, 0.891919, 0.0380901, 0, 0.205881, 0.882006, 0.0362341, 0, 0.220626, 0.871965, 0.0343444, 0, 0.235749, 0.862145, 0.0324832, 0, 0.251248, 0.852058, 0.0306681, 0, 0.267121, 0.84161, 0.0289097, 0, 0.283368, 0.830806, 0.0272079, 0, 0.299992, 0.820476, 0.0256089, 0, 0.316992, 0.809514, 0.0240394, 0, 0.334374, 0.797865, 0.0225379, 0, 0.35214, 0.785621, 0.0211235, 0, 0.370296, 0.773765, 0.0197908, 0, 0.388849, 0.761629, 0.0185235, 0, 0.407807, 0.748891, 0.0173358, 0, 0.427178, 0.736437, 0.0162305, 0, 0.446974, 0.723707, 0.0151778, 0, 0.467207, 0.710606, 0.0141791, 0, 0.487892, 0.698019, 0.0132592, 0, 0.509046, 0.686203, 0.0123887, 0, 0.530687, 0.675692, 0.0115976, 0, 0.552839, 0.664826, 0.0108325, 0, 0.575527, 0.65349, 0.0101348, 0, 0.59878, 0.641774, 947756e-8, 0, 0.622634, 0.629794, 886058e-8, 0, 0.647128, 0.617647, 828526e-8, 0, 0.672308, 0.60534, 775312e-8, 0, 0.698231, 0.592718, 726033e-8, 0, 0.724958, 0.579746, 679731e-8, 0, 0.752563, 0.566763, 636111e-8, 0, 0.781127, 0.553515, 595228e-8, 0, 0.810733, 0.540118, 556876e-8, 0, 0.841426, 0.527325, 523051e-8, 0, 0.873016, 0.514265, 490712e-8, 0, 0.904762, 0.501406, 460297e-8, 0, 0.936508, 0.488922, 431247e-8, 0, 0.968254, 0.476541, 40472e-7, 0, 1, 1, 0.0659184, 0, 0, 1, 0.0659185, 0, 0, 0.999998, 0.06592, 0, 0, 0.999988, 0.0659259, 0, 0, 0.999963, 0.0659423, 0, 0, 0.999907, 0.0659764, 0, 374198e-9, 0.999806, 0.0660376, 0, 182071e-8, 0.999639, 0.0661361, 0, 43894e-7, 0.999378, 0.0662814, 0, 800055e-8, 0.998985, 0.0664779, 0, 0.0125594, 0.998285, 0.0666914, 0, 0.0179786, 0.995071, 0.0661989, 0, 0.0241822, 0.993172, 0.0660454, 0, 0.031106, 0.991438, 0.0660105, 0, 0.0386952, 0.988428, 0.0656875, 0, 0.0469032, 0.985218, 0.0652913, 0, 0.0556905, 0.981128, 0.0647107, 0, 0.065023, 0.976015, 0.0638491, 0, 0.0748717, 0.97097, 0.062993, 0, 0.0852112, 0.964582, 0.0617927, 0, 0.0960199, 0.957383, 0.0603626, 0, 0.107279, 0.949969, 0.0588128, 0, 0.118971, 0.941843, 0.0570274, 0, 0.131084, 0.933624, 0.0551885, 0, 0.143604, 0.924543, 0.053122, 0, 0.156521, 0.914919, 0.0508897, 0, 0.169825, 0.905773, 0.0486418, 0, 0.18351, 0.896434, 0.0463364, 0, 0.197569, 0.887195, 0.0440623, 0, 0.211997, 0.877706, 0.0417799, 0, 0.226789, 0.867719, 0.03945, 0, 0.241944, 0.858587, 0.037243, 0, 0.257458, 0.849317, 0.0350956, 0, 0.273331, 0.839585, 0.0329852, 0, 0.289563, 0.829856, 0.0310028, 0, 0.306154, 0.819589, 0.0290953, 0, 0.323108, 0.809714, 0.0272738, 0, 0.340426, 0.79934, 0.0255631, 0, 0.358113, 0.788224, 0.0239175, 0, 0.376175, 0.776619, 0.0223831, 0, 0.394616, 0.76521, 0.0209298, 0, 0.413445, 0.753716, 0.0195786, 0, 0.432671, 0.741564, 0.0183001, 0, 0.452305, 0.729413, 0.0171259, 0, 0.472358, 0.717146, 0.0159933, 0, 0.492845, 0.70436, 0.0149495, 0, 0.513783, 0.69219, 0.0139681, 0, 0.535189, 0.680289, 0.0130577, 0, 0.557087, 0.669611, 0.0122198, 0, 0.5795, 0.659113, 0.0114174, 0, 0.602459, 0.648148, 0.0106729, 0, 0.625997, 0.636905, 998997e-8, 0, 0.650154, 0.625154, 934313e-8, 0, 0.674976, 0.613481, 874839e-8, 0, 0.700518, 0.60154, 818265e-8, 0, 0.726845, 0.58943, 766889e-8, 0, 0.754032, 0.576828, 717153e-8, 0, 0.782167, 0.564194, 672696e-8, 0, 0.811344, 0.551501, 630863e-8, 0, 0.841644, 0.538635, 592177e-8, 0, 0.873016, 0.525724, 554888e-8, 0, 0.904762, 0.513209, 520225e-8, 0, 0.936508, 0.500457, 488231e-8, 0, 0.968254, 0.48799, 457153e-8, 0, 1, 1, 0.0810131, 0, 0, 1, 0.0810133, 0, 0, 0.999997, 0.0810145, 0, 0, 0.999985, 0.08102, 0, 0, 0.999956, 0.0810347, 0, 195026e-10, 0.999893, 0.0810656, 0, 719316e-9, 0.999777, 0.0811205, 0, 259774e-8, 0.999583, 0.081208, 0, 561807e-8, 0.999281, 0.0813343, 0, 967472e-8, 0.998813, 0.0814969, 0, 0.0146627, 0.997597, 0.0815217, 0, 0.0204902, 0.994379, 0.0808502, 0, 0.0270802, 0.992744, 0.0806792, 0, 0.0343674, 0.990745, 0.0804589, 0, 0.0422974, 0.986646, 0.0796107, 0, 0.0508242, 0.983611, 0.0790913, 0, 0.0599087, 0.978869, 0.0780746, 0, 0.0695175, 0.973475, 0.0768218, 0, 0.0796223, 0.967845, 0.0754926, 0, 0.0901983, 0.960778, 0.0737063, 0, 0.101224, 0.953333, 0.0718052, 0, 0.112682, 0.945274, 0.0695946, 0, 0.124555, 0.936955, 0.0672492, 0, 0.136831, 0.928319, 0.0647732, 0, 0.149496, 0.919075, 0.0620947, 0, 0.162542, 0.909114, 0.0591816, 0, 0.175958, 0.900137, 0.0563917, 0, 0.189739, 0.891069, 0.0535392, 0, 0.203877, 0.882262, 0.0507642, 0, 0.218368, 0.873232, 0.0479793, 0, 0.233208, 0.864042, 0.045226, 0, 0.248393, 0.855002, 0.0425413, 0, 0.263923, 0.846569, 0.0400126, 0, 0.279796, 0.837714, 0.0375269, 0, 0.296012, 0.828918, 0.0352027, 0, 0.312573, 0.819783, 0.0330011, 0, 0.329479, 0.810129, 0.0308908, 0, 0.346734, 0.800866, 0.0289112, 0, 0.364342, 0.79093, 0.0270255, 0, 0.382307, 0.780593, 0.0252758, 0, 0.400637, 0.769511, 0.0236178, 0, 0.419337, 0.758558, 0.0220652, 0, 0.438418, 0.747632, 0.0206289, 0, 0.457889, 0.736146, 0.0192873, 0, 0.477761, 0.724093, 0.0180333, 0, 0.49805, 0.71234, 0.0168264, 0, 0.51877, 0.700201, 0.015746, 0, 0.53994, 0.687949, 0.0147027, 0, 0.561581, 0.676163, 0.0137512, 0, 0.583718, 0.665001, 0.0128655, 0, 0.60638, 0.65472, 0.0120366, 0, 0.629599, 0.644213, 0.0112604, 0, 0.653415, 0.633382, 0.0105413, 0, 0.677874, 0.62212, 986498e-8, 0, 0.70303, 0.610631, 923308e-8, 0, 0.728948, 0.599078, 864206e-8, 0, 0.755706, 0.587519, 811784e-8, 0, 0.783396, 0.575505, 761237e-8, 0, 0.812121, 0.563148, 713949e-8, 0, 0.841989, 0.550828, 668379e-8, 0, 0.873035, 0.538458, 627715e-8, 0, 0.904762, 0.525905, 588336e-8, 0, 0.936508, 0.513517, 552687e-8, 0, 0.968254, 0.501395, 519681e-8, 0, 1, 1, 0.0991506, 0, 0, 1, 0.0991504, 0, 0, 0.999996, 0.0991515, 0, 0, 0.999984, 0.0991558, 0, 0, 0.999947, 0.0991672, 0, 114389e-9, 0.999874, 0.0991912, 0, 121503e-8, 0.999739, 0.0992331, 0, 356108e-8, 0.999514, 0.0992983, 0, 705578e-8, 0.999159, 0.0993877, 0, 0.011574, 0.998586, 0.0994837, 0, 0.017003, 0.995731, 0.0988425, 0, 0.0232484, 0.993384, 0.098276, 0, 0.0302318, 0.991615, 0.0979269, 0, 0.0378884, 0.989029, 0.0973432, 0, 0.0461641, 0.985373, 0.0963539, 0, 0.0550136, 0.981278, 0.0952306, 0, 0.0643988, 0.975777, 0.0936233, 0, 0.0742868, 0.970526, 0.0920219, 0, 0.0846501, 0.963755, 0.0898912, 0, 0.0954644, 0.956676, 0.0876064, 0, 0.106709, 0.948099, 0.0847751, 0, 0.118367, 0.939718, 0.0818638, 0, 0.130423, 0.931305, 0.078857, 0, 0.142862, 0.922342, 0.0756127, 0, 0.155674, 0.912842, 0.0721473, 0, 0.168849, 0.903304, 0.0686195, 0, 0.182378, 0.89411, 0.0650589, 0, 0.196255, 0.885512, 0.0616022, 0, 0.210473, 0.877193, 0.0582434, 0, 0.225027, 0.86877, 0.0548979, 0, 0.239915, 0.860267, 0.0516095, 0, 0.255132, 0.851915, 0.048468, 0, 0.270678, 0.843912, 0.0454447, 0, 0.286551, 0.83604, 0.0425612, 0, 0.302751, 0.828245, 0.0398752, 0, 0.31928, 0.820159, 0.0373198, 0, 0.336138, 0.81167, 0.034916, 0, 0.35333, 0.802659, 0.0326402, 0, 0.370858, 0.793921, 0.0304901, 0, 0.388728, 0.784713, 0.0284857, 0, 0.406944, 0.774946, 0.0266186, 0, 0.425515, 0.76448, 0.0248593, 0, 0.444449, 0.753793, 0.0232114, 0, 0.463756, 0.743506, 0.0217039, 0, 0.483447, 0.732555, 0.0202841, 0, 0.503535, 0.720965, 0.0189648, 0, 0.524036, 0.709422, 0.0177189, 0, 0.544968, 0.697756, 0.0165626, 0, 0.56635, 0.685565, 0.015483, 0, 0.588208, 0.673987, 0.0144892, 0, 0.610569, 0.66244, 0.0135607, 0, 0.633466, 0.651675, 0.0126956, 0, 0.656936, 0.641598, 0.0118788, 0, 0.681025, 0.63121, 0.0111261, 0, 0.705788, 0.620514, 0.010437, 0, 0.731289, 0.609366, 978747e-8, 0, 0.757606, 0.598137, 917257e-8, 0, 0.784834, 0.586966, 859778e-8, 0, 0.813085, 0.575549, 806803e-8, 0, 0.842485, 0.563797, 757294e-8, 0, 0.87313, 0.551758, 710592e-8, 0, 0.904762, 0.539894, 66841e-7, 0, 0.936508, 0.527901, 627901e-8, 0, 0.968254, 0.515819, 590506e-8, 0, 1, 1, 0.120864, 0, 0, 1, 0.120864, 0, 0, 0.999996, 0.120864, 0, 0, 0.99998, 0.120867, 0, 0, 0.99994, 0.120872, 0, 323781e-9, 0.999852, 0.120884, 0, 188693e-8, 0.999693, 0.120903, 0, 473489e-8, 0.999426, 0.120929, 0, 872704e-8, 0.999002, 0.120955, 0, 0.0137237, 0.998235, 0.120918, 0, 0.0196068, 0.994608, 0.119764, 0, 0.0262803, 0.992997, 0.119265, 0, 0.0336657, 0.990968, 0.11863, 0, 0.0416987, 0.987002, 0.117261, 0, 0.0503261, 0.983524, 0.116009, 0, 0.0595035, 0.97875, 0.114252, 0, 0.0691935, 0.972652, 0.11193, 0, 0.0793645, 0.966613, 0.109555, 0, 0.0899894, 0.959275, 0.106612, 0, 0.101045, 0.951272, 0.103375, 0, 0.112512, 0.942323, 0.0996594, 0, 0.124372, 0.933679, 0.0958841, 0, 0.136611, 0.924822, 0.0919265, 0, 0.149216, 0.915742, 0.0878061, 0, 0.162176, 0.906348, 0.0834894, 0, 0.175482, 0.896883, 0.079085, 0, 0.189125, 0.88774, 0.0746745, 0, 0.203098, 0.87986, 0.0705773, 0, 0.217396, 0.871998, 0.0665005, 0, 0.232015, 0.864325, 0.0625413, 0, 0.24695, 0.856685, 0.0586781, 0, 0.2622, 0.84925, 0.0550063, 0, 0.277761, 0.841719, 0.0514727, 0, 0.293634, 0.834755, 0.0481398, 0, 0.309819, 0.827853, 0.0450172, 0, 0.326315, 0.820888, 0.0420969, 0, 0.343126, 0.813616, 0.0393702, 0, 0.360254, 0.805767, 0.0367771, 0, 0.377701, 0.797338, 0.0343274, 0, 0.395474, 0.789122, 0.0320529, 0, 0.413577, 0.780601, 0.0299485, 0, 0.432018, 0.771424, 0.0279812, 0, 0.450804, 0.761502, 0.0261054, 0, 0.469944, 0.751166, 0.0243942, 0, 0.489451, 0.741276, 0.0228087, 0, 0.509337, 0.730898, 0.0213265, 0, 0.529617, 0.719878, 0.0199307, 0, 0.550307, 0.708379, 0.0186574, 0, 0.571428, 0.697165, 0.0174446, 0, 0.593003, 0.685554, 0.0163144, 0, 0.615059, 0.673631, 0.015276, 0, 0.637628, 0.662385, 0.0143003, 0, 0.660746, 0.651059, 0.0134112, 0, 0.68446, 0.640451, 0.0125794, 0, 0.70882, 0.630536, 0.011793, 0, 0.733893, 0.620316, 0.0110547, 0, 0.759756, 0.609722, 0.0103668, 0, 0.786505, 0.598804, 973009e-8, 0, 0.814259, 0.587871, 912812e-8, 0, 0.843157, 0.577121, 858916e-8, 0, 0.87334, 0.566019, 807333e-8, 0, 0.904762, 0.554664, 759687e-8, 0, 0.936508, 0.543101, 714759e-8, 0, 0.968254, 0.531558, 673418e-8, 0, 1, 1, 0.146767, 0, 0, 1, 0.146767, 0, 0, 0.999997, 0.146767, 0, 0, 0.999977, 0.146765, 0, 320658e-11, 0.999929, 0.146762, 0, 682576e-9, 0.999823, 0.146753, 0, 276402e-8, 0.999633, 0.146735, 0, 614771e-8, 0.999314, 0.146699, 0, 0.0106613, 0.998796, 0.14662, 0, 0.0161546, 0.997124, 0.146107, 0, 0.0225063, 0.994062, 0.144857, 0, 0.0296198, 0.992154, 0.144011, 0, 0.037417, 0.989186, 0.142712, 0, 0.0458348, 0.985279, 0.140926, 0, 0.0548211, 0.980826, 0.13885, 0, 0.0643326, 0.975056, 0.136168, 0, 0.074333, 0.969005, 0.133217, 0, 0.0847917, 0.961554, 0.12959, 0, 0.0956828, 0.954206, 0.125886, 0, 0.106984, 0.945046, 0.121335, 0, 0.118675, 0.935678, 0.116492, 0, 0.130741, 0.926748, 0.111635, 0, 0.143166, 0.917764, 0.106625, 0, 0.155939, 0.908358, 0.101325, 0, 0.169049, 0.899219, 0.0960249, 0, 0.182487, 0.890089, 0.0906527, 0, 0.196245, 0.881488, 0.0853905, 0, 0.210317, 0.874031, 0.0804177, 0, 0.224697, 0.866932, 0.0756005, 0, 0.23938, 0.859976, 0.0709019, 0, 0.254364, 0.853375, 0.0664391, 0, 0.269646, 0.846971, 0.0622012, 0, 0.285223, 0.840483, 0.058129, 0, 0.301096, 0.833969, 0.0542762, 0, 0.317265, 0.82806, 0.0507042, 0, 0.333729, 0.822128, 0.047368, 0, 0.350491, 0.815989, 0.044272, 0, 0.367554, 0.809336, 0.0413444, 0, 0.38492, 0.802177, 0.038601, 0, 0.402594, 0.79441, 0.0360227, 0, 0.420582, 0.786573, 0.0336383, 0, 0.438891, 0.778619, 0.0314321, 0, 0.457527, 0.77, 0.029362, 0, 0.476499, 0.760698, 0.0274102, 0, 0.49582, 0.750932, 0.0256146, 0, 0.5155, 0.740993, 0.023974, 0, 0.535555, 0.731159, 0.0224182, 0, 0.556, 0.720836, 0.0209889, 0, 0.576855, 0.709913, 0.0196411, 0, 0.598143, 0.698415, 0.0183824, 0, 0.619888, 0.68745, 0.0172222, 0, 0.642123, 0.676154, 0.0161509, 0, 0.664883, 0.664383, 0.0151397, 0, 0.688211, 0.6533, 0.0141873, 0, 0.71216, 0.642072, 0.0133105, 0, 0.736792, 0.631412, 0.0124932, 0, 0.762186, 0.621622, 0.0117408, 0, 0.788439, 0.611681, 0.0110358, 0, 0.815672, 0.60142, 0.0103775, 0, 0.844034, 0.59083, 975623e-8, 0, 0.873699, 0.580254, 918084e-8, 0, 0.904765, 0.569841, 864721e-8, 0, 0.936508, 0.559224, 815731e-8, 0, 0.968254, 0.548315, 767924e-8, 0, 1, 1, 0.177563, 0, 0, 1, 0.177563, 0, 0, 0.999994, 0.177562, 0, 0, 0.999972, 0.177555, 0, 664171e-10, 0.999914, 0.177536, 0, 12276e-7, 0.999787, 0.177496, 0, 388025e-8, 0.999556, 0.17742, 0, 783463e-8, 0.999165, 0.177285, 0, 0.0128953, 0.9985, 0.177037, 0, 0.0189053, 0.995388, 0.175634, 0, 0.025742, 0.993102, 0.174375, 0, 0.033309, 0.990992, 0.173121, 0, 0.0415298, 0.986932, 0.170896, 0, 0.0503425, 0.982786, 0.16847, 0, 0.0596964, 0.977592, 0.165455, 0, 0.0695498, 0.971075, 0.161676, 0, 0.0798676, 0.963967, 0.157458, 0, 0.0906201, 0.956397, 0.152836, 0, 0.101783, 0.947489, 0.147467, 0, 0.113333, 0.937564, 0.14145, 0, 0.125254, 0.928182, 0.135383, 0, 0.137529, 0.919027, 0.129212, 0, 0.150144, 0.909618, 0.12276, 0, 0.163088, 0.900492, 0.116273, 0, 0.176351, 0.891671, 0.1098, 0, 0.189924, 0.883146, 0.103362, 0, 0.203799, 0.875151, 0.0970799, 0, 0.21797, 0.868338, 0.0911732, 0, 0.232433, 0.862033, 0.0854966, 0, 0.247182, 0.856107, 0.0800691, 0, 0.262216, 0.850644, 0.0749618, 0, 0.27753, 0.845261, 0.070079, 0, 0.293124, 0.839885, 0.0654321, 0, 0.308997, 0.834609, 0.0610975, 0, 0.325149, 0.829083, 0.0569741, 0, 0.341581, 0.82404, 0.0531736, 0, 0.358294, 0.818968, 0.049665, 0, 0.37529, 0.813496, 0.0463856, 0, 0.392573, 0.807533, 0.0433217, 0, 0.410148, 0.80099, 0.0404402, 0, 0.428019, 0.793891, 0.0377578, 0, 0.446192, 0.786281, 0.0352616, 0, 0.464676, 0.778773, 0.0329577, 0, 0.483478, 0.770737, 0.030808, 0, 0.502608, 0.762094, 0.0287964, 0, 0.522079, 0.752898, 0.0269254, 0, 0.541905, 0.743306, 0.0251926, 0, 0.5621, 0.733416, 0.023595, 0, 0.582684, 0.723742, 0.0221155, 0, 0.603677, 0.713542, 0.0207435, 0, 0.625106, 0.702755, 0.019434, 0, 0.646998, 0.691484, 0.0182046, 0, 0.66939, 0.680531, 0.0170771, 0, 0.692324, 0.66953, 0.0160339, 0, 0.715849, 0.658126, 0.0150677, 0, 0.740028, 0.646933, 0.0141551, 0, 0.764937, 0.636107, 0.0133179, 0, 0.790673, 0.625271, 0.0125284, 0, 0.817358, 0.615225, 0.0117937, 0, 0.84515, 0.605678, 0.0111181, 0, 0.874244, 0.59583, 0.0104759, 0, 0.904828, 0.585704, 986672e-8, 0, 0.936508, 0.575413, 929712e-8, 0, 0.968254, 0.565373, 876713e-8, 0, 1, 1, 0.214058, 0, 0, 0.999999, 0.214058, 0, 0, 0.999994, 0.214055, 0, 0, 0.999966, 0.214039, 0, 259642e-9, 0.999893, 0.213998, 0, 200075e-8, 0.999737, 0.21391, 0, 527775e-8, 0.999449, 0.213745, 0, 983959e-8, 0.99896, 0.213458, 0, 0.0154755, 0.9979, 0.212855, 0, 0.0220249, 0.994278, 0.210779, 0, 0.0293654, 0.992254, 0.20926, 0, 0.0374021, 0.98881, 0.206908, 0, 0.0460604, 0.984715, 0.204009, 0, 0.0552802, 0.979738, 0.200471, 0, 0.0650127, 0.972884, 0.195813, 0, 0.0752175, 0.965996, 0.190856, 0, 0.0858612, 0.957974, 0.185077, 0, 0.0969155, 0.949155, 0.17868, 0, 0.108356, 0.939288, 0.171513, 0, 0.120163, 0.928996, 0.163838, 0, 0.132319, 0.919563, 0.156246, 0, 0.144808, 0.910004, 0.148359, 0, 0.157618, 0.900791, 0.140417, 0, 0.170737, 0.892135, 0.132569, 0, 0.184155, 0.883803, 0.124741, 0, 0.197866, 0.876034, 0.117091, 0, 0.211861, 0.869219, 0.109835, 0, 0.226134, 0.863062, 0.102859, 0, 0.240682, 0.857795, 0.0962928, 0, 0.255499, 0.853009, 0.0900725, 0, 0.270583, 0.848603, 0.0842101, 0, 0.285931, 0.844335, 0.0786527, 0, 0.301542, 0.840208, 0.0734397, 0, 0.317415, 0.836035, 0.0685334, 0, 0.33355, 0.83172, 0.0639275, 0, 0.349948, 0.827135, 0.0595909, 0, 0.36661, 0.822797, 0.0556204, 0, 0.383539, 0.818387, 0.0519394, 0, 0.400738, 0.813565, 0.0485317, 0, 0.41821, 0.808142, 0.0453138, 0, 0.435961, 0.802212, 0.0423354, 0, 0.453997, 0.79573, 0.0395553, 0, 0.472324, 0.788741, 0.036988, 0, 0.490951, 0.781093, 0.0345688, 0, 0.509887, 0.773597, 0.0323297, 0, 0.529144, 0.765622, 0.0302719, 0, 0.548735, 0.757083, 0.0283477, 0, 0.568674, 0.747992, 0.0265562, 0, 0.588979, 0.738591, 0.0248844, 0, 0.609671, 0.728719, 0.0233342, 0, 0.630773, 0.719146, 0.0219081, 0, 0.652314, 0.709165, 0.0205711, 0, 0.674328, 0.69875, 0.0193248, 0, 0.696854, 0.687884, 0.0181582, 0, 0.719942, 0.676818, 0.0170746, 0, 0.743651, 0.666247, 0.0160718, 0, 0.768057, 0.655284, 0.0151262, 0, 0.793253, 0.64401, 0.0142561, 0, 0.819363, 0.633353, 0.0134327, 0, 0.846547, 0.622674, 0.012653, 0, 0.875017, 0.612265, 0.0119354, 0, 0.905021, 0.602455, 0.0112533, 0, 0.936508, 0.593147, 0.0106234, 0, 0.968254, 0.583592, 0.0100213, 0, 1, 1, 0.25717, 0, 0, 1, 0.25717, 0, 0, 0.999992, 0.257164, 0, 0, 0.999958, 0.257135, 0, 641715e-9, 0.999864, 0.25706, 0, 305314e-8, 0.999666, 0.256897, 0, 700975e-8, 0.999302, 0.256596, 0, 0.0122194, 0.998663, 0.25607, 0, 0.0184622, 0.995607, 0.254123, 0, 0.0255773, 0.993094, 0.252081, 0, 0.0334439, 0.9907, 0.249867, 0, 0.0419696, 0.98594, 0.246118, 0, 0.0510823, 0.981214, 0.242049, 0, 0.0607242, 0.974966, 0.236869, 0, 0.0708486, 0.967589, 0.230724, 0, 0.081417, 0.95915, 0.223635, 0, 0.0923974, 0.950257, 0.21596, 0, 0.103763, 0.940165, 0.207296, 0, 0.115491, 0.929396, 0.197901, 0, 0.127562, 0.919288, 0.188437, 0, 0.13996, 0.909428, 0.178762, 0, 0.15267, 0.900105, 0.169072, 0, 0.165679, 0.891418, 0.159478, 0, 0.178979, 0.883347, 0.15002, 0, 0.192558, 0.875992, 0.140813, 0, 0.20641, 0.869466, 0.13196, 0, 0.220529, 0.863699, 0.123501, 0, 0.234907, 0.858553, 0.115436, 0, 0.249542, 0.854379, 0.107901, 0, 0.264428, 0.850894, 0.10088, 0, 0.279564, 0.847632, 0.0942296, 0, 0.294947, 0.844571, 0.0879861, 0, 0.310575, 0.84163, 0.0821534, 0, 0.326448, 0.838542, 0.0766409, 0, 0.342566, 0.835412, 0.0715322, 0, 0.358929, 0.831899, 0.0666883, 0, 0.37554, 0.828177, 0.0622175, 0, 0.392399, 0.82416, 0.0580452, 0, 0.409511, 0.820393, 0.054267, 0, 0.426878, 0.816068, 0.0507172, 0, 0.444506, 0.811201, 0.0474041, 0, 0.4624, 0.805785, 0.0443174, 0, 0.480566, 0.799878, 0.0414562, 0, 0.499013, 0.793469, 0.0388147, 0, 0.517749, 0.786473, 0.0363453, 0, 0.536785, 0.778874, 0.0340225, 0, 0.556134, 0.771277, 0.0318599, 0, 0.575809, 0.763426, 0.0298859, 0, 0.595827, 0.755044, 0.0280357, 0, 0.616207, 0.746161, 0.0262979, 0, 0.636973, 0.737124, 0.0247295, 0, 0.65815, 0.72761, 0.0232514, 0, 0.679772, 0.717822, 0.0218755, 0, 0.701876, 0.708279, 0.0205942, 0, 0.724509, 0.698333, 0.0193947, 0, 0.74773, 0.68802, 0.0182717, 0, 0.771609, 0.677321, 0.0172044, 0, 0.79624, 0.666504, 0.0162122, 0, 0.821743, 0.656184, 0.0152924, 0, 0.84828, 0.64556, 0.0144326, 0, 0.876069, 0.634636, 0.0136157, 0, 0.905404, 0.624124, 0.0128612, 0, 0.936508, 0.613914, 0.0121435, 0, 0.968254, 0.603589, 0.0114887, 0, 1, 1, 0.307946, 0, 0, 0.999999, 0.307945, 0, 0, 0.999988, 0.307934, 0, 204479e-10, 0.999944, 0.307886, 0, 127833e-8, 0.999824, 0.307756, 0, 445047e-8, 0.999565, 0.30748, 0, 914673e-8, 0.999085, 0.306966, 0, 0.0150498, 0.998103, 0.306004, 0, 0.0219367, 0.994249, 0.303028, 0, 0.0296485, 0.991807, 0.300435, 0, 0.038068, 0.987773, 0.296554, 0, 0.0471062, 0.982673, 0.2916, 0, 0.0566942, 0.976623, 0.285641, 0, 0.0667768, 0.968757, 0.27815, 0, 0.0773099, 0.959849, 0.269529, 0, 0.088257, 0.950663, 0.260248, 0, 0.0995879, 0.940129, 0.249704, 0, 0.111277, 0.92895, 0.238291, 0, 0.123304, 0.917996, 0.226501, 0, 0.13565, 0.907813, 0.214669, 0, 0.148299, 0.898305, 0.202835, 0, 0.161237, 0.889626, 0.191158, 0, 0.174455, 0.88175, 0.179695, 0, 0.187941, 0.874715, 0.168548, 0, 0.201687, 0.868746, 0.15792, 0, 0.215687, 0.863703, 0.147807, 0, 0.229933, 0.859315, 0.138149, 0, 0.24442, 0.855538, 0.128993, 0, 0.259145, 0.852428, 0.120414, 0, 0.274103, 0.850168, 0.112498, 0, 0.289293, 0.848132, 0.105054, 0, 0.304711, 0.846291, 0.0981087, 0, 0.320357, 0.844431, 0.0915942, 0, 0.33623, 0.842493, 0.0855056, 0, 0.35233, 0.840368, 0.0798204, 0, 0.368658, 0.83798, 0.0745097, 0, 0.385214, 0.83523, 0.0695424, 0, 0.402002, 0.832091, 0.0649092, 0, 0.419023, 0.828667, 0.0606291, 0, 0.436282, 0.824805, 0.0566523, 0, 0.453782, 0.820988, 0.0530229, 0, 0.471529, 0.816635, 0.0496364, 0, 0.489528, 0.811725, 0.0464658, 0, 0.507788, 0.806316, 0.0435082, 0, 0.526317, 0.800469, 0.0407873, 0, 0.545124, 0.794107, 0.038255, 0, 0.564221, 0.787218, 0.0358825, 0, 0.583621, 0.779872, 0.0336785, 0, 0.603341, 0.772097, 0.0316379, 0, 0.623397, 0.764484, 0.0297379, 0, 0.643812, 0.756428, 0.0279581, 0, 0.664611, 0.748022, 0.0263153, 0, 0.685824, 0.739268, 0.0247799, 0, 0.707488, 0.73024, 0.0233385, 0, 0.729646, 0.720893, 0.0220035, 0, 0.752354, 0.71119, 0.0207555, 0, 0.77568, 0.701791, 0.0195843, 0, 0.799715, 0.692184, 0.0184891, 0, 0.824574, 0.682258, 0.0174541, 0, 0.850417, 0.67206, 0.0164873, 0, 0.877466, 0.661717, 0.0155959, 0, 0.90604, 0.651462, 0.0147519, 0, 0.936528, 0.641467, 0.0139727, 0, 0.968254, 0.631229, 0.0132363, 0, 1, 1, 0.367573, 0, 0, 0.999999, 0.367571, 0, 0, 0.999984, 0.367553, 0, 183382e-9, 0.999925, 0.367473, 0, 225254e-8, 0.999759, 0.367259, 0, 628165e-8, 0.99941, 0.366801, 0, 0.0117858, 0.998739, 0.365946, 0, 0.0184359, 0.995529, 0.363191, 0, 0.0260114, 0.992875, 0.360171, 0, 0.0343581, 0.989135, 0.355981, 0, 0.0433637, 0.984166, 0.350401, 0, 0.0529438, 0.977871, 0.343348, 0, 0.0630334, 0.96951, 0.334341, 0, 0.0735805, 0.959964, 0.323862, 0, 0.0845437, 0.950162, 0.312521, 0, 0.095889, 0.938882, 0.299577, 0, 0.107588, 0.926992, 0.285573, 0, 0.119617, 0.915589, 0.271212, 0, 0.131957, 0.904791, 0.256611, 0, 0.144591, 0.895177, 0.242224, 0, 0.157503, 0.886403, 0.227952, 0, 0.170682, 0.878957, 0.214192, 0, 0.184117, 0.872418, 0.200795, 0, 0.197799, 0.867029, 0.188015, 0, 0.21172, 0.862835, 0.175975, 0, 0.225873, 0.859411, 0.164526, 0, 0.240253, 0.856655, 0.153693, 0, 0.254854, 0.854519, 0.14352, 0, 0.269673, 0.852828, 0.13397, 0, 0.284707, 0.851412, 0.124984, 0, 0.299953, 0.850609, 0.116748, 0, 0.315408, 0.849855, 0.10905, 0, 0.331073, 0.849017, 0.101839, 0, 0.346946, 0.848079, 0.0951359, 0, 0.363028, 0.846911, 0.0888774, 0, 0.379318, 0.845445, 0.0830375, 0, 0.395818, 0.84362, 0.0775844, 0, 0.41253, 0.841411, 0.0725054, 0, 0.429457, 0.838768, 0.0677691, 0, 0.446602, 0.835801, 0.0634016, 0, 0.463968, 0.832341, 0.0593095, 0, 0.481561, 0.828424, 0.0555121, 0, 0.499386, 0.824312, 0.052024, 0, 0.51745, 0.819918, 0.0487865, 0, 0.535761, 0.815072, 0.0457801, 0, 0.554328, 0.809863, 0.0430184, 0, 0.573162, 0.804164, 0.0404245, 0, 0.592275, 0.798034, 0.0380146, 0, 0.611681, 0.791436, 0.0357436, 0, 0.631398, 0.784498, 0.0336475, 0, 0.651445, 0.777125, 0.0316666, 0, 0.671845, 0.769365, 0.0298122, 0, 0.692628, 0.761579, 0.0281001, 0, 0.713827, 0.753746, 0.0265049, 0, 0.735484, 0.745573, 0.0250067, 0, 0.75765, 0.737083, 0.0236026, 0, 0.78039, 0.728545, 0.0223302, 0, 0.803789, 0.719691, 0.0211243, 0, 0.82796, 0.710569, 0.0199983, 0, 0.853056, 0.701216, 0.0189569, 0, 0.879298, 0.692094, 0.0179702, 0, 0.907014, 0.682909, 0.0170418, 0, 0.936691, 0.673509, 0.0161732, 0, 0.968254, 0.663863, 0.0153406, 0, 1, 1, 0.437395, 0, 0, 0.999998, 0.437394, 0, 0, 0.99998, 0.437363, 0, 616704e-9, 0.999891, 0.437232, 0, 367925e-8, 0.999656, 0.436877, 0, 867446e-8, 0.999148, 0.436121, 0, 0.0150679, 0.997959, 0.434564, 0, 0.022531, 0.993464, 0.430134, 0, 0.0308507, 0.990606, 0.426077, 0, 0.0398805, 0.985027, 0.419397, 0, 0.0495148, 0.978491, 0.41118, 0, 0.0596749, 0.969643, 0.40048, 0, 0.0703001, 0.959189, 0.38769, 0, 0.0813427, 0.948223, 0.373575, 0, 0.0927641, 0.935955, 0.357622, 0, 0.104533, 0.923237, 0.34043, 0, 0.116624, 0.911074, 0.322735, 0, 0.129015, 0.899724, 0.30479, 0, 0.141687, 0.890189, 0.287392, 0, 0.154626, 0.881796, 0.270248, 0, 0.167818, 0.874781, 0.253659, 0, 0.181252, 0.869166, 0.237786, 0, 0.194918, 0.864725, 0.222618, 0, 0.208807, 0.861565, 0.208356, 0, 0.222913, 0.859284, 0.194867, 0, 0.237229, 0.857677, 0.18212, 0, 0.25175, 0.856714, 0.17018, 0, 0.266473, 0.856155, 0.158969, 0, 0.281392, 0.8558, 0.148413, 0, 0.296505, 0.855672, 0.138578, 0, 0.311811, 0.855538, 0.129345, 0, 0.327306, 0.855689, 0.120861, 0, 0.342991, 0.855767, 0.112969, 0, 0.358864, 0.855618, 0.105593, 0, 0.374925, 0.85525, 0.0987451, 0, 0.391176, 0.854583, 0.0923727, 0, 0.407616, 0.853534, 0.0864143, 0, 0.424249, 0.852061, 0.0808338, 0, 0.441076, 0.850253, 0.0756771, 0, 0.4581, 0.848004, 0.0708612, 0, 0.475324, 0.845333, 0.0663784, 0, 0.492754, 0.842376, 0.0622631, 0, 0.510394, 0.838956, 0.0584112, 0, 0.528251, 0.835121, 0.0548328, 0, 0.546331, 0.830842, 0.0514838, 0, 0.564644, 0.826212, 0.048355, 0, 0.583198, 0.821522, 0.0454714, 0, 0.602005, 0.816551, 0.0428263, 0, 0.621078, 0.811211, 0.0403612, 0, 0.640434, 0.805479, 0.038039, 0, 0.660089, 0.799409, 0.0358739, 0, 0.680066, 0.79306, 0.0338727, 0, 0.70039, 0.786395, 0.0319985, 0, 0.721094, 0.779416, 0.030241, 0, 0.742215, 0.77214, 0.0285951, 0, 0.7638, 0.764636, 0.0270747, 0, 0.785912, 0.756836, 0.0256354, 0, 0.808628, 0.749315, 0.0243027, 0, 0.832055, 0.741561, 0.0230497, 0, 0.856338, 0.733589, 0.0218801, 0, 0.88169, 0.725479, 0.020784, 0, 0.908441, 0.717255, 0.0197702, 0, 0.937125, 0.708829, 0.0188168, 0, 0.968254, 0.700191, 0.0179113, 0, 1, 1, 0.518937, 0, 0, 0.999998, 0.518933, 0, 0, 0.999967, 0.518883, 0, 147741e-8, 0.999832, 0.51866, 0, 573221e-8, 0.999466, 0.518057, 0, 0.011826, 0.998644, 0.516752, 0, 0.0192116, 0.994458, 0.512347, 0, 0.027573, 0.991223, 0.507675, 0, 0.0367099, 0.985515, 0.500188, 0, 0.046487, 0.978308, 0.490408, 0, 0.0568071, 0.968359, 0.477357, 0, 0.0675984, 0.95682, 0.461752, 0, 0.0788059, 0.943929, 0.443796, 0, 0.090386, 0.930224, 0.423893, 0, 0.102304, 0.916514, 0.402682, 0, 0.114532, 0.903653, 0.380914, 0, 0.127047, 0.892315, 0.359212, 0, 0.139828, 0.882942, 0.338102, 0, 0.152861, 0.875438, 0.31773, 0, 0.16613, 0.869642, 0.298186, 0, 0.179624, 0.865304, 0.279491, 0, 0.193332, 0.862382, 0.261804, 0, 0.207247, 0.860666, 0.245146, 0, 0.22136, 0.859788, 0.229406, 0, 0.235666, 0.859608, 0.214605, 0, 0.250158, 0.859912, 0.200691, 0, 0.264832, 0.86053, 0.187623, 0, 0.279684, 0.861368, 0.17539, 0, 0.294711, 0.862237, 0.163901, 0, 0.309911, 0.863127, 0.153175, 0, 0.32528, 0.863923, 0.143147, 0, 0.340819, 0.864567, 0.133781, 0, 0.356524, 0.865013, 0.125042, 0, 0.372397, 0.86539, 0.116952, 0, 0.388438, 0.865591, 0.109476, 0, 0.404645, 0.865517, 0.102542, 0, 0.421022, 0.865084, 0.0960688, 0, 0.437569, 0.864309, 0.0900499, 0, 0.454287, 0.863151, 0.0844328, 0, 0.471181, 0.861649, 0.0792218, 0, 0.488253, 0.859742, 0.0743482, 0, 0.505507, 0.857446, 0.0697963, 0, 0.522947, 0.854757, 0.0655364, 0, 0.54058, 0.851783, 0.061608, 0, 0.558412, 0.848516, 0.0579701, 0, 0.576449, 0.844897, 0.0545742, 0, 0.594701, 0.840956, 0.0514167, 0, 0.613178, 0.836676, 0.0484598, 0, 0.631892, 0.832075, 0.0456934, 0, 0.650856, 0.827191, 0.0431178, 0, 0.670088, 0.822295, 0.0407718, 0, 0.689606, 0.817294, 0.0386032, 0, 0.709434, 0.812013, 0.0365675, 0, 0.7296, 0.806465, 0.0346547, 0, 0.750138, 0.800691, 0.0328717, 0, 0.771093, 0.794709, 0.031211, 0, 0.792519, 0.788493, 0.0296504, 0, 0.814488, 0.782049, 0.0281782, 0, 0.837097, 0.775403, 0.0267965, 0, 0.860481, 0.76857, 0.0255002, 0, 0.884842, 0.761536, 0.0242759, 0, 0.910494, 0.754303, 0.0231142, 0, 0.937985, 0.74692, 0.0220305, 0, 0.968254, 0.739745, 0.0210192, 0, 1, 1, 0.613914, 0, 0, 0.999996, 0.613907, 0, 963597e-10, 0.999942, 0.613814, 0, 301247e-8, 0.999704, 0.613407, 0, 870385e-8, 0.999046, 0.612302, 0, 0.0160714, 0.995516, 0.608266, 0, 0.0245899, 0.991726, 0.602863, 0, 0.0339681, 0.985157, 0.593956, 0, 0.0440254, 0.97642, 0.581748, 0, 0.0546409, 0.964404, 0.565183, 0, 0.0657284, 0.950601, 0.545273, 0, 0.0772246, 0.935158, 0.522129, 0, 0.0890812, 0.919364, 0.496782, 0, 0.10126, 0.904754, 0.470571, 0, 0.113731, 0.89176, 0.444037, 0, 0.126469, 0.881492, 0.418322, 0, 0.139454, 0.873656, 0.393522, 0, 0.15267, 0.868053, 0.369795, 0, 0.166101, 0.864336, 0.347171, 0, 0.179736, 0.862259, 0.325737, 0, 0.193565, 0.861556, 0.305532, 0, 0.207578, 0.861776, 0.286416, 0, 0.221769, 0.862661, 0.268355, 0, 0.23613, 0.864015, 0.251334, 0, 0.250656, 0.865711, 0.235352, 0, 0.265343, 0.867519, 0.220302, 0, 0.280187, 0.869351, 0.206161, 0, 0.295183, 0.871144, 0.192908, 0, 0.31033, 0.872839, 0.180505, 0, 0.325624, 0.874307, 0.168848, 0, 0.341065, 0.875667, 0.158021, 0, 0.35665, 0.876758, 0.147877, 0, 0.37238, 0.87764, 0.138441, 0, 0.388253, 0.878237, 0.129627, 0, 0.404269, 0.878563, 0.121415, 0, 0.42043, 0.878572, 0.113741, 0, 0.436735, 0.87842, 0.106652, 0, 0.453187, 0.878057, 0.100097, 0, 0.469786, 0.877413, 0.0940128, 0, 0.486536, 0.87646, 0.0883462, 0, 0.503439, 0.875233, 0.0830924, 0, 0.520498, 0.8737, 0.0781975, 0, 0.537717, 0.871873, 0.07364, 0, 0.555102, 0.86978, 0.0694103, 0, 0.572657, 0.867405, 0.0654696, 0, 0.59039, 0.864751, 0.0617914, 0, 0.608307, 0.861818, 0.0583491, 0, 0.626419, 0.858645, 0.0551443, 0, 0.644733, 0.855307, 0.0521894, 0, 0.663264, 0.851736, 0.0494334, 0, 0.682025, 0.847927, 0.0468504, 0, 0.701032, 0.843888, 0.0444261, 0, 0.720308, 0.839629, 0.0421497, 0, 0.739875, 0.835158, 0.0400082, 0, 0.759764, 0.830509, 0.0380076, 0, 0.780014, 0.825714, 0.0361488, 0, 0.800673, 0.820729, 0.0343956, 0, 0.821803, 0.815751, 0.0327781, 0, 0.843492, 0.810752, 0.031275, 0, 0.86586, 0.805587, 0.0298542, 0, 0.889087, 0.800317, 0.0285397, 0, 0.913466, 0.79489, 0.0272948, 0, 0.93952, 0.789314, 0.0261139, 0, 0.96835, 0.783593, 0.0249938, 0, 1, 1, 0.724258, 0, 0, 0.999992, 0.724243, 0, 726889e-9, 0.99987, 0.724044, 0, 569574e-8, 0.999336, 0.72317, 0, 0.0131702, 0.996271, 0.719432, 0, 0.0220738, 0.991159, 0.712576, 0, 0.0319405, 0.982465, 0.700927, 0, 0.0425202, 0.97049, 0.684297, 0, 0.0536599, 0.953973, 0.661244, 0, 0.065258, 0.935546, 0.633804, 0, 0.0772427, 0.916596, 0.603071, 0, 0.0895616, 0.899353, 0.57105, 0, 0.102175, 0.885216, 0.539206, 0, 0.11505, 0.875076, 0.508714, 0, 0.128164, 0.868334, 0.479571, 0, 0.141495, 0.864414, 0.451796, 0, 0.155026, 0.862678, 0.425328, 0, 0.168745, 0.862835, 0.400352, 0, 0.182639, 0.864067, 0.376532, 0, 0.196699, 0.866086, 0.35391, 0, 0.210915, 0.868557, 0.332424, 0, 0.225282, 0.871271, 0.312053, 0, 0.239792, 0.874058, 0.292764, 0, 0.25444, 0.8768, 0.27453, 0, 0.269223, 0.87939, 0.257297, 0, 0.284135, 0.8819, 0.24114, 0, 0.299174, 0.884187, 0.225934, 0, 0.314337, 0.886262, 0.211669, 0, 0.329622, 0.888119, 0.198311, 0, 0.345026, 0.889709, 0.185783, 0, 0.360549, 0.891054, 0.174063, 0, 0.376189, 0.892196, 0.163143, 0, 0.391946, 0.893101, 0.152952, 0, 0.407819, 0.893803, 0.143475, 0, 0.423808, 0.894277, 0.134647, 0, 0.439914, 0.894532, 0.126434, 0, 0.456137, 0.894576, 0.1188, 0, 0.472479, 0.894393, 0.111694, 0, 0.48894, 0.893976, 0.105069, 0, 0.505523, 0.893346, 0.0989077, 0, 0.52223, 0.892502, 0.0931724, 0, 0.539064, 0.891441, 0.0878276, 0, 0.556028, 0.890276, 0.082903, 0, 0.573125, 0.888972, 0.0783505, 0, 0.590361, 0.887469, 0.0741083, 0, 0.607741, 0.885785, 0.0701633, 0, 0.62527, 0.883914, 0.0664835, 0, 0.642957, 0.881872, 0.0630567, 0, 0.660809, 0.879651, 0.0598527, 0, 0.678836, 0.877267, 0.0568615, 0, 0.69705, 0.874717, 0.05406, 0, 0.715465, 0.872012, 0.0514378, 0, 0.734098, 0.869157, 0.0489805, 0, 0.752968, 0.866155, 0.0466727, 0, 0.772101, 0.863014, 0.0445056, 0, 0.791529, 0.859748, 0.0424733, 0, 0.81129, 0.856416, 0.0405957, 0, 0.831438, 0.852958, 0.0388273, 0, 0.852044, 0.849382, 0.0371619, 0, 0.87321, 0.845694, 0.0355959, 0, 0.89509, 0.841893, 0.0341155, 0, 0.917932, 0.837981, 0.0327141, 0, 0.942204, 0.833963, 0.0313856, 0, 0.968981, 0.829847, 0.0301275, 0, 1, 1, 0.85214, 0, 0, 0.999969, 0.852095, 0, 279627e-8, 0.999483, 0.851408, 0, 0.0107635, 0.994545, 0.84579, 0, 0.0206454, 0.986188, 0.835231, 0, 0.0315756, 0.969847, 0.814687, 0, 0.0432021, 0.945951, 0.783735, 0, 0.0553396, 0.91917, 0.746074, 0, 0.0678766, 0.895488, 0.706938, 0, 0.0807395, 0.878232, 0.669534, 0, 0.0938767, 0.868252, 0.635168, 0, 0.10725, 0.863873, 0.603069, 0, 0.120832, 0.863369, 0.572514, 0, 0.134598, 0.86545, 0.543169, 0, 0.148533, 0.868803, 0.514578, 0, 0.16262, 0.872794, 0.486762, 0, 0.176849, 0.87702, 0.459811, 0, 0.19121, 0.881054, 0.433654, 0, 0.205694, 0.884974, 0.408574, 0, 0.220294, 0.888587, 0.384525, 0, 0.235005, 0.891877, 0.36156, 0, 0.24982, 0.894793, 0.339661, 0, 0.264737, 0.89743, 0.318913, 0, 0.279751, 0.899796, 0.299302, 0, 0.294859, 0.901943, 0.280843, 0, 0.310058, 0.903858, 0.263481, 0, 0.325346, 0.905574, 0.247197, 0, 0.340721, 0.907069, 0.231915, 0, 0.356181, 0.908379, 0.217614, 0, 0.371725, 0.90952, 0.20425, 0, 0.387353, 0.910483, 0.191758, 0, 0.403063, 0.91128, 0.180092, 0, 0.418854, 0.911936, 0.169222, 0, 0.434727, 0.912454, 0.159098, 0, 0.450682, 0.912835, 0.149668, 0, 0.466718, 0.913078, 0.140884, 0, 0.482837, 0.913192, 0.132709, 0, 0.499038, 0.913175, 0.125095, 0, 0.515324, 0.91304, 0.118012, 0, 0.531695, 0.912781, 0.111417, 0, 0.548153, 0.91241, 0.105281, 0, 0.5647, 0.911924, 0.0995691, 0, 0.581338, 0.911331, 0.0942531, 0, 0.59807, 0.910637, 0.0893076, 0, 0.6149, 0.90984, 0.0846998, 0, 0.63183, 0.908941, 0.0804044, 0, 0.648865, 0.907944, 0.0763984, 0, 0.666011, 0.906857, 0.0726638, 0, 0.683273, 0.90568, 0.0691783, 0, 0.700659, 0.904416, 0.0659222, 0, 0.718176, 0.903067, 0.0628782, 0, 0.735834, 0.901637, 0.0600307, 0, 0.753646, 0.900128, 0.0573647, 0, 0.771625, 0.898544, 0.0548668, 0, 0.78979, 0.89689, 0.052527, 0, 0.808162, 0.895165, 0.0503306, 0, 0.826771, 0.893371, 0.0482668, 0, 0.845654, 0.891572, 0.0463605, 0, 0.864863, 0.889763, 0.0445998, 0, 0.884472, 0.887894, 0.0429451, 0, 0.904592, 0.885967, 0.0413884, 0, 0.925407, 0.883984, 0.0399225, 0, 0.947271, 0.881945, 0.0385405, 0, 0.97105, 0.879854, 0.0372362, 0, 1, 0.999804, 0.995833, 0, 0, 0.938155, 0.933611, 0, 0.0158731, 0.864755, 0.854311, 0, 0.0317461, 0.888594, 0.865264, 0, 0.0476191, 0.905575, 0.863922, 0, 0.0634921, 0.915125, 0.850558, 0, 0.0793651, 0.920665, 0.829254, 0, 0.0952381, 0.924073, 0.802578, 0, 0.111111, 0.926304, 0.772211, 0, 0.126984, 0.927829, 0.739366, 0, 0.142857, 0.928924, 0.705033, 0, 0.15873, 0.92973, 0.670019, 0, 0.174603, 0.930339, 0.634993, 0, 0.190476, 0.930811, 0.600485, 0, 0.206349, 0.931191, 0.566897, 0, 0.222222, 0.93149, 0.534485, 0, 0.238095, 0.931737, 0.503429, 0, 0.253968, 0.931939, 0.473811, 0, 0.269841, 0.932108, 0.445668, 0, 0.285714, 0.93225, 0.418993, 0, 0.301587, 0.932371, 0.393762, 0, 0.31746, 0.932474, 0.369939, 0, 0.333333, 0.932562, 0.347479, 0, 0.349206, 0.932638, 0.326336, 0, 0.365079, 0.932703, 0.306462, 0, 0.380952, 0.93276, 0.287805, 0, 0.396825, 0.932809, 0.270313, 0, 0.412698, 0.932851, 0.253933, 0, 0.428571, 0.932887, 0.23861, 0, 0.444444, 0.932917, 0.224289, 0, 0.460317, 0.932943, 0.210917, 0, 0.47619, 0.932965, 0.19844, 0, 0.492063, 0.932982, 0.186807, 0, 0.507937, 0.932995, 0.175966, 0, 0.52381, 0.933005, 0.165869, 0, 0.539683, 0.933011, 0.156468, 0, 0.555556, 0.933013, 0.147719, 0, 0.571429, 0.933013, 0.139579, 0, 0.587302, 0.93301, 0.132007, 0, 0.603175, 0.933004, 0.124965, 0, 0.619048, 0.932994, 0.118416, 0, 0.634921, 0.932982, 0.112326, 0, 0.650794, 0.932968, 0.106663, 0, 0.666667, 0.93295, 0.101397, 0, 0.68254, 0.932931, 0.0964993, 0, 0.698413, 0.932908, 0.0919438, 0, 0.714286, 0.932883, 0.0877057, 0, 0.730159, 0.932856, 0.0837623, 0, 0.746032, 0.932827, 0.0800921, 0, 0.761905, 0.932796, 0.0766754, 0, 0.777778, 0.932762, 0.0734936, 0, 0.793651, 0.932727, 0.0705296, 0, 0.809524, 0.932689, 0.0677676, 0, 0.825397, 0.93265, 0.0651929, 0, 0.84127, 0.932609, 0.0627917, 0, 0.857143, 0.932565, 0.0605515, 0, 0.873016, 0.932521, 0.0584606, 0, 0.888889, 0.932474, 0.0565082, 0, 0.904762, 0.932427, 0.0546841, 0, 0.920635, 0.932377, 0.0529793, 0, 0.936508, 0.932326, 0.0513851, 0, 0.952381, 0.932274, 0.0498936, 0, 0.968254, 0.93222, 0.0484975, 0, 0.984127, 0.932164, 0.0471899, 0, 1];
  const ltc_float_1 = new Float32Array(LTC_MAT_1);
  const ltc_float_2 = new Float32Array(LTC_MAT_2);
  UniformsLib.LTC_FLOAT_1 = new DataTexture(ltc_float_1, 64, 64, RGBAFormat, FloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1);
  UniformsLib.LTC_FLOAT_2 = new DataTexture(ltc_float_2, 64, 64, RGBAFormat, FloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1);
  const ltc_half_1 = new Uint16Array(LTC_MAT_1.length);
  LTC_MAT_1.forEach(function(x, index) {
    ltc_half_1[index] = DataUtils.toHalfFloat(x);
  });
  const ltc_half_2 = new Uint16Array(LTC_MAT_2.length);
  LTC_MAT_2.forEach(function(x, index) {
    ltc_half_2[index] = DataUtils.toHalfFloat(x);
  });
  UniformsLib.LTC_HALF_1 = new DataTexture(ltc_half_1, 64, 64, RGBAFormat, HalfFloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1);
  UniformsLib.LTC_HALF_2 = new DataTexture(ltc_half_2, 64, 64, RGBAFormat, HalfFloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1);
} };

// node_modules/three-stdlib/lights/LightProbeGenerator.js
var LightProbeGenerator = {
  fromCubeTexture: function(cubeTexture) {
    var norm, lengthSq, weight, totalWeight = 0;
    var coord = new Vector3();
    var dir = new Vector3();
    var color2 = new Color();
    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    var sh = new SphericalHarmonics3();
    var shCoefficients = sh.coefficients;
    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
      var image = cubeTexture.image[faceIndex];
      var width = image.width;
      var height = image.height;
      var canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      var context = canvas.getContext("2d");
      context.drawImage(image, 0, 0, width, height);
      var imageData = context.getImageData(0, 0, width, height);
      var data = imageData.data;
      var imageWidth = imageData.width;
      var pixelSize = 2 / imageWidth;
      for (let i2 = 0, il = data.length; i2 < il; i2 += 4) {
        color2.setRGB(data[i2] / 255, data[i2 + 1] / 255, data[i2 + 2] / 255);
        convertColorToLinear(color2, cubeTexture.encoding);
        var pixelIndex = i2 / 4;
        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;
        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;
        switch (faceIndex) {
          case 0:
            coord.set(-1, row, -col);
            break;
          case 1:
            coord.set(1, row, col);
            break;
          case 2:
            coord.set(-col, 1, -row);
            break;
          case 3:
            coord.set(-col, -1, row);
            break;
          case 4:
            coord.set(-col, row, 1);
            break;
          case 5:
            coord.set(col, row, -1);
            break;
        }
        lengthSq = coord.lengthSq();
        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);
        totalWeight += weight;
        dir.copy(coord).normalize();
        SphericalHarmonics3.getBasisAt(dir, shBasis);
        for (let j2 = 0; j2 < 9; j2++) {
          shCoefficients[j2].x += shBasis[j2] * color2.r * weight;
          shCoefficients[j2].y += shBasis[j2] * color2.g * weight;
          shCoefficients[j2].z += shBasis[j2] * color2.b * weight;
        }
      }
    }
    norm = 4 * Math.PI / totalWeight;
    for (let j2 = 0; j2 < 9; j2++) {
      shCoefficients[j2].x *= norm;
      shCoefficients[j2].y *= norm;
      shCoefficients[j2].z *= norm;
    }
    return new LightProbe(sh);
  },
  fromCubeRenderTarget: function(renderer, cubeRenderTarget) {
    var norm, lengthSq, weight, totalWeight = 0;
    var coord = new Vector3();
    var dir = new Vector3();
    var color2 = new Color();
    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    var sh = new SphericalHarmonics3();
    var shCoefficients = sh.coefficients;
    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
      var imageWidth = cubeRenderTarget.width;
      var data = new Uint8Array(imageWidth * imageWidth * 4);
      renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex);
      var pixelSize = 2 / imageWidth;
      for (let i2 = 0, il = data.length; i2 < il; i2 += 4) {
        color2.setRGB(data[i2] / 255, data[i2 + 1] / 255, data[i2 + 2] / 255);
        convertColorToLinear(color2, cubeRenderTarget.texture.encoding);
        var pixelIndex = i2 / 4;
        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;
        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;
        switch (faceIndex) {
          case 0:
            coord.set(1, row, -col);
            break;
          case 1:
            coord.set(-1, row, col);
            break;
          case 2:
            coord.set(col, 1, -row);
            break;
          case 3:
            coord.set(col, -1, row);
            break;
          case 4:
            coord.set(col, row, 1);
            break;
          case 5:
            coord.set(-col, row, -1);
            break;
        }
        lengthSq = coord.lengthSq();
        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);
        totalWeight += weight;
        dir.copy(coord).normalize();
        SphericalHarmonics3.getBasisAt(dir, shBasis);
        for (let j2 = 0; j2 < 9; j2++) {
          shCoefficients[j2].x += shBasis[j2] * color2.r * weight;
          shCoefficients[j2].y += shBasis[j2] * color2.g * weight;
          shCoefficients[j2].z += shBasis[j2] * color2.b * weight;
        }
      }
    }
    norm = 4 * Math.PI / totalWeight;
    for (let j2 = 0; j2 < 9; j2++) {
      shCoefficients[j2].x *= norm;
      shCoefficients[j2].y *= norm;
      shCoefficients[j2].z *= norm;
    }
    return new LightProbe(sh);
  }
};
var convertColorToLinear = function(color2, encoding) {
  switch (encoding) {
    case sRGBEncoding:
      color2.convertSRGBToLinear();
      break;
    case LinearEncoding:
      break;
    default:
      console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.");
      break;
  }
  return color2;
};

// node_modules/three-stdlib/curves/NURBSSurface.js
var NURBSSurface = class {
  constructor(degree1, degree2, knots1, knots2, controlPoints) {
    this.degree1 = degree1;
    this.degree2 = degree2;
    this.knots1 = knots1;
    this.knots2 = knots2;
    this.controlPoints = [];
    const len1 = knots1.length - degree1 - 1;
    const len2 = knots2.length - degree2 - 1;
    for (let i2 = 0; i2 < len1; ++i2) {
      this.controlPoints[i2] = [];
      for (let j2 = 0; j2 < len2; ++j2) {
        const point = controlPoints[i2][j2];
        this.controlPoints[i2][j2] = new Vector4(point.x, point.y, point.z, point.w);
      }
    }
  }
  getPoint(t1, t2, target) {
    const u = this.knots1[0] + t1 * (this.knots1[this.knots1.length - 1] - this.knots1[0]);
    const v = this.knots2[0] + t2 * (this.knots2[this.knots2.length - 1] - this.knots2[0]);
    calcSurfacePoint(this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, u, v, target);
  }
};

// node_modules/three-stdlib/curves/CurveExtras.js
var GrannyKnot = class extends Curve {
  constructor() {
    super();
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    t2 = 2 * Math.PI * t2;
    const x = -0.22 * Math.cos(t2) - 1.28 * Math.sin(t2) - 0.44 * Math.cos(3 * t2) - 0.78 * Math.sin(3 * t2);
    const y = -0.1 * Math.cos(2 * t2) - 0.27 * Math.sin(2 * t2) + 0.38 * Math.cos(4 * t2) + 0.46 * Math.sin(4 * t2);
    const z = 0.7 * Math.cos(3 * t2) - 0.4 * Math.sin(3 * t2);
    return point.set(x, y, z).multiplyScalar(20);
  }
};
var HeartCurve = class extends Curve {
  constructor(scale) {
    super();
    this.scale = scale === void 0 ? 5 : scale;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    t2 *= 2 * Math.PI;
    const x = 16 * Math.pow(Math.sin(t2), 3);
    const y = 13 * Math.cos(t2) - 5 * Math.cos(2 * t2) - 2 * Math.cos(3 * t2) - Math.cos(4 * t2);
    const z = 0;
    return point.set(x, y, z).multiplyScalar(this.scale);
  }
};
var VivianiCurve = class extends Curve {
  constructor(scale) {
    super();
    this.scale = scale === void 0 ? 70 : scale;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    t2 = t2 * 4 * Math.PI;
    const a2 = this.scale / 2;
    const x = a2 * (1 + Math.cos(t2));
    const y = a2 * Math.sin(t2);
    const z = 2 * a2 * Math.sin(t2 / 2);
    return point.set(x, y, z);
  }
};
var KnotCurve = class extends Curve {
  constructor() {
    super();
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    t2 *= 2 * Math.PI;
    const R2 = 10;
    const s = 50;
    const x = s * Math.sin(t2);
    const y = Math.cos(t2) * (R2 + s * Math.cos(t2));
    const z = Math.sin(t2) * (R2 + s * Math.cos(t2));
    return point.set(x, y, z);
  }
};
var HelixCurve = class extends Curve {
  constructor() {
    super();
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    const a2 = 30;
    const b3 = 150;
    const t22 = 2 * Math.PI * t2 * b3 / 30;
    const x = Math.cos(t22) * a2;
    const y = Math.sin(t22) * a2;
    const z = b3 * t2;
    return point.set(x, y, z);
  }
};
var TrefoilKnot = class extends Curve {
  constructor(scale) {
    super();
    this.scale = scale === void 0 ? 10 : scale;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    t2 *= Math.PI * 2;
    const x = (2 + Math.cos(3 * t2)) * Math.cos(2 * t2);
    const y = (2 + Math.cos(3 * t2)) * Math.sin(2 * t2);
    const z = Math.sin(3 * t2);
    return point.set(x, y, z).multiplyScalar(this.scale);
  }
};
var TorusKnot = class extends Curve {
  constructor(scale) {
    super();
    this.scale = scale === void 0 ? 10 : scale;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    const p = 3;
    const q = 4;
    t2 *= Math.PI * 2;
    const x = (2 + Math.cos(q * t2)) * Math.cos(p * t2);
    const y = (2 + Math.cos(q * t2)) * Math.sin(p * t2);
    const z = Math.sin(q * t2);
    return point.set(x, y, z).multiplyScalar(this.scale);
  }
};
var CinquefoilKnot = class extends Curve {
  constructor(scale) {
    super();
    this.scale = scale === void 0 ? 10 : scale;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    const p = 2;
    const q = 5;
    t2 *= Math.PI * 2;
    const x = (2 + Math.cos(q * t2)) * Math.cos(p * t2);
    const y = (2 + Math.cos(q * t2)) * Math.sin(p * t2);
    const z = Math.sin(q * t2);
    return point.set(x, y, z).multiplyScalar(this.scale);
  }
};
var TrefoilPolynomialKnot = class extends Curve {
  constructor(scale) {
    super();
    this.scale = scale === void 0 ? 10 : scale;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    t2 = t2 * 4 - 2;
    const x = Math.pow(t2, 3) - 3 * t2;
    const y = Math.pow(t2, 4) - 4 * t2 * t2;
    const z = 1 / 5 * Math.pow(t2, 5) - 2 * t2;
    return point.set(x, y, z).multiplyScalar(this.scale);
  }
};
var scaleTo = (x, y, t2) => {
  const r = y - x;
  return t2 * r + x;
};
var FigureEightPolynomialKnot = class extends Curve {
  constructor(scale) {
    super();
    this.scale = scale === void 0 ? 1 : scale;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    t2 = scaleTo(-4, 4, t2);
    const x = 2 / 5 * t2 * (t2 * t2 - 7) * (t2 * t2 - 10);
    const y = Math.pow(t2, 4) - 13 * t2 * t2;
    const z = 1 / 10 * t2 * (t2 * t2 - 4) * (t2 * t2 - 9) * (t2 * t2 - 12);
    return point.set(x, y, z).multiplyScalar(this.scale);
  }
};
var DecoratedTorusKnot4a = class extends Curve {
  constructor(scale) {
    super();
    this.scale = scale === void 0 ? 40 : scale;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    t2 *= Math.PI * 2;
    const x = Math.cos(2 * t2) * (1 + 0.6 * (Math.cos(5 * t2) + 0.75 * Math.cos(10 * t2)));
    const y = Math.sin(2 * t2) * (1 + 0.6 * (Math.cos(5 * t2) + 0.75 * Math.cos(10 * t2)));
    const z = 0.35 * Math.sin(5 * t2);
    return point.set(x, y, z).multiplyScalar(this.scale);
  }
};
var DecoratedTorusKnot4b = class extends Curve {
  constructor(scale) {
    super();
    this.scale = scale === void 0 ? 40 : scale;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    const fi = t2 * Math.PI * 2;
    const x = Math.cos(2 * fi) * (1 + 0.45 * Math.cos(3 * fi) + 0.4 * Math.cos(9 * fi));
    const y = Math.sin(2 * fi) * (1 + 0.45 * Math.cos(3 * fi) + 0.4 * Math.cos(9 * fi));
    const z = 0.2 * Math.sin(9 * fi);
    return point.set(x, y, z).multiplyScalar(this.scale);
  }
};
var DecoratedTorusKnot5a = class extends Curve {
  constructor(scale) {
    super();
    this.scale = scale === void 0 ? 40 : scale;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    const fi = t2 * Math.PI * 2;
    const x = Math.cos(3 * fi) * (1 + 0.3 * Math.cos(5 * fi) + 0.5 * Math.cos(10 * fi));
    const y = Math.sin(3 * fi) * (1 + 0.3 * Math.cos(5 * fi) + 0.5 * Math.cos(10 * fi));
    const z = 0.2 * Math.sin(20 * fi);
    return point.set(x, y, z).multiplyScalar(this.scale);
  }
};
var DecoratedTorusKnot5c = class extends Curve {
  constructor(scale) {
    super();
    this.scale = scale === void 0 ? 40 : scale;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    const fi = t2 * Math.PI * 2;
    const x = Math.cos(4 * fi) * (1 + 0.5 * (Math.cos(5 * fi) + 0.4 * Math.cos(20 * fi)));
    const y = Math.sin(4 * fi) * (1 + 0.5 * (Math.cos(5 * fi) + 0.4 * Math.cos(20 * fi)));
    const z = 0.35 * Math.sin(15 * fi);
    return point.set(x, y, z).multiplyScalar(this.scale);
  }
};

// node_modules/three-stdlib/deprecated/Geometry.js
var _m1 = new Matrix4();
var _obj = new Object3D();
var _offset = new Vector3();
var Geometry = class extends EventDispatcher {
  constructor() {
    super();
    this.isGeometry = true;
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.elementsNeedUpdate = false;
    this.verticesNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
  }
  applyMatrix4(matrix3) {
    const normalMatrix = new Matrix3().getNormalMatrix(matrix3);
    for (let i2 = 0, il = this.vertices.length; i2 < il; i2++) {
      const vertex = this.vertices[i2];
      vertex.applyMatrix4(matrix3);
    }
    for (let i2 = 0, il = this.faces.length; i2 < il; i2++) {
      const face = this.faces[i2];
      face.normal.applyMatrix3(normalMatrix).normalize();
      for (let j2 = 0, jl2 = face.vertexNormals.length; j2 < jl2; j2++) {
        face.vertexNormals[j2].applyMatrix3(normalMatrix).normalize();
      }
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;
    return this;
  }
  rotateX(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x, y, z) {
    _m1.makeTranslation(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x, y, z) {
    _m1.makeScale(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector2) {
    _obj.lookAt(vector2);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  fromBufferGeometry(geometry) {
    const scope2 = this;
    const index = geometry.index !== null ? geometry.index : void 0;
    const attributes = geometry.attributes;
    if (attributes.position === void 0) {
      console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.");
      return this;
    }
    const position = attributes.position;
    const normal = attributes.normal;
    const color2 = attributes.color;
    const uv2 = attributes.uv;
    const uv22 = attributes.uv2;
    if (uv22 !== void 0)
      this.faceVertexUvs[1] = [];
    for (let i2 = 0; i2 < position.count; i2++) {
      scope2.vertices.push(new Vector3().fromBufferAttribute(position, i2));
      if (color2 !== void 0) {
        scope2.colors.push(new Color().fromBufferAttribute(color2, i2));
      }
    }
    function addFace(a2, b3, c, materialIndex) {
      const vertexColors = color2 === void 0 ? [] : [scope2.colors[a2].clone(), scope2.colors[b3].clone(), scope2.colors[c].clone()];
      const vertexNormals = normal === void 0 ? [] : [new Vector3().fromBufferAttribute(normal, a2), new Vector3().fromBufferAttribute(normal, b3), new Vector3().fromBufferAttribute(normal, c)];
      const face = new Face3(a2, b3, c, vertexNormals, vertexColors, materialIndex);
      scope2.faces.push(face);
      if (uv2 !== void 0) {
        scope2.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv2, a2), new Vector2().fromBufferAttribute(uv2, b3), new Vector2().fromBufferAttribute(uv2, c)]);
      }
      if (uv22 !== void 0) {
        scope2.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv22, a2), new Vector2().fromBufferAttribute(uv22, b3), new Vector2().fromBufferAttribute(uv22, c)]);
      }
    }
    const groups = geometry.groups;
    if (groups.length > 0) {
      for (let i2 = 0; i2 < groups.length; i2++) {
        const group = groups[i2];
        const start = group.start;
        const count = group.count;
        for (let j2 = start, jl2 = start + count; j2 < jl2; j2 += 3) {
          if (index !== void 0) {
            addFace(index.getX(j2), index.getX(j2 + 1), index.getX(j2 + 2), group.materialIndex);
          } else {
            addFace(j2, j2 + 1, j2 + 2, group.materialIndex);
          }
        }
      }
    } else {
      if (index !== void 0) {
        for (let i2 = 0; i2 < index.count; i2 += 3) {
          addFace(index.getX(i2), index.getX(i2 + 1), index.getX(i2 + 2));
        }
      } else {
        for (let i2 = 0; i2 < position.count; i2 += 3) {
          addFace(i2, i2 + 1, i2 + 2);
        }
      }
    }
    this.computeFaceNormals();
    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }
    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  normalize() {
    this.computeBoundingSphere();
    const center = this.boundingSphere.center;
    const radius = this.boundingSphere.radius;
    const s = radius === 0 ? 1 : 1 / radius;
    const matrix3 = new Matrix4();
    matrix3.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
    this.applyMatrix4(matrix3);
    return this;
  }
  computeFaceNormals() {
    const cb2 = new Vector3(), ab2 = new Vector3();
    for (let f = 0, fl2 = this.faces.length; f < fl2; f++) {
      const face = this.faces[f];
      const vA = this.vertices[face.a];
      const vB = this.vertices[face.b];
      const vC = this.vertices[face.c];
      cb2.subVectors(vC, vB);
      ab2.subVectors(vA, vB);
      cb2.cross(ab2);
      cb2.normalize();
      face.normal.copy(cb2);
    }
  }
  computeVertexNormals(areaWeighted = true) {
    const vertices = new Array(this.vertices.length);
    for (let v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v] = new Vector3();
    }
    if (areaWeighted) {
      const cb2 = new Vector3(), ab2 = new Vector3();
      for (let f = 0, fl2 = this.faces.length; f < fl2; f++) {
        const face = this.faces[f];
        const vA = this.vertices[face.a];
        const vB = this.vertices[face.b];
        const vC = this.vertices[face.c];
        cb2.subVectors(vC, vB);
        ab2.subVectors(vA, vB);
        cb2.cross(ab2);
        vertices[face.a].add(cb2);
        vertices[face.b].add(cb2);
        vertices[face.c].add(cb2);
      }
    } else {
      this.computeFaceNormals();
      for (let f = 0, fl2 = this.faces.length; f < fl2; f++) {
        const face = this.faces[f];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
      }
    }
    for (let v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v].normalize();
    }
    for (let f = 0, fl2 = this.faces.length; f < fl2; f++) {
      const face = this.faces[f];
      const vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(vertices[face.a]);
        vertexNormals[1].copy(vertices[face.b]);
        vertexNormals[2].copy(vertices[face.c]);
      } else {
        vertexNormals[0] = vertices[face.a].clone();
        vertexNormals[1] = vertices[face.b].clone();
        vertexNormals[2] = vertices[face.c].clone();
      }
    }
    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  }
  computeFlatVertexNormals() {
    this.computeFaceNormals();
    for (let f = 0, fl2 = this.faces.length; f < fl2; f++) {
      const face = this.faces[f];
      const vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(face.normal);
        vertexNormals[1].copy(face.normal);
        vertexNormals[2].copy(face.normal);
      } else {
        vertexNormals[0] = face.normal.clone();
        vertexNormals[1] = face.normal.clone();
        vertexNormals[2] = face.normal.clone();
      }
    }
    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  }
  computeMorphNormals() {
    for (let f = 0, fl2 = this.faces.length; f < fl2; f++) {
      const face = this.faces[f];
      if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
      } else {
        face.__originalFaceNormal.copy(face.normal);
      }
      if (!face.__originalVertexNormals)
        face.__originalVertexNormals = [];
      for (let i2 = 0, il = face.vertexNormals.length; i2 < il; i2++) {
        if (!face.__originalVertexNormals[i2]) {
          face.__originalVertexNormals[i2] = face.vertexNormals[i2].clone();
        } else {
          face.__originalVertexNormals[i2].copy(face.vertexNormals[i2]);
        }
      }
    }
    const tmpGeo = new Geometry();
    tmpGeo.faces = this.faces;
    for (let i2 = 0, il = this.morphTargets.length; i2 < il; i2++) {
      if (!this.morphNormals[i2]) {
        this.morphNormals[i2] = {};
        this.morphNormals[i2].faceNormals = [];
        this.morphNormals[i2].vertexNormals = [];
        const dstNormalsFace = this.morphNormals[i2].faceNormals;
        const dstNormalsVertex = this.morphNormals[i2].vertexNormals;
        for (let f = 0, fl2 = this.faces.length; f < fl2; f++) {
          const faceNormal = new Vector3();
          const vertexNormals = {
            a: new Vector3(),
            b: new Vector3(),
            c: new Vector3()
          };
          dstNormalsFace.push(faceNormal);
          dstNormalsVertex.push(vertexNormals);
        }
      }
      const morphNormals = this.morphNormals[i2];
      tmpGeo.vertices = this.morphTargets[i2].vertices;
      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals();
      for (let f = 0, fl2 = this.faces.length; f < fl2; f++) {
        const face = this.faces[f];
        const faceNormal = morphNormals.faceNormals[f];
        const vertexNormals = morphNormals.vertexNormals[f];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
      }
    }
    for (let f = 0, fl2 = this.faces.length; f < fl2; f++) {
      const face = this.faces[f];
      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;
    }
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    this.boundingBox.setFromPoints(this.vertices);
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    this.boundingSphere.setFromPoints(this.vertices);
  }
  merge(geometry, matrix3, materialIndexOffset = 0) {
    if (!(geometry && geometry.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
      return;
    }
    let normalMatrix;
    const vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;
    if (matrix3 !== void 0) {
      normalMatrix = new Matrix3().getNormalMatrix(matrix3);
    }
    for (let i2 = 0, il = vertices2.length; i2 < il; i2++) {
      const vertex = vertices2[i2];
      const vertexCopy = vertex.clone();
      if (matrix3 !== void 0)
        vertexCopy.applyMatrix4(matrix3);
      vertices1.push(vertexCopy);
    }
    for (let i2 = 0, il = colors2.length; i2 < il; i2++) {
      colors1.push(colors2[i2].clone());
    }
    for (let i2 = 0, il = faces2.length; i2 < il; i2++) {
      const face = faces2[i2];
      let normal, color2;
      const faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
      faceCopy.normal.copy(face.normal);
      if (normalMatrix !== void 0) {
        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
      }
      for (let j2 = 0, jl2 = faceVertexNormals.length; j2 < jl2; j2++) {
        normal = faceVertexNormals[j2].clone();
        if (normalMatrix !== void 0) {
          normal.applyMatrix3(normalMatrix).normalize();
        }
        faceCopy.vertexNormals.push(normal);
      }
      faceCopy.color.copy(face.color);
      for (let j2 = 0, jl2 = faceVertexColors.length; j2 < jl2; j2++) {
        color2 = faceVertexColors[j2];
        faceCopy.vertexColors.push(color2.clone());
      }
      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
      faces1.push(faceCopy);
    }
    for (let i2 = 0, il = geometry.faceVertexUvs.length; i2 < il; i2++) {
      const faceVertexUvs2 = geometry.faceVertexUvs[i2];
      if (this.faceVertexUvs[i2] === void 0)
        this.faceVertexUvs[i2] = [];
      for (let j2 = 0, jl2 = faceVertexUvs2.length; j2 < jl2; j2++) {
        const uvs2 = faceVertexUvs2[j2], uvsCopy = [];
        for (let k = 0, kl = uvs2.length; k < kl; k++) {
          uvsCopy.push(uvs2[k].clone());
        }
        this.faceVertexUvs[i2].push(uvsCopy);
      }
    }
  }
  mergeMesh(mesh) {
    if (!(mesh && mesh.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
      return;
    }
    if (mesh.matrixAutoUpdate)
      mesh.updateMatrix();
    this.merge(mesh.geometry, mesh.matrix);
  }
  mergeVertices(precisionPoints = 4) {
    const verticesMap = {};
    const unique = [], changes = [];
    const precision = Math.pow(10, precisionPoints);
    for (let i2 = 0, il = this.vertices.length; i2 < il; i2++) {
      const v = this.vertices[i2];
      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;
      if (verticesMap[key] === void 0) {
        verticesMap[key] = i2;
        unique.push(this.vertices[i2]);
        changes[i2] = unique.length - 1;
      } else {
        changes[i2] = changes[verticesMap[key]];
      }
    }
    const faceIndicesToRemove = [];
    for (let i2 = 0, il = this.faces.length; i2 < il; i2++) {
      const face = this.faces[i2];
      face.a = changes[face.a];
      face.b = changes[face.b];
      face.c = changes[face.c];
      const indices = [face.a, face.b, face.c];
      for (let n = 0; n < 3; n++) {
        if (indices[n] === indices[(n + 1) % 3]) {
          faceIndicesToRemove.push(i2);
          break;
        }
      }
    }
    for (let i2 = faceIndicesToRemove.length - 1; i2 >= 0; i2--) {
      const idx = faceIndicesToRemove[i2];
      this.faces.splice(idx, 1);
      for (let j2 = 0, jl2 = this.faceVertexUvs.length; j2 < jl2; j2++) {
        this.faceVertexUvs[j2].splice(idx, 1);
      }
    }
    const diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;
  }
  setFromPoints(points) {
    this.vertices = [];
    for (let i2 = 0, l = points.length; i2 < l; i2++) {
      const point = points[i2];
      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }
    return this;
  }
  sortFacesByMaterialIndex() {
    const faces = this.faces;
    const length2 = faces.length;
    for (let i2 = 0; i2 < length2; i2++) {
      faces[i2]._id = i2;
    }
    function materialIndexSort(a2, b3) {
      return a2.materialIndex - b3.materialIndex;
    }
    faces.sort(materialIndexSort);
    const uvs1 = this.faceVertexUvs[0];
    const uvs2 = this.faceVertexUvs[1];
    let newUvs1, newUvs2;
    if (uvs1 && uvs1.length === length2)
      newUvs1 = [];
    if (uvs2 && uvs2.length === length2)
      newUvs2 = [];
    for (let i2 = 0; i2 < length2; i2++) {
      const id = faces[i2]._id;
      if (newUvs1)
        newUvs1.push(uvs1[id]);
      if (newUvs2)
        newUvs2.push(uvs2[id]);
    }
    if (newUvs1)
      this.faceVertexUvs[0] = newUvs1;
    if (newUvs2)
      this.faceVertexUvs[1] = newUvs2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (let key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    const vertices = [];
    for (let i2 = 0; i2 < this.vertices.length; i2++) {
      const vertex = this.vertices[i2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
    const faces = [];
    const normals = [];
    const normalsHash = {};
    const colors = [];
    const colorsHash = {};
    const uvs = [];
    const uvsHash = {};
    for (let i2 = 0; i2 < this.faces.length; i2++) {
      const face = this.faces[i2];
      const hasMaterial = true;
      const hasFaceUv = false;
      const hasFaceVertexUv = this.faceVertexUvs[0][i2] !== void 0;
      const hasFaceNormal = face.normal.length() > 0;
      const hasFaceVertexNormal = face.vertexNormals.length > 0;
      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      const hasFaceVertexColor = face.vertexColors.length > 0;
      let faceType = 0;
      faceType = setBit(faceType, 0, 0);
      faceType = setBit(faceType, 1, hasMaterial);
      faceType = setBit(faceType, 2, hasFaceUv);
      faceType = setBit(faceType, 3, hasFaceVertexUv);
      faceType = setBit(faceType, 4, hasFaceNormal);
      faceType = setBit(faceType, 5, hasFaceVertexNormal);
      faceType = setBit(faceType, 6, hasFaceColor);
      faceType = setBit(faceType, 7, hasFaceVertexColor);
      faces.push(faceType);
      faces.push(face.a, face.b, face.c);
      faces.push(face.materialIndex);
      if (hasFaceVertexUv) {
        const faceVertexUvs = this.faceVertexUvs[0][i2];
        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
      }
      if (hasFaceNormal) {
        faces.push(getNormalIndex(face.normal));
      }
      if (hasFaceVertexNormal) {
        const vertexNormals = face.vertexNormals;
        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
      }
      if (hasFaceColor) {
        faces.push(getColorIndex(face.color));
      }
      if (hasFaceVertexColor) {
        const vertexColors = face.vertexColors;
        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
      }
    }
    function setBit(value, position, enabled) {
      return enabled ? value | 1 << position : value & ~(1 << position);
    }
    function getNormalIndex(normal) {
      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
      if (normalsHash[hash] !== void 0) {
        return normalsHash[hash];
      }
      normalsHash[hash] = normals.length / 3;
      normals.push(normal.x, normal.y, normal.z);
      return normalsHash[hash];
    }
    function getColorIndex(color2) {
      const hash = color2.r.toString() + color2.g.toString() + color2.b.toString();
      if (colorsHash[hash] !== void 0) {
        return colorsHash[hash];
      }
      colorsHash[hash] = colors.length;
      colors.push(color2.getHex());
      return colorsHash[hash];
    }
    function getUvIndex(uv2) {
      const hash = uv2.x.toString() + uv2.y.toString();
      if (uvsHash[hash] !== void 0) {
        return uvsHash[hash];
      }
      uvsHash[hash] = uvs.length / 2;
      uvs.push(uv2.x, uv2.y);
      return uvsHash[hash];
    }
    data.data = {};
    data.data.vertices = vertices;
    data.data.normals = normals;
    if (colors.length > 0)
      data.data.colors = colors;
    if (uvs.length > 0)
      data.data.uvs = [uvs];
    data.data.faces = faces;
    return data;
  }
  clone() {
    return new Geometry().copy(this);
  }
  copy(source) {
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.name = source.name;
    const vertices = source.vertices;
    for (let i2 = 0, il = vertices.length; i2 < il; i2++) {
      this.vertices.push(vertices[i2].clone());
    }
    const colors = source.colors;
    for (let i2 = 0, il = colors.length; i2 < il; i2++) {
      this.colors.push(colors[i2].clone());
    }
    const faces = source.faces;
    for (let i2 = 0, il = faces.length; i2 < il; i2++) {
      this.faces.push(faces[i2].clone());
    }
    for (let i2 = 0, il = source.faceVertexUvs.length; i2 < il; i2++) {
      const faceVertexUvs = source.faceVertexUvs[i2];
      if (this.faceVertexUvs[i2] === void 0) {
        this.faceVertexUvs[i2] = [];
      }
      for (let j2 = 0, jl2 = faceVertexUvs.length; j2 < jl2; j2++) {
        const uvs = faceVertexUvs[j2], uvsCopy = [];
        for (let k = 0, kl = uvs.length; k < kl; k++) {
          const uv2 = uvs[k];
          uvsCopy.push(uv2.clone());
        }
        this.faceVertexUvs[i2].push(uvsCopy);
      }
    }
    const morphTargets = source.morphTargets;
    for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
      const morphTarget = {};
      morphTarget.name = morphTargets[i2].name;
      if (morphTargets[i2].vertices !== void 0) {
        morphTarget.vertices = [];
        for (let j2 = 0, jl2 = morphTargets[i2].vertices.length; j2 < jl2; j2++) {
          morphTarget.vertices.push(morphTargets[i2].vertices[j2].clone());
        }
      }
      if (morphTargets[i2].normals !== void 0) {
        morphTarget.normals = [];
        for (let j2 = 0, jl2 = morphTargets[i2].normals.length; j2 < jl2; j2++) {
          morphTarget.normals.push(morphTargets[i2].normals[j2].clone());
        }
      }
      this.morphTargets.push(morphTarget);
    }
    const morphNormals = source.morphNormals;
    for (let i2 = 0, il = morphNormals.length; i2 < il; i2++) {
      const morphNormal = {};
      if (morphNormals[i2].vertexNormals !== void 0) {
        morphNormal.vertexNormals = [];
        for (let j2 = 0, jl2 = morphNormals[i2].vertexNormals.length; j2 < jl2; j2++) {
          const srcVertexNormal = morphNormals[i2].vertexNormals[j2];
          const destVertexNormal = {};
          destVertexNormal.a = srcVertexNormal.a.clone();
          destVertexNormal.b = srcVertexNormal.b.clone();
          destVertexNormal.c = srcVertexNormal.c.clone();
          morphNormal.vertexNormals.push(destVertexNormal);
        }
      }
      if (morphNormals[i2].faceNormals !== void 0) {
        morphNormal.faceNormals = [];
        for (let j2 = 0, jl2 = morphNormals[i2].faceNormals.length; j2 < jl2; j2++) {
          morphNormal.faceNormals.push(morphNormals[i2].faceNormals[j2].clone());
        }
      }
      this.morphNormals.push(morphNormal);
    }
    const skinWeights = source.skinWeights;
    for (let i2 = 0, il = skinWeights.length; i2 < il; i2++) {
      this.skinWeights.push(skinWeights[i2].clone());
    }
    const skinIndices = source.skinIndices;
    for (let i2 = 0, il = skinIndices.length; i2 < il; i2++) {
      this.skinIndices.push(skinIndices[i2].clone());
    }
    const lineDistances = source.lineDistances;
    for (let i2 = 0, il = lineDistances.length; i2 < il; i2++) {
      this.lineDistances.push(lineDistances[i2]);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.elementsNeedUpdate = source.elementsNeedUpdate;
    this.verticesNeedUpdate = source.verticesNeedUpdate;
    this.uvsNeedUpdate = source.uvsNeedUpdate;
    this.normalsNeedUpdate = source.normalsNeedUpdate;
    this.colorsNeedUpdate = source.colorsNeedUpdate;
    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
    this.groupsNeedUpdate = source.groupsNeedUpdate;
    return this;
  }
  toBufferGeometry() {
    const geometry = new DirectGeometry().fromGeometry(this);
    const buffergeometry = new BufferGeometry();
    const positions = new Float32Array(geometry.vertices.length * 3);
    buffergeometry.setAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
    if (geometry.normals.length > 0) {
      const normals = new Float32Array(geometry.normals.length * 3);
      buffergeometry.setAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
    }
    if (geometry.colors.length > 0) {
      const colors = new Float32Array(geometry.colors.length * 3);
      buffergeometry.setAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
    }
    if (geometry.uvs.length > 0) {
      const uvs = new Float32Array(geometry.uvs.length * 2);
      buffergeometry.setAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
    }
    if (geometry.uvs2.length > 0) {
      const uvs2 = new Float32Array(geometry.uvs2.length * 2);
      buffergeometry.setAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
    }
    buffergeometry.groups = geometry.groups;
    for (let name in geometry.morphTargets) {
      const array = [];
      const morphTargets = geometry.morphTargets[name];
      for (let i2 = 0, l = morphTargets.length; i2 < l; i2++) {
        const morphTarget = morphTargets[i2];
        const attribute2 = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
        attribute2.name = morphTarget.name;
        array.push(attribute2.copyVector3sArray(morphTarget.data));
      }
      buffergeometry.morphAttributes[name] = array;
    }
    if (geometry.skinIndices.length > 0) {
      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
      buffergeometry.setAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
    }
    if (geometry.skinWeights.length > 0) {
      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
      buffergeometry.setAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
    }
    if (geometry.boundingSphere !== null) {
      buffergeometry.boundingSphere = geometry.boundingSphere.clone();
    }
    if (geometry.boundingBox !== null) {
      buffergeometry.boundingBox = geometry.boundingBox.clone();
    }
    return buffergeometry;
  }
  computeTangents() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  }
  computeLineDistances() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  }
  applyMatrix(matrix3) {
    console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().");
    return this.applyMatrix4(matrix3);
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose"
    });
  }
};
Geometry.createBufferGeometryFromObject = (object) => {
  let buffergeometry = new BufferGeometry();
  const geometry = object.geometry;
  if (object.isPoints || object.isLine) {
    const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
    const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
    buffergeometry.setAttribute("position", positions.copyVector3sArray(geometry.vertices));
    buffergeometry.setAttribute("color", colors.copyColorsArray(geometry.colors));
    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
      const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
      buffergeometry.setAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
    }
    if (geometry.boundingSphere !== null) {
      buffergeometry.boundingSphere = geometry.boundingSphere.clone();
    }
    if (geometry.boundingBox !== null) {
      buffergeometry.boundingBox = geometry.boundingBox.clone();
    }
  } else if (object.isMesh) {
    buffergeometry = geometry.toBufferGeometry();
  }
  return buffergeometry;
};
var DirectGeometry = class {
  constructor() {
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;
  }
  computeGroups(geometry) {
    const groups = [];
    let group, i2;
    let materialIndex = void 0;
    const faces = geometry.faces;
    for (i2 = 0; i2 < faces.length; i2++) {
      const face = faces[i2];
      if (face.materialIndex !== materialIndex) {
        materialIndex = face.materialIndex;
        if (group !== void 0) {
          group.count = i2 * 3 - group.start;
          groups.push(group);
        }
        group = {
          start: i2 * 3,
          materialIndex
        };
      }
    }
    if (group !== void 0) {
      group.count = i2 * 3 - group.start;
      groups.push(group);
    }
    this.groups = groups;
  }
  fromGeometry(geometry) {
    const faces = geometry.faces;
    const vertices = geometry.vertices;
    const faceVertexUvs = geometry.faceVertexUvs;
    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
    const morphTargets = geometry.morphTargets;
    const morphTargetsLength = morphTargets.length;
    let morphTargetsPosition;
    if (morphTargetsLength > 0) {
      morphTargetsPosition = [];
      for (let i2 = 0; i2 < morphTargetsLength; i2++) {
        morphTargetsPosition[i2] = {
          name: morphTargets[i2].name,
          data: []
        };
      }
      this.morphTargets.position = morphTargetsPosition;
    }
    const morphNormals = geometry.morphNormals;
    const morphNormalsLength = morphNormals.length;
    let morphTargetsNormal;
    if (morphNormalsLength > 0) {
      morphTargetsNormal = [];
      for (let i2 = 0; i2 < morphNormalsLength; i2++) {
        morphTargetsNormal[i2] = {
          name: morphNormals[i2].name,
          data: []
        };
      }
      this.morphTargets.normal = morphTargetsNormal;
    }
    const skinIndices = geometry.skinIndices;
    const skinWeights = geometry.skinWeights;
    const hasSkinIndices = skinIndices.length === vertices.length;
    const hasSkinWeights = skinWeights.length === vertices.length;
    if (vertices.length > 0 && faces.length === 0) {
      console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    }
    for (let i2 = 0; i2 < faces.length; i2++) {
      const face = faces[i2];
      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
      const vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
      } else {
        const normal = face.normal;
        this.normals.push(normal, normal, normal);
      }
      const vertexColors = face.vertexColors;
      if (vertexColors.length === 3) {
        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
      } else {
        const color2 = face.color;
        this.colors.push(color2, color2, color2);
      }
      if (hasFaceVertexUv === true) {
        const vertexUvs = faceVertexUvs[0][i2];
        if (vertexUvs !== void 0) {
          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i2);
          this.uvs.push(new Vector2(), new Vector2(), new Vector2());
        }
      }
      if (hasFaceVertexUv2 === true) {
        const vertexUvs = faceVertexUvs[1][i2];
        if (vertexUvs !== void 0) {
          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i2);
          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
        }
      }
      for (let j2 = 0; j2 < morphTargetsLength; j2++) {
        const morphTarget = morphTargets[j2].vertices;
        morphTargetsPosition[j2].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
      }
      for (let j2 = 0; j2 < morphNormalsLength; j2++) {
        const morphNormal = morphNormals[j2].vertexNormals[i2];
        morphTargetsNormal[j2].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
      }
      if (hasSkinIndices) {
        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
      }
      if (hasSkinWeights) {
        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
      }
    }
    this.computeGroups(geometry);
    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry.uvsNeedUpdate;
    this.groupsNeedUpdate = geometry.groupsNeedUpdate;
    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }
    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }
    return this;
  }
};
var Face3 = class {
  constructor(a2, b3, c, normal, color2, materialIndex = 0) {
    this.a = a2;
    this.b = b3;
    this.c = c;
    this.normal = normal && normal.isVector3 ? normal : new Vector3();
    this.vertexNormals = Array.isArray(normal) ? normal : [];
    this.color = color2 && color2.isColor ? color2 : new Color();
    this.vertexColors = Array.isArray(color2) ? color2 : [];
    this.materialIndex = materialIndex;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.a = source.a;
    this.b = source.b;
    this.c = source.c;
    this.normal.copy(source.normal);
    this.color.copy(source.color);
    this.materialIndex = source.materialIndex;
    for (let i2 = 0, il = source.vertexNormals.length; i2 < il; i2++) {
      this.vertexNormals[i2] = source.vertexNormals[i2].clone();
    }
    for (let i2 = 0, il = source.vertexColors.length; i2 < il; i2++) {
      this.vertexColors[i2] = source.vertexColors[i2].clone();
    }
    return this;
  }
};

// node_modules/three-stdlib/libs/MeshoptDecoder.js
var generated;
var MeshoptDecoder = () => {
  if (generated)
    return generated;
  const wasm_base = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
  const wasm_simd = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB";
  const detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
  const wasmpack = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
  if (typeof WebAssembly !== "object") {
    return {
      supported: false
    };
  }
  let wasm = wasm_base;
  if (WebAssembly.validate(detector)) {
    wasm = wasm_simd;
  }
  let instance;
  const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result) => {
    instance = result.instance;
    instance.exports.__wasm_call_ctors();
  });
  function unpack(data) {
    const result = new Uint8Array(data.length);
    for (let i2 = 0; i2 < data.length; ++i2) {
      const ch3 = data.charCodeAt(i2);
      result[i2] = ch3 > 96 ? ch3 - 71 : ch3 > 64 ? ch3 - 65 : ch3 > 47 ? ch3 + 4 : ch3 > 46 ? 63 : 62;
    }
    let write = 0;
    for (let i2 = 0; i2 < data.length; ++i2) {
      result[write++] = result[i2] < 60 ? wasmpack[result[i2]] : (result[i2] - 60) * 64 + result[++i2];
    }
    return result.buffer.slice(0, write);
  }
  function decode2(fun, target, count, size2, source, filter) {
    const sbrk = instance.exports.sbrk;
    const count4 = count + 3 & ~3;
    const tp = sbrk(count4 * size2);
    const sp = sbrk(source.length);
    const heap = new Uint8Array(instance.exports.memory.buffer);
    heap.set(source, sp);
    const res = fun(tp, count, size2, sp, source.length);
    if (res === 0 && filter) {
      filter(tp, count4, size2);
    }
    target.set(heap.subarray(tp, tp + count * size2));
    sbrk(tp - sbrk(0));
    if (res !== 0) {
      throw new Error(`Malformed buffer data: ${res}`);
    }
  }
  const filters = {
    0: "",
    1: "meshopt_decodeFilterOct",
    2: "meshopt_decodeFilterQuat",
    3: "meshopt_decodeFilterExp",
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  };
  const decoders = {
    0: "meshopt_decodeVertexBuffer",
    1: "meshopt_decodeIndexBuffer",
    2: "meshopt_decodeIndexSequence",
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  };
  generated = {
    ready: promise,
    supported: true,
    decodeVertexBuffer(target, count, size2, source, filter) {
      decode2(instance.exports.meshopt_decodeVertexBuffer, target, count, size2, source, instance.exports[filters[filter]]);
    },
    decodeIndexBuffer(target, count, size2, source) {
      decode2(instance.exports.meshopt_decodeIndexBuffer, target, count, size2, source);
    },
    decodeIndexSequence(target, count, size2, source) {
      decode2(instance.exports.meshopt_decodeIndexSequence, target, count, size2, source);
    },
    decodeGltfBuffer(target, count, size2, source, mode, filter) {
      decode2(instance.exports[decoders[mode]], target, count, size2, source, instance.exports[filters[filter]]);
    }
  };
  return generated;
};

// node_modules/three-stdlib/nodes/materials/NodeMaterial.js
var NodeMaterial = class extends ShaderMaterial {
  constructor() {
    super();
    this.type = this.constructor.name;
    this.lights = true;
  }
  setDefaultValues(values) {
    let value;
    for (const property in values) {
      value = values[property];
      if (this[property] === void 0) {
        if (value && typeof value.clone === "function") {
          this[property] = value.clone();
        } else {
          this[property] = value;
        }
      }
    }
    Object.assign(this.defines, values.defines);
  }
  toJSON(meta2) {
    const isRoot = meta2 === void 0 || typeof meta2 === "string";
    if (isRoot) {
      meta2 = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = Material.prototype.toJSON.call(this, meta2);
    const nodeKeys = getNodesKeys(this);
    data.inputNodes = {};
    for (const name of nodeKeys) {
      data.inputNodes[name] = this[name].toJSON(meta2).uuid;
    }
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta2.textures);
      const images = extractFromCache(meta2.images);
      const nodes = extractFromCache(meta2.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
NodeMaterial.prototype.isNodeMaterial = true;
var NodeMaterial_default = NodeMaterial;

// node_modules/three-stdlib/nodes/materials/LineBasicNodeMaterial.js
var defaultValues = new LineBasicMaterial();
var LineBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
LineBasicNodeMaterial.prototype.isLineBasicNodeMaterial = true;
var LineBasicNodeMaterial_default = LineBasicNodeMaterial;

// node_modules/three-stdlib/nodes/materials/MeshBasicNodeMaterial.js
var defaultValues2 = new MeshBasicMaterial();
var MeshBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.lights = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues2);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
MeshBasicNodeMaterial.prototype.isMeshBasicNodeMaterial = true;
var MeshBasicNodeMaterial_default = MeshBasicNodeMaterial;

// node_modules/three-stdlib/nodes/materials/MeshStandardNodeMaterial.js
var defaultValues3 = new MeshStandardMaterial();
var MeshStandardNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.normalNode = null;
    this.emissiveNode = null;
    this.metalnessNode = null;
    this.roughnessNode = null;
    this.clearcoatNode = null;
    this.clearcoatRoughnessNode = null;
    this.envNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues3);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.normalNode = source.normalNode;
    this.emissiveNode = source.emissiveNode;
    this.metalnessNode = source.metalnessNode;
    this.roughnessNode = source.roughnessNode;
    this.clearcoatNode = source.clearcoatNode;
    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
    this.envNode = source.envNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
MeshStandardNodeMaterial.prototype.isMeshStandardNodeMaterial = true;
var MeshStandardNodeMaterial_default = MeshStandardNodeMaterial;

// node_modules/three-stdlib/nodes/materials/PointsNodeMaterial.js
var defaultValues4 = new PointsMaterial();
var PointsNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.transparent = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.sizeNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues4);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.sizeNode = source.sizeNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
PointsNodeMaterial.prototype.isPointsNodeMaterial = true;
var PointsNodeMaterial_default = PointsNodeMaterial;
export {
  ACESFilmicToneMappingShader,
  AMFLoader,
  ARButton,
  AdaptiveToneMappingPass,
  AfterimagePass,
  AfterimageShader,
  AmmoPhysics,
  AnaglyphEffect,
  AnimationClipCreator,
  ArcballControls,
  ArrayElementNode_default as ArrayElementNode,
  ArrayUniformNode_default as ArrayUniformNode,
  AsciiEffect,
  AssimpLoader,
  AttributeNode_default as AttributeNode,
  BRDF_GGX,
  BRDF_Lambert,
  BVHLoader,
  BasicShader,
  BasisTextureLoader,
  BleachBypassShader,
  BlendColorFactor,
  BlendShader,
  BloomPass,
  BlurShaderUtils,
  BokehPass,
  BokehShader,
  BokehShader2,
  BoxLineGeometry,
  BrightnessContrastShader,
  BufferNode_default as BufferNode,
  BypassNode_default as BypassNode,
  CCDIKHelper,
  CCDIKSolver,
  CSM,
  CSMFrustum,
  CSMHelper,
  CSMShader,
  CSS2DObject,
  CSS2DRenderer,
  CSS3DObject,
  CSS3DRenderer,
  CSS3DSprite,
  CameraControls,
  CameraNode_default as CameraNode,
  Capsule,
  CheckerNode_default as CheckerNode,
  CinematicCamera,
  CinquefoilKnot,
  ClearMaskPass,
  ClearPass,
  CodeNode_default as CodeNode,
  ColladaExporter,
  ColladaLoader,
  ColorConverter,
  ColorCorrectionShader,
  ColorMapKeywords,
  ColorNodeUniform,
  ColorSpaceNode_default as ColorSpaceNode,
  ColorUniform,
  ColorifyShader,
  CondNode_default as CondNode,
  ConstNode_default as ConstNode,
  ContextNode_default as ContextNode,
  ConvertNode_default as ConvertNode,
  ConvexGeometry,
  ConvexHull,
  ConvexObjectBreaker,
  ConvolutionShader,
  CopyShader,
  CubeTextureNode_default as CubeTextureNode,
  CubeTexturePass,
  DDSLoader,
  DOFMipMapShader,
  DRACOExporter,
  DRACOLoader,
  D_GGX,
  DecalGeometry,
  DecalVertex,
  DecoratedTorusKnot4a,
  DecoratedTorusKnot4b,
  DecoratedTorusKnot5a,
  DecoratedTorusKnot5c,
  DepthLimitedBlurShader,
  DeviceOrientationControls,
  DigitalGlitch,
  DotScreenPass,
  DotScreenShader,
  DragControls,
  EPSILON,
  EXRLoader,
  EdgeSplitModifier,
  EffectComposer,
  ExpressionNode_default as ExpressionNode,
  FBXLoader,
  FXAAShader,
  F_Schlick,
  Face3,
  FigureEightPolynomialKnot,
  FilmPass,
  FilmShader,
  FirstPersonControls,
  FlakesTexture,
  FloatNodeUniform,
  FloatUniform,
  Flow,
  FlyControls,
  FocusShader,
  FogNode_default as FogNode,
  FogRangeNode_default as FogRangeNode,
  Font,
  FontLoader,
  FreiChenShader,
  FresnelShader,
  FullScreenQuad,
  FunctionCallNode_default as FunctionCallNode,
  FunctionNode_default as FunctionNode,
  GCodeLoader,
  GLTFExporter,
  GLTFLoader,
  GPUAddressMode,
  GPUBindingType,
  GPUBlendFactor,
  GPUBlendOperation,
  GPUColorWriteFlags,
  GPUCompareFunction,
  GPUComputationRenderer,
  GPUCullMode,
  GPUFilterMode,
  GPUFrontFace,
  GPUIndexFormat,
  GPUInputStepMode,
  GPULoadOp,
  GPUPrimitiveTopology,
  GPUStencilOperation,
  GPUStoreOp,
  GPUTextureDimension,
  GPUTextureFormat,
  GPUTextureViewDimension,
  GPUVertexFormat,
  GammaCorrectionShader,
  Geometry,
  GeometryCompressionUtils,
  GeometryUtils,
  GlitchPass,
  GodRaysCombineShader,
  GodRaysDepthMaskShader,
  GodRaysFakeSunShader,
  GodRaysGenerateShader,
  GrannyKnot,
  GroundProjectedEnv,
  Gyroscope,
  HDRCubeTextureLoader,
  HalftonePass,
  HalftoneShader,
  HeartCurve,
  HelixCurve,
  HorizontalBlurShader,
  HorizontalTiltShiftShader,
  HueSaturationShader,
  IFFParser,
  INFINITY,
  ImprovedNoise,
  InstancedFlow,
  JoinNode_default as JoinNode,
  KMZLoader,
  KTX2Loader,
  KTXLoader,
  KaleidoShader,
  KnotCurve,
  LDrawLoader,
  LUT3dlLoader,
  LUTCubeLoader,
  LUTPass,
  LWO2Parser,
  LWO3Parser,
  LWOLoader,
  Lensflare,
  LensflareElement,
  LightContextNode_default as LightContextNode,
  LightNode_default as LightNode,
  LightProbeGenerator,
  LightProbeHelper,
  LightningStorm,
  LightningStrike,
  LightsNode_default as LightsNode,
  Line2,
  LineBasicNodeMaterial_default as LineBasicNodeMaterial,
  LineGeometry,
  LineMaterial,
  LineSegments2,
  LineSegmentsGeometry,
  LottieLoader,
  LuminosityHighPassShader,
  LuminosityShader,
  Lut,
  MD2Character,
  MD2CharacterComplex,
  MD2Loader,
  MDDLoader,
  MMDAnimationHelper,
  MMDExporter,
  MMDLoader,
  MMDPhysics,
  MTLLoader,
  MapControls,
  MapControlsExp,
  MarchingCubes,
  MaskPass,
  MatcapUVNode_default as MatcapUVNode,
  MaterialNode_default as MaterialNode,
  MaterialReferenceNode_default as MaterialReferenceNode,
  MathNode_default as MathNode,
  Matrix3NodeUniform,
  Matrix3Uniform,
  Matrix4NodeUniform,
  Matrix4Uniform,
  MeshBasicNodeMaterial_default as MeshBasicNodeMaterial,
  MeshStandardNodeMaterial_default as MeshStandardNodeMaterial,
  MeshSurfaceSampler,
  MeshoptDecoder,
  MirrorShader,
  ModelNode_default as ModelNode,
  ModelViewProjectionNode_default as ModelViewProjectionNode,
  MorphAnimMesh,
  MorphBlendMesh,
  MotionController,
  MotionControllerConstants,
  NRRDLoader,
  NURBSCurve,
  NURBSSurface,
  Node_default as Node,
  NodeAttribute_default as NodeAttribute,
  NodeBuilder_default as NodeBuilder,
  NodeCode_default as NodeCode,
  NodeFrame_default as NodeFrame,
  NodeFunctionInput_default as NodeFunctionInput,
  NodeKeywords_default as NodeKeywords,
  NodeLoader_default as NodeLoader,
  NodeMaterialLoader_default as NodeMaterialLoader,
  NodeMaterialLoaderUtils,
  NodeObjectLoader_default as NodeObjectLoader,
  NodeShaderStage,
  NodeType,
  NodeUniform_default as NodeUniform,
  NodeUpdateType,
  NodeVar_default as NodeVar,
  NodeVary_default as NodeVary,
  NormalMapNode_default as NormalMapNode,
  NormalMapShader,
  NormalNode_default as NormalNode,
  OBB,
  OBJExporter,
  OBJLoader,
  Object3DNode_default as Object3DNode,
  Octree,
  OculusHandModel,
  OculusHandPointerModel,
  OneMinusBlendColorFactor,
  OperatorNode_default as OperatorNode,
  OrbitControls,
  OrbitControlsExp,
  OscNode_default as OscNode,
  OutlineEffect,
  OutlinePass,
  PCDLoader,
  PDBLoader,
  PLYExporter,
  PLYLoader,
  PRWMLoader,
  PVRLoader,
  PackedPhongMaterial,
  ParallaxBarrierEffect,
  ParallaxShader,
  ParametricGeometries,
  ParametricGeometry,
  Pass,
  PeppersGhostEffect,
  PhysicalLightingModel,
  PixelShader,
  PointUVNode_default as PointUVNode,
  PointerLockControls,
  PointsNodeMaterial_default as PointsNodeMaterial,
  PositionNode_default as PositionNode,
  PositionalAudioHelper,
  ProgressiveLightMap,
  Projector,
  PropertyNode_default as PropertyNode,
  RE_Direct_Physical,
  RGBELoader,
  RGBMLoader,
  RGBShiftShader,
  RectAreaLightHelper,
  RectAreaLightUniformsLib,
  ReferenceNode_default as ReferenceNode,
  ReflectNode_default as ReflectNode,
  Reflector,
  ReflectorForSSRPass,
  ReflectorRTT,
  Refractor,
  RenderPass,
  RenderPixelatedPass,
  RenderableFace,
  RenderableLine,
  RenderableObject,
  RenderableSprite,
  RenderableVertex,
  Rhino3dmLoader,
  RollerCoasterGeometry,
  RollerCoasterLiftersGeometry,
  RollerCoasterShadowGeometry,
  RoomEnvironment,
  RoughnessMipmapper,
  RoundedBoxGeometry,
  SAOPass,
  SAOShader,
  SMAABlendShader,
  SMAAEdgesShader,
  SMAAPass,
  SMAAWeightsShader,
  SSAARenderPass,
  SSAOBlurShader,
  SSAODepthShader,
  SSAOPass,
  SSAOShader,
  SSRBlurShader,
  SSRDepthShader,
  SSRPass,
  SSRShader,
  STATE,
  STLExporter,
  STLLoader,
  SVGLoader,
  SVGObject,
  SVGRenderer,
  SavePass,
  SceneUtils,
  SelectionBox,
  SelectionHelper,
  SepiaShader,
  ShaderNode,
  ShaderPass,
  ShadowMapViewer,
  ShadowMesh,
  SimplexNoise,
  SimplifyModifier,
  SkeletonUtils,
  SkinningNode_default as SkinningNode,
  Sky,
  SkyGeometry,
  SobelOperatorShader,
  SplitNode_default as SplitNode,
  SpriteSheetUVNode_default as SpriteSheetUVNode,
  StereoEffect,
  SubsurfaceScatteringShader,
  TAARenderPass,
  TDSLoader,
  TGALoader,
  TTFLoader,
  TeapotGeometry,
  TechnicolorShader,
  TempNode_default as TempNode,
  TessellateModifier,
  TextGeometry as TextBufferGeometry,
  TextGeometry,
  TextureNode_default as TextureNode,
  TexturePass,
  ThreeMFLoader,
  TiltLoader,
  TimerNode_default as TimerNode,
  ToneMapShader,
  ToonShader1,
  ToonShader2,
  ToonShaderDotted,
  ToonShaderHatching,
  TorusKnot,
  TrackballControls,
  TrackballControlsExp,
  TransformControls,
  TransformControlsGizmo,
  TransformControlsPlane,
  TreesGeometry,
  TrefoilKnot,
  TrefoilPolynomialKnot,
  TriangleBlurShader,
  TubePainter,
  USDZExporter,
  UVNode_default as UVNode,
  UVsDebug,
  UniformNode_default as UniformNode,
  UnpackDepthRGBAShader,
  UnrealBloomPass,
  VOXDataTexture3D,
  VOXLoader,
  VOXMesh,
  VRButton,
  VRMLLoader,
  VRMLoader,
  VTKLoader,
  V_GGX_SmithCorrelated,
  VarNode_default as VarNode,
  VaryNode_default as VaryNode,
  Vector2NodeUniform,
  Vector2Uniform,
  Vector3NodeUniform,
  Vector3Uniform,
  Vector4NodeUniform,
  Vector4Uniform,
  VertexNormalsHelper,
  VertexTangentsHelper,
  VerticalBlurShader,
  VerticalTiltShiftShader,
  VignetteShader,
  VivianiCurve,
  Volume,
  VolumeRenderShader1,
  VolumeSlice,
  Water2 as Water,
  Water22 as Water2,
  WaterRefractionShader,
  WebGPUSampled3DTexture,
  WebGPUSampledArrayTexture,
  WebGPUSampledCubeTexture,
  WebGPUSampledTexture,
  Wireframe,
  WireframeGeometry2,
  XLoader,
  XRControllerModelFactory,
  XREstimatedLight,
  XRHandMeshModel,
  XRHandModelFactory,
  XRHandPrimitiveModel,
  XYZLoader,
  abs,
  acos,
  add,
  addTo,
  alphaTest,
  and,
  asin,
  assign,
  atan,
  attribute,
  bitAnd,
  bitOr,
  bitXor,
  bmat3,
  bmat4,
  bool,
  buffer,
  bvec2,
  bvec3,
  bvec4,
  calcBSplineDerivatives,
  calcBSplinePoint,
  calcBasisFunctionDerivatives,
  calcBasisFunctions,
  calcKoverI,
  calcNURBSDerivatives,
  calcRationalCurveDerivatives,
  calcSurfacePoint,
  cameraPosition,
  ceil,
  clamp,
  color,
  computeMorphedAttributes,
  cond,
  cos,
  createText,
  cross,
  dFdx,
  dFdy,
  degrees,
  diffuseColor,
  distance,
  div,
  dot,
  edgeTable,
  element,
  equal,
  estimateBytesUsed,
  exp,
  exp2,
  faceforward,
  fetchProfile,
  fetchProfilesList,
  findSpan,
  float,
  floor,
  fract,
  fromType,
  getDistanceAttenuation,
  getErrorMessage,
  getUniforms,
  getWebGL2ErrorMessage,
  getWebGLErrorMessage,
  greaterThan,
  greaterThanEqual,
  imat3,
  imat4,
  initSplineTexture,
  int,
  interleaveAttributes,
  inversesqrt,
  invert,
  isWebGL2Available,
  isWebGLAvailable,
  ivec2,
  ivec3,
  ivec4,
  join,
  label,
  length,
  lessThan,
  lessThanEqual,
  log,
  log2,
  mat3,
  mat4,
  max,
  mergeBufferAttributes,
  mergeBufferGeometries,
  mergeVertices,
  metalness,
  min,
  mix,
  mod,
  modifyShader,
  mul,
  negate,
  nodeObject,
  normalGeometry,
  normalLocal,
  normalView,
  normalWorld,
  normalize,
  or,
  positionLocal,
  positionView,
  positionViewDirection,
  positionWorld,
  pow,
  pow2,
  pow3,
  pow4,
  radians,
  reflect,
  refract,
  remainder,
  roughness,
  round,
  sampler,
  saturate,
  scaleTo,
  shiftLeft,
  shiftRight,
  sign,
  sin,
  smoothstep,
  specularColor,
  sqrt,
  step,
  sub,
  tan,
  temp,
  texture,
  toTrianglesDrawMode,
  transformDirection,
  transformedNormalView,
  triTable,
  uint,
  umat3,
  umat4,
  uniform,
  updateSplineTexture,
  uv,
  uvec2,
  uvec3,
  uvec4,
  vec2,
  vec3,
  vec4,
  viewMatrix,
  xor
};
/*! https://mths.be/codepointat v0.2.0 by @mathias */
//! A directional light source has a well-defined direction
//! A good example for a spot light is a light spot in
//! A point light source has a well-defined position
//! A spot light source emits light in a specific
//! The generic light level of the world, including the bounces
//! This light type doesn't have a valid position, direction, or
//! Typically, there's at most one ambient light in a scene.
//! angle. It has a position and a direction it is pointing to.
//! approximation for sun light.
//! but is infinitely far away. That's quite a good
//! directions. A normal bulb is a point light.
//! in space but no direction - it emits light in all
//! of all other lightsources.
//! other properties, just a color.
//! sport arenas.
//# sourceMappingURL=three-stdlib.js.map
